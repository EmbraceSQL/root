
        // ⚠️ generated - do not modify ⚠️

        /**
         * These types are node/browser isomorphic and are used by all other
         * EmbraceSQL generated code.
         */
        /* eslint-disable @typescript-eslint/no-explicit-any */
        /* eslint-disable @typescript-eslint/no-empty-interface */
        /* eslint-disable @typescript-eslint/no-namespace */
        /* eslint-disable @typescript-eslint/no-unused-vars */
        /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
        /* eslint-disable @typescript-eslint/no-redundant-type-constituents */
        /* @typescript-eslint/no-redundant-type-constituents */
        import {UUID, JsDate, JSONValue, JSONObject, Empty, Nullable, NullableMembers, undefinedIsNull, nullIsUndefined, NEVER} from "@embracesql/shared";
        import type { PartiallyOptional, PossiblyEmpty, ReadOptions, Sort } from "@embracesql/shared";
        import { parsePoint } from "@embracesql/shared";

    
export namespace PgCatalog {
export namespace Types {

export type Bool = boolean;

export type Bytea = Uint8Array;

export type Char = string;

export type Name = string;

export type Int8 = number;

export type Int2 = number;

export type Int2vector = Uint16Array;

export type Int4 = number;

export type Regproc = number;

export type Text = string;

export type Oid = number;

export type Tid = 
    {
      blockNumber: number;
      tupleIndex: number;
    }
    ;

export type Xid = number;

export type Cid = number;

export type Oidvector = 
     Array<PgCatalog.Types.Oid>
    ;

export type PgType = {
oid: PgCatalog.Types.Oid;
typname: PgCatalog.Types.Name;
typnamespace: PgCatalog.Types.Oid;
typowner: PgCatalog.Types.Oid;
typlen: PgCatalog.Types.Int2;
typbyval: PgCatalog.Types.Bool;
typtype: PgCatalog.Types.Char;
typcategory: PgCatalog.Types.Char;
typispreferred: PgCatalog.Types.Bool;
typisdefined: PgCatalog.Types.Bool;
typdelim: PgCatalog.Types.Char;
typrelid: PgCatalog.Types.Oid;
typsubscript: PgCatalog.Types.Regproc;
typelem: PgCatalog.Types.Oid;
typarray: PgCatalog.Types.Oid;
typinput: PgCatalog.Types.Regproc;
typoutput: PgCatalog.Types.Regproc;
typreceive: PgCatalog.Types.Regproc;
typsend: PgCatalog.Types.Regproc;
typmodin: PgCatalog.Types.Regproc;
typmodout: PgCatalog.Types.Regproc;
typanalyze: PgCatalog.Types.Regproc;
typalign: PgCatalog.Types.Char;
typstorage: PgCatalog.Types.Char;
typnotnull: PgCatalog.Types.Bool;
typbasetype: PgCatalog.Types.Oid;
typtypmod: PgCatalog.Types.Int4;
typndims: PgCatalog.Types.Int4;
typcollation: PgCatalog.Types.Oid;
typdefaultbin: Nullable<PgCatalog.Types.PgNodeTree>;
typdefault: Nullable<PgCatalog.Types.Text>;
typacl: PgCatalog.Types.AclitemArray;
}

export type PgAttribute = {
attrelid: PgCatalog.Types.Oid;
attname: PgCatalog.Types.Name;
atttypid: PgCatalog.Types.Oid;
attlen: PgCatalog.Types.Int2;
attnum: PgCatalog.Types.Int2;
attcacheoff: PgCatalog.Types.Int4;
atttypmod: PgCatalog.Types.Int4;
attndims: PgCatalog.Types.Int2;
attbyval: PgCatalog.Types.Bool;
attalign: PgCatalog.Types.Char;
attstorage: PgCatalog.Types.Char;
attcompression: PgCatalog.Types.Char;
attnotnull: PgCatalog.Types.Bool;
atthasdef: PgCatalog.Types.Bool;
atthasmissing: PgCatalog.Types.Bool;
attidentity: PgCatalog.Types.Char;
attgenerated: PgCatalog.Types.Char;
attisdropped: PgCatalog.Types.Bool;
attislocal: PgCatalog.Types.Bool;
attinhcount: PgCatalog.Types.Int2;
attstattarget: PgCatalog.Types.Int2;
attcollation: PgCatalog.Types.Oid;
attacl: PgCatalog.Types.AclitemArray;
attoptions: PgCatalog.Types.TextArray;
attfdwoptions: PgCatalog.Types.TextArray;
attmissingval: Nullable<PgCatalog.Types.Anyarray>;
}

export type PgProc = {
oid: PgCatalog.Types.Oid;
proname: PgCatalog.Types.Name;
pronamespace: PgCatalog.Types.Oid;
proowner: PgCatalog.Types.Oid;
prolang: PgCatalog.Types.Oid;
procost: PgCatalog.Types.Float4;
prorows: PgCatalog.Types.Float4;
provariadic: PgCatalog.Types.Oid;
prosupport: PgCatalog.Types.Regproc;
prokind: PgCatalog.Types.Char;
prosecdef: PgCatalog.Types.Bool;
proleakproof: PgCatalog.Types.Bool;
proisstrict: PgCatalog.Types.Bool;
proretset: PgCatalog.Types.Bool;
provolatile: PgCatalog.Types.Char;
proparallel: PgCatalog.Types.Char;
pronargs: PgCatalog.Types.Int2;
pronargdefaults: PgCatalog.Types.Int2;
prorettype: PgCatalog.Types.Oid;
proargtypes: PgCatalog.Types.Oidvector;
proallargtypes: PgCatalog.Types.OidArray;
proargmodes: PgCatalog.Types.CharArray;
proargnames: PgCatalog.Types.TextArray;
proargdefaults: Nullable<PgCatalog.Types.PgNodeTree>;
protrftypes: PgCatalog.Types.OidArray;
prosrc: PgCatalog.Types.Text;
probin: Nullable<PgCatalog.Types.Text>;
prosqlbody: Nullable<PgCatalog.Types.PgNodeTree>;
proconfig: PgCatalog.Types.TextArray;
proacl: PgCatalog.Types.AclitemArray;
}

export type PgClass = {
oid: PgCatalog.Types.Oid;
relname: PgCatalog.Types.Name;
relnamespace: PgCatalog.Types.Oid;
reltype: PgCatalog.Types.Oid;
reloftype: PgCatalog.Types.Oid;
relowner: PgCatalog.Types.Oid;
relam: PgCatalog.Types.Oid;
relfilenode: PgCatalog.Types.Oid;
reltablespace: PgCatalog.Types.Oid;
relpages: PgCatalog.Types.Int4;
reltuples: PgCatalog.Types.Float4;
relallvisible: PgCatalog.Types.Int4;
reltoastrelid: PgCatalog.Types.Oid;
relhasindex: PgCatalog.Types.Bool;
relisshared: PgCatalog.Types.Bool;
relpersistence: PgCatalog.Types.Char;
relkind: PgCatalog.Types.Char;
relnatts: PgCatalog.Types.Int2;
relchecks: PgCatalog.Types.Int2;
relhasrules: PgCatalog.Types.Bool;
relhastriggers: PgCatalog.Types.Bool;
relhassubclass: PgCatalog.Types.Bool;
relrowsecurity: PgCatalog.Types.Bool;
relforcerowsecurity: PgCatalog.Types.Bool;
relispopulated: PgCatalog.Types.Bool;
relreplident: PgCatalog.Types.Char;
relispartition: PgCatalog.Types.Bool;
relrewrite: PgCatalog.Types.Oid;
relfrozenxid: PgCatalog.Types.Xid;
relminmxid: PgCatalog.Types.Xid;
relacl: PgCatalog.Types.AclitemArray;
reloptions: PgCatalog.Types.TextArray;
relpartbound: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type Json = JSONObject;

export type Xml = string;

/**
 * FIXME: pg_node_tree did not resolve to a base type
 */
export type PgNodeTree = string;

/**
 * FIXME: pg_ndistinct did not resolve to a base type
 */
export type PgNdistinct = string;

/**
 * FIXME: pg_dependencies did not resolve to a base type
 */
export type PgDependencies = string;

/**
 * FIXME: pg_mcv_list did not resolve to a base type
 */
export type PgMcvList = string;

export type PgDdlCommand = unknown;

export type Xid8 = number;

export type Point = 
     {
      x: number;
      y: number;
    }
    ;

export type Lseg = 
     {
      from: Point;
      to: Point;
    }
    ;

export type Path = Array<Point>;

export type Box = 
    {
      upperRight: Point;
      lowerLeft: Point;
    }
    ;

export type Polygon = Array<Point>;

export type Line = 
    {
      a: number;
      b: number;
      c: number;
    }
    ;

export type Float4 = number;

export type Float8 = number;

export type Unknown = unknown;

export type Circle = 
    {
      center: Point;
      radius: number;
    }
    ;

export type Money = number;

export type Macaddr = Uint8Array;

export type Inet = string;

export type Cidr = Uint8Array;

export type Macaddr8 = Uint8Array;

export type Aclitem = string;

export type Bpchar = string;

export type Varchar = string;

export type Date = JsDate;

export type Time = JsDate;

export type Timestamp = JsDate;

export type Timestamptz = JsDate;

export type Interval = number;

export type Timetz = JsDate;

export type Bit = boolean;

export type Varbit = boolean;

export type Numeric = number;

export type Refcursor = string;

export type Regprocedure = number;

export type Regoper = number;

export type Regoperator = number;

export type Regclass = number;

export type Regcollation = number;

export type Regtype = number;

export type Regrole = number;

export type Regnamespace = number;

export type Uuid = UUID;

export type PgLsn = bigint;

export type Tsvector = string;

export type Gtsvector = Array<string>;

export type Tsquery = string;

export type Regconfig = number;

export type Regdictionary = number;

export type Jsonb = JSONObject;

export type Jsonpath = string;

/**
 * FIXME: txid_snapshot did not resolve to a base type
 */
export type TxidSnapshot = string;

/**
 * FIXME: pg_snapshot did not resolve to a base type
 */
export type PgSnapshot = string;

export type Int4range = [PgCatalog.Types.Int4, PgCatalog.Types.Int4];

export type Numrange = [PgCatalog.Types.Numeric, PgCatalog.Types.Numeric];

export type Tsrange = [PgCatalog.Types.Timestamp, PgCatalog.Types.Timestamp];

export type Tstzrange = [PgCatalog.Types.Timestamptz, PgCatalog.Types.Timestamptz];

export type Daterange = [PgCatalog.Types.Date, PgCatalog.Types.Date];

export type Int8range = [PgCatalog.Types.Int8, PgCatalog.Types.Int8];

export type Int4multirange = unknown;

export type Nummultirange = unknown;

export type Tsmultirange = unknown;

export type Tstzmultirange = unknown;

export type Datemultirange = unknown;

export type Int8multirange = unknown;

export type Record = unknown;

export type RecordArray = 
     Array<PgCatalog.Types.Record>
    ;

export type Cstring = unknown;

export type Any = unknown;

export type Anyarray = unknown;

export type Void = unknown;

export type Trigger = unknown;

export type EventTrigger = unknown;

export type LanguageHandler = unknown;

export type Internal = unknown;

export type Anyelement = any;

export type Anynonarray = unknown;

export type Anyenum = unknown;

export type FdwHandler = unknown;

export type IndexAmHandler = unknown;

export type TsmHandler = unknown;

export type TableAmHandler = unknown;

export type Anyrange = unknown;

export type Anycompatible = unknown;

export type Anycompatiblearray = unknown;

export type Anycompatiblenonarray = unknown;

export type Anycompatiblerange = unknown;

export type Anymultirange = unknown;

export type Anycompatiblemultirange = unknown;

/**
 * FIXME: pg_brin_bloom_summary did not resolve to a base type
 */
export type PgBrinBloomSummary = string;

/**
 * FIXME: pg_brin_minmax_multi_summary did not resolve to a base type
 */
export type PgBrinMinmaxMultiSummary = string;

export type BoolArray = 
     Array<PgCatalog.Types.Bool>
    ;

export type ByteaArray = 
     Array<PgCatalog.Types.Bytea>
    ;

export type CharArray = 
     Array<PgCatalog.Types.Char>
    ;

export type NameArray = 
     Array<PgCatalog.Types.Name>
    ;

export type Int8Array = 
     Array<PgCatalog.Types.Int8>
    ;

export type Int2Array = 
     Array<PgCatalog.Types.Int2>
    ;

export type Int2vectorArray = 
     Array<PgCatalog.Types.Int2vector>
    ;

export type Int4Array = 
     Array<PgCatalog.Types.Int4>
    ;

export type RegprocArray = 
     Array<PgCatalog.Types.Regproc>
    ;

export type TextArray = 
     Array<PgCatalog.Types.Text>
    ;

export type OidArray = 
     Array<PgCatalog.Types.Oid>
    ;

export type TidArray = 
     Array<PgCatalog.Types.Tid>
    ;

export type XidArray = 
     Array<PgCatalog.Types.Xid>
    ;

export type CidArray = 
     Array<PgCatalog.Types.Cid>
    ;

export type OidvectorArray = 
     Array<PgCatalog.Types.Oidvector>
    ;

export type PgTypeArray = 
     Array<PgCatalog.Types.PgType>
    ;

export type PgAttributeArray = 
     Array<PgCatalog.Types.PgAttribute>
    ;

export type PgProcArray = 
     Array<PgCatalog.Types.PgProc>
    ;

export type PgClassArray = 
     Array<PgCatalog.Types.PgClass>
    ;

export type JsonArray = 
     Array<PgCatalog.Types.Json>
    ;

export type XmlArray = 
     Array<PgCatalog.Types.Xml>
    ;

export type Xid8Array = 
     Array<PgCatalog.Types.Xid8>
    ;

export type PointArray = 
     Array<PgCatalog.Types.Point>
    ;

export type LsegArray = 
     Array<PgCatalog.Types.Lseg>
    ;

export type PathArray = 
     Array<PgCatalog.Types.Path>
    ;

export type BoxArray = 
     Array<PgCatalog.Types.Box>
    ;

export type PolygonArray = 
     Array<PgCatalog.Types.Polygon>
    ;

export type LineArray = 
     Array<PgCatalog.Types.Line>
    ;

export type Float4Array = 
     Array<PgCatalog.Types.Float4>
    ;

export type Float8Array = 
     Array<PgCatalog.Types.Float8>
    ;

export type CircleArray = 
     Array<PgCatalog.Types.Circle>
    ;

export type MoneyArray = 
     Array<PgCatalog.Types.Money>
    ;

export type MacaddrArray = 
     Array<PgCatalog.Types.Macaddr>
    ;

export type InetArray = 
     Array<PgCatalog.Types.Inet>
    ;

export type CidrArray = 
     Array<PgCatalog.Types.Cidr>
    ;

export type Macaddr8Array = 
     Array<PgCatalog.Types.Macaddr8>
    ;

export type AclitemArray = 
     Array<PgCatalog.Types.Aclitem>
    ;

export type BpcharArray = 
     Array<PgCatalog.Types.Bpchar>
    ;

export type VarcharArray = 
     Array<PgCatalog.Types.Varchar>
    ;

export type DateArray = 
     Array<PgCatalog.Types.Date>
    ;

export type TimeArray = 
     Array<PgCatalog.Types.Time>
    ;

export type TimestampArray = 
     Array<PgCatalog.Types.Timestamp>
    ;

export type TimestamptzArray = 
     Array<PgCatalog.Types.Timestamptz>
    ;

export type IntervalArray = 
     Array<PgCatalog.Types.Interval>
    ;

export type TimetzArray = 
     Array<PgCatalog.Types.Timetz>
    ;

export type BitArray = 
     Array<PgCatalog.Types.Bit>
    ;

export type VarbitArray = 
     Array<PgCatalog.Types.Varbit>
    ;

export type NumericArray = 
     Array<PgCatalog.Types.Numeric>
    ;

export type RefcursorArray = 
     Array<PgCatalog.Types.Refcursor>
    ;

export type RegprocedureArray = 
     Array<PgCatalog.Types.Regprocedure>
    ;

export type RegoperArray = 
     Array<PgCatalog.Types.Regoper>
    ;

export type RegoperatorArray = 
     Array<PgCatalog.Types.Regoperator>
    ;

export type RegclassArray = 
     Array<PgCatalog.Types.Regclass>
    ;

export type RegcollationArray = 
     Array<PgCatalog.Types.Regcollation>
    ;

export type RegtypeArray = 
     Array<PgCatalog.Types.Regtype>
    ;

export type RegroleArray = 
     Array<PgCatalog.Types.Regrole>
    ;

export type RegnamespaceArray = 
     Array<PgCatalog.Types.Regnamespace>
    ;

export type UuidArray = 
     Array<PgCatalog.Types.Uuid>
    ;

export type PgLsnArray = 
     Array<PgCatalog.Types.PgLsn>
    ;

export type TsvectorArray = 
     Array<PgCatalog.Types.Tsvector>
    ;

export type GtsvectorArray = 
     Array<PgCatalog.Types.Gtsvector>
    ;

export type TsqueryArray = 
     Array<PgCatalog.Types.Tsquery>
    ;

export type RegconfigArray = 
     Array<PgCatalog.Types.Regconfig>
    ;

export type RegdictionaryArray = 
     Array<PgCatalog.Types.Regdictionary>
    ;

export type JsonbArray = 
     Array<PgCatalog.Types.Jsonb>
    ;

export type JsonpathArray = 
     Array<PgCatalog.Types.Jsonpath>
    ;

export type TxidSnapshotArray = 
     Array<PgCatalog.Types.TxidSnapshot>
    ;

export type PgSnapshotArray = 
     Array<PgCatalog.Types.PgSnapshot>
    ;

export type Int4rangeArray = 
     Array<PgCatalog.Types.Int4range>
    ;

export type NumrangeArray = 
     Array<PgCatalog.Types.Numrange>
    ;

export type TsrangeArray = 
     Array<PgCatalog.Types.Tsrange>
    ;

export type TstzrangeArray = 
     Array<PgCatalog.Types.Tstzrange>
    ;

export type DaterangeArray = 
     Array<PgCatalog.Types.Daterange>
    ;

export type Int8rangeArray = 
     Array<PgCatalog.Types.Int8range>
    ;

export type Int4multirangeArray = 
     Array<PgCatalog.Types.Int4multirange>
    ;

export type NummultirangeArray = 
     Array<PgCatalog.Types.Nummultirange>
    ;

export type TsmultirangeArray = 
     Array<PgCatalog.Types.Tsmultirange>
    ;

export type TstzmultirangeArray = 
     Array<PgCatalog.Types.Tstzmultirange>
    ;

export type DatemultirangeArray = 
     Array<PgCatalog.Types.Datemultirange>
    ;

export type Int8multirangeArray = 
     Array<PgCatalog.Types.Int8multirange>
    ;

export type CstringArray = 
     Array<PgCatalog.Types.Cstring>
    ;

export type PgAttrdef = {
oid: PgCatalog.Types.Oid;
adrelid: PgCatalog.Types.Oid;
adnum: PgCatalog.Types.Int2;
adbin: PgCatalog.Types.PgNodeTree;
}

export type PgAttrdefArray = 
     Array<PgCatalog.Types.PgAttrdef>
    ;

export type PgConstraint = {
oid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
contype: PgCatalog.Types.Char;
condeferrable: PgCatalog.Types.Bool;
condeferred: PgCatalog.Types.Bool;
convalidated: PgCatalog.Types.Bool;
conrelid: PgCatalog.Types.Oid;
contypid: PgCatalog.Types.Oid;
conindid: PgCatalog.Types.Oid;
conparentid: PgCatalog.Types.Oid;
confrelid: PgCatalog.Types.Oid;
confupdtype: PgCatalog.Types.Char;
confdeltype: PgCatalog.Types.Char;
confmatchtype: PgCatalog.Types.Char;
conislocal: PgCatalog.Types.Bool;
coninhcount: PgCatalog.Types.Int2;
connoinherit: PgCatalog.Types.Bool;
conkey: PgCatalog.Types.Int2Array;
confkey: PgCatalog.Types.Int2Array;
conpfeqop: PgCatalog.Types.OidArray;
conppeqop: PgCatalog.Types.OidArray;
conffeqop: PgCatalog.Types.OidArray;
confdelsetcols: PgCatalog.Types.Int2Array;
conexclop: PgCatalog.Types.OidArray;
conbin: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgConstraintArray = 
     Array<PgCatalog.Types.PgConstraint>
    ;

export type PgInherits = {
inhrelid: PgCatalog.Types.Oid;
inhparent: PgCatalog.Types.Oid;
inhseqno: PgCatalog.Types.Int4;
inhdetachpending: PgCatalog.Types.Bool;
}

export type PgInheritsArray = 
     Array<PgCatalog.Types.PgInherits>
    ;

export type PgIndex = {
indexrelid: PgCatalog.Types.Oid;
indrelid: PgCatalog.Types.Oid;
indnatts: PgCatalog.Types.Int2;
indnkeyatts: PgCatalog.Types.Int2;
indisunique: PgCatalog.Types.Bool;
indnullsnotdistinct: PgCatalog.Types.Bool;
indisprimary: PgCatalog.Types.Bool;
indisexclusion: PgCatalog.Types.Bool;
indimmediate: PgCatalog.Types.Bool;
indisclustered: PgCatalog.Types.Bool;
indisvalid: PgCatalog.Types.Bool;
indcheckxmin: PgCatalog.Types.Bool;
indisready: PgCatalog.Types.Bool;
indislive: PgCatalog.Types.Bool;
indisreplident: PgCatalog.Types.Bool;
indkey: PgCatalog.Types.Int2vector;
indcollation: PgCatalog.Types.Oidvector;
indclass: PgCatalog.Types.Oidvector;
indoption: PgCatalog.Types.Int2vector;
indexprs: Nullable<PgCatalog.Types.PgNodeTree>;
indpred: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgIndexArray = 
     Array<PgCatalog.Types.PgIndex>
    ;

export type PgOperator = {
oid: PgCatalog.Types.Oid;
oprname: PgCatalog.Types.Name;
oprnamespace: PgCatalog.Types.Oid;
oprowner: PgCatalog.Types.Oid;
oprkind: PgCatalog.Types.Char;
oprcanmerge: PgCatalog.Types.Bool;
oprcanhash: PgCatalog.Types.Bool;
oprleft: PgCatalog.Types.Oid;
oprright: PgCatalog.Types.Oid;
oprresult: PgCatalog.Types.Oid;
oprcom: PgCatalog.Types.Oid;
oprnegate: PgCatalog.Types.Oid;
oprcode: PgCatalog.Types.Regproc;
oprrest: PgCatalog.Types.Regproc;
oprjoin: PgCatalog.Types.Regproc;
}

export type PgOperatorArray = 
     Array<PgCatalog.Types.PgOperator>
    ;

export type PgOpfamily = {
oid: PgCatalog.Types.Oid;
opfmethod: PgCatalog.Types.Oid;
opfname: PgCatalog.Types.Name;
opfnamespace: PgCatalog.Types.Oid;
opfowner: PgCatalog.Types.Oid;
}

export type PgOpfamilyArray = 
     Array<PgCatalog.Types.PgOpfamily>
    ;

export type PgOpclass = {
oid: PgCatalog.Types.Oid;
opcmethod: PgCatalog.Types.Oid;
opcname: PgCatalog.Types.Name;
opcnamespace: PgCatalog.Types.Oid;
opcowner: PgCatalog.Types.Oid;
opcfamily: PgCatalog.Types.Oid;
opcintype: PgCatalog.Types.Oid;
opcdefault: PgCatalog.Types.Bool;
opckeytype: PgCatalog.Types.Oid;
}

export type PgOpclassArray = 
     Array<PgCatalog.Types.PgOpclass>
    ;

export type PgAm = {
oid: PgCatalog.Types.Oid;
amname: PgCatalog.Types.Name;
amhandler: PgCatalog.Types.Regproc;
amtype: PgCatalog.Types.Char;
}

export type PgAmArray = 
     Array<PgCatalog.Types.PgAm>
    ;

export type PgAmop = {
oid: PgCatalog.Types.Oid;
amopfamily: PgCatalog.Types.Oid;
amoplefttype: PgCatalog.Types.Oid;
amoprighttype: PgCatalog.Types.Oid;
amopstrategy: PgCatalog.Types.Int2;
amoppurpose: PgCatalog.Types.Char;
amopopr: PgCatalog.Types.Oid;
amopmethod: PgCatalog.Types.Oid;
amopsortfamily: PgCatalog.Types.Oid;
}

export type PgAmopArray = 
     Array<PgCatalog.Types.PgAmop>
    ;

export type PgAmproc = {
oid: PgCatalog.Types.Oid;
amprocfamily: PgCatalog.Types.Oid;
amproclefttype: PgCatalog.Types.Oid;
amprocrighttype: PgCatalog.Types.Oid;
amprocnum: PgCatalog.Types.Int2;
amproc: PgCatalog.Types.Regproc;
}

export type PgAmprocArray = 
     Array<PgCatalog.Types.PgAmproc>
    ;

export type PgLanguage = {
oid: PgCatalog.Types.Oid;
lanname: PgCatalog.Types.Name;
lanowner: PgCatalog.Types.Oid;
lanispl: PgCatalog.Types.Bool;
lanpltrusted: PgCatalog.Types.Bool;
lanplcallfoid: PgCatalog.Types.Oid;
laninline: PgCatalog.Types.Oid;
lanvalidator: PgCatalog.Types.Oid;
lanacl: PgCatalog.Types.AclitemArray;
}

export type PgLanguageArray = 
     Array<PgCatalog.Types.PgLanguage>
    ;

export type PgLargeobjectMetadata = {
oid: PgCatalog.Types.Oid;
lomowner: PgCatalog.Types.Oid;
lomacl: PgCatalog.Types.AclitemArray;
}

export type PgLargeobjectMetadataArray = 
     Array<PgCatalog.Types.PgLargeobjectMetadata>
    ;

export type PgLargeobject = {
loid: PgCatalog.Types.Oid;
pageno: PgCatalog.Types.Int4;
data: PgCatalog.Types.Bytea;
}

export type PgLargeobjectArray = 
     Array<PgCatalog.Types.PgLargeobject>
    ;

export type PgAggregate = {
aggfnoid: PgCatalog.Types.Regproc;
aggkind: PgCatalog.Types.Char;
aggnumdirectargs: PgCatalog.Types.Int2;
aggtransfn: PgCatalog.Types.Regproc;
aggfinalfn: PgCatalog.Types.Regproc;
aggcombinefn: PgCatalog.Types.Regproc;
aggserialfn: PgCatalog.Types.Regproc;
aggdeserialfn: PgCatalog.Types.Regproc;
aggmtransfn: PgCatalog.Types.Regproc;
aggminvtransfn: PgCatalog.Types.Regproc;
aggmfinalfn: PgCatalog.Types.Regproc;
aggfinalextra: PgCatalog.Types.Bool;
aggmfinalextra: PgCatalog.Types.Bool;
aggfinalmodify: PgCatalog.Types.Char;
aggmfinalmodify: PgCatalog.Types.Char;
aggsortop: PgCatalog.Types.Oid;
aggtranstype: PgCatalog.Types.Oid;
aggtransspace: PgCatalog.Types.Int4;
aggmtranstype: PgCatalog.Types.Oid;
aggmtransspace: PgCatalog.Types.Int4;
agginitval: Nullable<PgCatalog.Types.Text>;
aggminitval: Nullable<PgCatalog.Types.Text>;
}

export type PgAggregateArray = 
     Array<PgCatalog.Types.PgAggregate>
    ;

export type PgStatistic = {
starelid: PgCatalog.Types.Oid;
staattnum: PgCatalog.Types.Int2;
stainherit: PgCatalog.Types.Bool;
stanullfrac: PgCatalog.Types.Float4;
stawidth: PgCatalog.Types.Int4;
stadistinct: PgCatalog.Types.Float4;
stakind1: PgCatalog.Types.Int2;
stakind2: PgCatalog.Types.Int2;
stakind3: PgCatalog.Types.Int2;
stakind4: PgCatalog.Types.Int2;
stakind5: PgCatalog.Types.Int2;
staop1: PgCatalog.Types.Oid;
staop2: PgCatalog.Types.Oid;
staop3: PgCatalog.Types.Oid;
staop4: PgCatalog.Types.Oid;
staop5: PgCatalog.Types.Oid;
stacoll1: PgCatalog.Types.Oid;
stacoll2: PgCatalog.Types.Oid;
stacoll3: PgCatalog.Types.Oid;
stacoll4: PgCatalog.Types.Oid;
stacoll5: PgCatalog.Types.Oid;
stanumbers1: PgCatalog.Types.Float4Array;
stanumbers2: PgCatalog.Types.Float4Array;
stanumbers3: PgCatalog.Types.Float4Array;
stanumbers4: PgCatalog.Types.Float4Array;
stanumbers5: PgCatalog.Types.Float4Array;
stavalues1: Nullable<PgCatalog.Types.Anyarray>;
stavalues2: Nullable<PgCatalog.Types.Anyarray>;
stavalues3: Nullable<PgCatalog.Types.Anyarray>;
stavalues4: Nullable<PgCatalog.Types.Anyarray>;
stavalues5: Nullable<PgCatalog.Types.Anyarray>;
}

export type PgStatisticArray = 
     Array<PgCatalog.Types.PgStatistic>
    ;

export type PgStatisticExt = {
oid: PgCatalog.Types.Oid;
stxrelid: PgCatalog.Types.Oid;
stxname: PgCatalog.Types.Name;
stxnamespace: PgCatalog.Types.Oid;
stxowner: PgCatalog.Types.Oid;
stxstattarget: PgCatalog.Types.Int4;
stxkeys: PgCatalog.Types.Int2vector;
stxkind: PgCatalog.Types.CharArray;
stxexprs: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgStatisticExtArray = 
     Array<PgCatalog.Types.PgStatisticExt>
    ;

export type PgStatisticExtData = {
stxoid: PgCatalog.Types.Oid;
stxdinherit: PgCatalog.Types.Bool;
stxdndistinct: Nullable<PgCatalog.Types.PgNdistinct>;
stxddependencies: Nullable<PgCatalog.Types.PgDependencies>;
stxdmcv: Nullable<PgCatalog.Types.PgMcvList>;
stxdexpr: PgCatalog.Types.PgStatisticArray;
}

export type PgStatisticExtDataArray = 
     Array<PgCatalog.Types.PgStatisticExtData>
    ;

export type PgRewrite = {
oid: PgCatalog.Types.Oid;
rulename: PgCatalog.Types.Name;
evClass: PgCatalog.Types.Oid;
evType: PgCatalog.Types.Char;
evEnabled: PgCatalog.Types.Char;
isInstead: PgCatalog.Types.Bool;
evQual: PgCatalog.Types.PgNodeTree;
evAction: PgCatalog.Types.PgNodeTree;
}

export type PgRewriteArray = 
     Array<PgCatalog.Types.PgRewrite>
    ;

export type PgTrigger = {
oid: PgCatalog.Types.Oid;
tgrelid: PgCatalog.Types.Oid;
tgparentid: PgCatalog.Types.Oid;
tgname: PgCatalog.Types.Name;
tgfoid: PgCatalog.Types.Oid;
tgtype: PgCatalog.Types.Int2;
tgenabled: PgCatalog.Types.Char;
tgisinternal: PgCatalog.Types.Bool;
tgconstrrelid: PgCatalog.Types.Oid;
tgconstrindid: PgCatalog.Types.Oid;
tgconstraint: PgCatalog.Types.Oid;
tgdeferrable: PgCatalog.Types.Bool;
tginitdeferred: PgCatalog.Types.Bool;
tgnargs: PgCatalog.Types.Int2;
tgattr: PgCatalog.Types.Int2vector;
tgargs: PgCatalog.Types.Bytea;
tgqual: Nullable<PgCatalog.Types.PgNodeTree>;
tgoldtable: Nullable<PgCatalog.Types.Name>;
tgnewtable: Nullable<PgCatalog.Types.Name>;
}

export type PgTriggerArray = 
     Array<PgCatalog.Types.PgTrigger>
    ;

export type PgEventTrigger = {
oid: PgCatalog.Types.Oid;
evtname: PgCatalog.Types.Name;
evtevent: PgCatalog.Types.Name;
evtowner: PgCatalog.Types.Oid;
evtfoid: PgCatalog.Types.Oid;
evtenabled: PgCatalog.Types.Char;
evttags: PgCatalog.Types.TextArray;
}

export type PgEventTriggerArray = 
     Array<PgCatalog.Types.PgEventTrigger>
    ;

export type PgDescription = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
description: PgCatalog.Types.Text;
}

export type PgDescriptionArray = 
     Array<PgCatalog.Types.PgDescription>
    ;

export type PgCast = {
oid: PgCatalog.Types.Oid;
castsource: PgCatalog.Types.Oid;
casttarget: PgCatalog.Types.Oid;
castfunc: PgCatalog.Types.Oid;
castcontext: PgCatalog.Types.Char;
castmethod: PgCatalog.Types.Char;
}

export type PgCastArray = 
     Array<PgCatalog.Types.PgCast>
    ;

export type PgEnum = {
oid: PgCatalog.Types.Oid;
enumtypid: PgCatalog.Types.Oid;
enumsortorder: PgCatalog.Types.Float4;
enumlabel: PgCatalog.Types.Name;
}

export type PgEnumArray = 
     Array<PgCatalog.Types.PgEnum>
    ;

export type PgNamespace = {
oid: PgCatalog.Types.Oid;
nspname: PgCatalog.Types.Name;
nspowner: PgCatalog.Types.Oid;
nspacl: PgCatalog.Types.AclitemArray;
}

export type PgNamespaceArray = 
     Array<PgCatalog.Types.PgNamespace>
    ;

export type PgConversion = {
oid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
conowner: PgCatalog.Types.Oid;
conforencoding: PgCatalog.Types.Int4;
contoencoding: PgCatalog.Types.Int4;
conproc: PgCatalog.Types.Regproc;
condefault: PgCatalog.Types.Bool;
}

export type PgConversionArray = 
     Array<PgCatalog.Types.PgConversion>
    ;

export type PgDepend = {
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
refobjsubid: PgCatalog.Types.Int4;
deptype: PgCatalog.Types.Char;
}

export type PgDependArray = 
     Array<PgCatalog.Types.PgDepend>
    ;

export type PgDatabase = {
oid: PgCatalog.Types.Oid;
datname: PgCatalog.Types.Name;
datdba: PgCatalog.Types.Oid;
encoding: PgCatalog.Types.Int4;
datlocprovider: PgCatalog.Types.Char;
datistemplate: PgCatalog.Types.Bool;
datallowconn: PgCatalog.Types.Bool;
datconnlimit: PgCatalog.Types.Int4;
datfrozenxid: PgCatalog.Types.Xid;
datminmxid: PgCatalog.Types.Xid;
dattablespace: PgCatalog.Types.Oid;
datcollate: PgCatalog.Types.Text;
datctype: PgCatalog.Types.Text;
daticulocale: Nullable<PgCatalog.Types.Text>;
daticurules: Nullable<PgCatalog.Types.Text>;
datcollversion: Nullable<PgCatalog.Types.Text>;
datacl: PgCatalog.Types.AclitemArray;
}

export type PgDatabaseArray = 
     Array<PgCatalog.Types.PgDatabase>
    ;

export type PgDbRoleSetting = {
setdatabase: PgCatalog.Types.Oid;
setrole: PgCatalog.Types.Oid;
setconfig: PgCatalog.Types.TextArray;
}

export type PgDbRoleSettingArray = 
     Array<PgCatalog.Types.PgDbRoleSetting>
    ;

export type PgTablespace = {
oid: PgCatalog.Types.Oid;
spcname: PgCatalog.Types.Name;
spcowner: PgCatalog.Types.Oid;
spcacl: PgCatalog.Types.AclitemArray;
spcoptions: PgCatalog.Types.TextArray;
}

export type PgTablespaceArray = 
     Array<PgCatalog.Types.PgTablespace>
    ;

export type PgAuthid = {
oid: PgCatalog.Types.Oid;
rolname: PgCatalog.Types.Name;
rolsuper: PgCatalog.Types.Bool;
rolinherit: PgCatalog.Types.Bool;
rolcreaterole: PgCatalog.Types.Bool;
rolcreatedb: PgCatalog.Types.Bool;
rolcanlogin: PgCatalog.Types.Bool;
rolreplication: PgCatalog.Types.Bool;
rolbypassrls: PgCatalog.Types.Bool;
rolconnlimit: PgCatalog.Types.Int4;
rolpassword: Nullable<PgCatalog.Types.Text>;
rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgAuthidArray = 
     Array<PgCatalog.Types.PgAuthid>
    ;

export type PgAuthMembers = {
oid: PgCatalog.Types.Oid;
roleid: PgCatalog.Types.Oid;
member: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
adminOption: PgCatalog.Types.Bool;
inheritOption: PgCatalog.Types.Bool;
setOption: PgCatalog.Types.Bool;
}

export type PgAuthMembersArray = 
     Array<PgCatalog.Types.PgAuthMembers>
    ;

export type PgShdepend = {
dbid: PgCatalog.Types.Oid;
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
deptype: PgCatalog.Types.Char;
}

export type PgShdependArray = 
     Array<PgCatalog.Types.PgShdepend>
    ;

export type PgShdescription = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
description: PgCatalog.Types.Text;
}

export type PgShdescriptionArray = 
     Array<PgCatalog.Types.PgShdescription>
    ;

export type PgTsConfig = {
oid: PgCatalog.Types.Oid;
cfgname: PgCatalog.Types.Name;
cfgnamespace: PgCatalog.Types.Oid;
cfgowner: PgCatalog.Types.Oid;
cfgparser: PgCatalog.Types.Oid;
}

export type PgTsConfigArray = 
     Array<PgCatalog.Types.PgTsConfig>
    ;

export type PgTsConfigMap = {
mapcfg: PgCatalog.Types.Oid;
maptokentype: PgCatalog.Types.Int4;
mapseqno: PgCatalog.Types.Int4;
mapdict: PgCatalog.Types.Oid;
}

export type PgTsConfigMapArray = 
     Array<PgCatalog.Types.PgTsConfigMap>
    ;

export type PgTsDict = {
oid: PgCatalog.Types.Oid;
dictname: PgCatalog.Types.Name;
dictnamespace: PgCatalog.Types.Oid;
dictowner: PgCatalog.Types.Oid;
dicttemplate: PgCatalog.Types.Oid;
dictinitoption: Nullable<PgCatalog.Types.Text>;
}

export type PgTsDictArray = 
     Array<PgCatalog.Types.PgTsDict>
    ;

export type PgTsParser = {
oid: PgCatalog.Types.Oid;
prsname: PgCatalog.Types.Name;
prsnamespace: PgCatalog.Types.Oid;
prsstart: PgCatalog.Types.Regproc;
prstoken: PgCatalog.Types.Regproc;
prsend: PgCatalog.Types.Regproc;
prsheadline: PgCatalog.Types.Regproc;
prslextype: PgCatalog.Types.Regproc;
}

export type PgTsParserArray = 
     Array<PgCatalog.Types.PgTsParser>
    ;

export type PgTsTemplate = {
oid: PgCatalog.Types.Oid;
tmplname: PgCatalog.Types.Name;
tmplnamespace: PgCatalog.Types.Oid;
tmplinit: PgCatalog.Types.Regproc;
tmpllexize: PgCatalog.Types.Regproc;
}

export type PgTsTemplateArray = 
     Array<PgCatalog.Types.PgTsTemplate>
    ;

export type PgExtension = {
oid: PgCatalog.Types.Oid;
extname: PgCatalog.Types.Name;
extowner: PgCatalog.Types.Oid;
extnamespace: PgCatalog.Types.Oid;
extrelocatable: PgCatalog.Types.Bool;
extversion: PgCatalog.Types.Text;
extconfig: PgCatalog.Types.OidArray;
extcondition: PgCatalog.Types.TextArray;
}

export type PgExtensionArray = 
     Array<PgCatalog.Types.PgExtension>
    ;

export type PgForeignDataWrapper = {
oid: PgCatalog.Types.Oid;
fdwname: PgCatalog.Types.Name;
fdwowner: PgCatalog.Types.Oid;
fdwhandler: PgCatalog.Types.Oid;
fdwvalidator: PgCatalog.Types.Oid;
fdwacl: PgCatalog.Types.AclitemArray;
fdwoptions: PgCatalog.Types.TextArray;
}

export type PgForeignDataWrapperArray = 
     Array<PgCatalog.Types.PgForeignDataWrapper>
    ;

export type PgForeignServer = {
oid: PgCatalog.Types.Oid;
srvname: PgCatalog.Types.Name;
srvowner: PgCatalog.Types.Oid;
srvfdw: PgCatalog.Types.Oid;
srvtype: Nullable<PgCatalog.Types.Text>;
srvversion: Nullable<PgCatalog.Types.Text>;
srvacl: PgCatalog.Types.AclitemArray;
srvoptions: PgCatalog.Types.TextArray;
}

export type PgForeignServerArray = 
     Array<PgCatalog.Types.PgForeignServer>
    ;

export type PgUserMapping = {
oid: PgCatalog.Types.Oid;
umuser: PgCatalog.Types.Oid;
umserver: PgCatalog.Types.Oid;
umoptions: PgCatalog.Types.TextArray;
}

export type PgUserMappingArray = 
     Array<PgCatalog.Types.PgUserMapping>
    ;

export type PgForeignTable = {
ftrelid: PgCatalog.Types.Oid;
ftserver: PgCatalog.Types.Oid;
ftoptions: PgCatalog.Types.TextArray;
}

export type PgForeignTableArray = 
     Array<PgCatalog.Types.PgForeignTable>
    ;

export type PgPolicy = {
oid: PgCatalog.Types.Oid;
polname: PgCatalog.Types.Name;
polrelid: PgCatalog.Types.Oid;
polcmd: PgCatalog.Types.Char;
polpermissive: PgCatalog.Types.Bool;
polroles: PgCatalog.Types.OidArray;
polqual: Nullable<PgCatalog.Types.PgNodeTree>;
polwithcheck: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgPolicyArray = 
     Array<PgCatalog.Types.PgPolicy>
    ;

export type PgReplicationOrigin = {
roident: PgCatalog.Types.Oid;
roname: PgCatalog.Types.Text;
}

export type PgReplicationOriginArray = 
     Array<PgCatalog.Types.PgReplicationOrigin>
    ;

export type PgDefaultAcl = {
oid: PgCatalog.Types.Oid;
defaclrole: PgCatalog.Types.Oid;
defaclnamespace: PgCatalog.Types.Oid;
defaclobjtype: PgCatalog.Types.Char;
defaclacl: PgCatalog.Types.AclitemArray;
}

export type PgDefaultAclArray = 
     Array<PgCatalog.Types.PgDefaultAcl>
    ;

export type PgInitPrivs = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
privtype: PgCatalog.Types.Char;
initprivs: PgCatalog.Types.AclitemArray;
}

export type PgInitPrivsArray = 
     Array<PgCatalog.Types.PgInitPrivs>
    ;

export type PgSeclabel = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
provider: PgCatalog.Types.Text;
label: PgCatalog.Types.Text;
}

export type PgSeclabelArray = 
     Array<PgCatalog.Types.PgSeclabel>
    ;

export type PgShseclabel = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
provider: PgCatalog.Types.Text;
label: PgCatalog.Types.Text;
}

export type PgShseclabelArray = 
     Array<PgCatalog.Types.PgShseclabel>
    ;

export type PgCollation = {
oid: PgCatalog.Types.Oid;
collname: PgCatalog.Types.Name;
collnamespace: PgCatalog.Types.Oid;
collowner: PgCatalog.Types.Oid;
collprovider: PgCatalog.Types.Char;
collisdeterministic: PgCatalog.Types.Bool;
collencoding: PgCatalog.Types.Int4;
collcollate: Nullable<PgCatalog.Types.Text>;
collctype: Nullable<PgCatalog.Types.Text>;
colliculocale: Nullable<PgCatalog.Types.Text>;
collicurules: Nullable<PgCatalog.Types.Text>;
collversion: Nullable<PgCatalog.Types.Text>;
}

export type PgCollationArray = 
     Array<PgCatalog.Types.PgCollation>
    ;

export type PgParameterAcl = {
oid: PgCatalog.Types.Oid;
parname: PgCatalog.Types.Text;
paracl: PgCatalog.Types.AclitemArray;
}

export type PgParameterAclArray = 
     Array<PgCatalog.Types.PgParameterAcl>
    ;

export type PgPartitionedTable = {
partrelid: PgCatalog.Types.Oid;
partstrat: PgCatalog.Types.Char;
partnatts: PgCatalog.Types.Int2;
partdefid: PgCatalog.Types.Oid;
partattrs: PgCatalog.Types.Int2vector;
partclass: PgCatalog.Types.Oidvector;
partcollation: PgCatalog.Types.Oidvector;
partexprs: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgPartitionedTableArray = 
     Array<PgCatalog.Types.PgPartitionedTable>
    ;

export type PgRange = {
rngtypid: PgCatalog.Types.Oid;
rngsubtype: PgCatalog.Types.Oid;
rngmultitypid: PgCatalog.Types.Oid;
rngcollation: PgCatalog.Types.Oid;
rngsubopc: PgCatalog.Types.Oid;
rngcanonical: PgCatalog.Types.Regproc;
rngsubdiff: PgCatalog.Types.Regproc;
}

export type PgRangeArray = 
     Array<PgCatalog.Types.PgRange>
    ;

export type PgTransform = {
oid: PgCatalog.Types.Oid;
trftype: PgCatalog.Types.Oid;
trflang: PgCatalog.Types.Oid;
trffromsql: PgCatalog.Types.Regproc;
trftosql: PgCatalog.Types.Regproc;
}

export type PgTransformArray = 
     Array<PgCatalog.Types.PgTransform>
    ;

export type PgSequence = {
seqrelid: PgCatalog.Types.Oid;
seqtypid: PgCatalog.Types.Oid;
seqstart: PgCatalog.Types.Int8;
seqincrement: PgCatalog.Types.Int8;
seqmax: PgCatalog.Types.Int8;
seqmin: PgCatalog.Types.Int8;
seqcache: PgCatalog.Types.Int8;
seqcycle: PgCatalog.Types.Bool;
}

export type PgSequenceArray = 
     Array<PgCatalog.Types.PgSequence>
    ;

export type PgPublication = {
oid: PgCatalog.Types.Oid;
pubname: PgCatalog.Types.Name;
pubowner: PgCatalog.Types.Oid;
puballtables: PgCatalog.Types.Bool;
pubinsert: PgCatalog.Types.Bool;
pubupdate: PgCatalog.Types.Bool;
pubdelete: PgCatalog.Types.Bool;
pubtruncate: PgCatalog.Types.Bool;
pubviaroot: PgCatalog.Types.Bool;
}

export type PgPublicationArray = 
     Array<PgCatalog.Types.PgPublication>
    ;

export type PgPublicationNamespace = {
oid: PgCatalog.Types.Oid;
pnpubid: PgCatalog.Types.Oid;
pnnspid: PgCatalog.Types.Oid;
}

export type PgPublicationNamespaceArray = 
     Array<PgCatalog.Types.PgPublicationNamespace>
    ;

export type PgPublicationRel = {
oid: PgCatalog.Types.Oid;
prpubid: PgCatalog.Types.Oid;
prrelid: PgCatalog.Types.Oid;
prqual: Nullable<PgCatalog.Types.PgNodeTree>;
prattrs: Nullable<PgCatalog.Types.Int2vector>;
}

export type PgPublicationRelArray = 
     Array<PgCatalog.Types.PgPublicationRel>
    ;

export type PgSubscription = {
oid: PgCatalog.Types.Oid;
subdbid: PgCatalog.Types.Oid;
subskiplsn: PgCatalog.Types.PgLsn;
subname: PgCatalog.Types.Name;
subowner: PgCatalog.Types.Oid;
subenabled: PgCatalog.Types.Bool;
subbinary: PgCatalog.Types.Bool;
substream: PgCatalog.Types.Char;
subtwophasestate: PgCatalog.Types.Char;
subdisableonerr: PgCatalog.Types.Bool;
subpasswordrequired: PgCatalog.Types.Bool;
subrunasowner: PgCatalog.Types.Bool;
subconninfo: PgCatalog.Types.Text;
subslotname: Nullable<PgCatalog.Types.Name>;
subsynccommit: PgCatalog.Types.Text;
subpublications: PgCatalog.Types.TextArray;
suborigin: Nullable<PgCatalog.Types.Text>;
}

export type PgSubscriptionArray = 
     Array<PgCatalog.Types.PgSubscription>
    ;

export type PgSubscriptionRel = {
srsubid: PgCatalog.Types.Oid;
srrelid: PgCatalog.Types.Oid;
srsubstate: PgCatalog.Types.Char;
srsublsn: Nullable<PgCatalog.Types.PgLsn>;
}

export type PgSubscriptionRelArray = 
     Array<PgCatalog.Types.PgSubscriptionRel>
    ;

export type PgRoles = {
rolname: Nullable<PgCatalog.Types.Name>;
rolsuper: Nullable<PgCatalog.Types.Bool>;
rolinherit: Nullable<PgCatalog.Types.Bool>;
rolcreaterole: Nullable<PgCatalog.Types.Bool>;
rolcreatedb: Nullable<PgCatalog.Types.Bool>;
rolcanlogin: Nullable<PgCatalog.Types.Bool>;
rolreplication: Nullable<PgCatalog.Types.Bool>;
rolconnlimit: Nullable<PgCatalog.Types.Int4>;
rolpassword: Nullable<PgCatalog.Types.Text>;
rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
rolbypassrls: Nullable<PgCatalog.Types.Bool>;
rolconfig: PgCatalog.Types.TextArray;
oid: Nullable<PgCatalog.Types.Oid>;
}

export type PgRolesArray = 
     Array<PgCatalog.Types.PgRoles>
    ;

export type PgShadow = {
usename: Nullable<PgCatalog.Types.Name>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usecreatedb: Nullable<PgCatalog.Types.Bool>;
usesuper: Nullable<PgCatalog.Types.Bool>;
userepl: Nullable<PgCatalog.Types.Bool>;
usebypassrls: Nullable<PgCatalog.Types.Bool>;
passwd: Nullable<PgCatalog.Types.Text>;
valuntil: Nullable<PgCatalog.Types.Timestamptz>;
useconfig: PgCatalog.Types.TextArray;
}

export type PgShadowArray = 
     Array<PgCatalog.Types.PgShadow>
    ;

export type PgGroup = {
groname: Nullable<PgCatalog.Types.Name>;
grosysid: Nullable<PgCatalog.Types.Oid>;
grolist: PgCatalog.Types.OidArray;
}

export type PgGroupArray = 
     Array<PgCatalog.Types.PgGroup>
    ;

export type PgUser = {
usename: Nullable<PgCatalog.Types.Name>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usecreatedb: Nullable<PgCatalog.Types.Bool>;
usesuper: Nullable<PgCatalog.Types.Bool>;
userepl: Nullable<PgCatalog.Types.Bool>;
usebypassrls: Nullable<PgCatalog.Types.Bool>;
passwd: Nullable<PgCatalog.Types.Text>;
valuntil: Nullable<PgCatalog.Types.Timestamptz>;
useconfig: PgCatalog.Types.TextArray;
}

export type PgUserArray = 
     Array<PgCatalog.Types.PgUser>
    ;

export type PgPolicies = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
policyname: Nullable<PgCatalog.Types.Name>;
permissive: Nullable<PgCatalog.Types.Text>;
roles: PgCatalog.Types.NameArray;
cmd: Nullable<PgCatalog.Types.Text>;
qual: Nullable<PgCatalog.Types.Text>;
withCheck: Nullable<PgCatalog.Types.Text>;
}

export type PgPoliciesArray = 
     Array<PgCatalog.Types.PgPolicies>
    ;

export type PgRules = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
rulename: Nullable<PgCatalog.Types.Name>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgRulesArray = 
     Array<PgCatalog.Types.PgRules>
    ;

export type PgViews = {
schemaname: Nullable<PgCatalog.Types.Name>;
viewname: Nullable<PgCatalog.Types.Name>;
viewowner: Nullable<PgCatalog.Types.Name>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgViewsArray = 
     Array<PgCatalog.Types.PgViews>
    ;

export type PgTables = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
tableowner: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
hasindexes: Nullable<PgCatalog.Types.Bool>;
hasrules: Nullable<PgCatalog.Types.Bool>;
hastriggers: Nullable<PgCatalog.Types.Bool>;
rowsecurity: Nullable<PgCatalog.Types.Bool>;
}

export type PgTablesArray = 
     Array<PgCatalog.Types.PgTables>
    ;

export type PgMatviews = {
schemaname: Nullable<PgCatalog.Types.Name>;
matviewname: Nullable<PgCatalog.Types.Name>;
matviewowner: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
hasindexes: Nullable<PgCatalog.Types.Bool>;
ispopulated: Nullable<PgCatalog.Types.Bool>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgMatviewsArray = 
     Array<PgCatalog.Types.PgMatviews>
    ;

export type PgIndexes = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
indexname: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
indexdef: Nullable<PgCatalog.Types.Text>;
}

export type PgIndexesArray = 
     Array<PgCatalog.Types.PgIndexes>
    ;

export type PgSequences = {
schemaname: Nullable<PgCatalog.Types.Name>;
sequencename: Nullable<PgCatalog.Types.Name>;
sequenceowner: Nullable<PgCatalog.Types.Name>;
dataType: Nullable<PgCatalog.Types.Regtype>;
startValue: Nullable<PgCatalog.Types.Int8>;
minValue: Nullable<PgCatalog.Types.Int8>;
maxValue: Nullable<PgCatalog.Types.Int8>;
incrementBy: Nullable<PgCatalog.Types.Int8>;
cycle: Nullable<PgCatalog.Types.Bool>;
cacheSize: Nullable<PgCatalog.Types.Int8>;
lastValue: Nullable<PgCatalog.Types.Int8>;
}

export type PgSequencesArray = 
     Array<PgCatalog.Types.PgSequences>
    ;

export type PgStats = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
attname: Nullable<PgCatalog.Types.Name>;
inherited: Nullable<PgCatalog.Types.Bool>;
nullFrac: Nullable<PgCatalog.Types.Float4>;
avgWidth: Nullable<PgCatalog.Types.Int4>;
nDistinct: Nullable<PgCatalog.Types.Float4>;
mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
mostCommonFreqs: PgCatalog.Types.Float4Array;
histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
correlation: Nullable<PgCatalog.Types.Float4>;
mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
mostCommonElemFreqs: PgCatalog.Types.Float4Array;
elemCountHistogram: PgCatalog.Types.Float4Array;
}

export type PgStatsArray = 
     Array<PgCatalog.Types.PgStats>
    ;

export type PgStatsExt = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
statisticsName: Nullable<PgCatalog.Types.Name>;
statisticsOwner: Nullable<PgCatalog.Types.Name>;
attnames: PgCatalog.Types.NameArray;
exprs: PgCatalog.Types.TextArray;
kinds: PgCatalog.Types.CharArray;
inherited: Nullable<PgCatalog.Types.Bool>;
nDistinct: Nullable<PgCatalog.Types.PgNdistinct>;
dependencies: Nullable<PgCatalog.Types.PgDependencies>;
mostCommonVals: PgCatalog.Types.TextArray;
mostCommonValNulls: PgCatalog.Types.BoolArray;
mostCommonFreqs: PgCatalog.Types.Float8Array;
mostCommonBaseFreqs: PgCatalog.Types.Float8Array;
}

export type PgStatsExtArray = 
     Array<PgCatalog.Types.PgStatsExt>
    ;

export type PgStatsExtExprs = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
statisticsName: Nullable<PgCatalog.Types.Name>;
statisticsOwner: Nullable<PgCatalog.Types.Name>;
expr: Nullable<PgCatalog.Types.Text>;
inherited: Nullable<PgCatalog.Types.Bool>;
nullFrac: Nullable<PgCatalog.Types.Float4>;
avgWidth: Nullable<PgCatalog.Types.Int4>;
nDistinct: Nullable<PgCatalog.Types.Float4>;
mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
mostCommonFreqs: PgCatalog.Types.Float4Array;
histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
correlation: Nullable<PgCatalog.Types.Float4>;
mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
mostCommonElemFreqs: PgCatalog.Types.Float4Array;
elemCountHistogram: PgCatalog.Types.Float4Array;
}

export type PgStatsExtExprsArray = 
     Array<PgCatalog.Types.PgStatsExtExprs>
    ;

export type PgPublicationTables = {
pubname: Nullable<PgCatalog.Types.Name>;
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
attnames: PgCatalog.Types.NameArray;
rowfilter: Nullable<PgCatalog.Types.Text>;
}

export type PgPublicationTablesArray = 
     Array<PgCatalog.Types.PgPublicationTables>
    ;

export type PgLocks = {
locktype: Nullable<PgCatalog.Types.Text>;
database: Nullable<PgCatalog.Types.Oid>;
relation: Nullable<PgCatalog.Types.Oid>;
page: Nullable<PgCatalog.Types.Int4>;
tuple: Nullable<PgCatalog.Types.Int2>;
virtualxid: Nullable<PgCatalog.Types.Text>;
transactionid: Nullable<PgCatalog.Types.Xid>;
classid: Nullable<PgCatalog.Types.Oid>;
objid: Nullable<PgCatalog.Types.Oid>;
objsubid: Nullable<PgCatalog.Types.Int2>;
virtualtransaction: Nullable<PgCatalog.Types.Text>;
pid: Nullable<PgCatalog.Types.Int4>;
mode: Nullable<PgCatalog.Types.Text>;
granted: Nullable<PgCatalog.Types.Bool>;
fastpath: Nullable<PgCatalog.Types.Bool>;
waitstart: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgLocksArray = 
     Array<PgCatalog.Types.PgLocks>
    ;

export type PgCursors = {
name: Nullable<PgCatalog.Types.Text>;
statement: Nullable<PgCatalog.Types.Text>;
isHoldable: Nullable<PgCatalog.Types.Bool>;
isBinary: Nullable<PgCatalog.Types.Bool>;
isScrollable: Nullable<PgCatalog.Types.Bool>;
creationTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgCursorsArray = 
     Array<PgCatalog.Types.PgCursors>
    ;

export type PgAvailableExtensions = {
name: Nullable<PgCatalog.Types.Name>;
defaultVersion: Nullable<PgCatalog.Types.Text>;
installedVersion: Nullable<PgCatalog.Types.Text>;
comment: Nullable<PgCatalog.Types.Text>;
}

export type PgAvailableExtensionsArray = 
     Array<PgCatalog.Types.PgAvailableExtensions>
    ;

export type PgAvailableExtensionVersions = {
name: Nullable<PgCatalog.Types.Name>;
version: Nullable<PgCatalog.Types.Text>;
installed: Nullable<PgCatalog.Types.Bool>;
superuser: Nullable<PgCatalog.Types.Bool>;
trusted: Nullable<PgCatalog.Types.Bool>;
relocatable: Nullable<PgCatalog.Types.Bool>;
schema: Nullable<PgCatalog.Types.Name>;
requires: PgCatalog.Types.NameArray;
comment: Nullable<PgCatalog.Types.Text>;
}

export type PgAvailableExtensionVersionsArray = 
     Array<PgCatalog.Types.PgAvailableExtensionVersions>
    ;

export type PgPreparedXacts = {
transaction: Nullable<PgCatalog.Types.Xid>;
gid: Nullable<PgCatalog.Types.Text>;
prepared: Nullable<PgCatalog.Types.Timestamptz>;
owner: Nullable<PgCatalog.Types.Name>;
database: Nullable<PgCatalog.Types.Name>;
}

export type PgPreparedXactsArray = 
     Array<PgCatalog.Types.PgPreparedXacts>
    ;

export type PgPreparedStatements = {
name: Nullable<PgCatalog.Types.Text>;
statement: Nullable<PgCatalog.Types.Text>;
prepareTime: Nullable<PgCatalog.Types.Timestamptz>;
parameterTypes: PgCatalog.Types.RegtypeArray;
resultTypes: PgCatalog.Types.RegtypeArray;
fromSql: Nullable<PgCatalog.Types.Bool>;
genericPlans: Nullable<PgCatalog.Types.Int8>;
customPlans: Nullable<PgCatalog.Types.Int8>;
}

export type PgPreparedStatementsArray = 
     Array<PgCatalog.Types.PgPreparedStatements>
    ;

export type PgSeclabels = {
objoid: Nullable<PgCatalog.Types.Oid>;
classoid: Nullable<PgCatalog.Types.Oid>;
objsubid: Nullable<PgCatalog.Types.Int4>;
objtype: Nullable<PgCatalog.Types.Text>;
objnamespace: Nullable<PgCatalog.Types.Oid>;
objname: Nullable<PgCatalog.Types.Text>;
provider: Nullable<PgCatalog.Types.Text>;
label: Nullable<PgCatalog.Types.Text>;
}

export type PgSeclabelsArray = 
     Array<PgCatalog.Types.PgSeclabels>
    ;

export type PgSettings = {
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
unit: Nullable<PgCatalog.Types.Text>;
category: Nullable<PgCatalog.Types.Text>;
shortDesc: Nullable<PgCatalog.Types.Text>;
extraDesc: Nullable<PgCatalog.Types.Text>;
context: Nullable<PgCatalog.Types.Text>;
vartype: Nullable<PgCatalog.Types.Text>;
source: Nullable<PgCatalog.Types.Text>;
minVal: Nullable<PgCatalog.Types.Text>;
maxVal: Nullable<PgCatalog.Types.Text>;
enumvals: PgCatalog.Types.TextArray;
bootVal: Nullable<PgCatalog.Types.Text>;
resetVal: Nullable<PgCatalog.Types.Text>;
sourcefile: Nullable<PgCatalog.Types.Text>;
sourceline: Nullable<PgCatalog.Types.Int4>;
pendingRestart: Nullable<PgCatalog.Types.Bool>;
}

export type PgSettingsArray = 
     Array<PgCatalog.Types.PgSettings>
    ;

export type PgFileSettings = {
sourcefile: Nullable<PgCatalog.Types.Text>;
sourceline: Nullable<PgCatalog.Types.Int4>;
seqno: Nullable<PgCatalog.Types.Int4>;
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
applied: Nullable<PgCatalog.Types.Bool>;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgFileSettingsArray = 
     Array<PgCatalog.Types.PgFileSettings>
    ;

export type PgHbaFileRules = {
ruleNumber: Nullable<PgCatalog.Types.Int4>;
fileName: Nullable<PgCatalog.Types.Text>;
lineNumber: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Text>;
database: PgCatalog.Types.TextArray;
userName: PgCatalog.Types.TextArray;
address: Nullable<PgCatalog.Types.Text>;
netmask: Nullable<PgCatalog.Types.Text>;
authMethod: Nullable<PgCatalog.Types.Text>;
options: PgCatalog.Types.TextArray;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgHbaFileRulesArray = 
     Array<PgCatalog.Types.PgHbaFileRules>
    ;

export type PgIdentFileMappings = {
mapNumber: Nullable<PgCatalog.Types.Int4>;
fileName: Nullable<PgCatalog.Types.Text>;
lineNumber: Nullable<PgCatalog.Types.Int4>;
mapName: Nullable<PgCatalog.Types.Text>;
sysName: Nullable<PgCatalog.Types.Text>;
pgUsername: Nullable<PgCatalog.Types.Text>;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgIdentFileMappingsArray = 
     Array<PgCatalog.Types.PgIdentFileMappings>
    ;

export type PgTimezoneAbbrevs = {
abbrev: Nullable<PgCatalog.Types.Text>;
utcOffset: Nullable<PgCatalog.Types.Interval>;
isDst: Nullable<PgCatalog.Types.Bool>;
}

export type PgTimezoneAbbrevsArray = 
     Array<PgCatalog.Types.PgTimezoneAbbrevs>
    ;

export type PgTimezoneNames = {
name: Nullable<PgCatalog.Types.Text>;
abbrev: Nullable<PgCatalog.Types.Text>;
utcOffset: Nullable<PgCatalog.Types.Interval>;
isDst: Nullable<PgCatalog.Types.Bool>;
}

export type PgTimezoneNamesArray = 
     Array<PgCatalog.Types.PgTimezoneNames>
    ;

export type PgConfig = {
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
}

export type PgConfigArray = 
     Array<PgCatalog.Types.PgConfig>
    ;

export type PgShmemAllocations = {
name: Nullable<PgCatalog.Types.Text>;
off: Nullable<PgCatalog.Types.Int8>;
size: Nullable<PgCatalog.Types.Int8>;
allocatedSize: Nullable<PgCatalog.Types.Int8>;
}

export type PgShmemAllocationsArray = 
     Array<PgCatalog.Types.PgShmemAllocations>
    ;

export type PgBackendMemoryContexts = {
name: Nullable<PgCatalog.Types.Text>;
ident: Nullable<PgCatalog.Types.Text>;
parent: Nullable<PgCatalog.Types.Text>;
level: Nullable<PgCatalog.Types.Int4>;
totalBytes: Nullable<PgCatalog.Types.Int8>;
totalNblocks: Nullable<PgCatalog.Types.Int8>;
freeBytes: Nullable<PgCatalog.Types.Int8>;
freeChunks: Nullable<PgCatalog.Types.Int8>;
usedBytes: Nullable<PgCatalog.Types.Int8>;
}

export type PgBackendMemoryContextsArray = 
     Array<PgCatalog.Types.PgBackendMemoryContexts>
    ;

export type PgStatAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatAllTablesArray = 
     Array<PgCatalog.Types.PgStatAllTables>
    ;

export type PgStatXactAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactAllTablesArray = 
     Array<PgCatalog.Types.PgStatXactAllTables>
    ;

export type PgStatSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatSysTablesArray = 
     Array<PgCatalog.Types.PgStatSysTables>
    ;

export type PgStatXactSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactSysTablesArray = 
     Array<PgCatalog.Types.PgStatXactSysTables>
    ;

export type PgStatUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatUserTablesArray = 
     Array<PgCatalog.Types.PgStatUserTables>
    ;

export type PgStatXactUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactUserTablesArray = 
     Array<PgCatalog.Types.PgStatXactUserTables>
    ;

export type PgStatioAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllTablesArray = 
     Array<PgCatalog.Types.PgStatioAllTables>
    ;

export type PgStatioSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysTablesArray = 
     Array<PgCatalog.Types.PgStatioSysTables>
    ;

export type PgStatioUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserTablesArray = 
     Array<PgCatalog.Types.PgStatioUserTables>
    ;

export type PgStatAllIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatAllIndexesArray = 
     Array<PgCatalog.Types.PgStatAllIndexes>
    ;

export type PgStatSysIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatSysIndexesArray = 
     Array<PgCatalog.Types.PgStatSysIndexes>
    ;

export type PgStatUserIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatUserIndexesArray = 
     Array<PgCatalog.Types.PgStatUserIndexes>
    ;

export type PgStatioAllIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllIndexesArray = 
     Array<PgCatalog.Types.PgStatioAllIndexes>
    ;

export type PgStatioSysIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysIndexesArray = 
     Array<PgCatalog.Types.PgStatioSysIndexes>
    ;

export type PgStatioUserIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserIndexesArray = 
     Array<PgCatalog.Types.PgStatioUserIndexes>
    ;

export type PgStatioAllSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllSequencesArray = 
     Array<PgCatalog.Types.PgStatioAllSequences>
    ;

export type PgStatioSysSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysSequencesArray = 
     Array<PgCatalog.Types.PgStatioSysSequences>
    ;

export type PgStatioUserSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserSequencesArray = 
     Array<PgCatalog.Types.PgStatioUserSequences>
    ;

export type PgStatActivity = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
pid: Nullable<PgCatalog.Types.Int4>;
leaderPid: Nullable<PgCatalog.Types.Int4>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
applicationName: Nullable<PgCatalog.Types.Text>;
clientAddr: Nullable<PgCatalog.Types.Inet>;
clientHostname: Nullable<PgCatalog.Types.Text>;
clientPort: Nullable<PgCatalog.Types.Int4>;
backendStart: Nullable<PgCatalog.Types.Timestamptz>;
xactStart: Nullable<PgCatalog.Types.Timestamptz>;
queryStart: Nullable<PgCatalog.Types.Timestamptz>;
stateChange: Nullable<PgCatalog.Types.Timestamptz>;
waitEventType: Nullable<PgCatalog.Types.Text>;
waitEvent: Nullable<PgCatalog.Types.Text>;
state: Nullable<PgCatalog.Types.Text>;
backendXid: Nullable<PgCatalog.Types.Xid>;
backendXmin: Nullable<PgCatalog.Types.Xid>;
queryId: Nullable<PgCatalog.Types.Int8>;
query: Nullable<PgCatalog.Types.Text>;
backendType: Nullable<PgCatalog.Types.Text>;
}

export type PgStatActivityArray = 
     Array<PgCatalog.Types.PgStatActivity>
    ;

export type PgStatReplication = {
pid: Nullable<PgCatalog.Types.Int4>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
applicationName: Nullable<PgCatalog.Types.Text>;
clientAddr: Nullable<PgCatalog.Types.Inet>;
clientHostname: Nullable<PgCatalog.Types.Text>;
clientPort: Nullable<PgCatalog.Types.Int4>;
backendStart: Nullable<PgCatalog.Types.Timestamptz>;
backendXmin: Nullable<PgCatalog.Types.Xid>;
state: Nullable<PgCatalog.Types.Text>;
sentLsn: Nullable<PgCatalog.Types.PgLsn>;
writeLsn: Nullable<PgCatalog.Types.PgLsn>;
flushLsn: Nullable<PgCatalog.Types.PgLsn>;
replayLsn: Nullable<PgCatalog.Types.PgLsn>;
writeLag: Nullable<PgCatalog.Types.Interval>;
flushLag: Nullable<PgCatalog.Types.Interval>;
replayLag: Nullable<PgCatalog.Types.Interval>;
syncPriority: Nullable<PgCatalog.Types.Int4>;
syncState: Nullable<PgCatalog.Types.Text>;
replyTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatReplicationArray = 
     Array<PgCatalog.Types.PgStatReplication>
    ;

export type PgStatSlru = {
name: Nullable<PgCatalog.Types.Text>;
blksZeroed: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksWritten: Nullable<PgCatalog.Types.Int8>;
blksExists: Nullable<PgCatalog.Types.Int8>;
flushes: Nullable<PgCatalog.Types.Int8>;
truncates: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSlruArray = 
     Array<PgCatalog.Types.PgStatSlru>
    ;

export type PgStatWalReceiver = {
pid: Nullable<PgCatalog.Types.Int4>;
status: Nullable<PgCatalog.Types.Text>;
receiveStartLsn: Nullable<PgCatalog.Types.PgLsn>;
receiveStartTli: Nullable<PgCatalog.Types.Int4>;
writtenLsn: Nullable<PgCatalog.Types.PgLsn>;
flushedLsn: Nullable<PgCatalog.Types.PgLsn>;
receivedTli: Nullable<PgCatalog.Types.Int4>;
lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
slotName: Nullable<PgCatalog.Types.Text>;
senderHost: Nullable<PgCatalog.Types.Text>;
senderPort: Nullable<PgCatalog.Types.Int4>;
conninfo: Nullable<PgCatalog.Types.Text>;
}

export type PgStatWalReceiverArray = 
     Array<PgCatalog.Types.PgStatWalReceiver>
    ;

export type PgStatRecoveryPrefetch = {
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
prefetch: Nullable<PgCatalog.Types.Int8>;
hit: Nullable<PgCatalog.Types.Int8>;
skipInit: Nullable<PgCatalog.Types.Int8>;
skipNew: Nullable<PgCatalog.Types.Int8>;
skipFpw: Nullable<PgCatalog.Types.Int8>;
skipRep: Nullable<PgCatalog.Types.Int8>;
walDistance: Nullable<PgCatalog.Types.Int4>;
blockDistance: Nullable<PgCatalog.Types.Int4>;
ioDepth: Nullable<PgCatalog.Types.Int4>;
}

export type PgStatRecoveryPrefetchArray = 
     Array<PgCatalog.Types.PgStatRecoveryPrefetch>
    ;

export type PgStatSubscription = {
subid: Nullable<PgCatalog.Types.Oid>;
subname: Nullable<PgCatalog.Types.Name>;
pid: Nullable<PgCatalog.Types.Int4>;
leaderPid: Nullable<PgCatalog.Types.Int4>;
relid: Nullable<PgCatalog.Types.Oid>;
receivedLsn: Nullable<PgCatalog.Types.PgLsn>;
lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSubscriptionArray = 
     Array<PgCatalog.Types.PgStatSubscription>
    ;

export type PgStatSsl = {
pid: Nullable<PgCatalog.Types.Int4>;
ssl: Nullable<PgCatalog.Types.Bool>;
version: Nullable<PgCatalog.Types.Text>;
cipher: Nullable<PgCatalog.Types.Text>;
bits: Nullable<PgCatalog.Types.Int4>;
clientDn: Nullable<PgCatalog.Types.Text>;
clientSerial: Nullable<PgCatalog.Types.Numeric>;
issuerDn: Nullable<PgCatalog.Types.Text>;
}

export type PgStatSslArray = 
     Array<PgCatalog.Types.PgStatSsl>
    ;

export type PgStatGssapi = {
pid: Nullable<PgCatalog.Types.Int4>;
gssAuthenticated: Nullable<PgCatalog.Types.Bool>;
principal: Nullable<PgCatalog.Types.Text>;
encrypted: Nullable<PgCatalog.Types.Bool>;
credentialsDelegated: Nullable<PgCatalog.Types.Bool>;
}

export type PgStatGssapiArray = 
     Array<PgCatalog.Types.PgStatGssapi>
    ;

export type PgReplicationSlots = {
slotName: Nullable<PgCatalog.Types.Name>;
plugin: Nullable<PgCatalog.Types.Name>;
slotType: Nullable<PgCatalog.Types.Text>;
datoid: Nullable<PgCatalog.Types.Oid>;
database: Nullable<PgCatalog.Types.Name>;
temporary: Nullable<PgCatalog.Types.Bool>;
active: Nullable<PgCatalog.Types.Bool>;
activePid: Nullable<PgCatalog.Types.Int4>;
xmin: Nullable<PgCatalog.Types.Xid>;
catalogXmin: Nullable<PgCatalog.Types.Xid>;
restartLsn: Nullable<PgCatalog.Types.PgLsn>;
confirmedFlushLsn: Nullable<PgCatalog.Types.PgLsn>;
walStatus: Nullable<PgCatalog.Types.Text>;
safeWalSize: Nullable<PgCatalog.Types.Int8>;
twoPhase: Nullable<PgCatalog.Types.Bool>;
conflicting: Nullable<PgCatalog.Types.Bool>;
}

export type PgReplicationSlotsArray = 
     Array<PgCatalog.Types.PgReplicationSlots>
    ;

export type PgStatReplicationSlots = {
slotName: Nullable<PgCatalog.Types.Text>;
spillTxns: Nullable<PgCatalog.Types.Int8>;
spillCount: Nullable<PgCatalog.Types.Int8>;
spillBytes: Nullable<PgCatalog.Types.Int8>;
streamTxns: Nullable<PgCatalog.Types.Int8>;
streamCount: Nullable<PgCatalog.Types.Int8>;
streamBytes: Nullable<PgCatalog.Types.Int8>;
totalTxns: Nullable<PgCatalog.Types.Int8>;
totalBytes: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatReplicationSlotsArray = 
     Array<PgCatalog.Types.PgStatReplicationSlots>
    ;

export type PgStatDatabase = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
numbackends: Nullable<PgCatalog.Types.Int4>;
xactCommit: Nullable<PgCatalog.Types.Int8>;
xactRollback: Nullable<PgCatalog.Types.Int8>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
tupReturned: Nullable<PgCatalog.Types.Int8>;
tupFetched: Nullable<PgCatalog.Types.Int8>;
tupInserted: Nullable<PgCatalog.Types.Int8>;
tupUpdated: Nullable<PgCatalog.Types.Int8>;
tupDeleted: Nullable<PgCatalog.Types.Int8>;
conflicts: Nullable<PgCatalog.Types.Int8>;
tempFiles: Nullable<PgCatalog.Types.Int8>;
tempBytes: Nullable<PgCatalog.Types.Int8>;
deadlocks: Nullable<PgCatalog.Types.Int8>;
checksumFailures: Nullable<PgCatalog.Types.Int8>;
checksumLastFailure: Nullable<PgCatalog.Types.Timestamptz>;
blkReadTime: Nullable<PgCatalog.Types.Float8>;
blkWriteTime: Nullable<PgCatalog.Types.Float8>;
sessionTime: Nullable<PgCatalog.Types.Float8>;
activeTime: Nullable<PgCatalog.Types.Float8>;
idleInTransactionTime: Nullable<PgCatalog.Types.Float8>;
sessions: Nullable<PgCatalog.Types.Int8>;
sessionsAbandoned: Nullable<PgCatalog.Types.Int8>;
sessionsFatal: Nullable<PgCatalog.Types.Int8>;
sessionsKilled: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatDatabaseArray = 
     Array<PgCatalog.Types.PgStatDatabase>
    ;

export type PgStatDatabaseConflicts = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
conflTablespace: Nullable<PgCatalog.Types.Int8>;
conflLock: Nullable<PgCatalog.Types.Int8>;
conflSnapshot: Nullable<PgCatalog.Types.Int8>;
conflBufferpin: Nullable<PgCatalog.Types.Int8>;
conflDeadlock: Nullable<PgCatalog.Types.Int8>;
conflActiveLogicalslot: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatDatabaseConflictsArray = 
     Array<PgCatalog.Types.PgStatDatabaseConflicts>
    ;

export type PgStatUserFunctions = {
funcid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
funcname: Nullable<PgCatalog.Types.Name>;
calls: Nullable<PgCatalog.Types.Int8>;
totalTime: Nullable<PgCatalog.Types.Float8>;
selfTime: Nullable<PgCatalog.Types.Float8>;
}

export type PgStatUserFunctionsArray = 
     Array<PgCatalog.Types.PgStatUserFunctions>
    ;

export type PgStatXactUserFunctions = {
funcid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
funcname: Nullable<PgCatalog.Types.Name>;
calls: Nullable<PgCatalog.Types.Int8>;
totalTime: Nullable<PgCatalog.Types.Float8>;
selfTime: Nullable<PgCatalog.Types.Float8>;
}

export type PgStatXactUserFunctionsArray = 
     Array<PgCatalog.Types.PgStatXactUserFunctions>
    ;

export type PgStatArchiver = {
archivedCount: Nullable<PgCatalog.Types.Int8>;
lastArchivedWal: Nullable<PgCatalog.Types.Text>;
lastArchivedTime: Nullable<PgCatalog.Types.Timestamptz>;
failedCount: Nullable<PgCatalog.Types.Int8>;
lastFailedWal: Nullable<PgCatalog.Types.Text>;
lastFailedTime: Nullable<PgCatalog.Types.Timestamptz>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatArchiverArray = 
     Array<PgCatalog.Types.PgStatArchiver>
    ;

export type PgStatBgwriter = {
checkpointsTimed: Nullable<PgCatalog.Types.Int8>;
checkpointsReq: Nullable<PgCatalog.Types.Int8>;
checkpointWriteTime: Nullable<PgCatalog.Types.Float8>;
checkpointSyncTime: Nullable<PgCatalog.Types.Float8>;
buffersCheckpoint: Nullable<PgCatalog.Types.Int8>;
buffersClean: Nullable<PgCatalog.Types.Int8>;
maxwrittenClean: Nullable<PgCatalog.Types.Int8>;
buffersBackend: Nullable<PgCatalog.Types.Int8>;
buffersBackendFsync: Nullable<PgCatalog.Types.Int8>;
buffersAlloc: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatBgwriterArray = 
     Array<PgCatalog.Types.PgStatBgwriter>
    ;

export type PgStatIo = {
backendType: Nullable<PgCatalog.Types.Text>;
object: Nullable<PgCatalog.Types.Text>;
context: Nullable<PgCatalog.Types.Text>;
reads: Nullable<PgCatalog.Types.Int8>;
readTime: Nullable<PgCatalog.Types.Float8>;
writes: Nullable<PgCatalog.Types.Int8>;
writeTime: Nullable<PgCatalog.Types.Float8>;
writebacks: Nullable<PgCatalog.Types.Int8>;
writebackTime: Nullable<PgCatalog.Types.Float8>;
extends: Nullable<PgCatalog.Types.Int8>;
extendTime: Nullable<PgCatalog.Types.Float8>;
opBytes: Nullable<PgCatalog.Types.Int8>;
hits: Nullable<PgCatalog.Types.Int8>;
evictions: Nullable<PgCatalog.Types.Int8>;
reuses: Nullable<PgCatalog.Types.Int8>;
fsyncs: Nullable<PgCatalog.Types.Int8>;
fsyncTime: Nullable<PgCatalog.Types.Float8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatIoArray = 
     Array<PgCatalog.Types.PgStatIo>
    ;

export type PgStatWal = {
walRecords: Nullable<PgCatalog.Types.Int8>;
walFpi: Nullable<PgCatalog.Types.Int8>;
walBytes: Nullable<PgCatalog.Types.Numeric>;
walBuffersFull: Nullable<PgCatalog.Types.Int8>;
walWrite: Nullable<PgCatalog.Types.Int8>;
walSync: Nullable<PgCatalog.Types.Int8>;
walWriteTime: Nullable<PgCatalog.Types.Float8>;
walSyncTime: Nullable<PgCatalog.Types.Float8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatWalArray = 
     Array<PgCatalog.Types.PgStatWal>
    ;

export type PgStatProgressAnalyze = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
phase: Nullable<PgCatalog.Types.Text>;
sampleBlksTotal: Nullable<PgCatalog.Types.Int8>;
sampleBlksScanned: Nullable<PgCatalog.Types.Int8>;
extStatsTotal: Nullable<PgCatalog.Types.Int8>;
extStatsComputed: Nullable<PgCatalog.Types.Int8>;
childTablesTotal: Nullable<PgCatalog.Types.Int8>;
childTablesDone: Nullable<PgCatalog.Types.Int8>;
currentChildTableRelid: Nullable<PgCatalog.Types.Oid>;
}

export type PgStatProgressAnalyzeArray = 
     Array<PgCatalog.Types.PgStatProgressAnalyze>
    ;

export type PgStatProgressVacuum = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
phase: Nullable<PgCatalog.Types.Text>;
heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
heapBlksVacuumed: Nullable<PgCatalog.Types.Int8>;
indexVacuumCount: Nullable<PgCatalog.Types.Int8>;
maxDeadTuples: Nullable<PgCatalog.Types.Int8>;
numDeadTuples: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressVacuumArray = 
     Array<PgCatalog.Types.PgStatProgressVacuum>
    ;

export type PgStatProgressCluster = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
phase: Nullable<PgCatalog.Types.Text>;
clusterIndexRelid: Nullable<PgCatalog.Types.Oid>;
heapTuplesScanned: Nullable<PgCatalog.Types.Int8>;
heapTuplesWritten: Nullable<PgCatalog.Types.Int8>;
heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
indexRebuildCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressClusterArray = 
     Array<PgCatalog.Types.PgStatProgressCluster>
    ;

export type PgStatProgressCreateIndex = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
indexRelid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
phase: Nullable<PgCatalog.Types.Text>;
lockersTotal: Nullable<PgCatalog.Types.Int8>;
lockersDone: Nullable<PgCatalog.Types.Int8>;
currentLockerPid: Nullable<PgCatalog.Types.Int8>;
blocksTotal: Nullable<PgCatalog.Types.Int8>;
blocksDone: Nullable<PgCatalog.Types.Int8>;
tuplesTotal: Nullable<PgCatalog.Types.Int8>;
tuplesDone: Nullable<PgCatalog.Types.Int8>;
partitionsTotal: Nullable<PgCatalog.Types.Int8>;
partitionsDone: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressCreateIndexArray = 
     Array<PgCatalog.Types.PgStatProgressCreateIndex>
    ;

export type PgStatProgressBasebackup = {
pid: Nullable<PgCatalog.Types.Int4>;
phase: Nullable<PgCatalog.Types.Text>;
backupTotal: Nullable<PgCatalog.Types.Int8>;
backupStreamed: Nullable<PgCatalog.Types.Int8>;
tablespacesTotal: Nullable<PgCatalog.Types.Int8>;
tablespacesStreamed: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressBasebackupArray = 
     Array<PgCatalog.Types.PgStatProgressBasebackup>
    ;

export type PgStatProgressCopy = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
type: Nullable<PgCatalog.Types.Text>;
bytesProcessed: Nullable<PgCatalog.Types.Int8>;
bytesTotal: Nullable<PgCatalog.Types.Int8>;
tuplesProcessed: Nullable<PgCatalog.Types.Int8>;
tuplesExcluded: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressCopyArray = 
     Array<PgCatalog.Types.PgStatProgressCopy>
    ;

export type PgUserMappings = {
umid: Nullable<PgCatalog.Types.Oid>;
srvid: Nullable<PgCatalog.Types.Oid>;
srvname: Nullable<PgCatalog.Types.Name>;
umuser: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
umoptions: PgCatalog.Types.TextArray;
}

export type PgUserMappingsArray = 
     Array<PgCatalog.Types.PgUserMappings>
    ;

export type PgReplicationOriginStatus = {
localId: Nullable<PgCatalog.Types.Oid>;
externalId: Nullable<PgCatalog.Types.Text>;
remoteLsn: Nullable<PgCatalog.Types.PgLsn>;
localLsn: Nullable<PgCatalog.Types.PgLsn>;
}

export type PgReplicationOriginStatusArray = 
     Array<PgCatalog.Types.PgReplicationOriginStatus>
    ;

export type PgStatSubscriptionStats = {
subid: Nullable<PgCatalog.Types.Oid>;
subname: Nullable<PgCatalog.Types.Name>;
applyErrorCount: Nullable<PgCatalog.Types.Int8>;
syncErrorCount: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSubscriptionStatsArray = 
     Array<PgCatalog.Types.PgStatSubscriptionStats>
    ;

export type PgProcOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgProcPronameArgsNspIndex = {
proname: PgCatalog.Types.Name;
proargtypes: PgCatalog.Types.Oidvector;
pronamespace: PgCatalog.Types.Oid;
}

export type PgTypeOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTypeTypnameNspIndex = {
typname: PgCatalog.Types.Name;
typnamespace: PgCatalog.Types.Oid;
}

export type PgAttributeRelidAttnamIndex = {
attrelid: PgCatalog.Types.Oid;
attname: PgCatalog.Types.Name;
}

export type PgAttributeRelidAttnumIndex = {
attrelid: PgCatalog.Types.Oid;
attnum: PgCatalog.Types.Int2;
}

export type PgClassOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgClassRelnameNspIndex = {
relname: PgCatalog.Types.Name;
relnamespace: PgCatalog.Types.Oid;
}

export type PgClassTblspcRelfilenodeIndex = {
reltablespace: PgCatalog.Types.Oid;
relfilenode: PgCatalog.Types.Oid;
}

export type PgAttrdefAdrelidAdnumIndex = {
adrelid: PgCatalog.Types.Oid;
adnum: PgCatalog.Types.Int2;
}

export type PgAttrdefOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConstraintConnameNspIndex = {
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
}

export type PgConstraintConrelidContypidConnameIndex = {
conrelid: PgCatalog.Types.Oid;
contypid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
}

export type PgConstraintContypidIndex = {
contypid: PgCatalog.Types.Oid;
}

export type PgConstraintOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConstraintConparentidIndex = {
conparentid: PgCatalog.Types.Oid;
}

export type PgInheritsRelidSeqnoIndex = {
inhrelid: PgCatalog.Types.Oid;
inhseqno: PgCatalog.Types.Int4;
}

export type PgInheritsParentIndex = {
inhparent: PgCatalog.Types.Oid;
}

export type PgIndexIndrelidIndex = {
indrelid: PgCatalog.Types.Oid;
}

export type PgIndexIndexrelidIndex = {
indexrelid: PgCatalog.Types.Oid;
}

export type PgOperatorOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgOperatorOprnameLRNIndex = {
oprname: PgCatalog.Types.Name;
oprleft: PgCatalog.Types.Oid;
oprright: PgCatalog.Types.Oid;
oprnamespace: PgCatalog.Types.Oid;
}

export type PgOpfamilyAmNameNspIndex = {
opfmethod: PgCatalog.Types.Oid;
opfname: PgCatalog.Types.Name;
opfnamespace: PgCatalog.Types.Oid;
}

export type PgOpfamilyOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgOpclassAmNameNspIndex = {
opcmethod: PgCatalog.Types.Oid;
opcname: PgCatalog.Types.Name;
opcnamespace: PgCatalog.Types.Oid;
}

export type PgOpclassOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmNameIndex = {
amname: PgCatalog.Types.Name;
}

export type PgAmOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmopFamStratIndex = {
amopfamily: PgCatalog.Types.Oid;
amoplefttype: PgCatalog.Types.Oid;
amoprighttype: PgCatalog.Types.Oid;
amopstrategy: PgCatalog.Types.Int2;
}

export type PgAmopOprFamIndex = {
amopopr: PgCatalog.Types.Oid;
amoppurpose: PgCatalog.Types.Char;
amopfamily: PgCatalog.Types.Oid;
}

export type PgAmopOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmprocFamProcIndex = {
amprocfamily: PgCatalog.Types.Oid;
amproclefttype: PgCatalog.Types.Oid;
amprocrighttype: PgCatalog.Types.Oid;
amprocnum: PgCatalog.Types.Int2;
}

export type PgAmprocOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLanguageNameIndex = {
lanname: PgCatalog.Types.Name;
}

export type PgLanguageOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLargeobjectMetadataOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLargeobjectLoidPnIndex = {
loid: PgCatalog.Types.Oid;
pageno: PgCatalog.Types.Int4;
}

export type PgAggregateFnoidIndex = {
aggfnoid: PgCatalog.Types.Regproc;
}

export type PgStatisticRelidAttInhIndex = {
starelid: PgCatalog.Types.Oid;
staattnum: PgCatalog.Types.Int2;
stainherit: PgCatalog.Types.Bool;
}

export type PgStatisticExtOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgStatisticExtNameIndex = {
stxname: PgCatalog.Types.Name;
stxnamespace: PgCatalog.Types.Oid;
}

export type PgStatisticExtRelidIndex = {
stxrelid: PgCatalog.Types.Oid;
}

export type PgStatisticExtDataStxoidInhIndex = {
stxoid: PgCatalog.Types.Oid;
stxdinherit: PgCatalog.Types.Bool;
}

export type PgRewriteOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgRewriteRelRulenameIndex = {
evClass: PgCatalog.Types.Oid;
rulename: PgCatalog.Types.Name;
}

export type PgTriggerTgconstraintIndex = {
tgconstraint: PgCatalog.Types.Oid;
}

export type PgTriggerTgrelidTgnameIndex = {
tgrelid: PgCatalog.Types.Oid;
tgname: PgCatalog.Types.Name;
}

export type PgTriggerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgEventTriggerEvtnameIndex = {
evtname: PgCatalog.Types.Name;
}

export type PgEventTriggerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDescriptionOCOIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgCastOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgCastSourceTargetIndex = {
castsource: PgCatalog.Types.Oid;
casttarget: PgCatalog.Types.Oid;
}

export type PgEnumOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgEnumTypidLabelIndex = {
enumtypid: PgCatalog.Types.Oid;
enumlabel: PgCatalog.Types.Name;
}

export type PgEnumTypidSortorderIndex = {
enumtypid: PgCatalog.Types.Oid;
enumsortorder: PgCatalog.Types.Float4;
}

export type PgNamespaceNspnameIndex = {
nspname: PgCatalog.Types.Name;
}

export type PgNamespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConversionDefaultIndex = {
connamespace: PgCatalog.Types.Oid;
conforencoding: PgCatalog.Types.Int4;
contoencoding: PgCatalog.Types.Int4;
oid: PgCatalog.Types.Oid;
}

export type PgConversionNameNspIndex = {
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
}

export type PgConversionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDependDependerIndex = {
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgDependReferenceIndex = {
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
refobjsubid: PgCatalog.Types.Int4;
}

export type PgDatabaseDatnameIndex = {
datname: PgCatalog.Types.Name;
}

export type PgDatabaseOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDbRoleSettingDatabaseidRolIndex = {
setdatabase: PgCatalog.Types.Oid;
setrole: PgCatalog.Types.Oid;
}

export type PgTablespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTablespaceSpcnameIndex = {
spcname: PgCatalog.Types.Name;
}

export type PgAuthidRolnameIndex = {
rolname: PgCatalog.Types.Name;
}

export type PgAuthidOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAuthMembersOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAuthMembersRoleMemberIndex = {
roleid: PgCatalog.Types.Oid;
member: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
}

export type PgAuthMembersMemberRoleIndex = {
member: PgCatalog.Types.Oid;
roleid: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
}

export type PgAuthMembersGrantorIndex = {
grantor: PgCatalog.Types.Oid;
}

export type PgShdependDependerIndex = {
dbid: PgCatalog.Types.Oid;
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgShdependReferenceIndex = {
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
}

export type PgShdescriptionOCIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
}

export type PgTsConfigCfgnameIndex = {
cfgname: PgCatalog.Types.Name;
cfgnamespace: PgCatalog.Types.Oid;
}

export type PgTsConfigOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsConfigMapIndex = {
mapcfg: PgCatalog.Types.Oid;
maptokentype: PgCatalog.Types.Int4;
mapseqno: PgCatalog.Types.Int4;
}

export type PgTsDictDictnameIndex = {
dictname: PgCatalog.Types.Name;
dictnamespace: PgCatalog.Types.Oid;
}

export type PgTsDictOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsParserPrsnameIndex = {
prsname: PgCatalog.Types.Name;
prsnamespace: PgCatalog.Types.Oid;
}

export type PgTsParserOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsTemplateTmplnameIndex = {
tmplname: PgCatalog.Types.Name;
tmplnamespace: PgCatalog.Types.Oid;
}

export type PgTsTemplateOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgExtensionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgExtensionNameIndex = {
extname: PgCatalog.Types.Name;
}

export type PgForeignDataWrapperOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgForeignDataWrapperNameIndex = {
fdwname: PgCatalog.Types.Name;
}

export type PgForeignServerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgForeignServerNameIndex = {
srvname: PgCatalog.Types.Name;
}

export type PgUserMappingOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgUserMappingUserServerIndex = {
umuser: PgCatalog.Types.Oid;
umserver: PgCatalog.Types.Oid;
}

export type PgForeignTableRelidIndex = {
ftrelid: PgCatalog.Types.Oid;
}

export type PgPolicyOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPolicyPolrelidPolnameIndex = {
polrelid: PgCatalog.Types.Oid;
polname: PgCatalog.Types.Name;
}

export type PgReplicationOriginRoiidentIndex = {
roident: PgCatalog.Types.Oid;
}

export type PgReplicationOriginRonameIndex = {
roname: PgCatalog.Types.Text;
}

export type PgDefaultAclRoleNspObjIndex = {
defaclrole: PgCatalog.Types.Oid;
defaclnamespace: PgCatalog.Types.Oid;
defaclobjtype: PgCatalog.Types.Char;
}

export type PgDefaultAclOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgInitPrivsOCOIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgSeclabelObjectIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
provider: PgCatalog.Types.Text;
}

export type PgShseclabelObjectIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
provider: PgCatalog.Types.Text;
}

export type PgCollationNameEncNspIndex = {
collname: PgCatalog.Types.Name;
collencoding: PgCatalog.Types.Int4;
collnamespace: PgCatalog.Types.Oid;
}

export type PgCollationOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgParameterAclParnameIndex = {
parname: PgCatalog.Types.Text;
}

export type PgParameterAclOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPartitionedTablePartrelidIndex = {
partrelid: PgCatalog.Types.Oid;
}

export type PgRangeRngtypidIndex = {
rngtypid: PgCatalog.Types.Oid;
}

export type PgRangeRngmultitypidIndex = {
rngmultitypid: PgCatalog.Types.Oid;
}

export type PgTransformOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTransformTypeLangIndex = {
trftype: PgCatalog.Types.Oid;
trflang: PgCatalog.Types.Oid;
}

export type PgSequenceSeqrelidIndex = {
seqrelid: PgCatalog.Types.Oid;
}

export type PgPublicationOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationPubnameIndex = {
pubname: PgCatalog.Types.Name;
}

export type PgPublicationNamespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationNamespacePnnspidPnpubidIndex = {
pnnspid: PgCatalog.Types.Oid;
pnpubid: PgCatalog.Types.Oid;
}

export type PgPublicationRelOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationRelPrrelidPrpubidIndex = {
prrelid: PgCatalog.Types.Oid;
prpubid: PgCatalog.Types.Oid;
}

export type PgPublicationRelPrpubidIndex = {
prpubid: PgCatalog.Types.Oid;
}

export type PgSubscriptionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgSubscriptionSubnameIndex = {
subdbid: PgCatalog.Types.Oid;
subname: PgCatalog.Types.Name;
}

export type PgSubscriptionRelSrrelidSrsubidIndex = {
srrelid: PgCatalog.Types.Oid;
srsubid: PgCatalog.Types.Oid;
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatistic> {
 return { starelid: undefined,staattnum: undefined,stainherit: undefined,stanullfrac: undefined,stawidth: undefined,stadistinct: undefined,stakind1: undefined,stakind2: undefined,stakind3: undefined,stakind4: undefined,stakind5: undefined,staop1: undefined,staop2: undefined,staop3: undefined,staop4: undefined,staop5: undefined,stacoll1: undefined,stacoll2: undefined,stacoll3: undefined,stacoll4: undefined,stacoll5: undefined,stanumbers1: undefined,stanumbers2: undefined,stanumbers3: undefined,stanumbers4: undefined,stanumbers5: undefined,stavalues1: undefined,stavalues2: undefined,stavalues3: undefined,stavalues4: undefined,stavalues5: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatistic,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatistic,  PrimaryKey>
export enum SortOptions  {
starelidAscending = "starelid ASC",
staattnumAscending = "staattnum ASC",
stainheritAscending = "stainherit ASC",
stanullfracAscending = "stanullfrac ASC",
stawidthAscending = "stawidth ASC",
stadistinctAscending = "stadistinct ASC",
stakind1Ascending = "stakind1 ASC",
stakind2Ascending = "stakind2 ASC",
stakind3Ascending = "stakind3 ASC",
stakind4Ascending = "stakind4 ASC",
stakind5Ascending = "stakind5 ASC",
staop1Ascending = "staop1 ASC",
staop2Ascending = "staop2 ASC",
staop3Ascending = "staop3 ASC",
staop4Ascending = "staop4 ASC",
staop5Ascending = "staop5 ASC",
stacoll1Ascending = "stacoll1 ASC",
stacoll2Ascending = "stacoll2 ASC",
stacoll3Ascending = "stacoll3 ASC",
stacoll4Ascending = "stacoll4 ASC",
stacoll5Ascending = "stacoll5 ASC",
stanumbers1Ascending = "stanumbers1 ASC",
stanumbers2Ascending = "stanumbers2 ASC",
stanumbers3Ascending = "stanumbers3 ASC",
stanumbers4Ascending = "stanumbers4 ASC",
stanumbers5Ascending = "stanumbers5 ASC",
stavalues1Ascending = "stavalues1 ASC",
stavalues2Ascending = "stavalues2 ASC",
stavalues3Ascending = "stavalues3 ASC",
stavalues4Ascending = "stavalues4 ASC",
stavalues5Ascending = "stavalues5 ASC",
starelidDescending = "starelid DESC",
staattnumDescending = "staattnum DESC",
stainheritDescending = "stainherit DESC",
stanullfracDescending = "stanullfrac DESC",
stawidthDescending = "stawidth DESC",
stadistinctDescending = "stadistinct DESC",
stakind1Descending = "stakind1 DESC",
stakind2Descending = "stakind2 DESC",
stakind3Descending = "stakind3 DESC",
stakind4Descending = "stakind4 DESC",
stakind5Descending = "stakind5 DESC",
staop1Descending = "staop1 DESC",
staop2Descending = "staop2 DESC",
staop3Descending = "staop3 DESC",
staop4Descending = "staop4 DESC",
staop5Descending = "staop5 DESC",
stacoll1Descending = "stacoll1 DESC",
stacoll2Descending = "stacoll2 DESC",
stacoll3Descending = "stacoll3 DESC",
stacoll4Descending = "stacoll4 DESC",
stacoll5Descending = "stacoll5 DESC",
stanumbers1Descending = "stanumbers1 DESC",
stanumbers2Descending = "stanumbers2 DESC",
stanumbers3Descending = "stanumbers3 DESC",
stanumbers4Descending = "stanumbers4 DESC",
stanumbers5Descending = "stanumbers5 DESC",
stavalues1Descending = "stavalues1 DESC",
stavalues2Descending = "stavalues2 DESC",
stavalues3Descending = "stavalues3 DESC",
stavalues4Descending = "stavalues4 DESC",
stavalues5Descending = "stavalues5 DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Starelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "starelid" as FieldNamesType,
},
Staattnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "staattnum" as FieldNamesType,
},
Stainherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "stainherit" as FieldNamesType,
},
Stanullfrac: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "stanullfrac" as FieldNamesType,
},
Stawidth: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "stawidth" as FieldNamesType,
},
Stadistinct: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "stadistinct" as FieldNamesType,
},
Stakind1: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind1" as FieldNamesType,
},
Stakind2: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind2" as FieldNamesType,
},
Stakind3: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind3" as FieldNamesType,
},
Stakind4: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind4" as FieldNamesType,
},
Stakind5: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind5" as FieldNamesType,
},
Staop1: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop1" as FieldNamesType,
},
Staop2: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop2" as FieldNamesType,
},
Staop3: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop3" as FieldNamesType,
},
Staop4: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop4" as FieldNamesType,
},
Staop5: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop5" as FieldNamesType,
},
Stacoll1: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll1" as FieldNamesType,
},
Stacoll2: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll2" as FieldNamesType,
},
Stacoll3: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll3" as FieldNamesType,
},
Stacoll4: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll4" as FieldNamesType,
},
Stacoll5: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll5" as FieldNamesType,
},
Stanumbers1: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers1" as FieldNamesType,
},
Stanumbers2: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers2" as FieldNamesType,
},
Stanumbers3: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers3" as FieldNamesType,
},
Stanumbers4: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers4" as FieldNamesType,
},
Stanumbers5: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers5" as FieldNamesType,
},
Stavalues1: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues1" as FieldNamesType,
},
Stavalues2: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues2" as FieldNamesType,
},
Stavalues3: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues3" as FieldNamesType,
},
Stavalues4: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues4" as FieldNamesType,
},
Stavalues5: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues5" as FieldNamesType,
},
}
export const ColumnNames = ["Starelid","Staattnum","Stainherit","Stanullfrac","Stawidth","Stadistinct","Stakind1","Stakind2","Stakind3","Stakind4","Stakind5","Staop1","Staop2","Staop3","Staop4","Staop5","Stacoll1","Stacoll2","Stacoll3","Stacoll4","Stacoll5","Stanumbers1","Stanumbers2","Stanumbers3","Stanumbers4","Stanumbers5","Stavalues1","Stavalues2","Stavalues3","Stavalues4","Stavalues5"] as const;
export const FieldNames = ["starelid","staattnum","stainherit","stanullfrac","stawidth","stadistinct","stakind1","stakind2","stakind3","stakind4","stakind5","staop1","staop2","staop3","staop4","staop5","stacoll1","stacoll2","stacoll3","stacoll4","stacoll5","stanumbers1","stanumbers2","stanumbers3","stanumbers4","stanumbers5","stavalues1","stavalues2","stavalues3","stavalues4","stavalues5"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticRelidAttInhIndex;
}
export namespace PgType {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgType> {
 return { oid: undefined,typname: undefined,typnamespace: undefined,typowner: undefined,typlen: undefined,typbyval: undefined,typtype: undefined,typcategory: undefined,typispreferred: undefined,typisdefined: undefined,typdelim: undefined,typrelid: undefined,typsubscript: undefined,typelem: undefined,typarray: undefined,typinput: undefined,typoutput: undefined,typreceive: undefined,typsend: undefined,typmodin: undefined,typmodout: undefined,typanalyze: undefined,typalign: undefined,typstorage: undefined,typnotnull: undefined,typbasetype: undefined,typtypmod: undefined,typndims: undefined,typcollation: undefined,typdefaultbin: undefined,typdefault: undefined,typacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgType,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgType,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
typnameAscending = "typname ASC",
typnamespaceAscending = "typnamespace ASC",
typownerAscending = "typowner ASC",
typlenAscending = "typlen ASC",
typbyvalAscending = "typbyval ASC",
typtypeAscending = "typtype ASC",
typcategoryAscending = "typcategory ASC",
typispreferredAscending = "typispreferred ASC",
typisdefinedAscending = "typisdefined ASC",
typdelimAscending = "typdelim ASC",
typrelidAscending = "typrelid ASC",
typsubscriptAscending = "typsubscript ASC",
typelemAscending = "typelem ASC",
typarrayAscending = "typarray ASC",
typinputAscending = "typinput ASC",
typoutputAscending = "typoutput ASC",
typreceiveAscending = "typreceive ASC",
typsendAscending = "typsend ASC",
typmodinAscending = "typmodin ASC",
typmodoutAscending = "typmodout ASC",
typanalyzeAscending = "typanalyze ASC",
typalignAscending = "typalign ASC",
typstorageAscending = "typstorage ASC",
typnotnullAscending = "typnotnull ASC",
typbasetypeAscending = "typbasetype ASC",
typtypmodAscending = "typtypmod ASC",
typndimsAscending = "typndims ASC",
typcollationAscending = "typcollation ASC",
typdefaultbinAscending = "typdefaultbin ASC",
typdefaultAscending = "typdefault ASC",
typaclAscending = "typacl ASC",
oidDescending = "oid DESC",
typnameDescending = "typname DESC",
typnamespaceDescending = "typnamespace DESC",
typownerDescending = "typowner DESC",
typlenDescending = "typlen DESC",
typbyvalDescending = "typbyval DESC",
typtypeDescending = "typtype DESC",
typcategoryDescending = "typcategory DESC",
typispreferredDescending = "typispreferred DESC",
typisdefinedDescending = "typisdefined DESC",
typdelimDescending = "typdelim DESC",
typrelidDescending = "typrelid DESC",
typsubscriptDescending = "typsubscript DESC",
typelemDescending = "typelem DESC",
typarrayDescending = "typarray DESC",
typinputDescending = "typinput DESC",
typoutputDescending = "typoutput DESC",
typreceiveDescending = "typreceive DESC",
typsendDescending = "typsend DESC",
typmodinDescending = "typmodin DESC",
typmodoutDescending = "typmodout DESC",
typanalyzeDescending = "typanalyze DESC",
typalignDescending = "typalign DESC",
typstorageDescending = "typstorage DESC",
typnotnullDescending = "typnotnull DESC",
typbasetypeDescending = "typbasetype DESC",
typtypmodDescending = "typtypmod DESC",
typndimsDescending = "typndims DESC",
typcollationDescending = "typcollation DESC",
typdefaultbinDescending = "typdefaultbin DESC",
typdefaultDescending = "typdefault DESC",
typaclDescending = "typacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Typname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "typname" as FieldNamesType,
},
Typnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typnamespace" as FieldNamesType,
},
Typowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typowner" as FieldNamesType,
},
Typlen: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "typlen" as FieldNamesType,
},
Typbyval: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typbyval" as FieldNamesType,
},
Typtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typtype" as FieldNamesType,
},
Typcategory: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typcategory" as FieldNamesType,
},
Typispreferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typispreferred" as FieldNamesType,
},
Typisdefined: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typisdefined" as FieldNamesType,
},
Typdelim: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typdelim" as FieldNamesType,
},
Typrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typrelid" as FieldNamesType,
},
Typsubscript: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typsubscript" as FieldNamesType,
},
Typelem: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typelem" as FieldNamesType,
},
Typarray: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typarray" as FieldNamesType,
},
Typinput: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typinput" as FieldNamesType,
},
Typoutput: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typoutput" as FieldNamesType,
},
Typreceive: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typreceive" as FieldNamesType,
},
Typsend: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typsend" as FieldNamesType,
},
Typmodin: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typmodin" as FieldNamesType,
},
Typmodout: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typmodout" as FieldNamesType,
},
Typanalyze: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typanalyze" as FieldNamesType,
},
Typalign: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typalign" as FieldNamesType,
},
Typstorage: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typstorage" as FieldNamesType,
},
Typnotnull: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typnotnull" as FieldNamesType,
},
Typbasetype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typbasetype" as FieldNamesType,
},
Typtypmod: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "typtypmod" as FieldNamesType,
},
Typndims: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "typndims" as FieldNamesType,
},
Typcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typcollation" as FieldNamesType,
},
Typdefaultbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "typdefaultbin" as FieldNamesType,
},
Typdefault: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "typdefault" as FieldNamesType,
},
Typacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "typacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Typname","Typnamespace","Typowner","Typlen","Typbyval","Typtype","Typcategory","Typispreferred","Typisdefined","Typdelim","Typrelid","Typsubscript","Typelem","Typarray","Typinput","Typoutput","Typreceive","Typsend","Typmodin","Typmodout","Typanalyze","Typalign","Typstorage","Typnotnull","Typbasetype","Typtypmod","Typndims","Typcollation","Typdefaultbin","Typdefault","Typacl"] as const;
export const FieldNames = ["oid","typname","typnamespace","typowner","typlen","typbyval","typtype","typcategory","typispreferred","typisdefined","typdelim","typrelid","typsubscript","typelem","typarray","typinput","typoutput","typreceive","typsend","typmodin","typmodout","typanalyze","typalign","typstorage","typnotnull","typbasetype","typtypmod","typndims","typcollation","typdefaultbin","typdefault","typacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTypeOidIndex;
}
export namespace PgForeignTable {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignTable> {
 return { ftrelid: undefined,ftserver: undefined,ftoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignTable,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignTable,  PrimaryKey>
export enum SortOptions  {
ftrelidAscending = "ftrelid ASC",
ftserverAscending = "ftserver ASC",
ftoptionsAscending = "ftoptions ASC",
ftrelidDescending = "ftrelid DESC",
ftserverDescending = "ftserver DESC",
ftoptionsDescending = "ftoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Ftrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "ftrelid" as FieldNamesType,
},
Ftserver: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "ftserver" as FieldNamesType,
},
Ftoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "ftoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Ftrelid","Ftserver","Ftoptions"] as const;
export const FieldNames = ["ftrelid","ftserver","ftoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignTableRelidIndex;
}
export namespace PgAuthid {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAuthid> {
 return { oid: undefined,rolname: undefined,rolsuper: undefined,rolinherit: undefined,rolcreaterole: undefined,rolcreatedb: undefined,rolcanlogin: undefined,rolreplication: undefined,rolbypassrls: undefined,rolconnlimit: undefined,rolpassword: undefined,rolvaliduntil: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAuthid,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAuthid,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
rolnameAscending = "rolname ASC",
rolsuperAscending = "rolsuper ASC",
rolinheritAscending = "rolinherit ASC",
rolcreateroleAscending = "rolcreaterole ASC",
rolcreatedbAscending = "rolcreatedb ASC",
rolcanloginAscending = "rolcanlogin ASC",
rolreplicationAscending = "rolreplication ASC",
rolbypassrlsAscending = "rolbypassrls ASC",
rolconnlimitAscending = "rolconnlimit ASC",
rolpasswordAscending = "rolpassword ASC",
rolvaliduntilAscending = "rolvaliduntil ASC",
oidDescending = "oid DESC",
rolnameDescending = "rolname DESC",
rolsuperDescending = "rolsuper DESC",
rolinheritDescending = "rolinherit DESC",
rolcreateroleDescending = "rolcreaterole DESC",
rolcreatedbDescending = "rolcreatedb DESC",
rolcanloginDescending = "rolcanlogin DESC",
rolreplicationDescending = "rolreplication DESC",
rolbypassrlsDescending = "rolbypassrls DESC",
rolconnlimitDescending = "rolconnlimit DESC",
rolpasswordDescending = "rolpassword DESC",
rolvaliduntilDescending = "rolvaliduntil DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Rolname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "rolname" as FieldNamesType,
},
Rolsuper: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolsuper" as FieldNamesType,
},
Rolinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolinherit" as FieldNamesType,
},
Rolcreaterole: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcreaterole" as FieldNamesType,
},
Rolcreatedb: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcreatedb" as FieldNamesType,
},
Rolcanlogin: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcanlogin" as FieldNamesType,
},
Rolreplication: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolreplication" as FieldNamesType,
},
Rolbypassrls: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolbypassrls" as FieldNamesType,
},
Rolconnlimit: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "rolconnlimit" as FieldNamesType,
},
Rolpassword: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "rolpassword" as FieldNamesType,
},
Rolvaliduntil: {
 typeName: "PgCatalog.Types.Timestamptz",
 fieldName: "rolvaliduntil" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Rolname","Rolsuper","Rolinherit","Rolcreaterole","Rolcreatedb","Rolcanlogin","Rolreplication","Rolbypassrls","Rolconnlimit","Rolpassword","Rolvaliduntil"] as const;
export const FieldNames = ["oid","rolname","rolsuper","rolinherit","rolcreaterole","rolcreatedb","rolcanlogin","rolreplication","rolbypassrls","rolconnlimit","rolpassword","rolvaliduntil"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAuthidOidIndex;
}
export namespace PgStatisticExtData {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatisticExtData> {
 return { stxoid: undefined,stxdinherit: undefined,stxdndistinct: undefined,stxddependencies: undefined,stxdmcv: undefined,stxdexpr: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatisticExtData,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatisticExtData,  PrimaryKey>
export enum SortOptions  {
stxoidAscending = "stxoid ASC",
stxdinheritAscending = "stxdinherit ASC",
stxdndistinctAscending = "stxdndistinct ASC",
stxddependenciesAscending = "stxddependencies ASC",
stxdmcvAscending = "stxdmcv ASC",
stxdexprAscending = "stxdexpr ASC",
stxoidDescending = "stxoid DESC",
stxdinheritDescending = "stxdinherit DESC",
stxdndistinctDescending = "stxdndistinct DESC",
stxddependenciesDescending = "stxddependencies DESC",
stxdmcvDescending = "stxdmcv DESC",
stxdexprDescending = "stxdexpr DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Stxoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxoid" as FieldNamesType,
},
Stxdinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "stxdinherit" as FieldNamesType,
},
Stxdndistinct: {
 typeName: "PgCatalog.Types.PgNdistinct",
 fieldName: "stxdndistinct" as FieldNamesType,
},
Stxddependencies: {
 typeName: "PgCatalog.Types.PgDependencies",
 fieldName: "stxddependencies" as FieldNamesType,
},
Stxdmcv: {
 typeName: "PgCatalog.Types.PgMcvList",
 fieldName: "stxdmcv" as FieldNamesType,
},
Stxdexpr: {
 typeName: "PgCatalog.Types.PgStatisticArray",
 fieldName: "stxdexpr" as FieldNamesType,
},
}
export const ColumnNames = ["Stxoid","Stxdinherit","Stxdndistinct","Stxddependencies","Stxdmcv","Stxdexpr"] as const;
export const FieldNames = ["stxoid","stxdinherit","stxdndistinct","stxddependencies","stxdmcv","stxdexpr"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticExtDataStxoidInhIndex;
}
export namespace PgUserMapping {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgUserMapping> {
 return { oid: undefined,umuser: undefined,umserver: undefined,umoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgUserMapping,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgUserMapping,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
umuserAscending = "umuser ASC",
umserverAscending = "umserver ASC",
umoptionsAscending = "umoptions ASC",
oidDescending = "oid DESC",
umuserDescending = "umuser DESC",
umserverDescending = "umserver DESC",
umoptionsDescending = "umoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Umuser: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "umuser" as FieldNamesType,
},
Umserver: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "umserver" as FieldNamesType,
},
Umoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "umoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Umuser","Umserver","Umoptions"] as const;
export const FieldNames = ["oid","umuser","umserver","umoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgUserMappingOidIndex;
}
export namespace PgSubscription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSubscription> {
 return { oid: undefined,subdbid: undefined,subskiplsn: undefined,subname: undefined,subowner: undefined,subenabled: undefined,subbinary: undefined,substream: undefined,subtwophasestate: undefined,subdisableonerr: undefined,subpasswordrequired: undefined,subrunasowner: undefined,subconninfo: undefined,subslotname: undefined,subsynccommit: undefined,subpublications: undefined,suborigin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSubscription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSubscription,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
subdbidAscending = "subdbid ASC",
subskiplsnAscending = "subskiplsn ASC",
subnameAscending = "subname ASC",
subownerAscending = "subowner ASC",
subenabledAscending = "subenabled ASC",
subbinaryAscending = "subbinary ASC",
substreamAscending = "substream ASC",
subtwophasestateAscending = "subtwophasestate ASC",
subdisableonerrAscending = "subdisableonerr ASC",
subpasswordrequiredAscending = "subpasswordrequired ASC",
subrunasownerAscending = "subrunasowner ASC",
subconninfoAscending = "subconninfo ASC",
subslotnameAscending = "subslotname ASC",
subsynccommitAscending = "subsynccommit ASC",
subpublicationsAscending = "subpublications ASC",
suboriginAscending = "suborigin ASC",
oidDescending = "oid DESC",
subdbidDescending = "subdbid DESC",
subskiplsnDescending = "subskiplsn DESC",
subnameDescending = "subname DESC",
subownerDescending = "subowner DESC",
subenabledDescending = "subenabled DESC",
subbinaryDescending = "subbinary DESC",
substreamDescending = "substream DESC",
subtwophasestateDescending = "subtwophasestate DESC",
subdisableonerrDescending = "subdisableonerr DESC",
subpasswordrequiredDescending = "subpasswordrequired DESC",
subrunasownerDescending = "subrunasowner DESC",
subconninfoDescending = "subconninfo DESC",
subslotnameDescending = "subslotname DESC",
subsynccommitDescending = "subsynccommit DESC",
subpublicationsDescending = "subpublications DESC",
suboriginDescending = "suborigin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Subdbid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "subdbid" as FieldNamesType,
},
Subskiplsn: {
 typeName: "PgCatalog.Types.PgLsn",
 fieldName: "subskiplsn" as FieldNamesType,
},
Subname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "subname" as FieldNamesType,
},
Subowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "subowner" as FieldNamesType,
},
Subenabled: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subenabled" as FieldNamesType,
},
Subbinary: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subbinary" as FieldNamesType,
},
Substream: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "substream" as FieldNamesType,
},
Subtwophasestate: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "subtwophasestate" as FieldNamesType,
},
Subdisableonerr: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subdisableonerr" as FieldNamesType,
},
Subpasswordrequired: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subpasswordrequired" as FieldNamesType,
},
Subrunasowner: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subrunasowner" as FieldNamesType,
},
Subconninfo: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "subconninfo" as FieldNamesType,
},
Subslotname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "subslotname" as FieldNamesType,
},
Subsynccommit: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "subsynccommit" as FieldNamesType,
},
Subpublications: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "subpublications" as FieldNamesType,
},
Suborigin: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "suborigin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Subdbid","Subskiplsn","Subname","Subowner","Subenabled","Subbinary","Substream","Subtwophasestate","Subdisableonerr","Subpasswordrequired","Subrunasowner","Subconninfo","Subslotname","Subsynccommit","Subpublications","Suborigin"] as const;
export const FieldNames = ["oid","subdbid","subskiplsn","subname","subowner","subenabled","subbinary","substream","subtwophasestate","subdisableonerr","subpasswordrequired","subrunasowner","subconninfo","subslotname","subsynccommit","subpublications","suborigin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSubscriptionOidIndex;
}
export namespace PgAttribute {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAttribute> {
 return { attrelid: undefined,attname: undefined,atttypid: undefined,attlen: undefined,attnum: undefined,attcacheoff: undefined,atttypmod: undefined,attndims: undefined,attbyval: undefined,attalign: undefined,attstorage: undefined,attcompression: undefined,attnotnull: undefined,atthasdef: undefined,atthasmissing: undefined,attidentity: undefined,attgenerated: undefined,attisdropped: undefined,attislocal: undefined,attinhcount: undefined,attstattarget: undefined,attcollation: undefined,attacl: undefined,attoptions: undefined,attfdwoptions: undefined,attmissingval: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAttribute,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAttribute,  PrimaryKey>
export enum SortOptions  {
attrelidAscending = "attrelid ASC",
attnameAscending = "attname ASC",
atttypidAscending = "atttypid ASC",
attlenAscending = "attlen ASC",
attnumAscending = "attnum ASC",
attcacheoffAscending = "attcacheoff ASC",
atttypmodAscending = "atttypmod ASC",
attndimsAscending = "attndims ASC",
attbyvalAscending = "attbyval ASC",
attalignAscending = "attalign ASC",
attstorageAscending = "attstorage ASC",
attcompressionAscending = "attcompression ASC",
attnotnullAscending = "attnotnull ASC",
atthasdefAscending = "atthasdef ASC",
atthasmissingAscending = "atthasmissing ASC",
attidentityAscending = "attidentity ASC",
attgeneratedAscending = "attgenerated ASC",
attisdroppedAscending = "attisdropped ASC",
attislocalAscending = "attislocal ASC",
attinhcountAscending = "attinhcount ASC",
attstattargetAscending = "attstattarget ASC",
attcollationAscending = "attcollation ASC",
attaclAscending = "attacl ASC",
attoptionsAscending = "attoptions ASC",
attfdwoptionsAscending = "attfdwoptions ASC",
attmissingvalAscending = "attmissingval ASC",
attrelidDescending = "attrelid DESC",
attnameDescending = "attname DESC",
atttypidDescending = "atttypid DESC",
attlenDescending = "attlen DESC",
attnumDescending = "attnum DESC",
attcacheoffDescending = "attcacheoff DESC",
atttypmodDescending = "atttypmod DESC",
attndimsDescending = "attndims DESC",
attbyvalDescending = "attbyval DESC",
attalignDescending = "attalign DESC",
attstorageDescending = "attstorage DESC",
attcompressionDescending = "attcompression DESC",
attnotnullDescending = "attnotnull DESC",
atthasdefDescending = "atthasdef DESC",
atthasmissingDescending = "atthasmissing DESC",
attidentityDescending = "attidentity DESC",
attgeneratedDescending = "attgenerated DESC",
attisdroppedDescending = "attisdropped DESC",
attislocalDescending = "attislocal DESC",
attinhcountDescending = "attinhcount DESC",
attstattargetDescending = "attstattarget DESC",
attcollationDescending = "attcollation DESC",
attaclDescending = "attacl DESC",
attoptionsDescending = "attoptions DESC",
attfdwoptionsDescending = "attfdwoptions DESC",
attmissingvalDescending = "attmissingval DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Attrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "attrelid" as FieldNamesType,
},
Attname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "attname" as FieldNamesType,
},
Atttypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "atttypid" as FieldNamesType,
},
Attlen: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attlen" as FieldNamesType,
},
Attnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attnum" as FieldNamesType,
},
Attcacheoff: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "attcacheoff" as FieldNamesType,
},
Atttypmod: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "atttypmod" as FieldNamesType,
},
Attndims: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attndims" as FieldNamesType,
},
Attbyval: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attbyval" as FieldNamesType,
},
Attalign: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attalign" as FieldNamesType,
},
Attstorage: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attstorage" as FieldNamesType,
},
Attcompression: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attcompression" as FieldNamesType,
},
Attnotnull: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attnotnull" as FieldNamesType,
},
Atthasdef: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "atthasdef" as FieldNamesType,
},
Atthasmissing: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "atthasmissing" as FieldNamesType,
},
Attidentity: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attidentity" as FieldNamesType,
},
Attgenerated: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attgenerated" as FieldNamesType,
},
Attisdropped: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attisdropped" as FieldNamesType,
},
Attislocal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attislocal" as FieldNamesType,
},
Attinhcount: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attinhcount" as FieldNamesType,
},
Attstattarget: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attstattarget" as FieldNamesType,
},
Attcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "attcollation" as FieldNamesType,
},
Attacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "attacl" as FieldNamesType,
},
Attoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "attoptions" as FieldNamesType,
},
Attfdwoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "attfdwoptions" as FieldNamesType,
},
Attmissingval: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "attmissingval" as FieldNamesType,
},
}
export const ColumnNames = ["Attrelid","Attname","Atttypid","Attlen","Attnum","Attcacheoff","Atttypmod","Attndims","Attbyval","Attalign","Attstorage","Attcompression","Attnotnull","Atthasdef","Atthasmissing","Attidentity","Attgenerated","Attisdropped","Attislocal","Attinhcount","Attstattarget","Attcollation","Attacl","Attoptions","Attfdwoptions","Attmissingval"] as const;
export const FieldNames = ["attrelid","attname","atttypid","attlen","attnum","attcacheoff","atttypmod","attndims","attbyval","attalign","attstorage","attcompression","attnotnull","atthasdef","atthasmissing","attidentity","attgenerated","attisdropped","attislocal","attinhcount","attstattarget","attcollation","attacl","attoptions","attfdwoptions","attmissingval"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAttributeRelidAttnumIndex;
}
export namespace PgProc {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgProc> {
 return { oid: undefined,proname: undefined,pronamespace: undefined,proowner: undefined,prolang: undefined,procost: undefined,prorows: undefined,provariadic: undefined,prosupport: undefined,prokind: undefined,prosecdef: undefined,proleakproof: undefined,proisstrict: undefined,proretset: undefined,provolatile: undefined,proparallel: undefined,pronargs: undefined,pronargdefaults: undefined,prorettype: undefined,proargtypes: undefined,proallargtypes: undefined,proargmodes: undefined,proargnames: undefined,proargdefaults: undefined,protrftypes: undefined,prosrc: undefined,probin: undefined,prosqlbody: undefined,proconfig: undefined,proacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgProc,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgProc,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pronameAscending = "proname ASC",
pronamespaceAscending = "pronamespace ASC",
proownerAscending = "proowner ASC",
prolangAscending = "prolang ASC",
procostAscending = "procost ASC",
prorowsAscending = "prorows ASC",
provariadicAscending = "provariadic ASC",
prosupportAscending = "prosupport ASC",
prokindAscending = "prokind ASC",
prosecdefAscending = "prosecdef ASC",
proleakproofAscending = "proleakproof ASC",
proisstrictAscending = "proisstrict ASC",
proretsetAscending = "proretset ASC",
provolatileAscending = "provolatile ASC",
proparallelAscending = "proparallel ASC",
pronargsAscending = "pronargs ASC",
pronargdefaultsAscending = "pronargdefaults ASC",
prorettypeAscending = "prorettype ASC",
proargtypesAscending = "proargtypes ASC",
proallargtypesAscending = "proallargtypes ASC",
proargmodesAscending = "proargmodes ASC",
proargnamesAscending = "proargnames ASC",
proargdefaultsAscending = "proargdefaults ASC",
protrftypesAscending = "protrftypes ASC",
prosrcAscending = "prosrc ASC",
probinAscending = "probin ASC",
prosqlbodyAscending = "prosqlbody ASC",
proconfigAscending = "proconfig ASC",
proaclAscending = "proacl ASC",
oidDescending = "oid DESC",
pronameDescending = "proname DESC",
pronamespaceDescending = "pronamespace DESC",
proownerDescending = "proowner DESC",
prolangDescending = "prolang DESC",
procostDescending = "procost DESC",
prorowsDescending = "prorows DESC",
provariadicDescending = "provariadic DESC",
prosupportDescending = "prosupport DESC",
prokindDescending = "prokind DESC",
prosecdefDescending = "prosecdef DESC",
proleakproofDescending = "proleakproof DESC",
proisstrictDescending = "proisstrict DESC",
proretsetDescending = "proretset DESC",
provolatileDescending = "provolatile DESC",
proparallelDescending = "proparallel DESC",
pronargsDescending = "pronargs DESC",
pronargdefaultsDescending = "pronargdefaults DESC",
prorettypeDescending = "prorettype DESC",
proargtypesDescending = "proargtypes DESC",
proallargtypesDescending = "proallargtypes DESC",
proargmodesDescending = "proargmodes DESC",
proargnamesDescending = "proargnames DESC",
proargdefaultsDescending = "proargdefaults DESC",
protrftypesDescending = "protrftypes DESC",
prosrcDescending = "prosrc DESC",
probinDescending = "probin DESC",
prosqlbodyDescending = "prosqlbody DESC",
proconfigDescending = "proconfig DESC",
proaclDescending = "proacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Proname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "proname" as FieldNamesType,
},
Pronamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pronamespace" as FieldNamesType,
},
Proowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "proowner" as FieldNamesType,
},
Prolang: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prolang" as FieldNamesType,
},
Procost: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "procost" as FieldNamesType,
},
Prorows: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "prorows" as FieldNamesType,
},
Provariadic: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "provariadic" as FieldNamesType,
},
Prosupport: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prosupport" as FieldNamesType,
},
Prokind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "prokind" as FieldNamesType,
},
Prosecdef: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "prosecdef" as FieldNamesType,
},
Proleakproof: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proleakproof" as FieldNamesType,
},
Proisstrict: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proisstrict" as FieldNamesType,
},
Proretset: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proretset" as FieldNamesType,
},
Provolatile: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "provolatile" as FieldNamesType,
},
Proparallel: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "proparallel" as FieldNamesType,
},
Pronargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "pronargs" as FieldNamesType,
},
Pronargdefaults: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "pronargdefaults" as FieldNamesType,
},
Prorettype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prorettype" as FieldNamesType,
},
Proargtypes: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "proargtypes" as FieldNamesType,
},
Proallargtypes: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "proallargtypes" as FieldNamesType,
},
Proargmodes: {
 typeName: "PgCatalog.Types.CharArray",
 fieldName: "proargmodes" as FieldNamesType,
},
Proargnames: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "proargnames" as FieldNamesType,
},
Proargdefaults: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "proargdefaults" as FieldNamesType,
},
Protrftypes: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "protrftypes" as FieldNamesType,
},
Prosrc: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "prosrc" as FieldNamesType,
},
Probin: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "probin" as FieldNamesType,
},
Prosqlbody: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "prosqlbody" as FieldNamesType,
},
Proconfig: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "proconfig" as FieldNamesType,
},
Proacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "proacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Proname","Pronamespace","Proowner","Prolang","Procost","Prorows","Provariadic","Prosupport","Prokind","Prosecdef","Proleakproof","Proisstrict","Proretset","Provolatile","Proparallel","Pronargs","Pronargdefaults","Prorettype","Proargtypes","Proallargtypes","Proargmodes","Proargnames","Proargdefaults","Protrftypes","Prosrc","Probin","Prosqlbody","Proconfig","Proacl"] as const;
export const FieldNames = ["oid","proname","pronamespace","proowner","prolang","procost","prorows","provariadic","prosupport","prokind","prosecdef","proleakproof","proisstrict","proretset","provolatile","proparallel","pronargs","pronargdefaults","prorettype","proargtypes","proallargtypes","proargmodes","proargnames","proargdefaults","protrftypes","prosrc","probin","prosqlbody","proconfig","proacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgProcOidIndex;
}
export namespace PgClass {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgClass> {
 return { oid: undefined,relname: undefined,relnamespace: undefined,reltype: undefined,reloftype: undefined,relowner: undefined,relam: undefined,relfilenode: undefined,reltablespace: undefined,relpages: undefined,reltuples: undefined,relallvisible: undefined,reltoastrelid: undefined,relhasindex: undefined,relisshared: undefined,relpersistence: undefined,relkind: undefined,relnatts: undefined,relchecks: undefined,relhasrules: undefined,relhastriggers: undefined,relhassubclass: undefined,relrowsecurity: undefined,relforcerowsecurity: undefined,relispopulated: undefined,relreplident: undefined,relispartition: undefined,relrewrite: undefined,relfrozenxid: undefined,relminmxid: undefined,relacl: undefined,reloptions: undefined,relpartbound: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgClass,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgClass,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
relnameAscending = "relname ASC",
relnamespaceAscending = "relnamespace ASC",
reltypeAscending = "reltype ASC",
reloftypeAscending = "reloftype ASC",
relownerAscending = "relowner ASC",
relamAscending = "relam ASC",
relfilenodeAscending = "relfilenode ASC",
reltablespaceAscending = "reltablespace ASC",
relpagesAscending = "relpages ASC",
reltuplesAscending = "reltuples ASC",
relallvisibleAscending = "relallvisible ASC",
reltoastrelidAscending = "reltoastrelid ASC",
relhasindexAscending = "relhasindex ASC",
relissharedAscending = "relisshared ASC",
relpersistenceAscending = "relpersistence ASC",
relkindAscending = "relkind ASC",
relnattsAscending = "relnatts ASC",
relchecksAscending = "relchecks ASC",
relhasrulesAscending = "relhasrules ASC",
relhastriggersAscending = "relhastriggers ASC",
relhassubclassAscending = "relhassubclass ASC",
relrowsecurityAscending = "relrowsecurity ASC",
relforcerowsecurityAscending = "relforcerowsecurity ASC",
relispopulatedAscending = "relispopulated ASC",
relreplidentAscending = "relreplident ASC",
relispartitionAscending = "relispartition ASC",
relrewriteAscending = "relrewrite ASC",
relfrozenxidAscending = "relfrozenxid ASC",
relminmxidAscending = "relminmxid ASC",
relaclAscending = "relacl ASC",
reloptionsAscending = "reloptions ASC",
relpartboundAscending = "relpartbound ASC",
oidDescending = "oid DESC",
relnameDescending = "relname DESC",
relnamespaceDescending = "relnamespace DESC",
reltypeDescending = "reltype DESC",
reloftypeDescending = "reloftype DESC",
relownerDescending = "relowner DESC",
relamDescending = "relam DESC",
relfilenodeDescending = "relfilenode DESC",
reltablespaceDescending = "reltablespace DESC",
relpagesDescending = "relpages DESC",
reltuplesDescending = "reltuples DESC",
relallvisibleDescending = "relallvisible DESC",
reltoastrelidDescending = "reltoastrelid DESC",
relhasindexDescending = "relhasindex DESC",
relissharedDescending = "relisshared DESC",
relpersistenceDescending = "relpersistence DESC",
relkindDescending = "relkind DESC",
relnattsDescending = "relnatts DESC",
relchecksDescending = "relchecks DESC",
relhasrulesDescending = "relhasrules DESC",
relhastriggersDescending = "relhastriggers DESC",
relhassubclassDescending = "relhassubclass DESC",
relrowsecurityDescending = "relrowsecurity DESC",
relforcerowsecurityDescending = "relforcerowsecurity DESC",
relispopulatedDescending = "relispopulated DESC",
relreplidentDescending = "relreplident DESC",
relispartitionDescending = "relispartition DESC",
relrewriteDescending = "relrewrite DESC",
relfrozenxidDescending = "relfrozenxid DESC",
relminmxidDescending = "relminmxid DESC",
relaclDescending = "relacl DESC",
reloptionsDescending = "reloptions DESC",
relpartboundDescending = "relpartbound DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Relname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "relname" as FieldNamesType,
},
Relnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relnamespace" as FieldNamesType,
},
Reltype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltype" as FieldNamesType,
},
Reloftype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reloftype" as FieldNamesType,
},
Relowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relowner" as FieldNamesType,
},
Relam: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relam" as FieldNamesType,
},
Relfilenode: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relfilenode" as FieldNamesType,
},
Reltablespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltablespace" as FieldNamesType,
},
Relpages: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "relpages" as FieldNamesType,
},
Reltuples: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "reltuples" as FieldNamesType,
},
Relallvisible: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "relallvisible" as FieldNamesType,
},
Reltoastrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltoastrelid" as FieldNamesType,
},
Relhasindex: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhasindex" as FieldNamesType,
},
Relisshared: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relisshared" as FieldNamesType,
},
Relpersistence: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relpersistence" as FieldNamesType,
},
Relkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relkind" as FieldNamesType,
},
Relnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "relnatts" as FieldNamesType,
},
Relchecks: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "relchecks" as FieldNamesType,
},
Relhasrules: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhasrules" as FieldNamesType,
},
Relhastriggers: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhastriggers" as FieldNamesType,
},
Relhassubclass: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhassubclass" as FieldNamesType,
},
Relrowsecurity: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relrowsecurity" as FieldNamesType,
},
Relforcerowsecurity: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relforcerowsecurity" as FieldNamesType,
},
Relispopulated: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relispopulated" as FieldNamesType,
},
Relreplident: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relreplident" as FieldNamesType,
},
Relispartition: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relispartition" as FieldNamesType,
},
Relrewrite: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relrewrite" as FieldNamesType,
},
Relfrozenxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "relfrozenxid" as FieldNamesType,
},
Relminmxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "relminmxid" as FieldNamesType,
},
Relacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "relacl" as FieldNamesType,
},
Reloptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "reloptions" as FieldNamesType,
},
Relpartbound: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "relpartbound" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Relname","Relnamespace","Reltype","Reloftype","Relowner","Relam","Relfilenode","Reltablespace","Relpages","Reltuples","Relallvisible","Reltoastrelid","Relhasindex","Relisshared","Relpersistence","Relkind","Relnatts","Relchecks","Relhasrules","Relhastriggers","Relhassubclass","Relrowsecurity","Relforcerowsecurity","Relispopulated","Relreplident","Relispartition","Relrewrite","Relfrozenxid","Relminmxid","Relacl","Reloptions","Relpartbound"] as const;
export const FieldNames = ["oid","relname","relnamespace","reltype","reloftype","relowner","relam","relfilenode","reltablespace","relpages","reltuples","relallvisible","reltoastrelid","relhasindex","relisshared","relpersistence","relkind","relnatts","relchecks","relhasrules","relhastriggers","relhassubclass","relrowsecurity","relforcerowsecurity","relispopulated","relreplident","relispartition","relrewrite","relfrozenxid","relminmxid","relacl","reloptions","relpartbound"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgClassOidIndex;
}
export namespace PgAttrdef {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAttrdef> {
 return { oid: undefined,adrelid: undefined,adnum: undefined,adbin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAttrdef,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAttrdef,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
adrelidAscending = "adrelid ASC",
adnumAscending = "adnum ASC",
adbinAscending = "adbin ASC",
oidDescending = "oid DESC",
adrelidDescending = "adrelid DESC",
adnumDescending = "adnum DESC",
adbinDescending = "adbin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Adrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "adrelid" as FieldNamesType,
},
Adnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "adnum" as FieldNamesType,
},
Adbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "adbin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Adrelid","Adnum","Adbin"] as const;
export const FieldNames = ["oid","adrelid","adnum","adbin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAttrdefOidIndex;
}
export namespace PgConstraint {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgConstraint> {
 return { oid: undefined,conname: undefined,connamespace: undefined,contype: undefined,condeferrable: undefined,condeferred: undefined,convalidated: undefined,conrelid: undefined,contypid: undefined,conindid: undefined,conparentid: undefined,confrelid: undefined,confupdtype: undefined,confdeltype: undefined,confmatchtype: undefined,conislocal: undefined,coninhcount: undefined,connoinherit: undefined,conkey: undefined,confkey: undefined,conpfeqop: undefined,conppeqop: undefined,conffeqop: undefined,confdelsetcols: undefined,conexclop: undefined,conbin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgConstraint,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgConstraint,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
connameAscending = "conname ASC",
connamespaceAscending = "connamespace ASC",
contypeAscending = "contype ASC",
condeferrableAscending = "condeferrable ASC",
condeferredAscending = "condeferred ASC",
convalidatedAscending = "convalidated ASC",
conrelidAscending = "conrelid ASC",
contypidAscending = "contypid ASC",
conindidAscending = "conindid ASC",
conparentidAscending = "conparentid ASC",
confrelidAscending = "confrelid ASC",
confupdtypeAscending = "confupdtype ASC",
confdeltypeAscending = "confdeltype ASC",
confmatchtypeAscending = "confmatchtype ASC",
conislocalAscending = "conislocal ASC",
coninhcountAscending = "coninhcount ASC",
connoinheritAscending = "connoinherit ASC",
conkeyAscending = "conkey ASC",
confkeyAscending = "confkey ASC",
conpfeqopAscending = "conpfeqop ASC",
conppeqopAscending = "conppeqop ASC",
conffeqopAscending = "conffeqop ASC",
confdelsetcolsAscending = "confdelsetcols ASC",
conexclopAscending = "conexclop ASC",
conbinAscending = "conbin ASC",
oidDescending = "oid DESC",
connameDescending = "conname DESC",
connamespaceDescending = "connamespace DESC",
contypeDescending = "contype DESC",
condeferrableDescending = "condeferrable DESC",
condeferredDescending = "condeferred DESC",
convalidatedDescending = "convalidated DESC",
conrelidDescending = "conrelid DESC",
contypidDescending = "contypid DESC",
conindidDescending = "conindid DESC",
conparentidDescending = "conparentid DESC",
confrelidDescending = "confrelid DESC",
confupdtypeDescending = "confupdtype DESC",
confdeltypeDescending = "confdeltype DESC",
confmatchtypeDescending = "confmatchtype DESC",
conislocalDescending = "conislocal DESC",
coninhcountDescending = "coninhcount DESC",
connoinheritDescending = "connoinherit DESC",
conkeyDescending = "conkey DESC",
confkeyDescending = "confkey DESC",
conpfeqopDescending = "conpfeqop DESC",
conppeqopDescending = "conppeqop DESC",
conffeqopDescending = "conffeqop DESC",
confdelsetcolsDescending = "confdelsetcols DESC",
conexclopDescending = "conexclop DESC",
conbinDescending = "conbin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Conname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "conname" as FieldNamesType,
},
Connamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "connamespace" as FieldNamesType,
},
Contype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "contype" as FieldNamesType,
},
Condeferrable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condeferrable" as FieldNamesType,
},
Condeferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condeferred" as FieldNamesType,
},
Convalidated: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "convalidated" as FieldNamesType,
},
Conrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conrelid" as FieldNamesType,
},
Contypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "contypid" as FieldNamesType,
},
Conindid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conindid" as FieldNamesType,
},
Conparentid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conparentid" as FieldNamesType,
},
Confrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "confrelid" as FieldNamesType,
},
Confupdtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confupdtype" as FieldNamesType,
},
Confdeltype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confdeltype" as FieldNamesType,
},
Confmatchtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confmatchtype" as FieldNamesType,
},
Conislocal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "conislocal" as FieldNamesType,
},
Coninhcount: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "coninhcount" as FieldNamesType,
},
Connoinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "connoinherit" as FieldNamesType,
},
Conkey: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "conkey" as FieldNamesType,
},
Confkey: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "confkey" as FieldNamesType,
},
Conpfeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conpfeqop" as FieldNamesType,
},
Conppeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conppeqop" as FieldNamesType,
},
Conffeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conffeqop" as FieldNamesType,
},
Confdelsetcols: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "confdelsetcols" as FieldNamesType,
},
Conexclop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conexclop" as FieldNamesType,
},
Conbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "conbin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Conname","Connamespace","Contype","Condeferrable","Condeferred","Convalidated","Conrelid","Contypid","Conindid","Conparentid","Confrelid","Confupdtype","Confdeltype","Confmatchtype","Conislocal","Coninhcount","Connoinherit","Conkey","Confkey","Conpfeqop","Conppeqop","Conffeqop","Confdelsetcols","Conexclop","Conbin"] as const;
export const FieldNames = ["oid","conname","connamespace","contype","condeferrable","condeferred","convalidated","conrelid","contypid","conindid","conparentid","confrelid","confupdtype","confdeltype","confmatchtype","conislocal","coninhcount","connoinherit","conkey","confkey","conpfeqop","conppeqop","conffeqop","confdelsetcols","conexclop","conbin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgConstraintOidIndex;
}
export namespace PgInherits {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgInherits> {
 return { inhrelid: undefined,inhparent: undefined,inhseqno: undefined,inhdetachpending: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgInherits,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgInherits,  PrimaryKey>
export enum SortOptions  {
inhrelidAscending = "inhrelid ASC",
inhparentAscending = "inhparent ASC",
inhseqnoAscending = "inhseqno ASC",
inhdetachpendingAscending = "inhdetachpending ASC",
inhrelidDescending = "inhrelid DESC",
inhparentDescending = "inhparent DESC",
inhseqnoDescending = "inhseqno DESC",
inhdetachpendingDescending = "inhdetachpending DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Inhrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "inhrelid" as FieldNamesType,
},
Inhparent: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "inhparent" as FieldNamesType,
},
Inhseqno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "inhseqno" as FieldNamesType,
},
Inhdetachpending: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "inhdetachpending" as FieldNamesType,
},
}
export const ColumnNames = ["Inhrelid","Inhparent","Inhseqno","Inhdetachpending"] as const;
export const FieldNames = ["inhrelid","inhparent","inhseqno","inhdetachpending"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgInheritsRelidSeqnoIndex;
}
export namespace PgIndex {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgIndex> {
 return { indexrelid: undefined,indrelid: undefined,indnatts: undefined,indnkeyatts: undefined,indisunique: undefined,indnullsnotdistinct: undefined,indisprimary: undefined,indisexclusion: undefined,indimmediate: undefined,indisclustered: undefined,indisvalid: undefined,indcheckxmin: undefined,indisready: undefined,indislive: undefined,indisreplident: undefined,indkey: undefined,indcollation: undefined,indclass: undefined,indoption: undefined,indexprs: undefined,indpred: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgIndex,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgIndex,  PrimaryKey>
export enum SortOptions  {
indexrelidAscending = "indexrelid ASC",
indrelidAscending = "indrelid ASC",
indnattsAscending = "indnatts ASC",
indnkeyattsAscending = "indnkeyatts ASC",
indisuniqueAscending = "indisunique ASC",
indnullsnotdistinctAscending = "indnullsnotdistinct ASC",
indisprimaryAscending = "indisprimary ASC",
indisexclusionAscending = "indisexclusion ASC",
indimmediateAscending = "indimmediate ASC",
indisclusteredAscending = "indisclustered ASC",
indisvalidAscending = "indisvalid ASC",
indcheckxminAscending = "indcheckxmin ASC",
indisreadyAscending = "indisready ASC",
indisliveAscending = "indislive ASC",
indisreplidentAscending = "indisreplident ASC",
indkeyAscending = "indkey ASC",
indcollationAscending = "indcollation ASC",
indclassAscending = "indclass ASC",
indoptionAscending = "indoption ASC",
indexprsAscending = "indexprs ASC",
indpredAscending = "indpred ASC",
indexrelidDescending = "indexrelid DESC",
indrelidDescending = "indrelid DESC",
indnattsDescending = "indnatts DESC",
indnkeyattsDescending = "indnkeyatts DESC",
indisuniqueDescending = "indisunique DESC",
indnullsnotdistinctDescending = "indnullsnotdistinct DESC",
indisprimaryDescending = "indisprimary DESC",
indisexclusionDescending = "indisexclusion DESC",
indimmediateDescending = "indimmediate DESC",
indisclusteredDescending = "indisclustered DESC",
indisvalidDescending = "indisvalid DESC",
indcheckxminDescending = "indcheckxmin DESC",
indisreadyDescending = "indisready DESC",
indisliveDescending = "indislive DESC",
indisreplidentDescending = "indisreplident DESC",
indkeyDescending = "indkey DESC",
indcollationDescending = "indcollation DESC",
indclassDescending = "indclass DESC",
indoptionDescending = "indoption DESC",
indexprsDescending = "indexprs DESC",
indpredDescending = "indpred DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Indexrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "indexrelid" as FieldNamesType,
},
Indrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "indrelid" as FieldNamesType,
},
Indnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "indnatts" as FieldNamesType,
},
Indnkeyatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "indnkeyatts" as FieldNamesType,
},
Indisunique: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisunique" as FieldNamesType,
},
Indnullsnotdistinct: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indnullsnotdistinct" as FieldNamesType,
},
Indisprimary: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisprimary" as FieldNamesType,
},
Indisexclusion: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisexclusion" as FieldNamesType,
},
Indimmediate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indimmediate" as FieldNamesType,
},
Indisclustered: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisclustered" as FieldNamesType,
},
Indisvalid: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisvalid" as FieldNamesType,
},
Indcheckxmin: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indcheckxmin" as FieldNamesType,
},
Indisready: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisready" as FieldNamesType,
},
Indislive: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indislive" as FieldNamesType,
},
Indisreplident: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisreplident" as FieldNamesType,
},
Indkey: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "indkey" as FieldNamesType,
},
Indcollation: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "indcollation" as FieldNamesType,
},
Indclass: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "indclass" as FieldNamesType,
},
Indoption: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "indoption" as FieldNamesType,
},
Indexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "indexprs" as FieldNamesType,
},
Indpred: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "indpred" as FieldNamesType,
},
}
export const ColumnNames = ["Indexrelid","Indrelid","Indnatts","Indnkeyatts","Indisunique","Indnullsnotdistinct","Indisprimary","Indisexclusion","Indimmediate","Indisclustered","Indisvalid","Indcheckxmin","Indisready","Indislive","Indisreplident","Indkey","Indcollation","Indclass","Indoption","Indexprs","Indpred"] as const;
export const FieldNames = ["indexrelid","indrelid","indnatts","indnkeyatts","indisunique","indnullsnotdistinct","indisprimary","indisexclusion","indimmediate","indisclustered","indisvalid","indcheckxmin","indisready","indislive","indisreplident","indkey","indcollation","indclass","indoption","indexprs","indpred"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgIndexIndexrelidIndex;
}
export namespace PgOperator {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOperator> {
 return { oid: undefined,oprname: undefined,oprnamespace: undefined,oprowner: undefined,oprkind: undefined,oprcanmerge: undefined,oprcanhash: undefined,oprleft: undefined,oprright: undefined,oprresult: undefined,oprcom: undefined,oprnegate: undefined,oprcode: undefined,oprrest: undefined,oprjoin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOperator,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOperator,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
oprnameAscending = "oprname ASC",
oprnamespaceAscending = "oprnamespace ASC",
oprownerAscending = "oprowner ASC",
oprkindAscending = "oprkind ASC",
oprcanmergeAscending = "oprcanmerge ASC",
oprcanhashAscending = "oprcanhash ASC",
oprleftAscending = "oprleft ASC",
oprrightAscending = "oprright ASC",
oprresultAscending = "oprresult ASC",
oprcomAscending = "oprcom ASC",
oprnegateAscending = "oprnegate ASC",
oprcodeAscending = "oprcode ASC",
oprrestAscending = "oprrest ASC",
oprjoinAscending = "oprjoin ASC",
oidDescending = "oid DESC",
oprnameDescending = "oprname DESC",
oprnamespaceDescending = "oprnamespace DESC",
oprownerDescending = "oprowner DESC",
oprkindDescending = "oprkind DESC",
oprcanmergeDescending = "oprcanmerge DESC",
oprcanhashDescending = "oprcanhash DESC",
oprleftDescending = "oprleft DESC",
oprrightDescending = "oprright DESC",
oprresultDescending = "oprresult DESC",
oprcomDescending = "oprcom DESC",
oprnegateDescending = "oprnegate DESC",
oprcodeDescending = "oprcode DESC",
oprrestDescending = "oprrest DESC",
oprjoinDescending = "oprjoin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Oprname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "oprname" as FieldNamesType,
},
Oprnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprnamespace" as FieldNamesType,
},
Oprowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprowner" as FieldNamesType,
},
Oprkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "oprkind" as FieldNamesType,
},
Oprcanmerge: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "oprcanmerge" as FieldNamesType,
},
Oprcanhash: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "oprcanhash" as FieldNamesType,
},
Oprleft: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprleft" as FieldNamesType,
},
Oprright: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprright" as FieldNamesType,
},
Oprresult: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprresult" as FieldNamesType,
},
Oprcom: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprcom" as FieldNamesType,
},
Oprnegate: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprnegate" as FieldNamesType,
},
Oprcode: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprcode" as FieldNamesType,
},
Oprrest: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprrest" as FieldNamesType,
},
Oprjoin: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprjoin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Oprname","Oprnamespace","Oprowner","Oprkind","Oprcanmerge","Oprcanhash","Oprleft","Oprright","Oprresult","Oprcom","Oprnegate","Oprcode","Oprrest","Oprjoin"] as const;
export const FieldNames = ["oid","oprname","oprnamespace","oprowner","oprkind","oprcanmerge","oprcanhash","oprleft","oprright","oprresult","oprcom","oprnegate","oprcode","oprrest","oprjoin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOperatorOidIndex;
}
export namespace PgOpfamily {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOpfamily> {
 return { oid: undefined,opfmethod: undefined,opfname: undefined,opfnamespace: undefined,opfowner: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOpfamily,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOpfamily,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
opfmethodAscending = "opfmethod ASC",
opfnameAscending = "opfname ASC",
opfnamespaceAscending = "opfnamespace ASC",
opfownerAscending = "opfowner ASC",
oidDescending = "oid DESC",
opfmethodDescending = "opfmethod DESC",
opfnameDescending = "opfname DESC",
opfnamespaceDescending = "opfnamespace DESC",
opfownerDescending = "opfowner DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Opfmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfmethod" as FieldNamesType,
},
Opfname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "opfname" as FieldNamesType,
},
Opfnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfnamespace" as FieldNamesType,
},
Opfowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfowner" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Opfmethod","Opfname","Opfnamespace","Opfowner"] as const;
export const FieldNames = ["oid","opfmethod","opfname","opfnamespace","opfowner"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOpfamilyOidIndex;
}
export namespace PgOpclass {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOpclass> {
 return { oid: undefined,opcmethod: undefined,opcname: undefined,opcnamespace: undefined,opcowner: undefined,opcfamily: undefined,opcintype: undefined,opcdefault: undefined,opckeytype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOpclass,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOpclass,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
opcmethodAscending = "opcmethod ASC",
opcnameAscending = "opcname ASC",
opcnamespaceAscending = "opcnamespace ASC",
opcownerAscending = "opcowner ASC",
opcfamilyAscending = "opcfamily ASC",
opcintypeAscending = "opcintype ASC",
opcdefaultAscending = "opcdefault ASC",
opckeytypeAscending = "opckeytype ASC",
oidDescending = "oid DESC",
opcmethodDescending = "opcmethod DESC",
opcnameDescending = "opcname DESC",
opcnamespaceDescending = "opcnamespace DESC",
opcownerDescending = "opcowner DESC",
opcfamilyDescending = "opcfamily DESC",
opcintypeDescending = "opcintype DESC",
opcdefaultDescending = "opcdefault DESC",
opckeytypeDescending = "opckeytype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Opcmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcmethod" as FieldNamesType,
},
Opcname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "opcname" as FieldNamesType,
},
Opcnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcnamespace" as FieldNamesType,
},
Opcowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcowner" as FieldNamesType,
},
Opcfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcfamily" as FieldNamesType,
},
Opcintype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcintype" as FieldNamesType,
},
Opcdefault: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "opcdefault" as FieldNamesType,
},
Opckeytype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opckeytype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Opcmethod","Opcname","Opcnamespace","Opcowner","Opcfamily","Opcintype","Opcdefault","Opckeytype"] as const;
export const FieldNames = ["oid","opcmethod","opcname","opcnamespace","opcowner","opcfamily","opcintype","opcdefault","opckeytype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOpclassOidIndex;
}
export namespace PgAm {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAm> {
 return { oid: undefined,amname: undefined,amhandler: undefined,amtype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAm,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAm,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amnameAscending = "amname ASC",
amhandlerAscending = "amhandler ASC",
amtypeAscending = "amtype ASC",
oidDescending = "oid DESC",
amnameDescending = "amname DESC",
amhandlerDescending = "amhandler DESC",
amtypeDescending = "amtype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "amname" as FieldNamesType,
},
Amhandler: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "amhandler" as FieldNamesType,
},
Amtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "amtype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amname","Amhandler","Amtype"] as const;
export const FieldNames = ["oid","amname","amhandler","amtype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmOidIndex;
}
export namespace PgAmop {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAmop> {
 return { oid: undefined,amopfamily: undefined,amoplefttype: undefined,amoprighttype: undefined,amopstrategy: undefined,amoppurpose: undefined,amopopr: undefined,amopmethod: undefined,amopsortfamily: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAmop,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAmop,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amopfamilyAscending = "amopfamily ASC",
amoplefttypeAscending = "amoplefttype ASC",
amoprighttypeAscending = "amoprighttype ASC",
amopstrategyAscending = "amopstrategy ASC",
amoppurposeAscending = "amoppurpose ASC",
amopoprAscending = "amopopr ASC",
amopmethodAscending = "amopmethod ASC",
amopsortfamilyAscending = "amopsortfamily ASC",
oidDescending = "oid DESC",
amopfamilyDescending = "amopfamily DESC",
amoplefttypeDescending = "amoplefttype DESC",
amoprighttypeDescending = "amoprighttype DESC",
amopstrategyDescending = "amopstrategy DESC",
amoppurposeDescending = "amoppurpose DESC",
amopoprDescending = "amopopr DESC",
amopmethodDescending = "amopmethod DESC",
amopsortfamilyDescending = "amopsortfamily DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amopfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopfamily" as FieldNamesType,
},
Amoplefttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amoplefttype" as FieldNamesType,
},
Amoprighttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amoprighttype" as FieldNamesType,
},
Amopstrategy: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "amopstrategy" as FieldNamesType,
},
Amoppurpose: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "amoppurpose" as FieldNamesType,
},
Amopopr: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopopr" as FieldNamesType,
},
Amopmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopmethod" as FieldNamesType,
},
Amopsortfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopsortfamily" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amopfamily","Amoplefttype","Amoprighttype","Amopstrategy","Amoppurpose","Amopopr","Amopmethod","Amopsortfamily"] as const;
export const FieldNames = ["oid","amopfamily","amoplefttype","amoprighttype","amopstrategy","amoppurpose","amopopr","amopmethod","amopsortfamily"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmopOidIndex;
}
export namespace PgAmproc {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAmproc> {
 return { oid: undefined,amprocfamily: undefined,amproclefttype: undefined,amprocrighttype: undefined,amprocnum: undefined,amproc: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAmproc,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAmproc,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amprocfamilyAscending = "amprocfamily ASC",
amproclefttypeAscending = "amproclefttype ASC",
amprocrighttypeAscending = "amprocrighttype ASC",
amprocnumAscending = "amprocnum ASC",
amprocAscending = "amproc ASC",
oidDescending = "oid DESC",
amprocfamilyDescending = "amprocfamily DESC",
amproclefttypeDescending = "amproclefttype DESC",
amprocrighttypeDescending = "amprocrighttype DESC",
amprocnumDescending = "amprocnum DESC",
amprocDescending = "amproc DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amprocfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amprocfamily" as FieldNamesType,
},
Amproclefttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amproclefttype" as FieldNamesType,
},
Amprocrighttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amprocrighttype" as FieldNamesType,
},
Amprocnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "amprocnum" as FieldNamesType,
},
Amproc: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "amproc" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amprocfamily","Amproclefttype","Amprocrighttype","Amprocnum","Amproc"] as const;
export const FieldNames = ["oid","amprocfamily","amproclefttype","amprocrighttype","amprocnum","amproc"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmprocOidIndex;
}
export namespace PgLanguage {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLanguage> {
 return { oid: undefined,lanname: undefined,lanowner: undefined,lanispl: undefined,lanpltrusted: undefined,lanplcallfoid: undefined,laninline: undefined,lanvalidator: undefined,lanacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLanguage,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLanguage,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
lannameAscending = "lanname ASC",
lanownerAscending = "lanowner ASC",
lanisplAscending = "lanispl ASC",
lanpltrustedAscending = "lanpltrusted ASC",
lanplcallfoidAscending = "lanplcallfoid ASC",
laninlineAscending = "laninline ASC",
lanvalidatorAscending = "lanvalidator ASC",
lanaclAscending = "lanacl ASC",
oidDescending = "oid DESC",
lannameDescending = "lanname DESC",
lanownerDescending = "lanowner DESC",
lanisplDescending = "lanispl DESC",
lanpltrustedDescending = "lanpltrusted DESC",
lanplcallfoidDescending = "lanplcallfoid DESC",
laninlineDescending = "laninline DESC",
lanvalidatorDescending = "lanvalidator DESC",
lanaclDescending = "lanacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Lanname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "lanname" as FieldNamesType,
},
Lanowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanowner" as FieldNamesType,
},
Lanispl: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "lanispl" as FieldNamesType,
},
Lanpltrusted: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "lanpltrusted" as FieldNamesType,
},
Lanplcallfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanplcallfoid" as FieldNamesType,
},
Laninline: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "laninline" as FieldNamesType,
},
Lanvalidator: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanvalidator" as FieldNamesType,
},
Lanacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "lanacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Lanname","Lanowner","Lanispl","Lanpltrusted","Lanplcallfoid","Laninline","Lanvalidator","Lanacl"] as const;
export const FieldNames = ["oid","lanname","lanowner","lanispl","lanpltrusted","lanplcallfoid","laninline","lanvalidator","lanacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLanguageOidIndex;
}
export namespace PgLargeobjectMetadata {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLargeobjectMetadata> {
 return { oid: undefined,lomowner: undefined,lomacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLargeobjectMetadata,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLargeobjectMetadata,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
lomownerAscending = "lomowner ASC",
lomaclAscending = "lomacl ASC",
oidDescending = "oid DESC",
lomownerDescending = "lomowner DESC",
lomaclDescending = "lomacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Lomowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lomowner" as FieldNamesType,
},
Lomacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "lomacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Lomowner","Lomacl"] as const;
export const FieldNames = ["oid","lomowner","lomacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLargeobjectMetadataOidIndex;
}
export namespace PgAggregate {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAggregate> {
 return { aggfnoid: undefined,aggkind: undefined,aggnumdirectargs: undefined,aggtransfn: undefined,aggfinalfn: undefined,aggcombinefn: undefined,aggserialfn: undefined,aggdeserialfn: undefined,aggmtransfn: undefined,aggminvtransfn: undefined,aggmfinalfn: undefined,aggfinalextra: undefined,aggmfinalextra: undefined,aggfinalmodify: undefined,aggmfinalmodify: undefined,aggsortop: undefined,aggtranstype: undefined,aggtransspace: undefined,aggmtranstype: undefined,aggmtransspace: undefined,agginitval: undefined,aggminitval: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAggregate,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAggregate,  PrimaryKey>
export enum SortOptions  {
aggfnoidAscending = "aggfnoid ASC",
aggkindAscending = "aggkind ASC",
aggnumdirectargsAscending = "aggnumdirectargs ASC",
aggtransfnAscending = "aggtransfn ASC",
aggfinalfnAscending = "aggfinalfn ASC",
aggcombinefnAscending = "aggcombinefn ASC",
aggserialfnAscending = "aggserialfn ASC",
aggdeserialfnAscending = "aggdeserialfn ASC",
aggmtransfnAscending = "aggmtransfn ASC",
aggminvtransfnAscending = "aggminvtransfn ASC",
aggmfinalfnAscending = "aggmfinalfn ASC",
aggfinalextraAscending = "aggfinalextra ASC",
aggmfinalextraAscending = "aggmfinalextra ASC",
aggfinalmodifyAscending = "aggfinalmodify ASC",
aggmfinalmodifyAscending = "aggmfinalmodify ASC",
aggsortopAscending = "aggsortop ASC",
aggtranstypeAscending = "aggtranstype ASC",
aggtransspaceAscending = "aggtransspace ASC",
aggmtranstypeAscending = "aggmtranstype ASC",
aggmtransspaceAscending = "aggmtransspace ASC",
agginitvalAscending = "agginitval ASC",
aggminitvalAscending = "aggminitval ASC",
aggfnoidDescending = "aggfnoid DESC",
aggkindDescending = "aggkind DESC",
aggnumdirectargsDescending = "aggnumdirectargs DESC",
aggtransfnDescending = "aggtransfn DESC",
aggfinalfnDescending = "aggfinalfn DESC",
aggcombinefnDescending = "aggcombinefn DESC",
aggserialfnDescending = "aggserialfn DESC",
aggdeserialfnDescending = "aggdeserialfn DESC",
aggmtransfnDescending = "aggmtransfn DESC",
aggminvtransfnDescending = "aggminvtransfn DESC",
aggmfinalfnDescending = "aggmfinalfn DESC",
aggfinalextraDescending = "aggfinalextra DESC",
aggmfinalextraDescending = "aggmfinalextra DESC",
aggfinalmodifyDescending = "aggfinalmodify DESC",
aggmfinalmodifyDescending = "aggmfinalmodify DESC",
aggsortopDescending = "aggsortop DESC",
aggtranstypeDescending = "aggtranstype DESC",
aggtransspaceDescending = "aggtransspace DESC",
aggmtranstypeDescending = "aggmtranstype DESC",
aggmtransspaceDescending = "aggmtransspace DESC",
agginitvalDescending = "agginitval DESC",
aggminitvalDescending = "aggminitval DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Aggfnoid: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggfnoid" as FieldNamesType,
},
Aggkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggkind" as FieldNamesType,
},
Aggnumdirectargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "aggnumdirectargs" as FieldNamesType,
},
Aggtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggtransfn" as FieldNamesType,
},
Aggfinalfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggfinalfn" as FieldNamesType,
},
Aggcombinefn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggcombinefn" as FieldNamesType,
},
Aggserialfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggserialfn" as FieldNamesType,
},
Aggdeserialfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggdeserialfn" as FieldNamesType,
},
Aggmtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggmtransfn" as FieldNamesType,
},
Aggminvtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggminvtransfn" as FieldNamesType,
},
Aggmfinalfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggmfinalfn" as FieldNamesType,
},
Aggfinalextra: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "aggfinalextra" as FieldNamesType,
},
Aggmfinalextra: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "aggmfinalextra" as FieldNamesType,
},
Aggfinalmodify: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggfinalmodify" as FieldNamesType,
},
Aggmfinalmodify: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggmfinalmodify" as FieldNamesType,
},
Aggsortop: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggsortop" as FieldNamesType,
},
Aggtranstype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggtranstype" as FieldNamesType,
},
Aggtransspace: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "aggtransspace" as FieldNamesType,
},
Aggmtranstype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggmtranstype" as FieldNamesType,
},
Aggmtransspace: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "aggmtransspace" as FieldNamesType,
},
Agginitval: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "agginitval" as FieldNamesType,
},
Aggminitval: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "aggminitval" as FieldNamesType,
},
}
export const ColumnNames = ["Aggfnoid","Aggkind","Aggnumdirectargs","Aggtransfn","Aggfinalfn","Aggcombinefn","Aggserialfn","Aggdeserialfn","Aggmtransfn","Aggminvtransfn","Aggmfinalfn","Aggfinalextra","Aggmfinalextra","Aggfinalmodify","Aggmfinalmodify","Aggsortop","Aggtranstype","Aggtransspace","Aggmtranstype","Aggmtransspace","Agginitval","Aggminitval"] as const;
export const FieldNames = ["aggfnoid","aggkind","aggnumdirectargs","aggtransfn","aggfinalfn","aggcombinefn","aggserialfn","aggdeserialfn","aggmtransfn","aggminvtransfn","aggmfinalfn","aggfinalextra","aggmfinalextra","aggfinalmodify","aggmfinalmodify","aggsortop","aggtranstype","aggtransspace","aggmtranstype","aggmtransspace","agginitval","aggminitval"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAggregateFnoidIndex;
}
export namespace PgStatisticExt {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatisticExt> {
 return { oid: undefined,stxrelid: undefined,stxname: undefined,stxnamespace: undefined,stxowner: undefined,stxstattarget: undefined,stxkeys: undefined,stxkind: undefined,stxexprs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatisticExt,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatisticExt,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
stxrelidAscending = "stxrelid ASC",
stxnameAscending = "stxname ASC",
stxnamespaceAscending = "stxnamespace ASC",
stxownerAscending = "stxowner ASC",
stxstattargetAscending = "stxstattarget ASC",
stxkeysAscending = "stxkeys ASC",
stxkindAscending = "stxkind ASC",
stxexprsAscending = "stxexprs ASC",
oidDescending = "oid DESC",
stxrelidDescending = "stxrelid DESC",
stxnameDescending = "stxname DESC",
stxnamespaceDescending = "stxnamespace DESC",
stxownerDescending = "stxowner DESC",
stxstattargetDescending = "stxstattarget DESC",
stxkeysDescending = "stxkeys DESC",
stxkindDescending = "stxkind DESC",
stxexprsDescending = "stxexprs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Stxrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxrelid" as FieldNamesType,
},
Stxname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "stxname" as FieldNamesType,
},
Stxnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxnamespace" as FieldNamesType,
},
Stxowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxowner" as FieldNamesType,
},
Stxstattarget: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "stxstattarget" as FieldNamesType,
},
Stxkeys: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "stxkeys" as FieldNamesType,
},
Stxkind: {
 typeName: "PgCatalog.Types.CharArray",
 fieldName: "stxkind" as FieldNamesType,
},
Stxexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "stxexprs" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Stxrelid","Stxname","Stxnamespace","Stxowner","Stxstattarget","Stxkeys","Stxkind","Stxexprs"] as const;
export const FieldNames = ["oid","stxrelid","stxname","stxnamespace","stxowner","stxstattarget","stxkeys","stxkind","stxexprs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticExtOidIndex;
}
export namespace PgRewrite {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgRewrite> {
 return { oid: undefined,rulename: undefined,evClass: undefined,evType: undefined,evEnabled: undefined,isInstead: undefined,evQual: undefined,evAction: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgRewrite,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgRewrite,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
rulenameAscending = "rulename ASC",
evClassAscending = "ev_class ASC",
evTypeAscending = "ev_type ASC",
evEnabledAscending = "ev_enabled ASC",
isInsteadAscending = "is_instead ASC",
evQualAscending = "ev_qual ASC",
evActionAscending = "ev_action ASC",
oidDescending = "oid DESC",
rulenameDescending = "rulename DESC",
evClassDescending = "ev_class DESC",
evTypeDescending = "ev_type DESC",
evEnabledDescending = "ev_enabled DESC",
isInsteadDescending = "is_instead DESC",
evQualDescending = "ev_qual DESC",
evActionDescending = "ev_action DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Rulename: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "rulename" as FieldNamesType,
},
EvClass: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evClass" as FieldNamesType,
},
EvType: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evType" as FieldNamesType,
},
EvEnabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evEnabled" as FieldNamesType,
},
IsInstead: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "isInstead" as FieldNamesType,
},
EvQual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "evQual" as FieldNamesType,
},
EvAction: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "evAction" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Rulename","EvClass","EvType","EvEnabled","IsInstead","EvQual","EvAction"] as const;
export const FieldNames = ["oid","rulename","evClass","evType","evEnabled","isInstead","evQual","evAction"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgRewriteOidIndex;
}
export namespace PgTrigger {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTrigger> {
 return { oid: undefined,tgrelid: undefined,tgparentid: undefined,tgname: undefined,tgfoid: undefined,tgtype: undefined,tgenabled: undefined,tgisinternal: undefined,tgconstrrelid: undefined,tgconstrindid: undefined,tgconstraint: undefined,tgdeferrable: undefined,tginitdeferred: undefined,tgnargs: undefined,tgattr: undefined,tgargs: undefined,tgqual: undefined,tgoldtable: undefined,tgnewtable: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTrigger,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTrigger,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
tgrelidAscending = "tgrelid ASC",
tgparentidAscending = "tgparentid ASC",
tgnameAscending = "tgname ASC",
tgfoidAscending = "tgfoid ASC",
tgtypeAscending = "tgtype ASC",
tgenabledAscending = "tgenabled ASC",
tgisinternalAscending = "tgisinternal ASC",
tgconstrrelidAscending = "tgconstrrelid ASC",
tgconstrindidAscending = "tgconstrindid ASC",
tgconstraintAscending = "tgconstraint ASC",
tgdeferrableAscending = "tgdeferrable ASC",
tginitdeferredAscending = "tginitdeferred ASC",
tgnargsAscending = "tgnargs ASC",
tgattrAscending = "tgattr ASC",
tgargsAscending = "tgargs ASC",
tgqualAscending = "tgqual ASC",
tgoldtableAscending = "tgoldtable ASC",
tgnewtableAscending = "tgnewtable ASC",
oidDescending = "oid DESC",
tgrelidDescending = "tgrelid DESC",
tgparentidDescending = "tgparentid DESC",
tgnameDescending = "tgname DESC",
tgfoidDescending = "tgfoid DESC",
tgtypeDescending = "tgtype DESC",
tgenabledDescending = "tgenabled DESC",
tgisinternalDescending = "tgisinternal DESC",
tgconstrrelidDescending = "tgconstrrelid DESC",
tgconstrindidDescending = "tgconstrindid DESC",
tgconstraintDescending = "tgconstraint DESC",
tgdeferrableDescending = "tgdeferrable DESC",
tginitdeferredDescending = "tginitdeferred DESC",
tgnargsDescending = "tgnargs DESC",
tgattrDescending = "tgattr DESC",
tgargsDescending = "tgargs DESC",
tgqualDescending = "tgqual DESC",
tgoldtableDescending = "tgoldtable DESC",
tgnewtableDescending = "tgnewtable DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Tgrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgrelid" as FieldNamesType,
},
Tgparentid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgparentid" as FieldNamesType,
},
Tgname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgname" as FieldNamesType,
},
Tgfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgfoid" as FieldNamesType,
},
Tgtype: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "tgtype" as FieldNamesType,
},
Tgenabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "tgenabled" as FieldNamesType,
},
Tgisinternal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tgisinternal" as FieldNamesType,
},
Tgconstrrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstrrelid" as FieldNamesType,
},
Tgconstrindid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstrindid" as FieldNamesType,
},
Tgconstraint: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstraint" as FieldNamesType,
},
Tgdeferrable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tgdeferrable" as FieldNamesType,
},
Tginitdeferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tginitdeferred" as FieldNamesType,
},
Tgnargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "tgnargs" as FieldNamesType,
},
Tgattr: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "tgattr" as FieldNamesType,
},
Tgargs: {
 typeName: "PgCatalog.Types.Bytea",
 fieldName: "tgargs" as FieldNamesType,
},
Tgqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "tgqual" as FieldNamesType,
},
Tgoldtable: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgoldtable" as FieldNamesType,
},
Tgnewtable: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgnewtable" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Tgrelid","Tgparentid","Tgname","Tgfoid","Tgtype","Tgenabled","Tgisinternal","Tgconstrrelid","Tgconstrindid","Tgconstraint","Tgdeferrable","Tginitdeferred","Tgnargs","Tgattr","Tgargs","Tgqual","Tgoldtable","Tgnewtable"] as const;
export const FieldNames = ["oid","tgrelid","tgparentid","tgname","tgfoid","tgtype","tgenabled","tgisinternal","tgconstrrelid","tgconstrindid","tgconstraint","tgdeferrable","tginitdeferred","tgnargs","tgattr","tgargs","tgqual","tgoldtable","tgnewtable"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTriggerOidIndex;
}
export namespace PgEventTrigger {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgEventTrigger> {
 return { oid: undefined,evtname: undefined,evtevent: undefined,evtowner: undefined,evtfoid: undefined,evtenabled: undefined,evttags: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgEventTrigger,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgEventTrigger,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
evtnameAscending = "evtname ASC",
evteventAscending = "evtevent ASC",
evtownerAscending = "evtowner ASC",
evtfoidAscending = "evtfoid ASC",
evtenabledAscending = "evtenabled ASC",
evttagsAscending = "evttags ASC",
oidDescending = "oid DESC",
evtnameDescending = "evtname DESC",
evteventDescending = "evtevent DESC",
evtownerDescending = "evtowner DESC",
evtfoidDescending = "evtfoid DESC",
evtenabledDescending = "evtenabled DESC",
evttagsDescending = "evttags DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Evtname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "evtname" as FieldNamesType,
},
Evtevent: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "evtevent" as FieldNamesType,
},
Evtowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evtowner" as FieldNamesType,
},
Evtfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evtfoid" as FieldNamesType,
},
Evtenabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evtenabled" as FieldNamesType,
},
Evttags: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "evttags" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Evtname","Evtevent","Evtowner","Evtfoid","Evtenabled","Evttags"] as const;
export const FieldNames = ["oid","evtname","evtevent","evtowner","evtfoid","evtenabled","evttags"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgEventTriggerOidIndex;
}
export namespace PgDescription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDescription> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,description: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDescription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDescription,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
descriptionAscending = "description ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
descriptionDescending = "description DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Description: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "description" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Description"] as const;
export const FieldNames = ["objoid","classoid","objsubid","description"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDescriptionOCOIndex;
}
export namespace PgCast {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgCast> {
 return { oid: undefined,castsource: undefined,casttarget: undefined,castfunc: undefined,castcontext: undefined,castmethod: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgCast,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgCast,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
castsourceAscending = "castsource ASC",
casttargetAscending = "casttarget ASC",
castfuncAscending = "castfunc ASC",
castcontextAscending = "castcontext ASC",
castmethodAscending = "castmethod ASC",
oidDescending = "oid DESC",
castsourceDescending = "castsource DESC",
casttargetDescending = "casttarget DESC",
castfuncDescending = "castfunc DESC",
castcontextDescending = "castcontext DESC",
castmethodDescending = "castmethod DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Castsource: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "castsource" as FieldNamesType,
},
Casttarget: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "casttarget" as FieldNamesType,
},
Castfunc: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "castfunc" as FieldNamesType,
},
Castcontext: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "castcontext" as FieldNamesType,
},
Castmethod: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "castmethod" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Castsource","Casttarget","Castfunc","Castcontext","Castmethod"] as const;
export const FieldNames = ["oid","castsource","casttarget","castfunc","castcontext","castmethod"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgCastOidIndex;
}
export namespace PgEnum {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgEnum> {
 return { oid: undefined,enumtypid: undefined,enumsortorder: undefined,enumlabel: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgEnum,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgEnum,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
enumtypidAscending = "enumtypid ASC",
enumsortorderAscending = "enumsortorder ASC",
enumlabelAscending = "enumlabel ASC",
oidDescending = "oid DESC",
enumtypidDescending = "enumtypid DESC",
enumsortorderDescending = "enumsortorder DESC",
enumlabelDescending = "enumlabel DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Enumtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "enumtypid" as FieldNamesType,
},
Enumsortorder: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "enumsortorder" as FieldNamesType,
},
Enumlabel: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "enumlabel" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Enumtypid","Enumsortorder","Enumlabel"] as const;
export const FieldNames = ["oid","enumtypid","enumsortorder","enumlabel"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgEnumOidIndex;
}
export namespace PgNamespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgNamespace> {
 return { oid: undefined,nspname: undefined,nspowner: undefined,nspacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgNamespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgNamespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
nspnameAscending = "nspname ASC",
nspownerAscending = "nspowner ASC",
nspaclAscending = "nspacl ASC",
oidDescending = "oid DESC",
nspnameDescending = "nspname DESC",
nspownerDescending = "nspowner DESC",
nspaclDescending = "nspacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Nspname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "nspname" as FieldNamesType,
},
Nspowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "nspowner" as FieldNamesType,
},
Nspacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "nspacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Nspname","Nspowner","Nspacl"] as const;
export const FieldNames = ["oid","nspname","nspowner","nspacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgNamespaceOidIndex;
}
export namespace PgConversion {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgConversion> {
 return { oid: undefined,conname: undefined,connamespace: undefined,conowner: undefined,conforencoding: undefined,contoencoding: undefined,conproc: undefined,condefault: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgConversion,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgConversion,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
connameAscending = "conname ASC",
connamespaceAscending = "connamespace ASC",
conownerAscending = "conowner ASC",
conforencodingAscending = "conforencoding ASC",
contoencodingAscending = "contoencoding ASC",
conprocAscending = "conproc ASC",
condefaultAscending = "condefault ASC",
oidDescending = "oid DESC",
connameDescending = "conname DESC",
connamespaceDescending = "connamespace DESC",
conownerDescending = "conowner DESC",
conforencodingDescending = "conforencoding DESC",
contoencodingDescending = "contoencoding DESC",
conprocDescending = "conproc DESC",
condefaultDescending = "condefault DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Conname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "conname" as FieldNamesType,
},
Connamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "connamespace" as FieldNamesType,
},
Conowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conowner" as FieldNamesType,
},
Conforencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "conforencoding" as FieldNamesType,
},
Contoencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "contoencoding" as FieldNamesType,
},
Conproc: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "conproc" as FieldNamesType,
},
Condefault: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condefault" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Conname","Connamespace","Conowner","Conforencoding","Contoencoding","Conproc","Condefault"] as const;
export const FieldNames = ["oid","conname","connamespace","conowner","conforencoding","contoencoding","conproc","condefault"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgConversionOidIndex;
}
export namespace PgDepend {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDepend> {
 return { classid: undefined,objid: undefined,objsubid: undefined,refclassid: undefined,refobjid: undefined,refobjsubid: undefined,deptype: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<PgCatalog.Types.PgDepend,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDepend,  PrimaryKey>
export enum SortOptions  {
classidAscending = "classid ASC",
objidAscending = "objid ASC",
objsubidAscending = "objsubid ASC",
refclassidAscending = "refclassid ASC",
refobjidAscending = "refobjid ASC",
refobjsubidAscending = "refobjsubid ASC",
deptypeAscending = "deptype ASC",
classidDescending = "classid DESC",
objidDescending = "objid DESC",
objsubidDescending = "objsubid DESC",
refclassidDescending = "refclassid DESC",
refobjidDescending = "refobjid DESC",
refobjsubidDescending = "refobjsubid DESC",
deptypeDescending = "deptype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Classid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classid" as FieldNamesType,
},
Objid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Refclassid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refclassid" as FieldNamesType,
},
Refobjid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refobjid" as FieldNamesType,
},
Refobjsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "refobjsubid" as FieldNamesType,
},
Deptype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "deptype" as FieldNamesType,
},
}
export const ColumnNames = ["Classid","Objid","Objsubid","Refclassid","Refobjid","Refobjsubid","Deptype"] as const;
export const FieldNames = ["classid","objid","objsubid","refclassid","refobjid","refobjsubid","deptype"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PgDatabase {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDatabase> {
 return { oid: undefined,datname: undefined,datdba: undefined,encoding: undefined,datlocprovider: undefined,datistemplate: undefined,datallowconn: undefined,datconnlimit: undefined,datfrozenxid: undefined,datminmxid: undefined,dattablespace: undefined,datcollate: undefined,datctype: undefined,daticulocale: undefined,daticurules: undefined,datcollversion: undefined,datacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDatabase,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDatabase,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
datnameAscending = "datname ASC",
datdbaAscending = "datdba ASC",
encodingAscending = "encoding ASC",
datlocproviderAscending = "datlocprovider ASC",
datistemplateAscending = "datistemplate ASC",
datallowconnAscending = "datallowconn ASC",
datconnlimitAscending = "datconnlimit ASC",
datfrozenxidAscending = "datfrozenxid ASC",
datminmxidAscending = "datminmxid ASC",
dattablespaceAscending = "dattablespace ASC",
datcollateAscending = "datcollate ASC",
datctypeAscending = "datctype ASC",
daticulocaleAscending = "daticulocale ASC",
daticurulesAscending = "daticurules ASC",
datcollversionAscending = "datcollversion ASC",
dataclAscending = "datacl ASC",
oidDescending = "oid DESC",
datnameDescending = "datname DESC",
datdbaDescending = "datdba DESC",
encodingDescending = "encoding DESC",
datlocproviderDescending = "datlocprovider DESC",
datistemplateDescending = "datistemplate DESC",
datallowconnDescending = "datallowconn DESC",
datconnlimitDescending = "datconnlimit DESC",
datfrozenxidDescending = "datfrozenxid DESC",
datminmxidDescending = "datminmxid DESC",
dattablespaceDescending = "dattablespace DESC",
datcollateDescending = "datcollate DESC",
datctypeDescending = "datctype DESC",
daticulocaleDescending = "daticulocale DESC",
daticurulesDescending = "daticurules DESC",
datcollversionDescending = "datcollversion DESC",
dataclDescending = "datacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Datname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "datname" as FieldNamesType,
},
Datdba: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "datdba" as FieldNamesType,
},
Encoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "encoding" as FieldNamesType,
},
Datlocprovider: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "datlocprovider" as FieldNamesType,
},
Datistemplate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "datistemplate" as FieldNamesType,
},
Datallowconn: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "datallowconn" as FieldNamesType,
},
Datconnlimit: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "datconnlimit" as FieldNamesType,
},
Datfrozenxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "datfrozenxid" as FieldNamesType,
},
Datminmxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "datminmxid" as FieldNamesType,
},
Dattablespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dattablespace" as FieldNamesType,
},
Datcollate: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datcollate" as FieldNamesType,
},
Datctype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datctype" as FieldNamesType,
},
Daticulocale: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "daticulocale" as FieldNamesType,
},
Daticurules: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "daticurules" as FieldNamesType,
},
Datcollversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datcollversion" as FieldNamesType,
},
Datacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "datacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Datname","Datdba","Encoding","Datlocprovider","Datistemplate","Datallowconn","Datconnlimit","Datfrozenxid","Datminmxid","Dattablespace","Datcollate","Datctype","Daticulocale","Daticurules","Datcollversion","Datacl"] as const;
export const FieldNames = ["oid","datname","datdba","encoding","datlocprovider","datistemplate","datallowconn","datconnlimit","datfrozenxid","datminmxid","dattablespace","datcollate","datctype","daticulocale","daticurules","datcollversion","datacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDatabaseOidIndex;
}
export namespace PgDbRoleSetting {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDbRoleSetting> {
 return { setdatabase: undefined,setrole: undefined,setconfig: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDbRoleSetting,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDbRoleSetting,  PrimaryKey>
export enum SortOptions  {
setdatabaseAscending = "setdatabase ASC",
setroleAscending = "setrole ASC",
setconfigAscending = "setconfig ASC",
setdatabaseDescending = "setdatabase DESC",
setroleDescending = "setrole DESC",
setconfigDescending = "setconfig DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Setdatabase: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "setdatabase" as FieldNamesType,
},
Setrole: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "setrole" as FieldNamesType,
},
Setconfig: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "setconfig" as FieldNamesType,
},
}
export const ColumnNames = ["Setdatabase","Setrole","Setconfig"] as const;
export const FieldNames = ["setdatabase","setrole","setconfig"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex;
}
export namespace PgTablespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTablespace> {
 return { oid: undefined,spcname: undefined,spcowner: undefined,spcacl: undefined,spcoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTablespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTablespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
spcnameAscending = "spcname ASC",
spcownerAscending = "spcowner ASC",
spcaclAscending = "spcacl ASC",
spcoptionsAscending = "spcoptions ASC",
oidDescending = "oid DESC",
spcnameDescending = "spcname DESC",
spcownerDescending = "spcowner DESC",
spcaclDescending = "spcacl DESC",
spcoptionsDescending = "spcoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Spcname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "spcname" as FieldNamesType,
},
Spcowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "spcowner" as FieldNamesType,
},
Spcacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "spcacl" as FieldNamesType,
},
Spcoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "spcoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Spcname","Spcowner","Spcacl","Spcoptions"] as const;
export const FieldNames = ["oid","spcname","spcowner","spcacl","spcoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTablespaceOidIndex;
}
export namespace PgAuthMembers {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAuthMembers> {
 return { oid: undefined,roleid: undefined,member: undefined,grantor: undefined,adminOption: undefined,inheritOption: undefined,setOption: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAuthMembers,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAuthMembers,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
roleidAscending = "roleid ASC",
memberAscending = "member ASC",
grantorAscending = "grantor ASC",
adminOptionAscending = "admin_option ASC",
inheritOptionAscending = "inherit_option ASC",
setOptionAscending = "set_option ASC",
oidDescending = "oid DESC",
roleidDescending = "roleid DESC",
memberDescending = "member DESC",
grantorDescending = "grantor DESC",
adminOptionDescending = "admin_option DESC",
inheritOptionDescending = "inherit_option DESC",
setOptionDescending = "set_option DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Roleid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "roleid" as FieldNamesType,
},
Member: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "member" as FieldNamesType,
},
Grantor: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "grantor" as FieldNamesType,
},
AdminOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "adminOption" as FieldNamesType,
},
InheritOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "inheritOption" as FieldNamesType,
},
SetOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "setOption" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Roleid","Member","Grantor","AdminOption","InheritOption","SetOption"] as const;
export const FieldNames = ["oid","roleid","member","grantor","adminOption","inheritOption","setOption"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAuthMembersOidIndex;
}
export namespace PgShdepend {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShdepend> {
 return { dbid: undefined,classid: undefined,objid: undefined,objsubid: undefined,refclassid: undefined,refobjid: undefined,deptype: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<PgCatalog.Types.PgShdepend,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShdepend,  PrimaryKey>
export enum SortOptions  {
dbidAscending = "dbid ASC",
classidAscending = "classid ASC",
objidAscending = "objid ASC",
objsubidAscending = "objsubid ASC",
refclassidAscending = "refclassid ASC",
refobjidAscending = "refobjid ASC",
deptypeAscending = "deptype ASC",
dbidDescending = "dbid DESC",
classidDescending = "classid DESC",
objidDescending = "objid DESC",
objsubidDescending = "objsubid DESC",
refclassidDescending = "refclassid DESC",
refobjidDescending = "refobjid DESC",
deptypeDescending = "deptype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Dbid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dbid" as FieldNamesType,
},
Classid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classid" as FieldNamesType,
},
Objid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Refclassid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refclassid" as FieldNamesType,
},
Refobjid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refobjid" as FieldNamesType,
},
Deptype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "deptype" as FieldNamesType,
},
}
export const ColumnNames = ["Dbid","Classid","Objid","Objsubid","Refclassid","Refobjid","Deptype"] as const;
export const FieldNames = ["dbid","classid","objid","objsubid","refclassid","refobjid","deptype"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PgShdescription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShdescription> {
 return { objoid: undefined,classoid: undefined,description: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgShdescription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShdescription,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
descriptionAscending = "description ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
descriptionDescending = "description DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Description: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "description" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Description"] as const;
export const FieldNames = ["objoid","classoid","description"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgShdescriptionOCIndex;
}
export namespace PgTsConfig {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsConfig> {
 return { oid: undefined,cfgname: undefined,cfgnamespace: undefined,cfgowner: undefined,cfgparser: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsConfig,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsConfig,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
cfgnameAscending = "cfgname ASC",
cfgnamespaceAscending = "cfgnamespace ASC",
cfgownerAscending = "cfgowner ASC",
cfgparserAscending = "cfgparser ASC",
oidDescending = "oid DESC",
cfgnameDescending = "cfgname DESC",
cfgnamespaceDescending = "cfgnamespace DESC",
cfgownerDescending = "cfgowner DESC",
cfgparserDescending = "cfgparser DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Cfgname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "cfgname" as FieldNamesType,
},
Cfgnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgnamespace" as FieldNamesType,
},
Cfgowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgowner" as FieldNamesType,
},
Cfgparser: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgparser" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Cfgname","Cfgnamespace","Cfgowner","Cfgparser"] as const;
export const FieldNames = ["oid","cfgname","cfgnamespace","cfgowner","cfgparser"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsConfigOidIndex;
}
export namespace PgTsConfigMap {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsConfigMap> {
 return { mapcfg: undefined,maptokentype: undefined,mapseqno: undefined,mapdict: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsConfigMap,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsConfigMap,  PrimaryKey>
export enum SortOptions  {
mapcfgAscending = "mapcfg ASC",
maptokentypeAscending = "maptokentype ASC",
mapseqnoAscending = "mapseqno ASC",
mapdictAscending = "mapdict ASC",
mapcfgDescending = "mapcfg DESC",
maptokentypeDescending = "maptokentype DESC",
mapseqnoDescending = "mapseqno DESC",
mapdictDescending = "mapdict DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Mapcfg: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "mapcfg" as FieldNamesType,
},
Maptokentype: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "maptokentype" as FieldNamesType,
},
Mapseqno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "mapseqno" as FieldNamesType,
},
Mapdict: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "mapdict" as FieldNamesType,
},
}
export const ColumnNames = ["Mapcfg","Maptokentype","Mapseqno","Mapdict"] as const;
export const FieldNames = ["mapcfg","maptokentype","mapseqno","mapdict"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsConfigMapIndex;
}
export namespace PgTsDict {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsDict> {
 return { oid: undefined,dictname: undefined,dictnamespace: undefined,dictowner: undefined,dicttemplate: undefined,dictinitoption: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsDict,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsDict,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
dictnameAscending = "dictname ASC",
dictnamespaceAscending = "dictnamespace ASC",
dictownerAscending = "dictowner ASC",
dicttemplateAscending = "dicttemplate ASC",
dictinitoptionAscending = "dictinitoption ASC",
oidDescending = "oid DESC",
dictnameDescending = "dictname DESC",
dictnamespaceDescending = "dictnamespace DESC",
dictownerDescending = "dictowner DESC",
dicttemplateDescending = "dicttemplate DESC",
dictinitoptionDescending = "dictinitoption DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Dictname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "dictname" as FieldNamesType,
},
Dictnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dictnamespace" as FieldNamesType,
},
Dictowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dictowner" as FieldNamesType,
},
Dicttemplate: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dicttemplate" as FieldNamesType,
},
Dictinitoption: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "dictinitoption" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Dictname","Dictnamespace","Dictowner","Dicttemplate","Dictinitoption"] as const;
export const FieldNames = ["oid","dictname","dictnamespace","dictowner","dicttemplate","dictinitoption"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsDictOidIndex;
}
export namespace PgTsParser {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsParser> {
 return { oid: undefined,prsname: undefined,prsnamespace: undefined,prsstart: undefined,prstoken: undefined,prsend: undefined,prsheadline: undefined,prslextype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsParser,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsParser,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
prsnameAscending = "prsname ASC",
prsnamespaceAscending = "prsnamespace ASC",
prsstartAscending = "prsstart ASC",
prstokenAscending = "prstoken ASC",
prsendAscending = "prsend ASC",
prsheadlineAscending = "prsheadline ASC",
prslextypeAscending = "prslextype ASC",
oidDescending = "oid DESC",
prsnameDescending = "prsname DESC",
prsnamespaceDescending = "prsnamespace DESC",
prsstartDescending = "prsstart DESC",
prstokenDescending = "prstoken DESC",
prsendDescending = "prsend DESC",
prsheadlineDescending = "prsheadline DESC",
prslextypeDescending = "prslextype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Prsname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "prsname" as FieldNamesType,
},
Prsnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prsnamespace" as FieldNamesType,
},
Prsstart: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsstart" as FieldNamesType,
},
Prstoken: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prstoken" as FieldNamesType,
},
Prsend: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsend" as FieldNamesType,
},
Prsheadline: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsheadline" as FieldNamesType,
},
Prslextype: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prslextype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Prsname","Prsnamespace","Prsstart","Prstoken","Prsend","Prsheadline","Prslextype"] as const;
export const FieldNames = ["oid","prsname","prsnamespace","prsstart","prstoken","prsend","prsheadline","prslextype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsParserOidIndex;
}
export namespace PgTsTemplate {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsTemplate> {
 return { oid: undefined,tmplname: undefined,tmplnamespace: undefined,tmplinit: undefined,tmpllexize: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsTemplate,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsTemplate,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
tmplnameAscending = "tmplname ASC",
tmplnamespaceAscending = "tmplnamespace ASC",
tmplinitAscending = "tmplinit ASC",
tmpllexizeAscending = "tmpllexize ASC",
oidDescending = "oid DESC",
tmplnameDescending = "tmplname DESC",
tmplnamespaceDescending = "tmplnamespace DESC",
tmplinitDescending = "tmplinit DESC",
tmpllexizeDescending = "tmpllexize DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Tmplname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tmplname" as FieldNamesType,
},
Tmplnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tmplnamespace" as FieldNamesType,
},
Tmplinit: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "tmplinit" as FieldNamesType,
},
Tmpllexize: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "tmpllexize" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Tmplname","Tmplnamespace","Tmplinit","Tmpllexize"] as const;
export const FieldNames = ["oid","tmplname","tmplnamespace","tmplinit","tmpllexize"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsTemplateOidIndex;
}
export namespace PgExtension {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgExtension> {
 return { oid: undefined,extname: undefined,extowner: undefined,extnamespace: undefined,extrelocatable: undefined,extversion: undefined,extconfig: undefined,extcondition: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgExtension,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgExtension,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
extnameAscending = "extname ASC",
extownerAscending = "extowner ASC",
extnamespaceAscending = "extnamespace ASC",
extrelocatableAscending = "extrelocatable ASC",
extversionAscending = "extversion ASC",
extconfigAscending = "extconfig ASC",
extconditionAscending = "extcondition ASC",
oidDescending = "oid DESC",
extnameDescending = "extname DESC",
extownerDescending = "extowner DESC",
extnamespaceDescending = "extnamespace DESC",
extrelocatableDescending = "extrelocatable DESC",
extversionDescending = "extversion DESC",
extconfigDescending = "extconfig DESC",
extconditionDescending = "extcondition DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Extname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "extname" as FieldNamesType,
},
Extowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "extowner" as FieldNamesType,
},
Extnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "extnamespace" as FieldNamesType,
},
Extrelocatable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "extrelocatable" as FieldNamesType,
},
Extversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "extversion" as FieldNamesType,
},
Extconfig: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "extconfig" as FieldNamesType,
},
Extcondition: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "extcondition" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Extname","Extowner","Extnamespace","Extrelocatable","Extversion","Extconfig","Extcondition"] as const;
export const FieldNames = ["oid","extname","extowner","extnamespace","extrelocatable","extversion","extconfig","extcondition"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgExtensionOidIndex;
}
export namespace PgForeignDataWrapper {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignDataWrapper> {
 return { oid: undefined,fdwname: undefined,fdwowner: undefined,fdwhandler: undefined,fdwvalidator: undefined,fdwacl: undefined,fdwoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignDataWrapper,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignDataWrapper,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
fdwnameAscending = "fdwname ASC",
fdwownerAscending = "fdwowner ASC",
fdwhandlerAscending = "fdwhandler ASC",
fdwvalidatorAscending = "fdwvalidator ASC",
fdwaclAscending = "fdwacl ASC",
fdwoptionsAscending = "fdwoptions ASC",
oidDescending = "oid DESC",
fdwnameDescending = "fdwname DESC",
fdwownerDescending = "fdwowner DESC",
fdwhandlerDescending = "fdwhandler DESC",
fdwvalidatorDescending = "fdwvalidator DESC",
fdwaclDescending = "fdwacl DESC",
fdwoptionsDescending = "fdwoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Fdwname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "fdwname" as FieldNamesType,
},
Fdwowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwowner" as FieldNamesType,
},
Fdwhandler: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwhandler" as FieldNamesType,
},
Fdwvalidator: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwvalidator" as FieldNamesType,
},
Fdwacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "fdwacl" as FieldNamesType,
},
Fdwoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "fdwoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Fdwname","Fdwowner","Fdwhandler","Fdwvalidator","Fdwacl","Fdwoptions"] as const;
export const FieldNames = ["oid","fdwname","fdwowner","fdwhandler","fdwvalidator","fdwacl","fdwoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignDataWrapperOidIndex;
}
export namespace PgForeignServer {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignServer> {
 return { oid: undefined,srvname: undefined,srvowner: undefined,srvfdw: undefined,srvtype: undefined,srvversion: undefined,srvacl: undefined,srvoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignServer,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignServer,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
srvnameAscending = "srvname ASC",
srvownerAscending = "srvowner ASC",
srvfdwAscending = "srvfdw ASC",
srvtypeAscending = "srvtype ASC",
srvversionAscending = "srvversion ASC",
srvaclAscending = "srvacl ASC",
srvoptionsAscending = "srvoptions ASC",
oidDescending = "oid DESC",
srvnameDescending = "srvname DESC",
srvownerDescending = "srvowner DESC",
srvfdwDescending = "srvfdw DESC",
srvtypeDescending = "srvtype DESC",
srvversionDescending = "srvversion DESC",
srvaclDescending = "srvacl DESC",
srvoptionsDescending = "srvoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Srvname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "srvname" as FieldNamesType,
},
Srvowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srvowner" as FieldNamesType,
},
Srvfdw: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srvfdw" as FieldNamesType,
},
Srvtype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srvtype" as FieldNamesType,
},
Srvversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srvversion" as FieldNamesType,
},
Srvacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "srvacl" as FieldNamesType,
},
Srvoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "srvoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Srvname","Srvowner","Srvfdw","Srvtype","Srvversion","Srvacl","Srvoptions"] as const;
export const FieldNames = ["oid","srvname","srvowner","srvfdw","srvtype","srvversion","srvacl","srvoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignServerOidIndex;
}
export namespace PgPolicy {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPolicy> {
 return { oid: undefined,polname: undefined,polrelid: undefined,polcmd: undefined,polpermissive: undefined,polroles: undefined,polqual: undefined,polwithcheck: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPolicy,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPolicy,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
polnameAscending = "polname ASC",
polrelidAscending = "polrelid ASC",
polcmdAscending = "polcmd ASC",
polpermissiveAscending = "polpermissive ASC",
polrolesAscending = "polroles ASC",
polqualAscending = "polqual ASC",
polwithcheckAscending = "polwithcheck ASC",
oidDescending = "oid DESC",
polnameDescending = "polname DESC",
polrelidDescending = "polrelid DESC",
polcmdDescending = "polcmd DESC",
polpermissiveDescending = "polpermissive DESC",
polrolesDescending = "polroles DESC",
polqualDescending = "polqual DESC",
polwithcheckDescending = "polwithcheck DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Polname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "polname" as FieldNamesType,
},
Polrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "polrelid" as FieldNamesType,
},
Polcmd: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "polcmd" as FieldNamesType,
},
Polpermissive: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "polpermissive" as FieldNamesType,
},
Polroles: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "polroles" as FieldNamesType,
},
Polqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "polqual" as FieldNamesType,
},
Polwithcheck: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "polwithcheck" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Polname","Polrelid","Polcmd","Polpermissive","Polroles","Polqual","Polwithcheck"] as const;
export const FieldNames = ["oid","polname","polrelid","polcmd","polpermissive","polroles","polqual","polwithcheck"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPolicyOidIndex;
}
export namespace PgReplicationOrigin {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgReplicationOrigin> {
 return { roident: undefined,roname: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgReplicationOrigin,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgReplicationOrigin,  PrimaryKey>
export enum SortOptions  {
roidentAscending = "roident ASC",
ronameAscending = "roname ASC",
roidentDescending = "roident DESC",
ronameDescending = "roname DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Roident: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "roident" as FieldNamesType,
},
Roname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "roname" as FieldNamesType,
},
}
export const ColumnNames = ["Roident","Roname"] as const;
export const FieldNames = ["roident","roname"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgReplicationOriginRoiidentIndex;
}
export namespace PgDefaultAcl {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDefaultAcl> {
 return { oid: undefined,defaclrole: undefined,defaclnamespace: undefined,defaclobjtype: undefined,defaclacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDefaultAcl,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDefaultAcl,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
defaclroleAscending = "defaclrole ASC",
defaclnamespaceAscending = "defaclnamespace ASC",
defaclobjtypeAscending = "defaclobjtype ASC",
defaclaclAscending = "defaclacl ASC",
oidDescending = "oid DESC",
defaclroleDescending = "defaclrole DESC",
defaclnamespaceDescending = "defaclnamespace DESC",
defaclobjtypeDescending = "defaclobjtype DESC",
defaclaclDescending = "defaclacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Defaclrole: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "defaclrole" as FieldNamesType,
},
Defaclnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "defaclnamespace" as FieldNamesType,
},
Defaclobjtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "defaclobjtype" as FieldNamesType,
},
Defaclacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "defaclacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Defaclrole","Defaclnamespace","Defaclobjtype","Defaclacl"] as const;
export const FieldNames = ["oid","defaclrole","defaclnamespace","defaclobjtype","defaclacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDefaultAclOidIndex;
}
export namespace PgInitPrivs {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgInitPrivs> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,privtype: undefined,initprivs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgInitPrivs,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgInitPrivs,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
privtypeAscending = "privtype ASC",
initprivsAscending = "initprivs ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
privtypeDescending = "privtype DESC",
initprivsDescending = "initprivs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Privtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "privtype" as FieldNamesType,
},
Initprivs: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "initprivs" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Privtype","Initprivs"] as const;
export const FieldNames = ["objoid","classoid","objsubid","privtype","initprivs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgInitPrivsOCOIndex;
}
export namespace PgSeclabel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSeclabel> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,provider: undefined,label: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSeclabel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSeclabel,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
providerAscending = "provider ASC",
labelAscending = "label ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
providerDescending = "provider DESC",
labelDescending = "label DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Provider: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "provider" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "label" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Provider","Label"] as const;
export const FieldNames = ["objoid","classoid","objsubid","provider","label"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSeclabelObjectIndex;
}
export namespace PgShseclabel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShseclabel> {
 return { objoid: undefined,classoid: undefined,provider: undefined,label: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgShseclabel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShseclabel,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
providerAscending = "provider ASC",
labelAscending = "label ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
providerDescending = "provider DESC",
labelDescending = "label DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Provider: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "provider" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "label" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Provider","Label"] as const;
export const FieldNames = ["objoid","classoid","provider","label"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgShseclabelObjectIndex;
}
export namespace PgCollation {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgCollation> {
 return { oid: undefined,collname: undefined,collnamespace: undefined,collowner: undefined,collprovider: undefined,collisdeterministic: undefined,collencoding: undefined,collcollate: undefined,collctype: undefined,colliculocale: undefined,collicurules: undefined,collversion: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgCollation,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgCollation,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
collnameAscending = "collname ASC",
collnamespaceAscending = "collnamespace ASC",
collownerAscending = "collowner ASC",
collproviderAscending = "collprovider ASC",
collisdeterministicAscending = "collisdeterministic ASC",
collencodingAscending = "collencoding ASC",
collcollateAscending = "collcollate ASC",
collctypeAscending = "collctype ASC",
colliculocaleAscending = "colliculocale ASC",
collicurulesAscending = "collicurules ASC",
collversionAscending = "collversion ASC",
oidDescending = "oid DESC",
collnameDescending = "collname DESC",
collnamespaceDescending = "collnamespace DESC",
collownerDescending = "collowner DESC",
collproviderDescending = "collprovider DESC",
collisdeterministicDescending = "collisdeterministic DESC",
collencodingDescending = "collencoding DESC",
collcollateDescending = "collcollate DESC",
collctypeDescending = "collctype DESC",
colliculocaleDescending = "colliculocale DESC",
collicurulesDescending = "collicurules DESC",
collversionDescending = "collversion DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Collname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "collname" as FieldNamesType,
},
Collnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "collnamespace" as FieldNamesType,
},
Collowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "collowner" as FieldNamesType,
},
Collprovider: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "collprovider" as FieldNamesType,
},
Collisdeterministic: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "collisdeterministic" as FieldNamesType,
},
Collencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "collencoding" as FieldNamesType,
},
Collcollate: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collcollate" as FieldNamesType,
},
Collctype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collctype" as FieldNamesType,
},
Colliculocale: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "colliculocale" as FieldNamesType,
},
Collicurules: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collicurules" as FieldNamesType,
},
Collversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collversion" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Collname","Collnamespace","Collowner","Collprovider","Collisdeterministic","Collencoding","Collcollate","Collctype","Colliculocale","Collicurules","Collversion"] as const;
export const FieldNames = ["oid","collname","collnamespace","collowner","collprovider","collisdeterministic","collencoding","collcollate","collctype","colliculocale","collicurules","collversion"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgCollationOidIndex;
}
export namespace PgParameterAcl {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgParameterAcl> {
 return { oid: undefined,parname: undefined,paracl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgParameterAcl,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgParameterAcl,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
parnameAscending = "parname ASC",
paraclAscending = "paracl ASC",
oidDescending = "oid DESC",
parnameDescending = "parname DESC",
paraclDescending = "paracl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Parname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "parname" as FieldNamesType,
},
Paracl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "paracl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Parname","Paracl"] as const;
export const FieldNames = ["oid","parname","paracl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgParameterAclOidIndex;
}
export namespace PgPartitionedTable {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPartitionedTable> {
 return { partrelid: undefined,partstrat: undefined,partnatts: undefined,partdefid: undefined,partattrs: undefined,partclass: undefined,partcollation: undefined,partexprs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPartitionedTable,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPartitionedTable,  PrimaryKey>
export enum SortOptions  {
partrelidAscending = "partrelid ASC",
partstratAscending = "partstrat ASC",
partnattsAscending = "partnatts ASC",
partdefidAscending = "partdefid ASC",
partattrsAscending = "partattrs ASC",
partclassAscending = "partclass ASC",
partcollationAscending = "partcollation ASC",
partexprsAscending = "partexprs ASC",
partrelidDescending = "partrelid DESC",
partstratDescending = "partstrat DESC",
partnattsDescending = "partnatts DESC",
partdefidDescending = "partdefid DESC",
partattrsDescending = "partattrs DESC",
partclassDescending = "partclass DESC",
partcollationDescending = "partcollation DESC",
partexprsDescending = "partexprs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Partrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "partrelid" as FieldNamesType,
},
Partstrat: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "partstrat" as FieldNamesType,
},
Partnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "partnatts" as FieldNamesType,
},
Partdefid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "partdefid" as FieldNamesType,
},
Partattrs: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "partattrs" as FieldNamesType,
},
Partclass: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "partclass" as FieldNamesType,
},
Partcollation: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "partcollation" as FieldNamesType,
},
Partexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "partexprs" as FieldNamesType,
},
}
export const ColumnNames = ["Partrelid","Partstrat","Partnatts","Partdefid","Partattrs","Partclass","Partcollation","Partexprs"] as const;
export const FieldNames = ["partrelid","partstrat","partnatts","partdefid","partattrs","partclass","partcollation","partexprs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPartitionedTablePartrelidIndex;
}
export namespace PgRange {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgRange> {
 return { rngtypid: undefined,rngsubtype: undefined,rngmultitypid: undefined,rngcollation: undefined,rngsubopc: undefined,rngcanonical: undefined,rngsubdiff: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgRange,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgRange,  PrimaryKey>
export enum SortOptions  {
rngtypidAscending = "rngtypid ASC",
rngsubtypeAscending = "rngsubtype ASC",
rngmultitypidAscending = "rngmultitypid ASC",
rngcollationAscending = "rngcollation ASC",
rngsubopcAscending = "rngsubopc ASC",
rngcanonicalAscending = "rngcanonical ASC",
rngsubdiffAscending = "rngsubdiff ASC",
rngtypidDescending = "rngtypid DESC",
rngsubtypeDescending = "rngsubtype DESC",
rngmultitypidDescending = "rngmultitypid DESC",
rngcollationDescending = "rngcollation DESC",
rngsubopcDescending = "rngsubopc DESC",
rngcanonicalDescending = "rngcanonical DESC",
rngsubdiffDescending = "rngsubdiff DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Rngtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngtypid" as FieldNamesType,
},
Rngsubtype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngsubtype" as FieldNamesType,
},
Rngmultitypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngmultitypid" as FieldNamesType,
},
Rngcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngcollation" as FieldNamesType,
},
Rngsubopc: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngsubopc" as FieldNamesType,
},
Rngcanonical: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "rngcanonical" as FieldNamesType,
},
Rngsubdiff: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "rngsubdiff" as FieldNamesType,
},
}
export const ColumnNames = ["Rngtypid","Rngsubtype","Rngmultitypid","Rngcollation","Rngsubopc","Rngcanonical","Rngsubdiff"] as const;
export const FieldNames = ["rngtypid","rngsubtype","rngmultitypid","rngcollation","rngsubopc","rngcanonical","rngsubdiff"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgRangeRngtypidIndex;
}
export namespace PgTransform {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTransform> {
 return { oid: undefined,trftype: undefined,trflang: undefined,trffromsql: undefined,trftosql: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTransform,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTransform,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
trftypeAscending = "trftype ASC",
trflangAscending = "trflang ASC",
trffromsqlAscending = "trffromsql ASC",
trftosqlAscending = "trftosql ASC",
oidDescending = "oid DESC",
trftypeDescending = "trftype DESC",
trflangDescending = "trflang DESC",
trffromsqlDescending = "trffromsql DESC",
trftosqlDescending = "trftosql DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Trftype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "trftype" as FieldNamesType,
},
Trflang: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "trflang" as FieldNamesType,
},
Trffromsql: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "trffromsql" as FieldNamesType,
},
Trftosql: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "trftosql" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Trftype","Trflang","Trffromsql","Trftosql"] as const;
export const FieldNames = ["oid","trftype","trflang","trffromsql","trftosql"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTransformOidIndex;
}
export namespace PgSequence {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSequence> {
 return { seqrelid: undefined,seqtypid: undefined,seqstart: undefined,seqincrement: undefined,seqmax: undefined,seqmin: undefined,seqcache: undefined,seqcycle: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSequence,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSequence,  PrimaryKey>
export enum SortOptions  {
seqrelidAscending = "seqrelid ASC",
seqtypidAscending = "seqtypid ASC",
seqstartAscending = "seqstart ASC",
seqincrementAscending = "seqincrement ASC",
seqmaxAscending = "seqmax ASC",
seqminAscending = "seqmin ASC",
seqcacheAscending = "seqcache ASC",
seqcycleAscending = "seqcycle ASC",
seqrelidDescending = "seqrelid DESC",
seqtypidDescending = "seqtypid DESC",
seqstartDescending = "seqstart DESC",
seqincrementDescending = "seqincrement DESC",
seqmaxDescending = "seqmax DESC",
seqminDescending = "seqmin DESC",
seqcacheDescending = "seqcache DESC",
seqcycleDescending = "seqcycle DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Seqrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "seqrelid" as FieldNamesType,
},
Seqtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "seqtypid" as FieldNamesType,
},
Seqstart: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqstart" as FieldNamesType,
},
Seqincrement: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqincrement" as FieldNamesType,
},
Seqmax: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqmax" as FieldNamesType,
},
Seqmin: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqmin" as FieldNamesType,
},
Seqcache: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqcache" as FieldNamesType,
},
Seqcycle: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "seqcycle" as FieldNamesType,
},
}
export const ColumnNames = ["Seqrelid","Seqtypid","Seqstart","Seqincrement","Seqmax","Seqmin","Seqcache","Seqcycle"] as const;
export const FieldNames = ["seqrelid","seqtypid","seqstart","seqincrement","seqmax","seqmin","seqcache","seqcycle"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSequenceSeqrelidIndex;
}
export namespace PgPublication {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublication> {
 return { oid: undefined,pubname: undefined,pubowner: undefined,puballtables: undefined,pubinsert: undefined,pubupdate: undefined,pubdelete: undefined,pubtruncate: undefined,pubviaroot: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublication,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublication,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pubnameAscending = "pubname ASC",
pubownerAscending = "pubowner ASC",
puballtablesAscending = "puballtables ASC",
pubinsertAscending = "pubinsert ASC",
pubupdateAscending = "pubupdate ASC",
pubdeleteAscending = "pubdelete ASC",
pubtruncateAscending = "pubtruncate ASC",
pubviarootAscending = "pubviaroot ASC",
oidDescending = "oid DESC",
pubnameDescending = "pubname DESC",
pubownerDescending = "pubowner DESC",
puballtablesDescending = "puballtables DESC",
pubinsertDescending = "pubinsert DESC",
pubupdateDescending = "pubupdate DESC",
pubdeleteDescending = "pubdelete DESC",
pubtruncateDescending = "pubtruncate DESC",
pubviarootDescending = "pubviaroot DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Pubname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "pubname" as FieldNamesType,
},
Pubowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pubowner" as FieldNamesType,
},
Puballtables: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "puballtables" as FieldNamesType,
},
Pubinsert: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubinsert" as FieldNamesType,
},
Pubupdate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubupdate" as FieldNamesType,
},
Pubdelete: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubdelete" as FieldNamesType,
},
Pubtruncate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubtruncate" as FieldNamesType,
},
Pubviaroot: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubviaroot" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Pubname","Pubowner","Puballtables","Pubinsert","Pubupdate","Pubdelete","Pubtruncate","Pubviaroot"] as const;
export const FieldNames = ["oid","pubname","pubowner","puballtables","pubinsert","pubupdate","pubdelete","pubtruncate","pubviaroot"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationOidIndex;
}
export namespace PgPublicationNamespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublicationNamespace> {
 return { oid: undefined,pnpubid: undefined,pnnspid: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublicationNamespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublicationNamespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pnpubidAscending = "pnpubid ASC",
pnnspidAscending = "pnnspid ASC",
oidDescending = "oid DESC",
pnpubidDescending = "pnpubid DESC",
pnnspidDescending = "pnnspid DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Pnpubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pnpubid" as FieldNamesType,
},
Pnnspid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pnnspid" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Pnpubid","Pnnspid"] as const;
export const FieldNames = ["oid","pnpubid","pnnspid"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationNamespaceOidIndex;
}
export namespace PgPublicationRel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublicationRel> {
 return { oid: undefined,prpubid: undefined,prrelid: undefined,prqual: undefined,prattrs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublicationRel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublicationRel,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
prpubidAscending = "prpubid ASC",
prrelidAscending = "prrelid ASC",
prqualAscending = "prqual ASC",
prattrsAscending = "prattrs ASC",
oidDescending = "oid DESC",
prpubidDescending = "prpubid DESC",
prrelidDescending = "prrelid DESC",
prqualDescending = "prqual DESC",
prattrsDescending = "prattrs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Prpubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prpubid" as FieldNamesType,
},
Prrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prrelid" as FieldNamesType,
},
Prqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "prqual" as FieldNamesType,
},
Prattrs: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "prattrs" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Prpubid","Prrelid","Prqual","Prattrs"] as const;
export const FieldNames = ["oid","prpubid","prrelid","prqual","prattrs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationRelOidIndex;
}
export namespace PgSubscriptionRel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSubscriptionRel> {
 return { srsubid: undefined,srrelid: undefined,srsubstate: undefined,srsublsn: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSubscriptionRel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSubscriptionRel,  PrimaryKey>
export enum SortOptions  {
srsubidAscending = "srsubid ASC",
srrelidAscending = "srrelid ASC",
srsubstateAscending = "srsubstate ASC",
srsublsnAscending = "srsublsn ASC",
srsubidDescending = "srsubid DESC",
srrelidDescending = "srrelid DESC",
srsubstateDescending = "srsubstate DESC",
srsublsnDescending = "srsublsn DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Srsubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srsubid" as FieldNamesType,
},
Srrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srrelid" as FieldNamesType,
},
Srsubstate: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "srsubstate" as FieldNamesType,
},
Srsublsn: {
 typeName: "PgCatalog.Types.PgLsn",
 fieldName: "srsublsn" as FieldNamesType,
},
}
export const ColumnNames = ["Srsubid","Srrelid","Srsubstate","Srsublsn"] as const;
export const FieldNames = ["srsubid","srrelid","srsubstate","srsublsn"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex;
}
export namespace PgLargeobject {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLargeobject> {
 return { loid: undefined,pageno: undefined,data: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLargeobject,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLargeobject,  PrimaryKey>
export enum SortOptions  {
loidAscending = "loid ASC",
pagenoAscending = "pageno ASC",
dataAscending = "data ASC",
loidDescending = "loid DESC",
pagenoDescending = "pageno DESC",
dataDescending = "data DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Loid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "loid" as FieldNamesType,
},
Pageno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "pageno" as FieldNamesType,
},
Data: {
 typeName: "PgCatalog.Types.Bytea",
 fieldName: "data" as FieldNamesType,
},
}
export const ColumnNames = ["Loid","Pageno","Data"] as const;
export const FieldNames = ["loid","pageno","data"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLargeobjectLoidPnIndex;
}
}
}
export namespace InformationSchema {
export namespace Types {

export type CardinalNumber = PgCatalog.Types.Int4;

export type CardinalNumberArray = 
     Array<InformationSchema.Types.CardinalNumber>
    ;

export type CharacterData = PgCatalog.Types.Varchar;

export type CharacterDataArray = 
     Array<InformationSchema.Types.CharacterData>
    ;

export type SqlIdentifier = PgCatalog.Types.Name;

export type SqlIdentifierArray = 
     Array<InformationSchema.Types.SqlIdentifier>
    ;

export type InformationSchemaCatalogName = {
catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type InformationSchemaCatalogNameArray = 
     Array<InformationSchema.Types.InformationSchemaCatalogName>
    ;

export type TimeStamp = PgCatalog.Types.Timestamptz;

export type TimeStampArray = 
     Array<InformationSchema.Types.TimeStamp>
    ;

export type YesOrNo = PgCatalog.Types.Varchar;

export type YesOrNoArray = 
     Array<InformationSchema.Types.YesOrNo>
    ;

export type ApplicableRoles = {
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ApplicableRolesArray = 
     Array<InformationSchema.Types.ApplicableRoles>
    ;

export type AdministrableRoleAuthorizations = {
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type AdministrableRoleAuthorizationsArray = 
     Array<InformationSchema.Types.AdministrableRoleAuthorizations>
    ;

export type Attributes = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
attributeDefault: Nullable<InformationSchema.Types.CharacterData>;
isNullable: Nullable<InformationSchema.Types.YesOrNo>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
attributeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
isDerivedReferenceAttribute: Nullable<InformationSchema.Types.YesOrNo>;
}

export type AttributesArray = 
     Array<InformationSchema.Types.Attributes>
    ;

export type CharacterSets = {
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
characterRepertoire: Nullable<InformationSchema.Types.SqlIdentifier>;
formOfUse: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CharacterSetsArray = 
     Array<InformationSchema.Types.CharacterSets>
    ;

export type CheckConstraintRoutineUsage = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CheckConstraintRoutineUsageArray = 
     Array<InformationSchema.Types.CheckConstraintRoutineUsage>
    ;

export type CheckConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
checkClause: Nullable<InformationSchema.Types.CharacterData>;
}

export type CheckConstraintsArray = 
     Array<InformationSchema.Types.CheckConstraints>
    ;

export type Collations = {
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
padAttribute: Nullable<InformationSchema.Types.CharacterData>;
}

export type CollationsArray = 
     Array<InformationSchema.Types.Collations>
    ;

export type CollationCharacterSetApplicability = {
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CollationCharacterSetApplicabilityArray = 
     Array<InformationSchema.Types.CollationCharacterSetApplicability>
    ;

export type ColumnColumnUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
dependentColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnColumnUsageArray = 
     Array<InformationSchema.Types.ColumnColumnUsage>
    ;

export type ColumnDomainUsage = {
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnDomainUsageArray = 
     Array<InformationSchema.Types.ColumnDomainUsage>
    ;

export type ColumnPrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ColumnPrivilegesArray = 
     Array<InformationSchema.Types.ColumnPrivileges>
    ;

export type ColumnUdtUsage = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnUdtUsageArray = 
     Array<InformationSchema.Types.ColumnUdtUsage>
    ;

export type Columns = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
columnDefault: Nullable<InformationSchema.Types.CharacterData>;
isNullable: Nullable<InformationSchema.Types.YesOrNo>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
isSelfReferencing: Nullable<InformationSchema.Types.YesOrNo>;
isIdentity: Nullable<InformationSchema.Types.YesOrNo>;
identityGeneration: Nullable<InformationSchema.Types.CharacterData>;
identityStart: Nullable<InformationSchema.Types.CharacterData>;
identityIncrement: Nullable<InformationSchema.Types.CharacterData>;
identityMaximum: Nullable<InformationSchema.Types.CharacterData>;
identityMinimum: Nullable<InformationSchema.Types.CharacterData>;
identityCycle: Nullable<InformationSchema.Types.YesOrNo>;
isGenerated: Nullable<InformationSchema.Types.CharacterData>;
generationExpression: Nullable<InformationSchema.Types.CharacterData>;
isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ColumnsArray = 
     Array<InformationSchema.Types.Columns>
    ;

export type ConstraintColumnUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ConstraintColumnUsageArray = 
     Array<InformationSchema.Types.ConstraintColumnUsage>
    ;

export type ConstraintTableUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ConstraintTableUsageArray = 
     Array<InformationSchema.Types.ConstraintTableUsage>
    ;

export type DomainConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
}

export type DomainConstraintsArray = 
     Array<InformationSchema.Types.DomainConstraints>
    ;

export type DomainUdtUsage = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DomainUdtUsageArray = 
     Array<InformationSchema.Types.DomainUdtUsage>
    ;

export type Domains = {
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
domainDefault: Nullable<InformationSchema.Types.CharacterData>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DomainsArray = 
     Array<InformationSchema.Types.Domains>
    ;

export type EnabledRoles = {
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type EnabledRolesArray = 
     Array<InformationSchema.Types.EnabledRoles>
    ;

export type KeyColumnUsage = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
positionInUniqueConstraint: Nullable<InformationSchema.Types.CardinalNumber>;
}

export type KeyColumnUsageArray = 
     Array<InformationSchema.Types.KeyColumnUsage>
    ;

export type Parameters = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
parameterMode: Nullable<InformationSchema.Types.CharacterData>;
isResult: Nullable<InformationSchema.Types.YesOrNo>;
asLocator: Nullable<InformationSchema.Types.YesOrNo>;
parameterName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
parameterDefault: Nullable<InformationSchema.Types.CharacterData>;
}

export type ParametersArray = 
     Array<InformationSchema.Types.Parameters>
    ;

export type ReferentialConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
matchOption: Nullable<InformationSchema.Types.CharacterData>;
updateRule: Nullable<InformationSchema.Types.CharacterData>;
deleteRule: Nullable<InformationSchema.Types.CharacterData>;
}

export type ReferentialConstraintsArray = 
     Array<InformationSchema.Types.ReferentialConstraints>
    ;

export type RoleColumnGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleColumnGrantsArray = 
     Array<InformationSchema.Types.RoleColumnGrants>
    ;

export type RoutineColumnUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineColumnUsageArray = 
     Array<InformationSchema.Types.RoutineColumnUsage>
    ;

export type RoutinePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoutinePrivilegesArray = 
     Array<InformationSchema.Types.RoutinePrivileges>
    ;

export type RoleRoutineGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleRoutineGrantsArray = 
     Array<InformationSchema.Types.RoleRoutineGrants>
    ;

export type RoutineRoutineUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineRoutineUsageArray = 
     Array<InformationSchema.Types.RoutineRoutineUsage>
    ;

export type RoutineSequenceUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineSequenceUsageArray = 
     Array<InformationSchema.Types.RoutineSequenceUsage>
    ;

export type RoutineTableUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineTableUsageArray = 
     Array<InformationSchema.Types.RoutineTableUsage>
    ;

export type Routines = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineType: Nullable<InformationSchema.Types.CharacterData>;
moduleCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
moduleSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
moduleName: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
typeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
typeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
typeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
routineBody: Nullable<InformationSchema.Types.CharacterData>;
routineDefinition: Nullable<InformationSchema.Types.CharacterData>;
externalName: Nullable<InformationSchema.Types.CharacterData>;
externalLanguage: Nullable<InformationSchema.Types.CharacterData>;
parameterStyle: Nullable<InformationSchema.Types.CharacterData>;
isDeterministic: Nullable<InformationSchema.Types.YesOrNo>;
sqlDataAccess: Nullable<InformationSchema.Types.CharacterData>;
isNullCall: Nullable<InformationSchema.Types.YesOrNo>;
sqlPath: Nullable<InformationSchema.Types.CharacterData>;
schemaLevelRoutine: Nullable<InformationSchema.Types.YesOrNo>;
maxDynamicResultSets: Nullable<InformationSchema.Types.CardinalNumber>;
isUserDefinedCast: Nullable<InformationSchema.Types.YesOrNo>;
isImplicitlyInvocable: Nullable<InformationSchema.Types.YesOrNo>;
securityType: Nullable<InformationSchema.Types.CharacterData>;
toSqlSpecificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
toSqlSpecificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
toSqlSpecificName: Nullable<InformationSchema.Types.SqlIdentifier>;
asLocator: Nullable<InformationSchema.Types.YesOrNo>;
created: Nullable<InformationSchema.Types.TimeStamp>;
lastAltered: Nullable<InformationSchema.Types.TimeStamp>;
newSavepointLevel: Nullable<InformationSchema.Types.YesOrNo>;
isUdtDependent: Nullable<InformationSchema.Types.YesOrNo>;
resultCastFromDataType: Nullable<InformationSchema.Types.CharacterData>;
resultCastAsLocator: Nullable<InformationSchema.Types.YesOrNo>;
resultCastCharMaxLength: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastCharOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastCharSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCharSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCharSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastNumericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastNumericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastNumericScale: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastDatetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastIntervalType: Nullable<InformationSchema.Types.CharacterData>;
resultCastIntervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastTypeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastTypeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastTypeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastMaximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutinesArray = 
     Array<InformationSchema.Types.Routines>
    ;

export type Schemata = {
catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
schemaName: Nullable<InformationSchema.Types.SqlIdentifier>;
schemaOwner: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
sqlPath: Nullable<InformationSchema.Types.CharacterData>;
}

export type SchemataArray = 
     Array<InformationSchema.Types.Schemata>
    ;

export type Sequences = {
sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
startValue: Nullable<InformationSchema.Types.CharacterData>;
minimumValue: Nullable<InformationSchema.Types.CharacterData>;
maximumValue: Nullable<InformationSchema.Types.CharacterData>;
increment: Nullable<InformationSchema.Types.CharacterData>;
cycleOption: Nullable<InformationSchema.Types.YesOrNo>;
}

export type SequencesArray = 
     Array<InformationSchema.Types.Sequences>
    ;

export type SqlFeatures = {
featureId: Nullable<InformationSchema.Types.CharacterData>;
featureName: Nullable<InformationSchema.Types.CharacterData>;
subFeatureId: Nullable<InformationSchema.Types.CharacterData>;
subFeatureName: Nullable<InformationSchema.Types.CharacterData>;
isSupported: Nullable<InformationSchema.Types.YesOrNo>;
isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlFeaturesArray = 
     Array<InformationSchema.Types.SqlFeatures>
    ;

export type SqlImplementationInfo = {
implementationInfoId: Nullable<InformationSchema.Types.CharacterData>;
implementationInfoName: Nullable<InformationSchema.Types.CharacterData>;
integerValue: Nullable<InformationSchema.Types.CardinalNumber>;
characterValue: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlImplementationInfoArray = 
     Array<InformationSchema.Types.SqlImplementationInfo>
    ;

export type SqlParts = {
featureId: Nullable<InformationSchema.Types.CharacterData>;
featureName: Nullable<InformationSchema.Types.CharacterData>;
isSupported: Nullable<InformationSchema.Types.YesOrNo>;
isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlPartsArray = 
     Array<InformationSchema.Types.SqlParts>
    ;

export type SqlSizing = {
sizingId: Nullable<InformationSchema.Types.CardinalNumber>;
sizingName: Nullable<InformationSchema.Types.CharacterData>;
supportedValue: Nullable<InformationSchema.Types.CardinalNumber>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlSizingArray = 
     Array<InformationSchema.Types.SqlSizing>
    ;

export type TableConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintType: Nullable<InformationSchema.Types.CharacterData>;
isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
enforced: Nullable<InformationSchema.Types.YesOrNo>;
nullsDistinct: Nullable<InformationSchema.Types.YesOrNo>;
}

export type TableConstraintsArray = 
     Array<InformationSchema.Types.TableConstraints>
    ;

export type TablePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
}

export type TablePrivilegesArray = 
     Array<InformationSchema.Types.TablePrivileges>
    ;

export type RoleTableGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleTableGrantsArray = 
     Array<InformationSchema.Types.RoleTableGrants>
    ;

export type Tables = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableType: Nullable<InformationSchema.Types.CharacterData>;
selfReferencingColumnName: Nullable<InformationSchema.Types.SqlIdentifier>;
referenceGeneration: Nullable<InformationSchema.Types.CharacterData>;
userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
isTyped: Nullable<InformationSchema.Types.YesOrNo>;
commitAction: Nullable<InformationSchema.Types.CharacterData>;
}

export type TablesArray = 
     Array<InformationSchema.Types.Tables>
    ;

export type Transforms = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
groupName: Nullable<InformationSchema.Types.SqlIdentifier>;
transformType: Nullable<InformationSchema.Types.CharacterData>;
}

export type TransformsArray = 
     Array<InformationSchema.Types.Transforms>
    ;

export type TriggeredUpdateColumns = {
triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type TriggeredUpdateColumnsArray = 
     Array<InformationSchema.Types.TriggeredUpdateColumns>
    ;

export type Triggers = {
triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
eventManipulation: Nullable<InformationSchema.Types.CharacterData>;
eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionOrder: Nullable<InformationSchema.Types.CardinalNumber>;
actionCondition: Nullable<InformationSchema.Types.CharacterData>;
actionStatement: Nullable<InformationSchema.Types.CharacterData>;
actionOrientation: Nullable<InformationSchema.Types.CharacterData>;
actionTiming: Nullable<InformationSchema.Types.CharacterData>;
actionReferenceOldTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceNewTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceOldRow: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceNewRow: Nullable<InformationSchema.Types.SqlIdentifier>;
created: Nullable<InformationSchema.Types.TimeStamp>;
}

export type TriggersArray = 
     Array<InformationSchema.Types.Triggers>
    ;

export type UdtPrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type UdtPrivilegesArray = 
     Array<InformationSchema.Types.UdtPrivileges>
    ;

export type RoleUdtGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleUdtGrantsArray = 
     Array<InformationSchema.Types.RoleUdtGrants>
    ;

export type UsagePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type UsagePrivilegesArray = 
     Array<InformationSchema.Types.UsagePrivileges>
    ;

export type RoleUsageGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleUsageGrantsArray = 
     Array<InformationSchema.Types.RoleUsageGrants>
    ;

export type UserDefinedTypes = {
userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeCategory: Nullable<InformationSchema.Types.CharacterData>;
isInstantiable: Nullable<InformationSchema.Types.YesOrNo>;
isFinal: Nullable<InformationSchema.Types.YesOrNo>;
orderingForm: Nullable<InformationSchema.Types.CharacterData>;
orderingCategory: Nullable<InformationSchema.Types.CharacterData>;
orderingRoutineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
orderingRoutineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
orderingRoutineName: Nullable<InformationSchema.Types.SqlIdentifier>;
referenceType: Nullable<InformationSchema.Types.CharacterData>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
sourceDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
refDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserDefinedTypesArray = 
     Array<InformationSchema.Types.UserDefinedTypes>
    ;

export type ViewColumnUsage = {
viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewColumnUsageArray = 
     Array<InformationSchema.Types.ViewColumnUsage>
    ;

export type ViewRoutineUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewRoutineUsageArray = 
     Array<InformationSchema.Types.ViewRoutineUsage>
    ;

export type ViewTableUsage = {
viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewTableUsageArray = 
     Array<InformationSchema.Types.ViewTableUsage>
    ;

export type Views = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
viewDefinition: Nullable<InformationSchema.Types.CharacterData>;
checkOption: Nullable<InformationSchema.Types.CharacterData>;
isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerDeletable: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ViewsArray = 
     Array<InformationSchema.Types.Views>
    ;

export type DataTypePrivileges = {
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DataTypePrivilegesArray = 
     Array<InformationSchema.Types.DataTypePrivileges>
    ;

export type ElementTypes = {
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
collectionTypeIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
domainDefault: Nullable<InformationSchema.Types.CharacterData>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ElementTypesArray = 
     Array<InformationSchema.Types.ElementTypes>
    ;

export type PgForeignTableColumns = {
nspname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
attname: Nullable<PgCatalog.Types.Name>;
attfdwoptions: PgCatalog.Types.TextArray;
}

export type ColumnOptions = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ColumnOptionsArray = 
     Array<InformationSchema.Types.ColumnOptions>
    ;

export type PgForeignDataWrappers = {
oid: Nullable<PgCatalog.Types.Oid>;
fdwowner: Nullable<PgCatalog.Types.Oid>;
fdwoptions: PgCatalog.Types.TextArray;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrapperOptions = {
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrapperOptionsArray = 
     Array<InformationSchema.Types.ForeignDataWrapperOptions>
    ;

export type ForeignDataWrappers = {
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
libraryName: Nullable<InformationSchema.Types.CharacterData>;
foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrappersArray = 
     Array<InformationSchema.Types.ForeignDataWrappers>
    ;

export type PgForeignServers = {
oid: Nullable<PgCatalog.Types.Oid>;
srvoptions: PgCatalog.Types.TextArray;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignServerOptions = {
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignServerOptionsArray = 
     Array<InformationSchema.Types.ForeignServerOptions>
    ;

export type ForeignServers = {
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignServersArray = 
     Array<InformationSchema.Types.ForeignServers>
    ;

export type PgForeignTables = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
ftoptions: PgCatalog.Types.TextArray;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignTableOptions = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignTableOptionsArray = 
     Array<InformationSchema.Types.ForeignTableOptions>
    ;

export type ForeignTables = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignTablesArray = 
     Array<InformationSchema.Types.ForeignTables>
    ;

export type PgUserMappings = {
oid: Nullable<PgCatalog.Types.Oid>;
umoptions: PgCatalog.Types.TextArray;
umuser: Nullable<PgCatalog.Types.Oid>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
srvowner: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserMappingOptions = {
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type UserMappingOptionsArray = 
     Array<InformationSchema.Types.UserMappingOptions>
    ;

export type UserMappings = {
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserMappingsArray = 
     Array<InformationSchema.Types.UserMappings>
    ;
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlFeatures> {
 return { featureId: undefined,featureName: undefined,subFeatureId: undefined,subFeatureName: undefined,isSupported: undefined,isVerifiedBy: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlFeatures,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlFeatures,  PrimaryKey>
export enum SortOptions  {
featureIdAscending = "feature_id ASC",
featureNameAscending = "feature_name ASC",
subFeatureIdAscending = "sub_feature_id ASC",
subFeatureNameAscending = "sub_feature_name ASC",
isSupportedAscending = "is_supported ASC",
isVerifiedByAscending = "is_verified_by ASC",
commentsAscending = "comments ASC",
featureIdDescending = "feature_id DESC",
featureNameDescending = "feature_name DESC",
subFeatureIdDescending = "sub_feature_id DESC",
subFeatureNameDescending = "sub_feature_name DESC",
isSupportedDescending = "is_supported DESC",
isVerifiedByDescending = "is_verified_by DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
FeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureId" as FieldNamesType,
},
FeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureName" as FieldNamesType,
},
SubFeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "subFeatureId" as FieldNamesType,
},
SubFeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "subFeatureName" as FieldNamesType,
},
IsSupported: {
 typeName: "InformationSchema.Types.YesOrNo",
 fieldName: "isSupported" as FieldNamesType,
},
IsVerifiedBy: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "isVerifiedBy" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["FeatureId","FeatureName","SubFeatureId","SubFeatureName","IsSupported","IsVerifiedBy","Comments"] as const;
export const FieldNames = ["featureId","featureName","subFeatureId","subFeatureName","isSupported","isVerifiedBy","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlImplementationInfo {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlImplementationInfo> {
 return { implementationInfoId: undefined,implementationInfoName: undefined,integerValue: undefined,characterValue: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlImplementationInfo,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlImplementationInfo,  PrimaryKey>
export enum SortOptions  {
implementationInfoIdAscending = "implementation_info_id ASC",
implementationInfoNameAscending = "implementation_info_name ASC",
integerValueAscending = "integer_value ASC",
characterValueAscending = "character_value ASC",
commentsAscending = "comments ASC",
implementationInfoIdDescending = "implementation_info_id DESC",
implementationInfoNameDescending = "implementation_info_name DESC",
integerValueDescending = "integer_value DESC",
characterValueDescending = "character_value DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
ImplementationInfoId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "implementationInfoId" as FieldNamesType,
},
ImplementationInfoName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "implementationInfoName" as FieldNamesType,
},
IntegerValue: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "integerValue" as FieldNamesType,
},
CharacterValue: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "characterValue" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["ImplementationInfoId","ImplementationInfoName","IntegerValue","CharacterValue","Comments"] as const;
export const FieldNames = ["implementationInfoId","implementationInfoName","integerValue","characterValue","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlParts {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlParts> {
 return { featureId: undefined,featureName: undefined,isSupported: undefined,isVerifiedBy: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlParts,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlParts,  PrimaryKey>
export enum SortOptions  {
featureIdAscending = "feature_id ASC",
featureNameAscending = "feature_name ASC",
isSupportedAscending = "is_supported ASC",
isVerifiedByAscending = "is_verified_by ASC",
commentsAscending = "comments ASC",
featureIdDescending = "feature_id DESC",
featureNameDescending = "feature_name DESC",
isSupportedDescending = "is_supported DESC",
isVerifiedByDescending = "is_verified_by DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
FeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureId" as FieldNamesType,
},
FeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureName" as FieldNamesType,
},
IsSupported: {
 typeName: "InformationSchema.Types.YesOrNo",
 fieldName: "isSupported" as FieldNamesType,
},
IsVerifiedBy: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "isVerifiedBy" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["FeatureId","FeatureName","IsSupported","IsVerifiedBy","Comments"] as const;
export const FieldNames = ["featureId","featureName","isSupported","isVerifiedBy","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlSizing {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlSizing> {
 return { sizingId: undefined,sizingName: undefined,supportedValue: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlSizing,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlSizing,  PrimaryKey>
export enum SortOptions  {
sizingIdAscending = "sizing_id ASC",
sizingNameAscending = "sizing_name ASC",
supportedValueAscending = "supported_value ASC",
commentsAscending = "comments ASC",
sizingIdDescending = "sizing_id DESC",
sizingNameDescending = "sizing_name DESC",
supportedValueDescending = "supported_value DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
SizingId: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "sizingId" as FieldNamesType,
},
SizingName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "sizingName" as FieldNamesType,
},
SupportedValue: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "supportedValue" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["SizingId","SizingName","SupportedValue","Comments"] as const;
export const FieldNames = ["sizingId","sizingName","supportedValue","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
}
}
export namespace Public {
export namespace Types {

/**
 * FIXME: spheroid did not resolve to a base type
 */
export type Spheroid = string;

export type SpheroidArray = 
     Array<Public.Types.Spheroid>
    ;

/**
 * FIXME: geometry did not resolve to a base type
 */
export type Geometry = string;

export type GeometryArray = 
     Array<Public.Types.Geometry>
    ;

/**
 * FIXME: box3d did not resolve to a base type
 */
export type Box3d = string;

export type Box3dArray = 
     Array<Public.Types.Box3d>
    ;

/**
 * FIXME: box2d did not resolve to a base type
 */
export type Box2d = string;

export type Box2dArray = 
     Array<Public.Types.Box2d>
    ;

/**
 * FIXME: box2df did not resolve to a base type
 */
export type Box2df = string;

export type Box2dfArray = 
     Array<Public.Types.Box2df>
    ;

/**
 * FIXME: gidx did not resolve to a base type
 */
export type Gidx = string;

export type GidxArray = 
     Array<Public.Types.Gidx>
    ;

export type GeometryDump = {
path: PgCatalog.Types.Int4Array;
geom: Nullable<Public.Types.Geometry>;
}

export type GeometryDumpArray = 
     Array<Public.Types.GeometryDump>
    ;

export type SpatialRefSys = {
srid: PgCatalog.Types.Int4;
authName: Nullable<PgCatalog.Types.Varchar>;
authSrid: Nullable<PgCatalog.Types.Int4>;
srtext: Nullable<PgCatalog.Types.Varchar>;
proj4text: Nullable<PgCatalog.Types.Varchar>;
}

export type SpatialRefSysArray = 
     Array<Public.Types.SpatialRefSys>
    ;

export type ValidDetail = {
valid: Nullable<PgCatalog.Types.Bool>;
reason: Nullable<PgCatalog.Types.Varchar>;
location: Nullable<Public.Types.Geometry>;
}

export type ValidDetailArray = 
     Array<Public.Types.ValidDetail>
    ;

/**
 * FIXME: geography did not resolve to a base type
 */
export type Geography = string;

export type GeographyArray = 
     Array<Public.Types.Geography>
    ;

export type GeographyColumns = {
fTableCatalog: Nullable<PgCatalog.Types.Name>;
fTableSchema: Nullable<PgCatalog.Types.Name>;
fTableName: Nullable<PgCatalog.Types.Name>;
fGeographyColumn: Nullable<PgCatalog.Types.Name>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
srid: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Text>;
}

export type GeographyColumnsArray = 
     Array<Public.Types.GeographyColumns>
    ;

export type GeometryColumns = {
fTableCatalog: Nullable<PgCatalog.Types.Varchar>;
fTableSchema: Nullable<PgCatalog.Types.Name>;
fTableName: Nullable<PgCatalog.Types.Name>;
fGeometryColumn: Nullable<PgCatalog.Types.Name>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
srid: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Varchar>;
}

export type GeometryColumnsArray = 
     Array<Public.Types.GeometryColumns>
    ;

export type NycCensusBlocks = {
gid: PgCatalog.Types.Int4;
blkid: Nullable<PgCatalog.Types.Varchar>;
popnTotal: Nullable<PgCatalog.Types.Float8>;
popnWhite: Nullable<PgCatalog.Types.Float8>;
popnBlack: Nullable<PgCatalog.Types.Float8>;
popnNativ: Nullable<PgCatalog.Types.Float8>;
popnAsian: Nullable<PgCatalog.Types.Float8>;
popnOther: Nullable<PgCatalog.Types.Float8>;
boroname: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycCensusBlocksArray = 
     Array<Public.Types.NycCensusBlocks>
    ;

export type NycHomicides = {
gid: PgCatalog.Types.Int4;
incidentD: Nullable<PgCatalog.Types.Date>;
boroname: Nullable<PgCatalog.Types.Varchar>;
numVictim: Nullable<PgCatalog.Types.Varchar>;
primaryMo: Nullable<PgCatalog.Types.Varchar>;
id: Nullable<PgCatalog.Types.Float8>;
weapon: Nullable<PgCatalog.Types.Varchar>;
lightDark: Nullable<PgCatalog.Types.Varchar>;
year: Nullable<PgCatalog.Types.Float8>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycHomicidesArray = 
     Array<Public.Types.NycHomicides>
    ;

export type NycNeighborhoods = {
gid: PgCatalog.Types.Int4;
boroname: Nullable<PgCatalog.Types.Varchar>;
name: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycNeighborhoodsArray = 
     Array<Public.Types.NycNeighborhoods>
    ;

export type NycStreets = {
gid: PgCatalog.Types.Int4;
id: Nullable<PgCatalog.Types.Float8>;
name: Nullable<PgCatalog.Types.Varchar>;
oneway: Nullable<PgCatalog.Types.Varchar>;
type: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycStreetsArray = 
     Array<Public.Types.NycStreets>
    ;

export type NycSubwayStations = {
gid: PgCatalog.Types.Int4;
objectid: Nullable<PgCatalog.Types.Numeric>;
id: Nullable<PgCatalog.Types.Numeric>;
name: Nullable<PgCatalog.Types.Varchar>;
altName: Nullable<PgCatalog.Types.Varchar>;
crossSt: Nullable<PgCatalog.Types.Varchar>;
longName: Nullable<PgCatalog.Types.Varchar>;
label: Nullable<PgCatalog.Types.Varchar>;
borough: Nullable<PgCatalog.Types.Varchar>;
nghbhd: Nullable<PgCatalog.Types.Varchar>;
routes: Nullable<PgCatalog.Types.Varchar>;
transfers: Nullable<PgCatalog.Types.Varchar>;
color: Nullable<PgCatalog.Types.Varchar>;
express: Nullable<PgCatalog.Types.Varchar>;
closed: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycSubwayStationsArray = 
     Array<Public.Types.NycSubwayStations>
    ;

export type SpatialRefSysPkey = {
srid: PgCatalog.Types.Int4;
}

export type NycCensusBlocksPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycHomicidesPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycNeighborhoodsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycStreetsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycSubwayStationsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycCensusBlocksGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycHomicidesGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycNeighborhoodsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycStreetsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycSubwayStationsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type PostgisSrs = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type PostgisSrsAll = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type PostgisSrsSearch = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type StMinimumboundingradius = {
center: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StMaximuminscribedcircle = {
center: Nullable<Public.Types.Geometry>;
nearest: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StLargestemptycircle = {
center: Nullable<Public.Types.Geometry>;
nearest: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StHexagongrid = {
geom: Nullable<Public.Types.Geometry>;
i: Nullable<PgCatalog.Types.Int4>;
j: Nullable<PgCatalog.Types.Int4>;
}

export type StSquaregrid = {
geom: Nullable<Public.Types.Geometry>;
i: Nullable<PgCatalog.Types.Int4>;
j: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Procedures {
export namespace StForcepolygoncw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace SpheroidIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace SpheroidOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Spheroid>;
}
}
export namespace GeometryIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace GeometryOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryTypmodIn {


export type Parameters = {
argument_0: PgCatalog.Types.CstringArray;
}
}
export namespace GeometryTypmodOut {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryAnalyze {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryRecv {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySend {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Geometry_4946 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Geometry_8997 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Point>;
}
}
export namespace Point {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryB0d8 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Path>;
}
}
export namespace Path {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryF1be {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Polygon>;
}
}
export namespace Polygon {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StX {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StY {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StZ {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StM {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3dIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box3dOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Box2dIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box2dOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Box2dfIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box2dfOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
}
}
export namespace GidxIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace GidxOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
}
}
export namespace GeometryLt {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryLe {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGt {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGe {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryEq {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryCmp {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySortsupport {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryHash {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistDistance_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistCompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPenalty_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPicksplit_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistUnion_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSame_2d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistDecompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSortsupport_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StForcerhr {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisNoop {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcepolygonccw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GserializedGistSel_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GserializedGistSelNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GserializedGistJoinsel_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int2>;
}
}
export namespace GserializedGistJoinselNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int2>;
}
}
export namespace GeometryOverlaps {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySame {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCentroid {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceBox {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContains {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryWithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryLeft {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverleft {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryBelow {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverbelow {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverright {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryRight {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverabove {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryAbove {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPenaltyNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistUnionNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSameNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistDecompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryOverlapsNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContainsNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryWithinNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySameNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCentroidNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCpa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistDistanceNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StShiftlongitude {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StWrapx {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
wrap: Nullable<PgCatalog.Types.Float8>;
move: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StXmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StYmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StZmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StXmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StYmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StZmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StExpand_3044 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpand_3ea7 {


export type Parameters = {
box: Nullable<Public.Types.Box2d>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PostgisGetbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakebox2d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StEstimatedextentD2f5 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StEstimatedextent_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StEstimatedextent_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StFindextent_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StFindextent_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisAddbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisDropbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisHasbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StQuantizecoordinates {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
precX: Nullable<PgCatalog.Types.Int4>;
precY: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMemsize {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSummary_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNpoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNrings {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlength {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLength2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLength_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLengthspheroid {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Spheroid>;
}
}
export namespace StLength2dspheroid {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Spheroid>;
}
}
export namespace St_3dperimeter {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPerimeter2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPerimeter_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StArea2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StArea_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIspolygoncw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIspolygonccw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistancespheroid_0cb2 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<Public.Types.Spheroid>;
}
}
export namespace StDistancespheroidEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistanceEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointinsidecircle {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAzimuthEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StProject_2077 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
azimuth: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StProjectE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAngleA4a1 {


export type Parameters = {
pt1: Nullable<Public.Types.Geometry>;
pt2: Nullable<Public.Types.Geometry>;
pt3: Nullable<Public.Types.Geometry>;
pt4: Nullable<Public.Types.Geometry>;
}
}
export namespace StLineextend {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
distanceForward: Nullable<PgCatalog.Types.Float8>;
distanceBackward: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForce3dz {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce3d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce3dm {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
mvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce4d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
mvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForcecollection {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectionextractEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StCollectionextract_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectionhomogenize {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMulti {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcecurve {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcesfs_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcesfsF1e2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
version: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StExpand_95d4 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpandF49e {


export type Parameters = {
box: Nullable<Public.Types.Box3d>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
dz: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpandDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpandBf72 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
dz: Nullable<PgCatalog.Types.Float8>;
dm: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StEnvelope {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBoundingdiagonal {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fits: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StReverse {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StScroll {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisGeosNoop {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNormalize {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
}
}
export namespace StZmflag {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNdims {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsewkt_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsewktEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAstwkb_8607 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
prec: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
withSizes: Nullable<PgCatalog.Types.Bool>;
withBoxes: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAstwkb_1445 {


export type Parameters = {
geom: Public.Types.GeometryArray;
ids: PgCatalog.Types.Int8Array;
prec: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
withSizes: Nullable<PgCatalog.Types.Bool>;
withBoxes: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAsewkb_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAshexewkb_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAshexewkbF1e2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsewkbF1e2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAslatlontext {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tmpl: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geomfromewkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromewkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromtwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Geomfromewkt {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromewkt {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisCacheBbox {

}
export namespace StMakepoint_0aec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepoint_81ec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepoint_570b {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepointm {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3dmakebox {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakelineF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StLinefrommultipoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakelineEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StAddpointEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StScale_2077 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAddpointCc0f {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StRemovepoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSetpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakeenvelope {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTileenvelope {


export type Parameters = {
zoom: Nullable<PgCatalog.Types.Int4>;
x: Nullable<PgCatalog.Types.Int4>;
y: Nullable<PgCatalog.Types.Int4>;
bounds: Nullable<Public.Types.Geometry>;
margin: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepolygon_0543 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Public.Types.GeometryArray;
}
}
export namespace StMakepolygon_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBuildarea {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPolygonizeF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StClusterintersectingF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StClusterwithin_2892 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinemerge_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLinemergeCad2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAffineA659 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
argument_6: Nullable<PgCatalog.Types.Float8>;
argument_7: Nullable<PgCatalog.Types.Float8>;
argument_8: Nullable<PgCatalog.Types.Float8>;
argument_9: Nullable<PgCatalog.Types.Float8>;
argument_10: Nullable<PgCatalog.Types.Float8>;
argument_11: Nullable<PgCatalog.Types.Float8>;
argument_12: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAffine_0997 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
argument_6: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotateDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotate_6aac {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotate_8af1 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<Public.Types.Geometry>;
}
}
export namespace StRotatez {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotatex {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotatey {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTranslate_6aac {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTranslate_2077 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StScaleEb6a {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StScale_8af1 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StScale_6aac {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTransscale {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDump {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumprings {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumppoints {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumpsegments {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PopulateGeometryColumns_23fc {


export type Parameters = {
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PopulateGeometryColumns_4174 {


export type Parameters = {
tblOid: Nullable<PgCatalog.Types.Oid>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_8fbb {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSridIn: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_4617 {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSrid: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_093c {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSrid: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Dropgeometrycolumn_0412 {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace Dropgeometrycolumn_2253 {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace DropgeometrycolumnF11a {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace Dropgeometrytable_2253 {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace StSegmentizeDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace DropgeometrytableF11a {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace DropgeometrytableBfde {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace UpdategeometrysridB2ee {


export type Parameters = {
catalognName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSridIn: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Updategeometrysrid_7b58 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Varchar>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Updategeometrysrid_11c8 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace FindSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace GetProj4FromSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSetsridEd82 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSrid_0faa {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisTransformGeometry {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisSrsCodes {


export type Parameters = {
authName: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisSrs {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisSrsAll {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PostgisSrsSearch {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
bounds: Nullable<Public.Types.Geometry>;
authname: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransformEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTransformF1e2 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
toProj: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransformEfe6 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fromProj: Nullable<PgCatalog.Types.Text>;
toProj: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransform_3ad9 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fromProj: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTransformPipelineGeometry {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
forward: Nullable<PgCatalog.Types.Bool>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTransformpipeline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StInversetransformpipeline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisVersion {

}
export namespace PostgisLiblwgeomVersion {

}
export namespace PostgisProjVersion {

}
export namespace PostgisWagyuVersion {

}
export namespace PostgisScriptsInstalled {

}
export namespace PostgisLibVersion {

}
export namespace PostgisScriptsReleased {

}
export namespace PostgisGeosVersion {

}
export namespace PostgisGeosCompiledVersion {

}
export namespace PostgisLibRevision {

}
export namespace PostgisSvnVersion {

}
export namespace PostgisLibxmlVersion {

}
export namespace PostgisScriptsBuildDate {

}
export namespace PostgisLibBuildDate {

}
export namespace PostgisExtensionsUpgrade {


export type Parameters = {
targetVersion: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLineinterpolatepointDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLineinterpolatepoints_1c13 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
repeat: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLinesubstring_2077 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinelocatepointEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StAddmeasure {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StClosestpointofapproach {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisFullVersion {

}
export namespace Box2d_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3d_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box2d_8784 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Box3dF5fa {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Box_8784 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Text {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3dtobox {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace GeometryF5fa {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Geometry_8784 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace GeometryE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geometry_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Bytea_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSimplifyDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSimplify_1c13 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSimplifyvw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSeteffectivearea {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StFilterbym {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StChaikinsmoothing {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSnaptogridBf72 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogrid_2077 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogridDeb6 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogrid_7713 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDistancecpa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCpawithin {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIsvalidtrajectory {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIntersectionE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBufferDcba {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
options: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StBuffer_3222 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
quadsegs: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMinimumboundingradius {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Radius"] as const;
export const FieldNames = ["center","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumboundingcircle {


export type Parameters = {
inputgeom: Nullable<Public.Types.Geometry>;
segsPerQuarter: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StOrientedenvelope {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StOffsetcurve {


export type Parameters = {
line: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
params: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeneratepointsEd82 {


export type Parameters = {
area: Nullable<Public.Types.Geometry>;
npoints: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeneratepointsA8be {


export type Parameters = {
area: Nullable<Public.Types.Geometry>;
npoints: Nullable<PgCatalog.Types.Int4>;
seed: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StConvexhull {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSimplifypreservetopology {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIsvalidreason_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsvaliddetail {
export const Columns = {
Valid: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "valid" as FieldNamesType,
},
Reason: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "reason" as FieldNamesType,
},
Location: {
 typeName: "Public.Types.Geometry",
 fieldName: "location" as FieldNamesType,
},
}
export const ColumnNames = ["Valid","Reason","Location"] as const;
export const FieldNames = ["valid","reason","location"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StIsvalidreasonEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StIsvalidEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StHausdorffdistanceEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StHausdorffdistanceE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StFrechetdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMaximuminscribedcircle {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Nearest: {
 typeName: "Public.Types.Geometry",
 fieldName: "nearest" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Nearest","Radius"] as const;
export const FieldNames = ["center","nearest","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLargestemptycircle {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Nearest: {
 typeName: "Public.Types.Geometry",
 fieldName: "nearest" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Nearest","Radius"] as const;
export const FieldNames = ["center","nearest","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
boundary: Nullable<Public.Types.Geometry>;
}
}
export namespace StDifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBoundary {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSymdifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSymmetricdifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StUnionEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StUnionE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StUnaryunion {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRemoverepeatedpoints {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StClipbybox2d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
box: Nullable<Public.Types.Box2d>;
}
}
export namespace StSubdivide {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxvertices: Nullable<PgCatalog.Types.Int4>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StReduceprecision {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakevalid_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakevalidF1e2 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
params: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCleangeometry {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSplit {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSharedpaths {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSnap {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRelatematch {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StNode {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
}
}
export namespace StDelaunaytriangles {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTriangulatepolygon {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
}
}
export namespace StVoronoipolygons {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
extendTo: Nullable<Public.Types.Geometry>;
}
}
export namespace StVoronoilines {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
extendTo: Nullable<Public.Types.Geometry>;
}
}
export namespace StCombinebbox_2c84 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCombinebboxEe61 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<Public.Types.Box3d>;
}
}
export namespace StCombinebbox_7c5a {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace PgisGeometryAccumTransfnE941 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisGeometryAccumTransfnDd3f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PgisGeometryAccumTransfn_0a1f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PgisGeometryCollectFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryPolygonizeFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryClusterintersectingFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryClusterwithinFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryMakelineFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryCoverageunionFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelTransfnE941 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisGeometryUnionParallelTransfnDd3f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PgisGeometryUnionParallelCombinefn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelSerialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelDeserialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StUnionF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StCoverageunionF393 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StRelateEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StRelateCc0f {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StRelate_6458 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDisjoint {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisIndexSupportfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StLinecrossingdirection {


export type Parameters = {
line1: Nullable<Public.Types.Geometry>;
line2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDwithinE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTouches {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StIntersectsEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCrosses {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StContains {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StContainsproperly {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StWithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCoversEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCoveredbyEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StOverlaps {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDfullywithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3ddwithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3ddfullywithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3dintersects {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StOrderingequals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StEquals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsvalid_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumclearance {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumclearanceline {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCentroid_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometricmedian {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
maxIter: Nullable<PgCatalog.Types.Int4>;
failIfNotConverged: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StIsring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointonsurface {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIssimple {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIscollection {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Equals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeomfromgml_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromgmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGmltosqlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGmltosql_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromkml {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfrommarc21 {


export type Parameters = {
marc21xml: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsmarc21 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
format: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromgeojsonE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromgeojson_608f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Json>;
}
}
export namespace StGeomfromgeojson_3c9d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Jsonb>;
}
}
export namespace PostgisLibjsonVersion {

}
export namespace StLinefromencodedpolyline {


export type Parameters = {
txtin: Nullable<PgCatalog.Types.Text>;
nprecision: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsencodedpolyline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
nprecision: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAssvgA8be {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
rel: Nullable<PgCatalog.Types.Int4>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgmlA8be {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgml_2621 {


export type Parameters = {
version: Nullable<PgCatalog.Types.Int4>;
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskmlE3da {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgeojsonA8be {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgeojsonF2c6 {


export type Parameters = {
r: Nullable<PgCatalog.Types.Record>;
geomColumn: Nullable<PgCatalog.Types.Text>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
prettyBool: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Json {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Jsonb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisAsmvtTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsmvtTransfn_27f4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtTransfnF57f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PgisAsmvtTransfn_92c1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
argument_4: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtTransfnF5be {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
argument_4: Nullable<PgCatalog.Types.Text>;
argument_5: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtCombinefn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtSerialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtDeserialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StAsmvtgeom {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
bounds: Nullable<Public.Types.Box2d>;
extent: Nullable<PgCatalog.Types.Int4>;
buffer: Nullable<PgCatalog.Types.Int4>;
clipGeom: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PostgisLibprotobufVersion {

}
export namespace PgisAsgeobufTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsgeobufTransfn_27f4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsgeobufFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsflatgeobufTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsflatgeobufTransfn_9633 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PgisAsflatgeobufTransfn_521f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Bool>;
argument_3: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsflatgeobufFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StFromflatgeobuftotable {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StFromflatgeobuf {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Anyelement>;
argument_1: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeohashEd82 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxchars: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBox2dfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StNumpoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNumgeometries {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometryn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StDimension {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StExteriorring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNuminteriorrings {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNuminteriorring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StInteriorringn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Geometrytype_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometrytype {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StNumpatches {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPatchn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StStartpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StEndpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsclosed {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsempty {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsbinaryF1e2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsbinary_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAstext_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAstextEd82 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeometryfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeometryfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StWkttosql {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPointfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPointfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinefromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLinefromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolyfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPolyfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMlinefromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMlinefromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultilinestringfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultilinestringfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultipointfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMpolyfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpolyfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultipolygonfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMultipolygonfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomcollfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomcollfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLinefromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinefromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLinestringfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinestringfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StPolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StPolygonfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMpointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultipointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyAnalyze {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StMultipointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultilinefromwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMlinefromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMlinefromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMpolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultipolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMultipolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomcollfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomcollfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMaxdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StClosestpointEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StShortestlineEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StLongestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSwapordinates {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
ords: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace StFlipcoordinates {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBdpolyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBdmpolyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Unlockrows {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geography_675a {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Geography_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Bytea_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstext_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstext_75a2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace LockrowE9aa {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Text>;
argument_4: Nullable<PgCatalog.Types.Timestamp>;
}
}
export namespace Lockrow_02b4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Lockrow_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Lockrow_9a8a {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Timestamp>;
}
}
export namespace Addauth {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauth_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauth_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauthtrigger {

}
export namespace Gettransactionid {

}
export namespace Enablelongtransactions {

}
export namespace Longtransactionsenabled {

}
export namespace Disablelongtransactions {

}
export namespace GeographyTypmodIn {


export type Parameters = {
argument_0: PgCatalog.Types.CstringArray;
}
}
export namespace GeographyTypmodOut {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyRecv {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographySend {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeographyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeogfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeogfromwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace PostgisTypmodDims {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTypmodSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTypmodType {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Geography_0faa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Geometry_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGistConsistent {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geography>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyGistCompress {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistPenalty {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistPicksplit {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistUnion {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistSame {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<Public.Types.Box2d>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistDecompress {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyOverlaps {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyDistanceKnn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGistDistance {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geography>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace OverlapsGeog_5a37 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace OverlapsGeogBd57 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace OverlapsGeog_1597 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace GeogBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyLt {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyLe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGt {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyEq {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyCmp {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace StAssvg_8ddb {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
rel: Nullable<PgCatalog.Types.Int4>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAssvgE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StProjectE61a {


export type Parameters = {
geogFrom: Nullable<Public.Types.Geography>;
geogTo: Nullable<Public.Types.Geography>;
distance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAzimuthA587 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StBuffer_49f7 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgmlCe11 {


export type Parameters = {
version: Nullable<PgCatalog.Types.Int4>;
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgml_98d7 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskml_48da {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgeojson_8ddb {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgeojsonE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDistance_89b8 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StDistance_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAreaAc0a {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAreaE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLengthAc0a {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLengthE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StProject_665e {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
distance: Nullable<PgCatalog.Types.Float8>;
azimuth: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StPerimeterAc0a {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSegmentize_772c {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxSegmentLength: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAsbinary_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAsbinaryF815 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsewkt_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAsewkt_75a2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsewktE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geometrytype_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StSummary_38ca {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StGeohash_75a2 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxchars: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSrid_38ca {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
}
}
export namespace StSetsrid_75a2 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StCentroidAc0a {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StCentroidE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCoversA587 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StDwithin_5395 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
tolerance: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StCoveredbyA587 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StIntersectsA587 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StBuffer_772c {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBuffer_2117 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBuffer_3a01 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StBufferC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBufferF7c6 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StIntersectionA587 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace StIntersection_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCovers_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCoveredby_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDwithinEfc0 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIntersects_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StClosestpoint_89b8 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StClosestpoint_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StShortestline_89b8 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StShortestline_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLinesubstring_665e {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinesubstringE586 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinelocatepoint_89b8 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLinelocatepoint_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLineinterpolatepoints_5d11 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
repeat: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLineinterpolatepointsC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLineinterpolatepointCee3 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLineinterpolatepointC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDistancesphereEb6a {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistancesphereE059 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PostgisTypeName {


export type Parameters = {
geomname: Nullable<PgCatalog.Types.Varchar>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
useNewName: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PostgisConstraintSrid {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisConstraintDims {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisConstraintType {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace St_3ddistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dmaxdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dclosestpoint {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dshortestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlongestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCoorddim {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StCurvetoline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tol: Nullable<PgCatalog.Types.Float8>;
toltype: Nullable<PgCatalog.Types.Int4>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StHasarc {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StLinetocurve {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StPoint_0aec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StPoint_0b7f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointz {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
zcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointm {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
mcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointzm {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
zcoordinate: Nullable<PgCatalog.Types.Float8>;
mcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygon {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StWkbtosql {


export type Parameters = {
wkb: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLocatebetween {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
frommeasure: Nullable<PgCatalog.Types.Float8>;
tomeasure: Nullable<PgCatalog.Types.Float8>;
leftrightoffset: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLocatealong {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
measure: Nullable<PgCatalog.Types.Float8>;
leftrightoffset: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLocatebetweenelevations {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
fromelevation: Nullable<PgCatalog.Types.Float8>;
toelevation: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StInterpolatepoint {


export type Parameters = {
line: Nullable<Public.Types.Geometry>;
point: Nullable<Public.Types.Geometry>;
}
}
export namespace StHexagon {


export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
cellI: Nullable<PgCatalog.Types.Int4>;
cellJ: Nullable<PgCatalog.Types.Int4>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StSquare {


export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
cellI: Nullable<PgCatalog.Types.Int4>;
cellJ: Nullable<PgCatalog.Types.Int4>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StHexagongrid {
export const Columns = {
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
I: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "i" as FieldNamesType,
},
J: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "j" as FieldNamesType,
},
}
export const ColumnNames = ["Geom","I","J"] as const;
export const FieldNames = ["geom","i","j"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
bounds: Nullable<Public.Types.Geometry>;
}
}
export namespace StSquaregrid {
export const Columns = {
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
I: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "i" as FieldNamesType,
},
J: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "j" as FieldNamesType,
},
}
export const ColumnNames = ["Geom","I","J"] as const;
export const FieldNames = ["geom","i","j"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
bounds: Nullable<Public.Types.Geometry>;
}
}
export namespace Contains_2dD703 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace IsContained_2dD703 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace Overlaps_2dD703 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace Overlaps_2d_1585 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Contains_2d_1585 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace IsContained_2d_1585 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Contains_2d_3f94 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace IsContained_2d_3f94 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Overlaps_2d_3f94 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace OverlapsNd_44c4 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace OverlapsNdBd57 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace OverlapsNd_19dd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace Geom2dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace Geom3dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace Geom4dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StSimplifypolygonhull {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
vertexFraction: Nullable<PgCatalog.Types.Float8>;
isOuter: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StConcavehull {


export type Parameters = {
paramGeom: Nullable<Public.Types.Geometry>;
paramPctconvex: Nullable<PgCatalog.Types.Float8>;
paramAllowHoles: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAsx3d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAngleEb6a {


export type Parameters = {
line1: Nullable<Public.Types.Geometry>;
line2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlineinterpolatepoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace GeometrySpgistConfig_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChoose_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplit_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryOverlaps_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContains_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContained_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySame_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySpgistConfig_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChoose_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplit_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistent_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistent_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompress_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistConfigNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChooseNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistConfigNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistChooseNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistInnerConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistLeafConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StLetters {


export type Parameters = {
letters: Nullable<PgCatalog.Types.Text>;
font: Nullable<PgCatalog.Types.Json>;
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
export function emptyRow() : PossiblyEmpty<Public.Types.SpatialRefSys> {
 return { srid: undefined,authName: undefined,authSrid: undefined,srtext: undefined,proj4text: undefined };
}

export type Optional = Pick<Public.Types.SpatialRefSys,never>
export type Values = PartiallyOptional<Public.Types.SpatialRefSys,  PrimaryKey>
export enum SortOptions  {
sridAscending = "srid ASC",
authNameAscending = "auth_name ASC",
authSridAscending = "auth_srid ASC",
srtextAscending = "srtext ASC",
proj4textAscending = "proj4text ASC",
sridDescending = "srid DESC",
authNameDescending = "auth_name DESC",
authSridDescending = "auth_srid DESC",
srtextDescending = "srtext DESC",
proj4textDescending = "proj4text DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Srid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "srid" as FieldNamesType,
},
AuthName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "authSrid" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "proj4text" as FieldNamesType,
},
}
export const ColumnNames = ["Srid","AuthName","AuthSrid","Srtext","Proj4text"] as const;
export const FieldNames = ["srid","authName","authSrid","srtext","proj4text"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.SpatialRefSysPkey;
}
export namespace NycCensusBlocks {
export function emptyRow() : PossiblyEmpty<Public.Types.NycCensusBlocks> {
 return { gid: undefined,blkid: undefined,popnTotal: undefined,popnWhite: undefined,popnBlack: undefined,popnNativ: undefined,popnAsian: undefined,popnOther: undefined,boroname: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycCensusBlocks,"gid">
export type Values = PartiallyOptional<Public.Types.NycCensusBlocks, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
blkidAscending = "blkid ASC",
popnTotalAscending = "popn_total ASC",
popnWhiteAscending = "popn_white ASC",
popnBlackAscending = "popn_black ASC",
popnNativAscending = "popn_nativ ASC",
popnAsianAscending = "popn_asian ASC",
popnOtherAscending = "popn_other ASC",
boronameAscending = "boroname ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
blkidDescending = "blkid DESC",
popnTotalDescending = "popn_total DESC",
popnWhiteDescending = "popn_white DESC",
popnBlackDescending = "popn_black DESC",
popnNativDescending = "popn_nativ DESC",
popnAsianDescending = "popn_asian DESC",
popnOtherDescending = "popn_other DESC",
boronameDescending = "boroname DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Blkid: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "blkid" as FieldNamesType,
},
PopnTotal: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnTotal" as FieldNamesType,
},
PopnWhite: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnWhite" as FieldNamesType,
},
PopnBlack: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnBlack" as FieldNamesType,
},
PopnNativ: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnNativ" as FieldNamesType,
},
PopnAsian: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnAsian" as FieldNamesType,
},
PopnOther: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnOther" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Blkid","PopnTotal","PopnWhite","PopnBlack","PopnNativ","PopnAsian","PopnOther","Boroname","Geom"] as const;
export const FieldNames = ["gid","blkid","popnTotal","popnWhite","popnBlack","popnNativ","popnAsian","popnOther","boroname","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycCensusBlocksPkey;
}
export namespace NycHomicides {
export function emptyRow() : PossiblyEmpty<Public.Types.NycHomicides> {
 return { gid: undefined,incidentD: undefined,boroname: undefined,numVictim: undefined,primaryMo: undefined,id: undefined,weapon: undefined,lightDark: undefined,year: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycHomicides,"gid">
export type Values = PartiallyOptional<Public.Types.NycHomicides, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
incidentDAscending = "incident_d ASC",
boronameAscending = "boroname ASC",
numVictimAscending = "num_victim ASC",
primaryMoAscending = "primary_mo ASC",
idAscending = "id ASC",
weaponAscending = "weapon ASC",
lightDarkAscending = "light_dark ASC",
yearAscending = "year ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
incidentDDescending = "incident_d DESC",
boronameDescending = "boroname DESC",
numVictimDescending = "num_victim DESC",
primaryMoDescending = "primary_mo DESC",
idDescending = "id DESC",
weaponDescending = "weapon DESC",
lightDarkDescending = "light_dark DESC",
yearDescending = "year DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
IncidentD: {
 typeName: "PgCatalog.Types.Date",
 fieldName: "incidentD" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
NumVictim: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "numVictim" as FieldNamesType,
},
PrimaryMo: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "primaryMo" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "id" as FieldNamesType,
},
Weapon: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "weapon" as FieldNamesType,
},
LightDark: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "lightDark" as FieldNamesType,
},
Year: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "year" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","IncidentD","Boroname","NumVictim","PrimaryMo","Id","Weapon","LightDark","Year","Geom"] as const;
export const FieldNames = ["gid","incidentD","boroname","numVictim","primaryMo","id","weapon","lightDark","year","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycHomicidesPkey;
}
export namespace NycNeighborhoods {
export function emptyRow() : PossiblyEmpty<Public.Types.NycNeighborhoods> {
 return { gid: undefined,boroname: undefined,name: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycNeighborhoods,"gid">
export type Values = PartiallyOptional<Public.Types.NycNeighborhoods, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
boronameAscending = "boroname ASC",
nameAscending = "name ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
boronameDescending = "boroname DESC",
nameDescending = "name DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Boroname","Name","Geom"] as const;
export const FieldNames = ["gid","boroname","name","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycNeighborhoodsPkey;
}
export namespace NycStreets {
export function emptyRow() : PossiblyEmpty<Public.Types.NycStreets> {
 return { gid: undefined,id: undefined,name: undefined,oneway: undefined,type: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycStreets,"gid">
export type Values = PartiallyOptional<Public.Types.NycStreets, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
idAscending = "id ASC",
nameAscending = "name ASC",
onewayAscending = "oneway ASC",
typeAscending = "type ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
idDescending = "id DESC",
nameDescending = "name DESC",
onewayDescending = "oneway DESC",
typeDescending = "type DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "id" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
Oneway: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "oneway" as FieldNamesType,
},
Type: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "type" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Id","Name","Oneway","Type","Geom"] as const;
export const FieldNames = ["gid","id","name","oneway","type","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycStreetsPkey;
}
export namespace NycSubwayStations {
export function emptyRow() : PossiblyEmpty<Public.Types.NycSubwayStations> {
 return { gid: undefined,objectid: undefined,id: undefined,name: undefined,altName: undefined,crossSt: undefined,longName: undefined,label: undefined,borough: undefined,nghbhd: undefined,routes: undefined,transfers: undefined,color: undefined,express: undefined,closed: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycSubwayStations,"gid">
export type Values = PartiallyOptional<Public.Types.NycSubwayStations, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
objectidAscending = "objectid ASC",
idAscending = "id ASC",
nameAscending = "name ASC",
altNameAscending = "alt_name ASC",
crossStAscending = "cross_st ASC",
longNameAscending = "long_name ASC",
labelAscending = "label ASC",
boroughAscending = "borough ASC",
nghbhdAscending = "nghbhd ASC",
routesAscending = "routes ASC",
transfersAscending = "transfers ASC",
colorAscending = "color ASC",
expressAscending = "express ASC",
closedAscending = "closed ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
objectidDescending = "objectid DESC",
idDescending = "id DESC",
nameDescending = "name DESC",
altNameDescending = "alt_name DESC",
crossStDescending = "cross_st DESC",
longNameDescending = "long_name DESC",
labelDescending = "label DESC",
boroughDescending = "borough DESC",
nghbhdDescending = "nghbhd DESC",
routesDescending = "routes DESC",
transfersDescending = "transfers DESC",
colorDescending = "color DESC",
expressDescending = "express DESC",
closedDescending = "closed DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Objectid: {
 typeName: "PgCatalog.Types.Numeric",
 fieldName: "objectid" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Numeric",
 fieldName: "id" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
AltName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "altName" as FieldNamesType,
},
CrossSt: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "crossSt" as FieldNamesType,
},
LongName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "longName" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "label" as FieldNamesType,
},
Borough: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "borough" as FieldNamesType,
},
Nghbhd: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "nghbhd" as FieldNamesType,
},
Routes: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "routes" as FieldNamesType,
},
Transfers: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "transfers" as FieldNamesType,
},
Color: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "color" as FieldNamesType,
},
Express: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "express" as FieldNamesType,
},
Closed: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "closed" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Objectid","Id","Name","AltName","CrossSt","LongName","Label","Borough","Nghbhd","Routes","Transfers","Color","Express","Closed","Geom"] as const;
export const FieldNames = ["gid","objectid","id","name","altName","crossSt","longName","label","borough","nghbhd","routes","transfers","color","express","closed","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycSubwayStationsPkey;
}
}
}
export namespace PgToast {
export namespace Types {

export type PgToast_49556Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_50314Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_50320Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1255Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1247Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2604Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2606Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2612Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2600Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2619Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3381Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3429Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2618Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2620Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3466Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2609Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_50326Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2615Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1262Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2964Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1213Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1260Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2396Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3600Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3079Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2328Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1417Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1418Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3118Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3256Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6000Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_826Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3394Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3596Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3592Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3456Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6243Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3350Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6106Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6100Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_50332Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_50338Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13658Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13663Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13668Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13673Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Procedures {
}
export namespace Tables {
}
}

export namespace PgCatalog {
export namespace Types {
export namespace Bool {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Bytea {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Char {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Name {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Int8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Int2 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Int2vector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return new Uint16Array(JSON.parse(from));
      }
      if (Array.isArray(from)) {
        return new Uint16Array(from);
      }
      return [];
    
}


}
export namespace Int4 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regproc {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Text {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Oid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Tid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Cid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Oidvector {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oid.parse(e));
    
}


}
export namespace PgType {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgType.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
typname: PgCatalog.Types.Name.parse(from.typname),
typnamespace: PgCatalog.Types.Oid.parse(from.typnamespace),
typowner: PgCatalog.Types.Oid.parse(from.typowner),
typlen: PgCatalog.Types.Int2.parse(from.typlen),
typbyval: PgCatalog.Types.Bool.parse(from.typbyval),
typtype: PgCatalog.Types.Char.parse(from.typtype),
typcategory: PgCatalog.Types.Char.parse(from.typcategory),
typispreferred: PgCatalog.Types.Bool.parse(from.typispreferred),
typisdefined: PgCatalog.Types.Bool.parse(from.typisdefined),
typdelim: PgCatalog.Types.Char.parse(from.typdelim),
typrelid: PgCatalog.Types.Oid.parse(from.typrelid),
typsubscript: PgCatalog.Types.Regproc.parse(from.typsubscript),
typelem: PgCatalog.Types.Oid.parse(from.typelem),
typarray: PgCatalog.Types.Oid.parse(from.typarray),
typinput: PgCatalog.Types.Regproc.parse(from.typinput),
typoutput: PgCatalog.Types.Regproc.parse(from.typoutput),
typreceive: PgCatalog.Types.Regproc.parse(from.typreceive),
typsend: PgCatalog.Types.Regproc.parse(from.typsend),
typmodin: PgCatalog.Types.Regproc.parse(from.typmodin),
typmodout: PgCatalog.Types.Regproc.parse(from.typmodout),
typanalyze: PgCatalog.Types.Regproc.parse(from.typanalyze),
typalign: PgCatalog.Types.Char.parse(from.typalign),
typstorage: PgCatalog.Types.Char.parse(from.typstorage),
typnotnull: PgCatalog.Types.Bool.parse(from.typnotnull),
typbasetype: PgCatalog.Types.Oid.parse(from.typbasetype),
typtypmod: PgCatalog.Types.Int4.parse(from.typtypmod),
typndims: PgCatalog.Types.Int4.parse(from.typndims),
typcollation: PgCatalog.Types.Oid.parse(from.typcollation),
typdefaultbin: PgCatalog.Types.PgNodeTree.parse(from.typdefaultbin),
typdefault: PgCatalog.Types.Text.parse(from.typdefault),
typacl: PgCatalog.Types.AclitemArray.parse(from.typacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttribute {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttribute.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attname: PgCatalog.Types.Name.parse(from.attname),
atttypid: PgCatalog.Types.Oid.parse(from.atttypid),
attlen: PgCatalog.Types.Int2.parse(from.attlen),
attnum: PgCatalog.Types.Int2.parse(from.attnum),
attcacheoff: PgCatalog.Types.Int4.parse(from.attcacheoff),
atttypmod: PgCatalog.Types.Int4.parse(from.atttypmod),
attndims: PgCatalog.Types.Int2.parse(from.attndims),
attbyval: PgCatalog.Types.Bool.parse(from.attbyval),
attalign: PgCatalog.Types.Char.parse(from.attalign),
attstorage: PgCatalog.Types.Char.parse(from.attstorage),
attcompression: PgCatalog.Types.Char.parse(from.attcompression),
attnotnull: PgCatalog.Types.Bool.parse(from.attnotnull),
atthasdef: PgCatalog.Types.Bool.parse(from.atthasdef),
atthasmissing: PgCatalog.Types.Bool.parse(from.atthasmissing),
attidentity: PgCatalog.Types.Char.parse(from.attidentity),
attgenerated: PgCatalog.Types.Char.parse(from.attgenerated),
attisdropped: PgCatalog.Types.Bool.parse(from.attisdropped),
attislocal: PgCatalog.Types.Bool.parse(from.attislocal),
attinhcount: PgCatalog.Types.Int2.parse(from.attinhcount),
attstattarget: PgCatalog.Types.Int2.parse(from.attstattarget),
attcollation: PgCatalog.Types.Oid.parse(from.attcollation),
attacl: PgCatalog.Types.AclitemArray.parse(from.attacl),
attoptions: PgCatalog.Types.TextArray.parse(from.attoptions),
attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
attmissingval: PgCatalog.Types.Anyarray.parse(from.attmissingval),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgProc {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProc.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
proname: PgCatalog.Types.Name.parse(from.proname),
pronamespace: PgCatalog.Types.Oid.parse(from.pronamespace),
proowner: PgCatalog.Types.Oid.parse(from.proowner),
prolang: PgCatalog.Types.Oid.parse(from.prolang),
procost: PgCatalog.Types.Float4.parse(from.procost),
prorows: PgCatalog.Types.Float4.parse(from.prorows),
provariadic: PgCatalog.Types.Oid.parse(from.provariadic),
prosupport: PgCatalog.Types.Regproc.parse(from.prosupport),
prokind: PgCatalog.Types.Char.parse(from.prokind),
prosecdef: PgCatalog.Types.Bool.parse(from.prosecdef),
proleakproof: PgCatalog.Types.Bool.parse(from.proleakproof),
proisstrict: PgCatalog.Types.Bool.parse(from.proisstrict),
proretset: PgCatalog.Types.Bool.parse(from.proretset),
provolatile: PgCatalog.Types.Char.parse(from.provolatile),
proparallel: PgCatalog.Types.Char.parse(from.proparallel),
pronargs: PgCatalog.Types.Int2.parse(from.pronargs),
pronargdefaults: PgCatalog.Types.Int2.parse(from.pronargdefaults),
prorettype: PgCatalog.Types.Oid.parse(from.prorettype),
proargtypes: PgCatalog.Types.Oidvector.parse(from.proargtypes),
proallargtypes: PgCatalog.Types.OidArray.parse(from.proallargtypes),
proargmodes: PgCatalog.Types.CharArray.parse(from.proargmodes),
proargnames: PgCatalog.Types.TextArray.parse(from.proargnames),
proargdefaults: PgCatalog.Types.PgNodeTree.parse(from.proargdefaults),
protrftypes: PgCatalog.Types.OidArray.parse(from.protrftypes),
prosrc: PgCatalog.Types.Text.parse(from.prosrc),
probin: PgCatalog.Types.Text.parse(from.probin),
prosqlbody: PgCatalog.Types.PgNodeTree.parse(from.prosqlbody),
proconfig: PgCatalog.Types.TextArray.parse(from.proconfig),
proacl: PgCatalog.Types.AclitemArray.parse(from.proacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClass {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClass.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
relname: PgCatalog.Types.Name.parse(from.relname),
relnamespace: PgCatalog.Types.Oid.parse(from.relnamespace),
reltype: PgCatalog.Types.Oid.parse(from.reltype),
reloftype: PgCatalog.Types.Oid.parse(from.reloftype),
relowner: PgCatalog.Types.Oid.parse(from.relowner),
relam: PgCatalog.Types.Oid.parse(from.relam),
relfilenode: PgCatalog.Types.Oid.parse(from.relfilenode),
reltablespace: PgCatalog.Types.Oid.parse(from.reltablespace),
relpages: PgCatalog.Types.Int4.parse(from.relpages),
reltuples: PgCatalog.Types.Float4.parse(from.reltuples),
relallvisible: PgCatalog.Types.Int4.parse(from.relallvisible),
reltoastrelid: PgCatalog.Types.Oid.parse(from.reltoastrelid),
relhasindex: PgCatalog.Types.Bool.parse(from.relhasindex),
relisshared: PgCatalog.Types.Bool.parse(from.relisshared),
relpersistence: PgCatalog.Types.Char.parse(from.relpersistence),
relkind: PgCatalog.Types.Char.parse(from.relkind),
relnatts: PgCatalog.Types.Int2.parse(from.relnatts),
relchecks: PgCatalog.Types.Int2.parse(from.relchecks),
relhasrules: PgCatalog.Types.Bool.parse(from.relhasrules),
relhastriggers: PgCatalog.Types.Bool.parse(from.relhastriggers),
relhassubclass: PgCatalog.Types.Bool.parse(from.relhassubclass),
relrowsecurity: PgCatalog.Types.Bool.parse(from.relrowsecurity),
relforcerowsecurity: PgCatalog.Types.Bool.parse(from.relforcerowsecurity),
relispopulated: PgCatalog.Types.Bool.parse(from.relispopulated),
relreplident: PgCatalog.Types.Char.parse(from.relreplident),
relispartition: PgCatalog.Types.Bool.parse(from.relispartition),
relrewrite: PgCatalog.Types.Oid.parse(from.relrewrite),
relfrozenxid: PgCatalog.Types.Xid.parse(from.relfrozenxid),
relminmxid: PgCatalog.Types.Xid.parse(from.relminmxid),
relacl: PgCatalog.Types.AclitemArray.parse(from.relacl),
reloptions: PgCatalog.Types.TextArray.parse(from.reloptions),
relpartbound: PgCatalog.Types.PgNodeTree.parse(from.relpartbound),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace Json {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xml {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgNodeTree {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgNdistinct {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgDependencies {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgMcvList {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgDdlCommand {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xid8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Point {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return parsePoint(from);
    
}


}
export namespace Lseg {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Path {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Box {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Polygon {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Line {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Float4 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Float8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Unknown {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Circle {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Money {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Macaddr {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Inet {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Cidr {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Macaddr8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Aclitem {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Bpchar {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Varchar {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Date {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Time {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Timestamp {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Timestamptz {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Interval {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Timetz {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Bit {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Varbit {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Numeric {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Refcursor {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Regprocedure {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regoper {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regoperator {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regclass {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regcollation {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regtype {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regrole {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regnamespace {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Uuid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return new UUID(from as string);
    
}


}
export namespace PgLsn {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "bigint") {
      return from;
    }
    if (typeof from === "number") {
      return BigInt(from);
    }
    if (typeof from === "string") {
      if (from === '') return null;
      return BigInt(from);
    }
    return null;
    
}


}
export namespace Tsvector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Gtsvector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsquery {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Regconfig {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regdictionary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Jsonb {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Jsonpath {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace TxidSnapshot {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgSnapshot {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Int4range {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Numrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tstzrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Daterange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int8range {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int4multirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Nummultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsmultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tstzmultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Datemultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int8multirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Record {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace RecordArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Record.parse(e));
    
}


}
export namespace Cstring {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Any {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Void {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Trigger {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace EventTrigger {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace LanguageHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Internal {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyelement {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      throw new Error("not implemented");
    
}


}
export namespace Anynonarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyenum {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace FdwHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace IndexAmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace TsmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace TableAmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatible {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblearray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblenonarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblerange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anymultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblemultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgBrinBloomSummary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgBrinMinmaxMultiSummary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace BoolArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bool.parse(e));
    
}


}
export namespace ByteaArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bytea.parse(e));
    
}


}
export namespace CharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Char.parse(e));
    
}


}
export namespace NameArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Name.parse(e));
    
}


}
export namespace Int8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8.parse(e));
    
}


}
export namespace Int2Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int2.parse(e));
    
}


}
export namespace Int2vectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int2vector.parse(e));
    
}


}
export namespace Int4Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4.parse(e));
    
}


}
export namespace RegprocArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regproc.parse(e));
    
}


}
export namespace TextArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Text.parse(e));
    
}


}
export namespace OidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oid.parse(e));
    
}


}
export namespace TidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tid.parse(e));
    
}


}
export namespace XidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xid.parse(e));
    
}


}
export namespace CidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cid.parse(e));
    
}


}
export namespace OidvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oidvector.parse(e));
    
}


}
export namespace PgTypeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgType.parse(e));
    
}


}
export namespace PgAttributeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAttribute.parse(e));
    
}


}
export namespace PgProcArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgProc.parse(e));
    
}


}
export namespace PgClassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgClass.parse(e));
    
}


}
export namespace JsonArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Json.parse(e));
    
}


}
export namespace XmlArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xml.parse(e));
    
}


}
export namespace Xid8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xid8.parse(e));
    
}


}
export namespace PointArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Point.parse(e));
    
}


}
export namespace LsegArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Lseg.parse(e));
    
}


}
export namespace PathArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Path.parse(e));
    
}


}
export namespace BoxArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box.parse(e));
    
}


}
export namespace PolygonArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Polygon.parse(e));
    
}


}
export namespace LineArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Line.parse(e));
    
}


}
export namespace Float4Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Float4.parse(e));
    
}


}
export namespace Float8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Float8.parse(e));
    
}


}
export namespace CircleArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Circle.parse(e));
    
}


}
export namespace MoneyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Money.parse(e));
    
}


}
export namespace MacaddrArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Macaddr.parse(e));
    
}


}
export namespace InetArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Inet.parse(e));
    
}


}
export namespace CidrArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cidr.parse(e));
    
}


}
export namespace Macaddr8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Macaddr8.parse(e));
    
}


}
export namespace AclitemArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Aclitem.parse(e));
    
}


}
export namespace BpcharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bpchar.parse(e));
    
}


}
export namespace VarcharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Varchar.parse(e));
    
}


}
export namespace DateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Date.parse(e));
    
}


}
export namespace TimeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Time.parse(e));
    
}


}
export namespace TimestampArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timestamp.parse(e));
    
}


}
export namespace TimestamptzArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timestamptz.parse(e));
    
}


}
export namespace IntervalArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Interval.parse(e));
    
}


}
export namespace TimetzArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timetz.parse(e));
    
}


}
export namespace BitArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bit.parse(e));
    
}


}
export namespace VarbitArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Varbit.parse(e));
    
}


}
export namespace NumericArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Numeric.parse(e));
    
}


}
export namespace RefcursorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Refcursor.parse(e));
    
}


}
export namespace RegprocedureArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regprocedure.parse(e));
    
}


}
export namespace RegoperArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regoper.parse(e));
    
}


}
export namespace RegoperatorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regoperator.parse(e));
    
}


}
export namespace RegclassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regclass.parse(e));
    
}


}
export namespace RegcollationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regcollation.parse(e));
    
}


}
export namespace RegtypeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regtype.parse(e));
    
}


}
export namespace RegroleArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regrole.parse(e));
    
}


}
export namespace RegnamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regnamespace.parse(e));
    
}


}
export namespace UuidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Uuid.parse(e));
    
}


}
export namespace PgLsnArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLsn.parse(e));
    
}


}
export namespace TsvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsvector.parse(e));
    
}


}
export namespace GtsvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Gtsvector.parse(e));
    
}


}
export namespace TsqueryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsquery.parse(e));
    
}


}
export namespace RegconfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regconfig.parse(e));
    
}


}
export namespace RegdictionaryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regdictionary.parse(e));
    
}


}
export namespace JsonbArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Jsonb.parse(e));
    
}


}
export namespace JsonpathArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Jsonpath.parse(e));
    
}


}
export namespace TxidSnapshotArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TxidSnapshot.parse(e));
    
}


}
export namespace PgSnapshotArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSnapshot.parse(e));
    
}


}
export namespace Int4rangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4range.parse(e));
    
}


}
export namespace NumrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Numrange.parse(e));
    
}


}
export namespace TsrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsrange.parse(e));
    
}


}
export namespace TstzrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tstzrange.parse(e));
    
}


}
export namespace DaterangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Daterange.parse(e));
    
}


}
export namespace Int8rangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8range.parse(e));
    
}


}
export namespace Int4multirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4multirange.parse(e));
    
}


}
export namespace NummultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Nummultirange.parse(e));
    
}


}
export namespace TsmultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsmultirange.parse(e));
    
}


}
export namespace TstzmultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tstzmultirange.parse(e));
    
}


}
export namespace DatemultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Datemultirange.parse(e));
    
}


}
export namespace Int8multirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8multirange.parse(e));
    
}


}
export namespace CstringArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cstring.parse(e));
    
}


}
export namespace PgAttrdef {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdef.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
adrelid: PgCatalog.Types.Oid.parse(from.adrelid),
adnum: PgCatalog.Types.Int2.parse(from.adnum),
adbin: PgCatalog.Types.PgNodeTree.parse(from.adbin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAttrdef.parse(e));
    
}


}
export namespace PgConstraint {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraint.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
contype: PgCatalog.Types.Char.parse(from.contype),
condeferrable: PgCatalog.Types.Bool.parse(from.condeferrable),
condeferred: PgCatalog.Types.Bool.parse(from.condeferred),
convalidated: PgCatalog.Types.Bool.parse(from.convalidated),
conrelid: PgCatalog.Types.Oid.parse(from.conrelid),
contypid: PgCatalog.Types.Oid.parse(from.contypid),
conindid: PgCatalog.Types.Oid.parse(from.conindid),
conparentid: PgCatalog.Types.Oid.parse(from.conparentid),
confrelid: PgCatalog.Types.Oid.parse(from.confrelid),
confupdtype: PgCatalog.Types.Char.parse(from.confupdtype),
confdeltype: PgCatalog.Types.Char.parse(from.confdeltype),
confmatchtype: PgCatalog.Types.Char.parse(from.confmatchtype),
conislocal: PgCatalog.Types.Bool.parse(from.conislocal),
coninhcount: PgCatalog.Types.Int2.parse(from.coninhcount),
connoinherit: PgCatalog.Types.Bool.parse(from.connoinherit),
conkey: PgCatalog.Types.Int2Array.parse(from.conkey),
confkey: PgCatalog.Types.Int2Array.parse(from.confkey),
conpfeqop: PgCatalog.Types.OidArray.parse(from.conpfeqop),
conppeqop: PgCatalog.Types.OidArray.parse(from.conppeqop),
conffeqop: PgCatalog.Types.OidArray.parse(from.conffeqop),
confdelsetcols: PgCatalog.Types.Int2Array.parse(from.confdelsetcols),
conexclop: PgCatalog.Types.OidArray.parse(from.conexclop),
conbin: PgCatalog.Types.PgNodeTree.parse(from.conbin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConstraint.parse(e));
    
}


}
export namespace PgInherits {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInherits.is(from)) {
  return {
inhrelid: PgCatalog.Types.Oid.parse(from.inhrelid),
inhparent: PgCatalog.Types.Oid.parse(from.inhparent),
inhseqno: PgCatalog.Types.Int4.parse(from.inhseqno),
inhdetachpending: PgCatalog.Types.Bool.parse(from.inhdetachpending),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgInherits.parse(e));
    
}


}
export namespace PgIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndex.is(from)) {
  return {
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
indrelid: PgCatalog.Types.Oid.parse(from.indrelid),
indnatts: PgCatalog.Types.Int2.parse(from.indnatts),
indnkeyatts: PgCatalog.Types.Int2.parse(from.indnkeyatts),
indisunique: PgCatalog.Types.Bool.parse(from.indisunique),
indnullsnotdistinct: PgCatalog.Types.Bool.parse(from.indnullsnotdistinct),
indisprimary: PgCatalog.Types.Bool.parse(from.indisprimary),
indisexclusion: PgCatalog.Types.Bool.parse(from.indisexclusion),
indimmediate: PgCatalog.Types.Bool.parse(from.indimmediate),
indisclustered: PgCatalog.Types.Bool.parse(from.indisclustered),
indisvalid: PgCatalog.Types.Bool.parse(from.indisvalid),
indcheckxmin: PgCatalog.Types.Bool.parse(from.indcheckxmin),
indisready: PgCatalog.Types.Bool.parse(from.indisready),
indislive: PgCatalog.Types.Bool.parse(from.indislive),
indisreplident: PgCatalog.Types.Bool.parse(from.indisreplident),
indkey: PgCatalog.Types.Int2vector.parse(from.indkey),
indcollation: PgCatalog.Types.Oidvector.parse(from.indcollation),
indclass: PgCatalog.Types.Oidvector.parse(from.indclass),
indoption: PgCatalog.Types.Int2vector.parse(from.indoption),
indexprs: PgCatalog.Types.PgNodeTree.parse(from.indexprs),
indpred: PgCatalog.Types.PgNodeTree.parse(from.indpred),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIndex.parse(e));
    
}


}
export namespace PgOperator {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperator.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
oprname: PgCatalog.Types.Name.parse(from.oprname),
oprnamespace: PgCatalog.Types.Oid.parse(from.oprnamespace),
oprowner: PgCatalog.Types.Oid.parse(from.oprowner),
oprkind: PgCatalog.Types.Char.parse(from.oprkind),
oprcanmerge: PgCatalog.Types.Bool.parse(from.oprcanmerge),
oprcanhash: PgCatalog.Types.Bool.parse(from.oprcanhash),
oprleft: PgCatalog.Types.Oid.parse(from.oprleft),
oprright: PgCatalog.Types.Oid.parse(from.oprright),
oprresult: PgCatalog.Types.Oid.parse(from.oprresult),
oprcom: PgCatalog.Types.Oid.parse(from.oprcom),
oprnegate: PgCatalog.Types.Oid.parse(from.oprnegate),
oprcode: PgCatalog.Types.Regproc.parse(from.oprcode),
oprrest: PgCatalog.Types.Regproc.parse(from.oprrest),
oprjoin: PgCatalog.Types.Regproc.parse(from.oprjoin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOperator.parse(e));
    
}


}
export namespace PgOpfamily {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamily.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
opfmethod: PgCatalog.Types.Oid.parse(from.opfmethod),
opfname: PgCatalog.Types.Name.parse(from.opfname),
opfnamespace: PgCatalog.Types.Oid.parse(from.opfnamespace),
opfowner: PgCatalog.Types.Oid.parse(from.opfowner),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOpfamily.parse(e));
    
}


}
export namespace PgOpclass {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclass.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
opcmethod: PgCatalog.Types.Oid.parse(from.opcmethod),
opcname: PgCatalog.Types.Name.parse(from.opcname),
opcnamespace: PgCatalog.Types.Oid.parse(from.opcnamespace),
opcowner: PgCatalog.Types.Oid.parse(from.opcowner),
opcfamily: PgCatalog.Types.Oid.parse(from.opcfamily),
opcintype: PgCatalog.Types.Oid.parse(from.opcintype),
opcdefault: PgCatalog.Types.Bool.parse(from.opcdefault),
opckeytype: PgCatalog.Types.Oid.parse(from.opckeytype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOpclass.parse(e));
    
}


}
export namespace PgAm {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAm.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amname: PgCatalog.Types.Name.parse(from.amname),
amhandler: PgCatalog.Types.Regproc.parse(from.amhandler),
amtype: PgCatalog.Types.Char.parse(from.amtype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAm.parse(e));
    
}


}
export namespace PgAmop {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmop.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
amoplefttype: PgCatalog.Types.Oid.parse(from.amoplefttype),
amoprighttype: PgCatalog.Types.Oid.parse(from.amoprighttype),
amopstrategy: PgCatalog.Types.Int2.parse(from.amopstrategy),
amoppurpose: PgCatalog.Types.Char.parse(from.amoppurpose),
amopopr: PgCatalog.Types.Oid.parse(from.amopopr),
amopmethod: PgCatalog.Types.Oid.parse(from.amopmethod),
amopsortfamily: PgCatalog.Types.Oid.parse(from.amopsortfamily),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAmop.parse(e));
    
}


}
export namespace PgAmproc {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmproc.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amprocfamily: PgCatalog.Types.Oid.parse(from.amprocfamily),
amproclefttype: PgCatalog.Types.Oid.parse(from.amproclefttype),
amprocrighttype: PgCatalog.Types.Oid.parse(from.amprocrighttype),
amprocnum: PgCatalog.Types.Int2.parse(from.amprocnum),
amproc: PgCatalog.Types.Regproc.parse(from.amproc),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAmproc.parse(e));
    
}


}
export namespace PgLanguage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguage.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
lanname: PgCatalog.Types.Name.parse(from.lanname),
lanowner: PgCatalog.Types.Oid.parse(from.lanowner),
lanispl: PgCatalog.Types.Bool.parse(from.lanispl),
lanpltrusted: PgCatalog.Types.Bool.parse(from.lanpltrusted),
lanplcallfoid: PgCatalog.Types.Oid.parse(from.lanplcallfoid),
laninline: PgCatalog.Types.Oid.parse(from.laninline),
lanvalidator: PgCatalog.Types.Oid.parse(from.lanvalidator),
lanacl: PgCatalog.Types.AclitemArray.parse(from.lanacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLanguage.parse(e));
    
}


}
export namespace PgLargeobjectMetadata {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectMetadata.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
lomowner: PgCatalog.Types.Oid.parse(from.lomowner),
lomacl: PgCatalog.Types.AclitemArray.parse(from.lomacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectMetadataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLargeobjectMetadata.parse(e));
    
}


}
export namespace PgLargeobject {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobject.is(from)) {
  return {
loid: PgCatalog.Types.Oid.parse(from.loid),
pageno: PgCatalog.Types.Int4.parse(from.pageno),
data: PgCatalog.Types.Bytea.parse(from.data),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLargeobject.parse(e));
    
}


}
export namespace PgAggregate {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAggregate.is(from)) {
  return {
aggfnoid: PgCatalog.Types.Regproc.parse(from.aggfnoid),
aggkind: PgCatalog.Types.Char.parse(from.aggkind),
aggnumdirectargs: PgCatalog.Types.Int2.parse(from.aggnumdirectargs),
aggtransfn: PgCatalog.Types.Regproc.parse(from.aggtransfn),
aggfinalfn: PgCatalog.Types.Regproc.parse(from.aggfinalfn),
aggcombinefn: PgCatalog.Types.Regproc.parse(from.aggcombinefn),
aggserialfn: PgCatalog.Types.Regproc.parse(from.aggserialfn),
aggdeserialfn: PgCatalog.Types.Regproc.parse(from.aggdeserialfn),
aggmtransfn: PgCatalog.Types.Regproc.parse(from.aggmtransfn),
aggminvtransfn: PgCatalog.Types.Regproc.parse(from.aggminvtransfn),
aggmfinalfn: PgCatalog.Types.Regproc.parse(from.aggmfinalfn),
aggfinalextra: PgCatalog.Types.Bool.parse(from.aggfinalextra),
aggmfinalextra: PgCatalog.Types.Bool.parse(from.aggmfinalextra),
aggfinalmodify: PgCatalog.Types.Char.parse(from.aggfinalmodify),
aggmfinalmodify: PgCatalog.Types.Char.parse(from.aggmfinalmodify),
aggsortop: PgCatalog.Types.Oid.parse(from.aggsortop),
aggtranstype: PgCatalog.Types.Oid.parse(from.aggtranstype),
aggtransspace: PgCatalog.Types.Int4.parse(from.aggtransspace),
aggmtranstype: PgCatalog.Types.Oid.parse(from.aggmtranstype),
aggmtransspace: PgCatalog.Types.Int4.parse(from.aggmtransspace),
agginitval: PgCatalog.Types.Text.parse(from.agginitval),
aggminitval: PgCatalog.Types.Text.parse(from.aggminitval),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAggregateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAggregate.parse(e));
    
}


}
export namespace PgStatistic {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatistic.is(from)) {
  return {
starelid: PgCatalog.Types.Oid.parse(from.starelid),
staattnum: PgCatalog.Types.Int2.parse(from.staattnum),
stainherit: PgCatalog.Types.Bool.parse(from.stainherit),
stanullfrac: PgCatalog.Types.Float4.parse(from.stanullfrac),
stawidth: PgCatalog.Types.Int4.parse(from.stawidth),
stadistinct: PgCatalog.Types.Float4.parse(from.stadistinct),
stakind1: PgCatalog.Types.Int2.parse(from.stakind1),
stakind2: PgCatalog.Types.Int2.parse(from.stakind2),
stakind3: PgCatalog.Types.Int2.parse(from.stakind3),
stakind4: PgCatalog.Types.Int2.parse(from.stakind4),
stakind5: PgCatalog.Types.Int2.parse(from.stakind5),
staop1: PgCatalog.Types.Oid.parse(from.staop1),
staop2: PgCatalog.Types.Oid.parse(from.staop2),
staop3: PgCatalog.Types.Oid.parse(from.staop3),
staop4: PgCatalog.Types.Oid.parse(from.staop4),
staop5: PgCatalog.Types.Oid.parse(from.staop5),
stacoll1: PgCatalog.Types.Oid.parse(from.stacoll1),
stacoll2: PgCatalog.Types.Oid.parse(from.stacoll2),
stacoll3: PgCatalog.Types.Oid.parse(from.stacoll3),
stacoll4: PgCatalog.Types.Oid.parse(from.stacoll4),
stacoll5: PgCatalog.Types.Oid.parse(from.stacoll5),
stanumbers1: PgCatalog.Types.Float4Array.parse(from.stanumbers1),
stanumbers2: PgCatalog.Types.Float4Array.parse(from.stanumbers2),
stanumbers3: PgCatalog.Types.Float4Array.parse(from.stanumbers3),
stanumbers4: PgCatalog.Types.Float4Array.parse(from.stanumbers4),
stanumbers5: PgCatalog.Types.Float4Array.parse(from.stanumbers5),
stavalues1: PgCatalog.Types.Anyarray.parse(from.stavalues1),
stavalues2: PgCatalog.Types.Anyarray.parse(from.stavalues2),
stavalues3: PgCatalog.Types.Anyarray.parse(from.stavalues3),
stavalues4: PgCatalog.Types.Anyarray.parse(from.stavalues4),
stavalues5: PgCatalog.Types.Anyarray.parse(from.stavalues5),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatistic.parse(e));
    
}


}
export namespace PgStatisticExt {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExt.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
stxrelid: PgCatalog.Types.Oid.parse(from.stxrelid),
stxname: PgCatalog.Types.Name.parse(from.stxname),
stxnamespace: PgCatalog.Types.Oid.parse(from.stxnamespace),
stxowner: PgCatalog.Types.Oid.parse(from.stxowner),
stxstattarget: PgCatalog.Types.Int4.parse(from.stxstattarget),
stxkeys: PgCatalog.Types.Int2vector.parse(from.stxkeys),
stxkind: PgCatalog.Types.CharArray.parse(from.stxkind),
stxexprs: PgCatalog.Types.PgNodeTree.parse(from.stxexprs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatisticExt.parse(e));
    
}


}
export namespace PgStatisticExtData {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtData.is(from)) {
  return {
stxoid: PgCatalog.Types.Oid.parse(from.stxoid),
stxdinherit: PgCatalog.Types.Bool.parse(from.stxdinherit),
stxdndistinct: PgCatalog.Types.PgNdistinct.parse(from.stxdndistinct),
stxddependencies: PgCatalog.Types.PgDependencies.parse(from.stxddependencies),
stxdmcv: PgCatalog.Types.PgMcvList.parse(from.stxdmcv),
stxdexpr: PgCatalog.Types.PgStatisticArray.parse(from.stxdexpr),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtDataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatisticExtData.parse(e));
    
}


}
export namespace PgRewrite {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewrite.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
rulename: PgCatalog.Types.Name.parse(from.rulename),
evClass: PgCatalog.Types.Oid.parse(from.evClass),
evType: PgCatalog.Types.Char.parse(from.evType),
evEnabled: PgCatalog.Types.Char.parse(from.evEnabled),
isInstead: PgCatalog.Types.Bool.parse(from.isInstead),
evQual: PgCatalog.Types.PgNodeTree.parse(from.evQual),
evAction: PgCatalog.Types.PgNodeTree.parse(from.evAction),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRewrite.parse(e));
    
}


}
export namespace PgTrigger {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTrigger.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
tgrelid: PgCatalog.Types.Oid.parse(from.tgrelid),
tgparentid: PgCatalog.Types.Oid.parse(from.tgparentid),
tgname: PgCatalog.Types.Name.parse(from.tgname),
tgfoid: PgCatalog.Types.Oid.parse(from.tgfoid),
tgtype: PgCatalog.Types.Int2.parse(from.tgtype),
tgenabled: PgCatalog.Types.Char.parse(from.tgenabled),
tgisinternal: PgCatalog.Types.Bool.parse(from.tgisinternal),
tgconstrrelid: PgCatalog.Types.Oid.parse(from.tgconstrrelid),
tgconstrindid: PgCatalog.Types.Oid.parse(from.tgconstrindid),
tgconstraint: PgCatalog.Types.Oid.parse(from.tgconstraint),
tgdeferrable: PgCatalog.Types.Bool.parse(from.tgdeferrable),
tginitdeferred: PgCatalog.Types.Bool.parse(from.tginitdeferred),
tgnargs: PgCatalog.Types.Int2.parse(from.tgnargs),
tgattr: PgCatalog.Types.Int2vector.parse(from.tgattr),
tgargs: PgCatalog.Types.Bytea.parse(from.tgargs),
tgqual: PgCatalog.Types.PgNodeTree.parse(from.tgqual),
tgoldtable: PgCatalog.Types.Name.parse(from.tgoldtable),
tgnewtable: PgCatalog.Types.Name.parse(from.tgnewtable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTrigger.parse(e));
    
}


}
export namespace PgEventTrigger {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTrigger.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
evtname: PgCatalog.Types.Name.parse(from.evtname),
evtevent: PgCatalog.Types.Name.parse(from.evtevent),
evtowner: PgCatalog.Types.Oid.parse(from.evtowner),
evtfoid: PgCatalog.Types.Oid.parse(from.evtfoid),
evtenabled: PgCatalog.Types.Char.parse(from.evtenabled),
evttags: PgCatalog.Types.TextArray.parse(from.evttags),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgEventTrigger.parse(e));
    
}


}
export namespace PgDescription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDescription.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
description: PgCatalog.Types.Text.parse(from.description),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDescriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDescription.parse(e));
    
}


}
export namespace PgCast {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCast.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
castsource: PgCatalog.Types.Oid.parse(from.castsource),
casttarget: PgCatalog.Types.Oid.parse(from.casttarget),
castfunc: PgCatalog.Types.Oid.parse(from.castfunc),
castcontext: PgCatalog.Types.Char.parse(from.castcontext),
castmethod: PgCatalog.Types.Char.parse(from.castmethod),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCast.parse(e));
    
}


}
export namespace PgEnum {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnum.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumsortorder: PgCatalog.Types.Float4.parse(from.enumsortorder),
enumlabel: PgCatalog.Types.Name.parse(from.enumlabel),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgEnum.parse(e));
    
}


}
export namespace PgNamespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
nspname: PgCatalog.Types.Name.parse(from.nspname),
nspowner: PgCatalog.Types.Oid.parse(from.nspowner),
nspacl: PgCatalog.Types.AclitemArray.parse(from.nspacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgNamespace.parse(e));
    
}


}
export namespace PgConversion {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversion.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
conowner: PgCatalog.Types.Oid.parse(from.conowner),
conforencoding: PgCatalog.Types.Int4.parse(from.conforencoding),
contoencoding: PgCatalog.Types.Int4.parse(from.contoencoding),
conproc: PgCatalog.Types.Regproc.parse(from.conproc),
condefault: PgCatalog.Types.Bool.parse(from.condefault),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConversion.parse(e));
    
}


}
export namespace PgDepend {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDepend.is(from)) {
  return {
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
refobjsubid: PgCatalog.Types.Int4.parse(from.refobjsubid),
deptype: PgCatalog.Types.Char.parse(from.deptype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDepend.parse(e));
    
}


}
export namespace PgDatabase {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabase.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
datname: PgCatalog.Types.Name.parse(from.datname),
datdba: PgCatalog.Types.Oid.parse(from.datdba),
encoding: PgCatalog.Types.Int4.parse(from.encoding),
datlocprovider: PgCatalog.Types.Char.parse(from.datlocprovider),
datistemplate: PgCatalog.Types.Bool.parse(from.datistemplate),
datallowconn: PgCatalog.Types.Bool.parse(from.datallowconn),
datconnlimit: PgCatalog.Types.Int4.parse(from.datconnlimit),
datfrozenxid: PgCatalog.Types.Xid.parse(from.datfrozenxid),
datminmxid: PgCatalog.Types.Xid.parse(from.datminmxid),
dattablespace: PgCatalog.Types.Oid.parse(from.dattablespace),
datcollate: PgCatalog.Types.Text.parse(from.datcollate),
datctype: PgCatalog.Types.Text.parse(from.datctype),
daticulocale: PgCatalog.Types.Text.parse(from.daticulocale),
daticurules: PgCatalog.Types.Text.parse(from.daticurules),
datcollversion: PgCatalog.Types.Text.parse(from.datcollversion),
datacl: PgCatalog.Types.AclitemArray.parse(from.datacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDatabase.parse(e));
    
}


}
export namespace PgDbRoleSetting {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDbRoleSetting.is(from)) {
  return {
setdatabase: PgCatalog.Types.Oid.parse(from.setdatabase),
setrole: PgCatalog.Types.Oid.parse(from.setrole),
setconfig: PgCatalog.Types.TextArray.parse(from.setconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDbRoleSettingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDbRoleSetting.parse(e));
    
}


}
export namespace PgTablespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
spcname: PgCatalog.Types.Name.parse(from.spcname),
spcowner: PgCatalog.Types.Oid.parse(from.spcowner),
spcacl: PgCatalog.Types.AclitemArray.parse(from.spcacl),
spcoptions: PgCatalog.Types.TextArray.parse(from.spcoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTablespace.parse(e));
    
}


}
export namespace PgAuthid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthid.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
rolname: PgCatalog.Types.Name.parse(from.rolname),
rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
rolvaliduntil: PgCatalog.Types.Timestamptz.parse(from.rolvaliduntil),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAuthid.parse(e));
    
}


}
export namespace PgAuthMembers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
roleid: PgCatalog.Types.Oid.parse(from.roleid),
member: PgCatalog.Types.Oid.parse(from.member),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
adminOption: PgCatalog.Types.Bool.parse(from.adminOption),
inheritOption: PgCatalog.Types.Bool.parse(from.inheritOption),
setOption: PgCatalog.Types.Bool.parse(from.setOption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAuthMembers.parse(e));
    
}


}
export namespace PgShdepend {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdepend.is(from)) {
  return {
dbid: PgCatalog.Types.Oid.parse(from.dbid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
deptype: PgCatalog.Types.Char.parse(from.deptype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShdepend.parse(e));
    
}


}
export namespace PgShdescription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdescription.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
description: PgCatalog.Types.Text.parse(from.description),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdescriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShdescription.parse(e));
    
}


}
export namespace PgTsConfig {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfig.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
cfgname: PgCatalog.Types.Name.parse(from.cfgname),
cfgnamespace: PgCatalog.Types.Oid.parse(from.cfgnamespace),
cfgowner: PgCatalog.Types.Oid.parse(from.cfgowner),
cfgparser: PgCatalog.Types.Oid.parse(from.cfgparser),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsConfig.parse(e));
    
}


}
export namespace PgTsConfigMap {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigMap.is(from)) {
  return {
mapcfg: PgCatalog.Types.Oid.parse(from.mapcfg),
maptokentype: PgCatalog.Types.Int4.parse(from.maptokentype),
mapseqno: PgCatalog.Types.Int4.parse(from.mapseqno),
mapdict: PgCatalog.Types.Oid.parse(from.mapdict),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigMapArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsConfigMap.parse(e));
    
}


}
export namespace PgTsDict {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDict.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
dictname: PgCatalog.Types.Name.parse(from.dictname),
dictnamespace: PgCatalog.Types.Oid.parse(from.dictnamespace),
dictowner: PgCatalog.Types.Oid.parse(from.dictowner),
dicttemplate: PgCatalog.Types.Oid.parse(from.dicttemplate),
dictinitoption: PgCatalog.Types.Text.parse(from.dictinitoption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsDict.parse(e));
    
}


}
export namespace PgTsParser {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParser.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
prsname: PgCatalog.Types.Name.parse(from.prsname),
prsnamespace: PgCatalog.Types.Oid.parse(from.prsnamespace),
prsstart: PgCatalog.Types.Regproc.parse(from.prsstart),
prstoken: PgCatalog.Types.Regproc.parse(from.prstoken),
prsend: PgCatalog.Types.Regproc.parse(from.prsend),
prsheadline: PgCatalog.Types.Regproc.parse(from.prsheadline),
prslextype: PgCatalog.Types.Regproc.parse(from.prslextype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsParser.parse(e));
    
}


}
export namespace PgTsTemplate {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplate.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
tmplname: PgCatalog.Types.Name.parse(from.tmplname),
tmplnamespace: PgCatalog.Types.Oid.parse(from.tmplnamespace),
tmplinit: PgCatalog.Types.Regproc.parse(from.tmplinit),
tmpllexize: PgCatalog.Types.Regproc.parse(from.tmpllexize),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsTemplate.parse(e));
    
}


}
export namespace PgExtension {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtension.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
extname: PgCatalog.Types.Name.parse(from.extname),
extowner: PgCatalog.Types.Oid.parse(from.extowner),
extnamespace: PgCatalog.Types.Oid.parse(from.extnamespace),
extrelocatable: PgCatalog.Types.Bool.parse(from.extrelocatable),
extversion: PgCatalog.Types.Text.parse(from.extversion),
extconfig: PgCatalog.Types.OidArray.parse(from.extconfig),
extcondition: PgCatalog.Types.TextArray.parse(from.extcondition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgExtension.parse(e));
    
}


}
export namespace PgForeignDataWrapper {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapper.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
fdwname: PgCatalog.Types.Name.parse(from.fdwname),
fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
fdwhandler: PgCatalog.Types.Oid.parse(from.fdwhandler),
fdwvalidator: PgCatalog.Types.Oid.parse(from.fdwvalidator),
fdwacl: PgCatalog.Types.AclitemArray.parse(from.fdwacl),
fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignDataWrapper.parse(e));
    
}


}
export namespace PgForeignServer {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServer.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
srvname: PgCatalog.Types.Name.parse(from.srvname),
srvowner: PgCatalog.Types.Oid.parse(from.srvowner),
srvfdw: PgCatalog.Types.Oid.parse(from.srvfdw),
srvtype: PgCatalog.Types.Text.parse(from.srvtype),
srvversion: PgCatalog.Types.Text.parse(from.srvversion),
srvacl: PgCatalog.Types.AclitemArray.parse(from.srvacl),
srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignServer.parse(e));
    
}


}
export namespace PgUserMapping {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMapping.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
umserver: PgCatalog.Types.Oid.parse(from.umserver),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUserMapping.parse(e));
    
}


}
export namespace PgForeignTable {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignTable.is(from)) {
  return {
ftrelid: PgCatalog.Types.Oid.parse(from.ftrelid),
ftserver: PgCatalog.Types.Oid.parse(from.ftserver),
ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignTableArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignTable.parse(e));
    
}


}
export namespace PgPolicy {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicy.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
polname: PgCatalog.Types.Name.parse(from.polname),
polrelid: PgCatalog.Types.Oid.parse(from.polrelid),
polcmd: PgCatalog.Types.Char.parse(from.polcmd),
polpermissive: PgCatalog.Types.Bool.parse(from.polpermissive),
polroles: PgCatalog.Types.OidArray.parse(from.polroles),
polqual: PgCatalog.Types.PgNodeTree.parse(from.polqual),
polwithcheck: PgCatalog.Types.PgNodeTree.parse(from.polwithcheck),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPolicy.parse(e));
    
}


}
export namespace PgReplicationOrigin {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOrigin.is(from)) {
  return {
roident: PgCatalog.Types.Oid.parse(from.roident),
roname: PgCatalog.Types.Text.parse(from.roname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationOrigin.parse(e));
    
}


}
export namespace PgDefaultAcl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAcl.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
defaclrole: PgCatalog.Types.Oid.parse(from.defaclrole),
defaclnamespace: PgCatalog.Types.Oid.parse(from.defaclnamespace),
defaclobjtype: PgCatalog.Types.Char.parse(from.defaclobjtype),
defaclacl: PgCatalog.Types.AclitemArray.parse(from.defaclacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDefaultAcl.parse(e));
    
}


}
export namespace PgInitPrivs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInitPrivs.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
privtype: PgCatalog.Types.Char.parse(from.privtype),
initprivs: PgCatalog.Types.AclitemArray.parse(from.initprivs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInitPrivsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgInitPrivs.parse(e));
    
}


}
export namespace PgSeclabel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabel.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSeclabel.parse(e));
    
}


}
export namespace PgShseclabel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShseclabel.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShseclabelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShseclabel.parse(e));
    
}


}
export namespace PgCollation {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollation.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
collname: PgCatalog.Types.Name.parse(from.collname),
collnamespace: PgCatalog.Types.Oid.parse(from.collnamespace),
collowner: PgCatalog.Types.Oid.parse(from.collowner),
collprovider: PgCatalog.Types.Char.parse(from.collprovider),
collisdeterministic: PgCatalog.Types.Bool.parse(from.collisdeterministic),
collencoding: PgCatalog.Types.Int4.parse(from.collencoding),
collcollate: PgCatalog.Types.Text.parse(from.collcollate),
collctype: PgCatalog.Types.Text.parse(from.collctype),
colliculocale: PgCatalog.Types.Text.parse(from.colliculocale),
collicurules: PgCatalog.Types.Text.parse(from.collicurules),
collversion: PgCatalog.Types.Text.parse(from.collversion),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCollation.parse(e));
    
}


}
export namespace PgParameterAcl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAcl.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
parname: PgCatalog.Types.Text.parse(from.parname),
paracl: PgCatalog.Types.AclitemArray.parse(from.paracl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgParameterAcl.parse(e));
    
}


}
export namespace PgPartitionedTable {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPartitionedTable.is(from)) {
  return {
partrelid: PgCatalog.Types.Oid.parse(from.partrelid),
partstrat: PgCatalog.Types.Char.parse(from.partstrat),
partnatts: PgCatalog.Types.Int2.parse(from.partnatts),
partdefid: PgCatalog.Types.Oid.parse(from.partdefid),
partattrs: PgCatalog.Types.Int2vector.parse(from.partattrs),
partclass: PgCatalog.Types.Oidvector.parse(from.partclass),
partcollation: PgCatalog.Types.Oidvector.parse(from.partcollation),
partexprs: PgCatalog.Types.PgNodeTree.parse(from.partexprs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPartitionedTableArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPartitionedTable.parse(e));
    
}


}
export namespace PgRange {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRange.is(from)) {
  return {
rngtypid: PgCatalog.Types.Oid.parse(from.rngtypid),
rngsubtype: PgCatalog.Types.Oid.parse(from.rngsubtype),
rngmultitypid: PgCatalog.Types.Oid.parse(from.rngmultitypid),
rngcollation: PgCatalog.Types.Oid.parse(from.rngcollation),
rngsubopc: PgCatalog.Types.Oid.parse(from.rngsubopc),
rngcanonical: PgCatalog.Types.Regproc.parse(from.rngcanonical),
rngsubdiff: PgCatalog.Types.Regproc.parse(from.rngsubdiff),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRange.parse(e));
    
}


}
export namespace PgTransform {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransform.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
trftype: PgCatalog.Types.Oid.parse(from.trftype),
trflang: PgCatalog.Types.Oid.parse(from.trflang),
trffromsql: PgCatalog.Types.Regproc.parse(from.trffromsql),
trftosql: PgCatalog.Types.Regproc.parse(from.trftosql),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTransform.parse(e));
    
}


}
export namespace PgSequence {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequence.is(from)) {
  return {
seqrelid: PgCatalog.Types.Oid.parse(from.seqrelid),
seqtypid: PgCatalog.Types.Oid.parse(from.seqtypid),
seqstart: PgCatalog.Types.Int8.parse(from.seqstart),
seqincrement: PgCatalog.Types.Int8.parse(from.seqincrement),
seqmax: PgCatalog.Types.Int8.parse(from.seqmax),
seqmin: PgCatalog.Types.Int8.parse(from.seqmin),
seqcache: PgCatalog.Types.Int8.parse(from.seqcache),
seqcycle: PgCatalog.Types.Bool.parse(from.seqcycle),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequenceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSequence.parse(e));
    
}


}
export namespace PgPublication {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublication.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
pubname: PgCatalog.Types.Name.parse(from.pubname),
pubowner: PgCatalog.Types.Oid.parse(from.pubowner),
puballtables: PgCatalog.Types.Bool.parse(from.puballtables),
pubinsert: PgCatalog.Types.Bool.parse(from.pubinsert),
pubupdate: PgCatalog.Types.Bool.parse(from.pubupdate),
pubdelete: PgCatalog.Types.Bool.parse(from.pubdelete),
pubtruncate: PgCatalog.Types.Bool.parse(from.pubtruncate),
pubviaroot: PgCatalog.Types.Bool.parse(from.pubviaroot),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublication.parse(e));
    
}


}
export namespace PgPublicationNamespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
pnpubid: PgCatalog.Types.Oid.parse(from.pnpubid),
pnnspid: PgCatalog.Types.Oid.parse(from.pnnspid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationNamespace.parse(e));
    
}


}
export namespace PgPublicationRel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRel.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
prrelid: PgCatalog.Types.Oid.parse(from.prrelid),
prqual: PgCatalog.Types.PgNodeTree.parse(from.prqual),
prattrs: PgCatalog.Types.Int2vector.parse(from.prattrs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationRel.parse(e));
    
}


}
export namespace PgSubscription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscription.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
subdbid: PgCatalog.Types.Oid.parse(from.subdbid),
subskiplsn: PgCatalog.Types.PgLsn.parse(from.subskiplsn),
subname: PgCatalog.Types.Name.parse(from.subname),
subowner: PgCatalog.Types.Oid.parse(from.subowner),
subenabled: PgCatalog.Types.Bool.parse(from.subenabled),
subbinary: PgCatalog.Types.Bool.parse(from.subbinary),
substream: PgCatalog.Types.Char.parse(from.substream),
subtwophasestate: PgCatalog.Types.Char.parse(from.subtwophasestate),
subdisableonerr: PgCatalog.Types.Bool.parse(from.subdisableonerr),
subpasswordrequired: PgCatalog.Types.Bool.parse(from.subpasswordrequired),
subrunasowner: PgCatalog.Types.Bool.parse(from.subrunasowner),
subconninfo: PgCatalog.Types.Text.parse(from.subconninfo),
subslotname: PgCatalog.Types.Name.parse(from.subslotname),
subsynccommit: PgCatalog.Types.Text.parse(from.subsynccommit),
subpublications: PgCatalog.Types.TextArray.parse(from.subpublications),
suborigin: PgCatalog.Types.Text.parse(from.suborigin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSubscription.parse(e));
    
}


}
export namespace PgSubscriptionRel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionRel.is(from)) {
  return {
srsubid: PgCatalog.Types.Oid.parse(from.srsubid),
srrelid: PgCatalog.Types.Oid.parse(from.srrelid),
srsubstate: PgCatalog.Types.Char.parse(from.srsubstate),
srsublsn: PgCatalog.Types.PgLsn.parse(from.srsublsn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionRelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSubscriptionRel.parse(e));
    
}


}
export namespace PgRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRoles.is(from)) {
  return {
rolname: PgCatalog.Types.Name.parse(from.rolname),
rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
rolvaliduntil: PgCatalog.Types.Timestamptz.parse(from.rolvaliduntil),
rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
rolconfig: PgCatalog.Types.TextArray.parse(from.rolconfig),
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRoles.parse(e));
    
}


}
export namespace PgShadow {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShadow.is(from)) {
  return {
usename: PgCatalog.Types.Name.parse(from.usename),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
userepl: PgCatalog.Types.Bool.parse(from.userepl),
usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
passwd: PgCatalog.Types.Text.parse(from.passwd),
valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShadowArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShadow.parse(e));
    
}


}
export namespace PgGroup {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgGroup.is(from)) {
  return {
groname: PgCatalog.Types.Name.parse(from.groname),
grosysid: PgCatalog.Types.Oid.parse(from.grosysid),
grolist: PgCatalog.Types.OidArray.parse(from.grolist),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgGroupArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgGroup.parse(e));
    
}


}
export namespace PgUser {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUser.is(from)) {
  return {
usename: PgCatalog.Types.Name.parse(from.usename),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
userepl: PgCatalog.Types.Bool.parse(from.userepl),
usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
passwd: PgCatalog.Types.Text.parse(from.passwd),
valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUser.parse(e));
    
}


}
export namespace PgPolicies {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicies.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
policyname: PgCatalog.Types.Name.parse(from.policyname),
permissive: PgCatalog.Types.Text.parse(from.permissive),
roles: PgCatalog.Types.NameArray.parse(from.roles),
cmd: PgCatalog.Types.Text.parse(from.cmd),
qual: PgCatalog.Types.Text.parse(from.qual),
withCheck: PgCatalog.Types.Text.parse(from.withCheck),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPoliciesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPolicies.parse(e));
    
}


}
export namespace PgRules {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRules.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
rulename: PgCatalog.Types.Name.parse(from.rulename),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRulesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRules.parse(e));
    
}


}
export namespace PgViews {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgViews.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
viewname: PgCatalog.Types.Name.parse(from.viewname),
viewowner: PgCatalog.Types.Name.parse(from.viewowner),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgViewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgViews.parse(e));
    
}


}
export namespace PgTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTables.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
tableowner: PgCatalog.Types.Name.parse(from.tableowner),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
hasrules: PgCatalog.Types.Bool.parse(from.hasrules),
hastriggers: PgCatalog.Types.Bool.parse(from.hastriggers),
rowsecurity: PgCatalog.Types.Bool.parse(from.rowsecurity),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTables.parse(e));
    
}


}
export namespace PgMatviews {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgMatviews.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
matviewname: PgCatalog.Types.Name.parse(from.matviewname),
matviewowner: PgCatalog.Types.Name.parse(from.matviewowner),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
ispopulated: PgCatalog.Types.Bool.parse(from.ispopulated),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgMatviewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgMatviews.parse(e));
    
}


}
export namespace PgIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexes.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
indexname: PgCatalog.Types.Name.parse(from.indexname),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
indexdef: PgCatalog.Types.Text.parse(from.indexdef),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIndexes.parse(e));
    
}


}
export namespace PgSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequences.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
sequencename: PgCatalog.Types.Name.parse(from.sequencename),
sequenceowner: PgCatalog.Types.Name.parse(from.sequenceowner),
dataType: PgCatalog.Types.Regtype.parse(from.dataType),
startValue: PgCatalog.Types.Int8.parse(from.startValue),
minValue: PgCatalog.Types.Int8.parse(from.minValue),
maxValue: PgCatalog.Types.Int8.parse(from.maxValue),
incrementBy: PgCatalog.Types.Int8.parse(from.incrementBy),
cycle: PgCatalog.Types.Bool.parse(from.cycle),
cacheSize: PgCatalog.Types.Int8.parse(from.cacheSize),
lastValue: PgCatalog.Types.Int8.parse(from.lastValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSequences.parse(e));
    
}


}
export namespace PgStats {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStats.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
attname: PgCatalog.Types.Name.parse(from.attname),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
mostCommonFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonFreqs),
histogramBounds: PgCatalog.Types.Anyarray.parse(from.histogramBounds),
correlation: PgCatalog.Types.Float4.parse(from.correlation),
mostCommonElems: PgCatalog.Types.Anyarray.parse(from.mostCommonElems),
mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonElemFreqs),
elemCountHistogram: PgCatalog.Types.Float4Array.parse(from.elemCountHistogram),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStats.parse(e));
    
}


}
export namespace PgStatsExt {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatsExt.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
statisticsSchemaname: PgCatalog.Types.Name.parse(from.statisticsSchemaname),
statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
attnames: PgCatalog.Types.NameArray.parse(from.attnames),
exprs: PgCatalog.Types.TextArray.parse(from.exprs),
kinds: PgCatalog.Types.CharArray.parse(from.kinds),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nDistinct: PgCatalog.Types.PgNdistinct.parse(from.nDistinct),
dependencies: PgCatalog.Types.PgDependencies.parse(from.dependencies),
mostCommonVals: PgCatalog.Types.TextArray.parse(from.mostCommonVals),
mostCommonValNulls: PgCatalog.Types.BoolArray.parse(from.mostCommonValNulls),
mostCommonFreqs: PgCatalog.Types.Float8Array.parse(from.mostCommonFreqs),
mostCommonBaseFreqs: PgCatalog.Types.Float8Array.parse(from.mostCommonBaseFreqs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsExtArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatsExt.parse(e));
    
}


}
export namespace PgStatsExtExprs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatsExtExprs.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
statisticsSchemaname: PgCatalog.Types.Name.parse(from.statisticsSchemaname),
statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
expr: PgCatalog.Types.Text.parse(from.expr),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
mostCommonFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonFreqs),
histogramBounds: PgCatalog.Types.Anyarray.parse(from.histogramBounds),
correlation: PgCatalog.Types.Float4.parse(from.correlation),
mostCommonElems: PgCatalog.Types.Anyarray.parse(from.mostCommonElems),
mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonElemFreqs),
elemCountHistogram: PgCatalog.Types.Float4Array.parse(from.elemCountHistogram),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsExtExprsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatsExtExprs.parse(e));
    
}


}
export namespace PgPublicationTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationTables.is(from)) {
  return {
pubname: PgCatalog.Types.Name.parse(from.pubname),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
attnames: PgCatalog.Types.NameArray.parse(from.attnames),
rowfilter: PgCatalog.Types.Text.parse(from.rowfilter),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationTables.parse(e));
    
}


}
export namespace PgLocks {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLocks.is(from)) {
  return {
locktype: PgCatalog.Types.Text.parse(from.locktype),
database: PgCatalog.Types.Oid.parse(from.database),
relation: PgCatalog.Types.Oid.parse(from.relation),
page: PgCatalog.Types.Int4.parse(from.page),
tuple: PgCatalog.Types.Int2.parse(from.tuple),
virtualxid: PgCatalog.Types.Text.parse(from.virtualxid),
transactionid: PgCatalog.Types.Xid.parse(from.transactionid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int2.parse(from.objsubid),
virtualtransaction: PgCatalog.Types.Text.parse(from.virtualtransaction),
pid: PgCatalog.Types.Int4.parse(from.pid),
mode: PgCatalog.Types.Text.parse(from.mode),
granted: PgCatalog.Types.Bool.parse(from.granted),
fastpath: PgCatalog.Types.Bool.parse(from.fastpath),
waitstart: PgCatalog.Types.Timestamptz.parse(from.waitstart),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLocksArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLocks.parse(e));
    
}


}
export namespace PgCursors {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCursors.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
statement: PgCatalog.Types.Text.parse(from.statement),
isHoldable: PgCatalog.Types.Bool.parse(from.isHoldable),
isBinary: PgCatalog.Types.Bool.parse(from.isBinary),
isScrollable: PgCatalog.Types.Bool.parse(from.isScrollable),
creationTime: PgCatalog.Types.Timestamptz.parse(from.creationTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCursorsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCursors.parse(e));
    
}


}
export namespace PgAvailableExtensions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAvailableExtensions.is(from)) {
  return {
name: PgCatalog.Types.Name.parse(from.name),
defaultVersion: PgCatalog.Types.Text.parse(from.defaultVersion),
installedVersion: PgCatalog.Types.Text.parse(from.installedVersion),
comment: PgCatalog.Types.Text.parse(from.comment),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAvailableExtensionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAvailableExtensions.parse(e));
    
}


}
export namespace PgAvailableExtensionVersions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAvailableExtensionVersions.is(from)) {
  return {
name: PgCatalog.Types.Name.parse(from.name),
version: PgCatalog.Types.Text.parse(from.version),
installed: PgCatalog.Types.Bool.parse(from.installed),
superuser: PgCatalog.Types.Bool.parse(from.superuser),
trusted: PgCatalog.Types.Bool.parse(from.trusted),
relocatable: PgCatalog.Types.Bool.parse(from.relocatable),
schema: PgCatalog.Types.Name.parse(from.schema),
requires: PgCatalog.Types.NameArray.parse(from.requires),
comment: PgCatalog.Types.Text.parse(from.comment),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAvailableExtensionVersionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAvailableExtensionVersions.parse(e));
    
}


}
export namespace PgPreparedXacts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPreparedXacts.is(from)) {
  return {
transaction: PgCatalog.Types.Xid.parse(from.transaction),
gid: PgCatalog.Types.Text.parse(from.gid),
prepared: PgCatalog.Types.Timestamptz.parse(from.prepared),
owner: PgCatalog.Types.Name.parse(from.owner),
database: PgCatalog.Types.Name.parse(from.database),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPreparedXactsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPreparedXacts.parse(e));
    
}


}
export namespace PgPreparedStatements {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPreparedStatements.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
statement: PgCatalog.Types.Text.parse(from.statement),
prepareTime: PgCatalog.Types.Timestamptz.parse(from.prepareTime),
parameterTypes: PgCatalog.Types.RegtypeArray.parse(from.parameterTypes),
resultTypes: PgCatalog.Types.RegtypeArray.parse(from.resultTypes),
fromSql: PgCatalog.Types.Bool.parse(from.fromSql),
genericPlans: PgCatalog.Types.Int8.parse(from.genericPlans),
customPlans: PgCatalog.Types.Int8.parse(from.customPlans),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPreparedStatementsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPreparedStatements.parse(e));
    
}


}
export namespace PgSeclabels {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabels.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
objtype: PgCatalog.Types.Text.parse(from.objtype),
objnamespace: PgCatalog.Types.Oid.parse(from.objnamespace),
objname: PgCatalog.Types.Text.parse(from.objname),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSeclabels.parse(e));
    
}


}
export namespace PgSettings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSettings.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
unit: PgCatalog.Types.Text.parse(from.unit),
category: PgCatalog.Types.Text.parse(from.category),
shortDesc: PgCatalog.Types.Text.parse(from.shortDesc),
extraDesc: PgCatalog.Types.Text.parse(from.extraDesc),
context: PgCatalog.Types.Text.parse(from.context),
vartype: PgCatalog.Types.Text.parse(from.vartype),
source: PgCatalog.Types.Text.parse(from.source),
minVal: PgCatalog.Types.Text.parse(from.minVal),
maxVal: PgCatalog.Types.Text.parse(from.maxVal),
enumvals: PgCatalog.Types.TextArray.parse(from.enumvals),
bootVal: PgCatalog.Types.Text.parse(from.bootVal),
resetVal: PgCatalog.Types.Text.parse(from.resetVal),
sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
pendingRestart: PgCatalog.Types.Bool.parse(from.pendingRestart),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSettingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSettings.parse(e));
    
}


}
export namespace PgFileSettings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgFileSettings.is(from)) {
  return {
sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
seqno: PgCatalog.Types.Int4.parse(from.seqno),
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
applied: PgCatalog.Types.Bool.parse(from.applied),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgFileSettingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgFileSettings.parse(e));
    
}


}
export namespace PgHbaFileRules {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgHbaFileRules.is(from)) {
  return {
ruleNumber: PgCatalog.Types.Int4.parse(from.ruleNumber),
fileName: PgCatalog.Types.Text.parse(from.fileName),
lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
type: PgCatalog.Types.Text.parse(from.type),
database: PgCatalog.Types.TextArray.parse(from.database),
userName: PgCatalog.Types.TextArray.parse(from.userName),
address: PgCatalog.Types.Text.parse(from.address),
netmask: PgCatalog.Types.Text.parse(from.netmask),
authMethod: PgCatalog.Types.Text.parse(from.authMethod),
options: PgCatalog.Types.TextArray.parse(from.options),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgHbaFileRulesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgHbaFileRules.parse(e));
    
}


}
export namespace PgIdentFileMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIdentFileMappings.is(from)) {
  return {
mapNumber: PgCatalog.Types.Int4.parse(from.mapNumber),
fileName: PgCatalog.Types.Text.parse(from.fileName),
lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
mapName: PgCatalog.Types.Text.parse(from.mapName),
sysName: PgCatalog.Types.Text.parse(from.sysName),
pgUsername: PgCatalog.Types.Text.parse(from.pgUsername),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIdentFileMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIdentFileMappings.parse(e));
    
}


}
export namespace PgTimezoneAbbrevs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTimezoneAbbrevs.is(from)) {
  return {
abbrev: PgCatalog.Types.Text.parse(from.abbrev),
utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
isDst: PgCatalog.Types.Bool.parse(from.isDst),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTimezoneAbbrevsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTimezoneAbbrevs.parse(e));
    
}


}
export namespace PgTimezoneNames {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTimezoneNames.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
abbrev: PgCatalog.Types.Text.parse(from.abbrev),
utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
isDst: PgCatalog.Types.Bool.parse(from.isDst),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTimezoneNamesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTimezoneNames.parse(e));
    
}


}
export namespace PgConfig {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConfig.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConfig.parse(e));
    
}


}
export namespace PgShmemAllocations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShmemAllocations.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
off: PgCatalog.Types.Int8.parse(from.off),
size: PgCatalog.Types.Int8.parse(from.size),
allocatedSize: PgCatalog.Types.Int8.parse(from.allocatedSize),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShmemAllocationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShmemAllocations.parse(e));
    
}


}
export namespace PgBackendMemoryContexts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgBackendMemoryContexts.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
ident: PgCatalog.Types.Text.parse(from.ident),
parent: PgCatalog.Types.Text.parse(from.parent),
level: PgCatalog.Types.Int4.parse(from.level),
totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
totalNblocks: PgCatalog.Types.Int8.parse(from.totalNblocks),
freeBytes: PgCatalog.Types.Int8.parse(from.freeBytes),
freeChunks: PgCatalog.Types.Int8.parse(from.freeChunks),
usedBytes: PgCatalog.Types.Int8.parse(from.usedBytes),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgBackendMemoryContextsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgBackendMemoryContexts.parse(e));
    
}


}
export namespace PgStatAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatAllTables.parse(e));
    
}


}
export namespace PgStatXactAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactAllTables.parse(e));
    
}


}
export namespace PgStatSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSysTables.parse(e));
    
}


}
export namespace PgStatXactSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactSysTables.parse(e));
    
}


}
export namespace PgStatUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserTables.parse(e));
    
}


}
export namespace PgStatXactUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactUserTables.parse(e));
    
}


}
export namespace PgStatioAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllTables.parse(e));
    
}


}
export namespace PgStatioSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysTables.parse(e));
    
}


}
export namespace PgStatioUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserTables.parse(e));
    
}


}
export namespace PgStatAllIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatAllIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatAllIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatAllIndexes.parse(e));
    
}


}
export namespace PgStatSysIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSysIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSysIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSysIndexes.parse(e));
    
}


}
export namespace PgStatUserIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserIndexes.parse(e));
    
}


}
export namespace PgStatioAllIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllIndexes.parse(e));
    
}


}
export namespace PgStatioSysIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysIndexes.parse(e));
    
}


}
export namespace PgStatioUserIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserIndexes.parse(e));
    
}


}
export namespace PgStatioAllSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllSequences.parse(e));
    
}


}
export namespace PgStatioSysSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysSequences.parse(e));
    
}


}
export namespace PgStatioUserSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserSequences.parse(e));
    
}


}
export namespace PgStatActivity {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatActivity.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
pid: PgCatalog.Types.Int4.parse(from.pid),
leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usename: PgCatalog.Types.Name.parse(from.usename),
applicationName: PgCatalog.Types.Text.parse(from.applicationName),
clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
xactStart: PgCatalog.Types.Timestamptz.parse(from.xactStart),
queryStart: PgCatalog.Types.Timestamptz.parse(from.queryStart),
stateChange: PgCatalog.Types.Timestamptz.parse(from.stateChange),
waitEventType: PgCatalog.Types.Text.parse(from.waitEventType),
waitEvent: PgCatalog.Types.Text.parse(from.waitEvent),
state: PgCatalog.Types.Text.parse(from.state),
backendXid: PgCatalog.Types.Xid.parse(from.backendXid),
backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
queryId: PgCatalog.Types.Int8.parse(from.queryId),
query: PgCatalog.Types.Text.parse(from.query),
backendType: PgCatalog.Types.Text.parse(from.backendType),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatActivityArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatActivity.parse(e));
    
}


}
export namespace PgStatReplication {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatReplication.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usename: PgCatalog.Types.Name.parse(from.usename),
applicationName: PgCatalog.Types.Text.parse(from.applicationName),
clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
state: PgCatalog.Types.Text.parse(from.state),
sentLsn: PgCatalog.Types.PgLsn.parse(from.sentLsn),
writeLsn: PgCatalog.Types.PgLsn.parse(from.writeLsn),
flushLsn: PgCatalog.Types.PgLsn.parse(from.flushLsn),
replayLsn: PgCatalog.Types.PgLsn.parse(from.replayLsn),
writeLag: PgCatalog.Types.Interval.parse(from.writeLag),
flushLag: PgCatalog.Types.Interval.parse(from.flushLag),
replayLag: PgCatalog.Types.Interval.parse(from.replayLag),
syncPriority: PgCatalog.Types.Int4.parse(from.syncPriority),
syncState: PgCatalog.Types.Text.parse(from.syncState),
replyTime: PgCatalog.Types.Timestamptz.parse(from.replyTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatReplicationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatReplication.parse(e));
    
}


}
export namespace PgStatSlru {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSlru.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
blksZeroed: PgCatalog.Types.Int8.parse(from.blksZeroed),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksWritten: PgCatalog.Types.Int8.parse(from.blksWritten),
blksExists: PgCatalog.Types.Int8.parse(from.blksExists),
flushes: PgCatalog.Types.Int8.parse(from.flushes),
truncates: PgCatalog.Types.Int8.parse(from.truncates),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSlruArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSlru.parse(e));
    
}


}
export namespace PgStatWalReceiver {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatWalReceiver.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
status: PgCatalog.Types.Text.parse(from.status),
receiveStartLsn: PgCatalog.Types.PgLsn.parse(from.receiveStartLsn),
receiveStartTli: PgCatalog.Types.Int4.parse(from.receiveStartTli),
writtenLsn: PgCatalog.Types.PgLsn.parse(from.writtenLsn),
flushedLsn: PgCatalog.Types.PgLsn.parse(from.flushedLsn),
receivedTli: PgCatalog.Types.Int4.parse(from.receivedTli),
lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgSendTime),
lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgReceiptTime),
latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
latestEndTime: PgCatalog.Types.Timestamptz.parse(from.latestEndTime),
slotName: PgCatalog.Types.Text.parse(from.slotName),
senderHost: PgCatalog.Types.Text.parse(from.senderHost),
senderPort: PgCatalog.Types.Int4.parse(from.senderPort),
conninfo: PgCatalog.Types.Text.parse(from.conninfo),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatWalReceiverArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatWalReceiver.parse(e));
    
}


}
export namespace PgStatRecoveryPrefetch {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatRecoveryPrefetch.is(from)) {
  return {
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
prefetch: PgCatalog.Types.Int8.parse(from.prefetch),
hit: PgCatalog.Types.Int8.parse(from.hit),
skipInit: PgCatalog.Types.Int8.parse(from.skipInit),
skipNew: PgCatalog.Types.Int8.parse(from.skipNew),
skipFpw: PgCatalog.Types.Int8.parse(from.skipFpw),
skipRep: PgCatalog.Types.Int8.parse(from.skipRep),
walDistance: PgCatalog.Types.Int4.parse(from.walDistance),
blockDistance: PgCatalog.Types.Int4.parse(from.blockDistance),
ioDepth: PgCatalog.Types.Int4.parse(from.ioDepth),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatRecoveryPrefetchArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatRecoveryPrefetch.parse(e));
    
}


}
export namespace PgStatSubscription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSubscription.is(from)) {
  return {
subid: PgCatalog.Types.Oid.parse(from.subid),
subname: PgCatalog.Types.Name.parse(from.subname),
pid: PgCatalog.Types.Int4.parse(from.pid),
leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
relid: PgCatalog.Types.Oid.parse(from.relid),
receivedLsn: PgCatalog.Types.PgLsn.parse(from.receivedLsn),
lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgSendTime),
lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgReceiptTime),
latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
latestEndTime: PgCatalog.Types.Timestamptz.parse(from.latestEndTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSubscriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSubscription.parse(e));
    
}


}
export namespace PgStatSsl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSsl.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
ssl: PgCatalog.Types.Bool.parse(from.ssl),
version: PgCatalog.Types.Text.parse(from.version),
cipher: PgCatalog.Types.Text.parse(from.cipher),
bits: PgCatalog.Types.Int4.parse(from.bits),
clientDn: PgCatalog.Types.Text.parse(from.clientDn),
clientSerial: PgCatalog.Types.Numeric.parse(from.clientSerial),
issuerDn: PgCatalog.Types.Text.parse(from.issuerDn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSslArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSsl.parse(e));
    
}


}
export namespace PgStatGssapi {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatGssapi.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
gssAuthenticated: PgCatalog.Types.Bool.parse(from.gssAuthenticated),
principal: PgCatalog.Types.Text.parse(from.principal),
encrypted: PgCatalog.Types.Bool.parse(from.encrypted),
credentialsDelegated: PgCatalog.Types.Bool.parse(from.credentialsDelegated),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatGssapiArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatGssapi.parse(e));
    
}


}
export namespace PgReplicationSlots {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationSlots.is(from)) {
  return {
slotName: PgCatalog.Types.Name.parse(from.slotName),
plugin: PgCatalog.Types.Name.parse(from.plugin),
slotType: PgCatalog.Types.Text.parse(from.slotType),
datoid: PgCatalog.Types.Oid.parse(from.datoid),
database: PgCatalog.Types.Name.parse(from.database),
temporary: PgCatalog.Types.Bool.parse(from.temporary),
active: PgCatalog.Types.Bool.parse(from.active),
activePid: PgCatalog.Types.Int4.parse(from.activePid),
xmin: PgCatalog.Types.Xid.parse(from.xmin),
catalogXmin: PgCatalog.Types.Xid.parse(from.catalogXmin),
restartLsn: PgCatalog.Types.PgLsn.parse(from.restartLsn),
confirmedFlushLsn: PgCatalog.Types.PgLsn.parse(from.confirmedFlushLsn),
walStatus: PgCatalog.Types.Text.parse(from.walStatus),
safeWalSize: PgCatalog.Types.Int8.parse(from.safeWalSize),
twoPhase: PgCatalog.Types.Bool.parse(from.twoPhase),
conflicting: PgCatalog.Types.Bool.parse(from.conflicting),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationSlotsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationSlots.parse(e));
    
}


}
export namespace PgStatReplicationSlots {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatReplicationSlots.is(from)) {
  return {
slotName: PgCatalog.Types.Text.parse(from.slotName),
spillTxns: PgCatalog.Types.Int8.parse(from.spillTxns),
spillCount: PgCatalog.Types.Int8.parse(from.spillCount),
spillBytes: PgCatalog.Types.Int8.parse(from.spillBytes),
streamTxns: PgCatalog.Types.Int8.parse(from.streamTxns),
streamCount: PgCatalog.Types.Int8.parse(from.streamCount),
streamBytes: PgCatalog.Types.Int8.parse(from.streamBytes),
totalTxns: PgCatalog.Types.Int8.parse(from.totalTxns),
totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatReplicationSlotsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatReplicationSlots.parse(e));
    
}


}
export namespace PgStatDatabase {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatDatabase.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
numbackends: PgCatalog.Types.Int4.parse(from.numbackends),
xactCommit: PgCatalog.Types.Int8.parse(from.xactCommit),
xactRollback: PgCatalog.Types.Int8.parse(from.xactRollback),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
tupReturned: PgCatalog.Types.Int8.parse(from.tupReturned),
tupFetched: PgCatalog.Types.Int8.parse(from.tupFetched),
tupInserted: PgCatalog.Types.Int8.parse(from.tupInserted),
tupUpdated: PgCatalog.Types.Int8.parse(from.tupUpdated),
tupDeleted: PgCatalog.Types.Int8.parse(from.tupDeleted),
conflicts: PgCatalog.Types.Int8.parse(from.conflicts),
tempFiles: PgCatalog.Types.Int8.parse(from.tempFiles),
tempBytes: PgCatalog.Types.Int8.parse(from.tempBytes),
deadlocks: PgCatalog.Types.Int8.parse(from.deadlocks),
checksumFailures: PgCatalog.Types.Int8.parse(from.checksumFailures),
checksumLastFailure: PgCatalog.Types.Timestamptz.parse(from.checksumLastFailure),
blkReadTime: PgCatalog.Types.Float8.parse(from.blkReadTime),
blkWriteTime: PgCatalog.Types.Float8.parse(from.blkWriteTime),
sessionTime: PgCatalog.Types.Float8.parse(from.sessionTime),
activeTime: PgCatalog.Types.Float8.parse(from.activeTime),
idleInTransactionTime: PgCatalog.Types.Float8.parse(from.idleInTransactionTime),
sessions: PgCatalog.Types.Int8.parse(from.sessions),
sessionsAbandoned: PgCatalog.Types.Int8.parse(from.sessionsAbandoned),
sessionsFatal: PgCatalog.Types.Int8.parse(from.sessionsFatal),
sessionsKilled: PgCatalog.Types.Int8.parse(from.sessionsKilled),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatDatabaseArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatDatabase.parse(e));
    
}


}
export namespace PgStatDatabaseConflicts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatDatabaseConflicts.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
conflTablespace: PgCatalog.Types.Int8.parse(from.conflTablespace),
conflLock: PgCatalog.Types.Int8.parse(from.conflLock),
conflSnapshot: PgCatalog.Types.Int8.parse(from.conflSnapshot),
conflBufferpin: PgCatalog.Types.Int8.parse(from.conflBufferpin),
conflDeadlock: PgCatalog.Types.Int8.parse(from.conflDeadlock),
conflActiveLogicalslot: PgCatalog.Types.Int8.parse(from.conflActiveLogicalslot),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatDatabaseConflictsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatDatabaseConflicts.parse(e));
    
}


}
export namespace PgStatUserFunctions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserFunctions.is(from)) {
  return {
funcid: PgCatalog.Types.Oid.parse(from.funcid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
funcname: PgCatalog.Types.Name.parse(from.funcname),
calls: PgCatalog.Types.Int8.parse(from.calls),
totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserFunctionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserFunctions.parse(e));
    
}


}
export namespace PgStatXactUserFunctions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactUserFunctions.is(from)) {
  return {
funcid: PgCatalog.Types.Oid.parse(from.funcid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
funcname: PgCatalog.Types.Name.parse(from.funcname),
calls: PgCatalog.Types.Int8.parse(from.calls),
totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactUserFunctionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactUserFunctions.parse(e));
    
}


}
export namespace PgStatArchiver {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatArchiver.is(from)) {
  return {
archivedCount: PgCatalog.Types.Int8.parse(from.archivedCount),
lastArchivedWal: PgCatalog.Types.Text.parse(from.lastArchivedWal),
lastArchivedTime: PgCatalog.Types.Timestamptz.parse(from.lastArchivedTime),
failedCount: PgCatalog.Types.Int8.parse(from.failedCount),
lastFailedWal: PgCatalog.Types.Text.parse(from.lastFailedWal),
lastFailedTime: PgCatalog.Types.Timestamptz.parse(from.lastFailedTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatArchiverArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatArchiver.parse(e));
    
}


}
export namespace PgStatBgwriter {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatBgwriter.is(from)) {
  return {
checkpointsTimed: PgCatalog.Types.Int8.parse(from.checkpointsTimed),
checkpointsReq: PgCatalog.Types.Int8.parse(from.checkpointsReq),
checkpointWriteTime: PgCatalog.Types.Float8.parse(from.checkpointWriteTime),
checkpointSyncTime: PgCatalog.Types.Float8.parse(from.checkpointSyncTime),
buffersCheckpoint: PgCatalog.Types.Int8.parse(from.buffersCheckpoint),
buffersClean: PgCatalog.Types.Int8.parse(from.buffersClean),
maxwrittenClean: PgCatalog.Types.Int8.parse(from.maxwrittenClean),
buffersBackend: PgCatalog.Types.Int8.parse(from.buffersBackend),
buffersBackendFsync: PgCatalog.Types.Int8.parse(from.buffersBackendFsync),
buffersAlloc: PgCatalog.Types.Int8.parse(from.buffersAlloc),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatBgwriterArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatBgwriter.parse(e));
    
}


}
export namespace PgStatIo {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatIo.is(from)) {
  return {
backendType: PgCatalog.Types.Text.parse(from.backendType),
object: PgCatalog.Types.Text.parse(from.object),
context: PgCatalog.Types.Text.parse(from.context),
reads: PgCatalog.Types.Int8.parse(from.reads),
readTime: PgCatalog.Types.Float8.parse(from.readTime),
writes: PgCatalog.Types.Int8.parse(from.writes),
writeTime: PgCatalog.Types.Float8.parse(from.writeTime),
writebacks: PgCatalog.Types.Int8.parse(from.writebacks),
writebackTime: PgCatalog.Types.Float8.parse(from.writebackTime),
extends: PgCatalog.Types.Int8.parse(from.extends),
extendTime: PgCatalog.Types.Float8.parse(from.extendTime),
opBytes: PgCatalog.Types.Int8.parse(from.opBytes),
hits: PgCatalog.Types.Int8.parse(from.hits),
evictions: PgCatalog.Types.Int8.parse(from.evictions),
reuses: PgCatalog.Types.Int8.parse(from.reuses),
fsyncs: PgCatalog.Types.Int8.parse(from.fsyncs),
fsyncTime: PgCatalog.Types.Float8.parse(from.fsyncTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatIoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatIo.parse(e));
    
}


}
export namespace PgStatWal {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatWal.is(from)) {
  return {
walRecords: PgCatalog.Types.Int8.parse(from.walRecords),
walFpi: PgCatalog.Types.Int8.parse(from.walFpi),
walBytes: PgCatalog.Types.Numeric.parse(from.walBytes),
walBuffersFull: PgCatalog.Types.Int8.parse(from.walBuffersFull),
walWrite: PgCatalog.Types.Int8.parse(from.walWrite),
walSync: PgCatalog.Types.Int8.parse(from.walSync),
walWriteTime: PgCatalog.Types.Float8.parse(from.walWriteTime),
walSyncTime: PgCatalog.Types.Float8.parse(from.walSyncTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatWalArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatWal.parse(e));
    
}


}
export namespace PgStatProgressAnalyze {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressAnalyze.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
phase: PgCatalog.Types.Text.parse(from.phase),
sampleBlksTotal: PgCatalog.Types.Int8.parse(from.sampleBlksTotal),
sampleBlksScanned: PgCatalog.Types.Int8.parse(from.sampleBlksScanned),
extStatsTotal: PgCatalog.Types.Int8.parse(from.extStatsTotal),
extStatsComputed: PgCatalog.Types.Int8.parse(from.extStatsComputed),
childTablesTotal: PgCatalog.Types.Int8.parse(from.childTablesTotal),
childTablesDone: PgCatalog.Types.Int8.parse(from.childTablesDone),
currentChildTableRelid: PgCatalog.Types.Oid.parse(from.currentChildTableRelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressAnalyzeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressAnalyze.parse(e));
    
}


}
export namespace PgStatProgressVacuum {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressVacuum.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
phase: PgCatalog.Types.Text.parse(from.phase),
heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
heapBlksVacuumed: PgCatalog.Types.Int8.parse(from.heapBlksVacuumed),
indexVacuumCount: PgCatalog.Types.Int8.parse(from.indexVacuumCount),
maxDeadTuples: PgCatalog.Types.Int8.parse(from.maxDeadTuples),
numDeadTuples: PgCatalog.Types.Int8.parse(from.numDeadTuples),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressVacuumArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressVacuum.parse(e));
    
}


}
export namespace PgStatProgressCluster {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCluster.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
command: PgCatalog.Types.Text.parse(from.command),
phase: PgCatalog.Types.Text.parse(from.phase),
clusterIndexRelid: PgCatalog.Types.Oid.parse(from.clusterIndexRelid),
heapTuplesScanned: PgCatalog.Types.Int8.parse(from.heapTuplesScanned),
heapTuplesWritten: PgCatalog.Types.Int8.parse(from.heapTuplesWritten),
heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
indexRebuildCount: PgCatalog.Types.Int8.parse(from.indexRebuildCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressClusterArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCluster.parse(e));
    
}


}
export namespace PgStatProgressCreateIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCreateIndex.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
indexRelid: PgCatalog.Types.Oid.parse(from.indexRelid),
command: PgCatalog.Types.Text.parse(from.command),
phase: PgCatalog.Types.Text.parse(from.phase),
lockersTotal: PgCatalog.Types.Int8.parse(from.lockersTotal),
lockersDone: PgCatalog.Types.Int8.parse(from.lockersDone),
currentLockerPid: PgCatalog.Types.Int8.parse(from.currentLockerPid),
blocksTotal: PgCatalog.Types.Int8.parse(from.blocksTotal),
blocksDone: PgCatalog.Types.Int8.parse(from.blocksDone),
tuplesTotal: PgCatalog.Types.Int8.parse(from.tuplesTotal),
tuplesDone: PgCatalog.Types.Int8.parse(from.tuplesDone),
partitionsTotal: PgCatalog.Types.Int8.parse(from.partitionsTotal),
partitionsDone: PgCatalog.Types.Int8.parse(from.partitionsDone),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressCreateIndexArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCreateIndex.parse(e));
    
}


}
export namespace PgStatProgressBasebackup {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressBasebackup.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
phase: PgCatalog.Types.Text.parse(from.phase),
backupTotal: PgCatalog.Types.Int8.parse(from.backupTotal),
backupStreamed: PgCatalog.Types.Int8.parse(from.backupStreamed),
tablespacesTotal: PgCatalog.Types.Int8.parse(from.tablespacesTotal),
tablespacesStreamed: PgCatalog.Types.Int8.parse(from.tablespacesStreamed),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressBasebackupArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressBasebackup.parse(e));
    
}


}
export namespace PgStatProgressCopy {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCopy.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
command: PgCatalog.Types.Text.parse(from.command),
type: PgCatalog.Types.Text.parse(from.type),
bytesProcessed: PgCatalog.Types.Int8.parse(from.bytesProcessed),
bytesTotal: PgCatalog.Types.Int8.parse(from.bytesTotal),
tuplesProcessed: PgCatalog.Types.Int8.parse(from.tuplesProcessed),
tuplesExcluded: PgCatalog.Types.Int8.parse(from.tuplesExcluded),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressCopyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCopy.parse(e));
    
}


}
export namespace PgUserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappings.is(from)) {
  return {
umid: PgCatalog.Types.Oid.parse(from.umid),
srvid: PgCatalog.Types.Oid.parse(from.srvid),
srvname: PgCatalog.Types.Name.parse(from.srvname),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
usename: PgCatalog.Types.Name.parse(from.usename),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUserMappings.parse(e));
    
}


}
export namespace PgReplicationOriginStatus {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginStatus.is(from)) {
  return {
localId: PgCatalog.Types.Oid.parse(from.localId),
externalId: PgCatalog.Types.Text.parse(from.externalId),
remoteLsn: PgCatalog.Types.PgLsn.parse(from.remoteLsn),
localLsn: PgCatalog.Types.PgLsn.parse(from.localLsn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginStatusArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationOriginStatus.parse(e));
    
}


}
export namespace PgStatSubscriptionStats {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSubscriptionStats.is(from)) {
  return {
subid: PgCatalog.Types.Oid.parse(from.subid),
subname: PgCatalog.Types.Name.parse(from.subname),
applyErrorCount: PgCatalog.Types.Int8.parse(from.applyErrorCount),
syncErrorCount: PgCatalog.Types.Int8.parse(from.syncErrorCount),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSubscriptionStatsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSubscriptionStats.parse(e));
    
}


}
export namespace PgProcOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProcOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgProcPronameArgsNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProcPronameArgsNspIndex.is(from)) {
  return {
proname: PgCatalog.Types.Name.parse(from.proname),
proargtypes: PgCatalog.Types.Oidvector.parse(from.proargtypes),
pronamespace: PgCatalog.Types.Oid.parse(from.pronamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTypeOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTypeOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTypeTypnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTypeTypnameNspIndex.is(from)) {
  return {
typname: PgCatalog.Types.Name.parse(from.typname),
typnamespace: PgCatalog.Types.Oid.parse(from.typnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttributeRelidAttnamIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttributeRelidAttnamIndex.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attname: PgCatalog.Types.Name.parse(from.attname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttributeRelidAttnumIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttributeRelidAttnumIndex.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attnum: PgCatalog.Types.Int2.parse(from.attnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassRelnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassRelnameNspIndex.is(from)) {
  return {
relname: PgCatalog.Types.Name.parse(from.relname),
relnamespace: PgCatalog.Types.Oid.parse(from.relnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassTblspcRelfilenodeIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassTblspcRelfilenodeIndex.is(from)) {
  return {
reltablespace: PgCatalog.Types.Oid.parse(from.reltablespace),
relfilenode: PgCatalog.Types.Oid.parse(from.relfilenode),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefAdrelidAdnumIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdefAdrelidAdnumIndex.is(from)) {
  return {
adrelid: PgCatalog.Types.Oid.parse(from.adrelid),
adnum: PgCatalog.Types.Int2.parse(from.adnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdefOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConnameNspIndex.is(from)) {
  return {
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConrelidContypidConnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConrelidContypidConnameIndex.is(from)) {
  return {
conrelid: PgCatalog.Types.Oid.parse(from.conrelid),
contypid: PgCatalog.Types.Oid.parse(from.contypid),
conname: PgCatalog.Types.Name.parse(from.conname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintContypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintContypidIndex.is(from)) {
  return {
contypid: PgCatalog.Types.Oid.parse(from.contypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConparentidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConparentidIndex.is(from)) {
  return {
conparentid: PgCatalog.Types.Oid.parse(from.conparentid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsRelidSeqnoIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInheritsRelidSeqnoIndex.is(from)) {
  return {
inhrelid: PgCatalog.Types.Oid.parse(from.inhrelid),
inhseqno: PgCatalog.Types.Int4.parse(from.inhseqno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsParentIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInheritsParentIndex.is(from)) {
  return {
inhparent: PgCatalog.Types.Oid.parse(from.inhparent),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexIndrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexIndrelidIndex.is(from)) {
  return {
indrelid: PgCatalog.Types.Oid.parse(from.indrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexIndexrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexIndexrelidIndex.is(from)) {
  return {
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperatorOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorOprnameLRNIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperatorOprnameLRNIndex.is(from)) {
  return {
oprname: PgCatalog.Types.Name.parse(from.oprname),
oprleft: PgCatalog.Types.Oid.parse(from.oprleft),
oprright: PgCatalog.Types.Oid.parse(from.oprright),
oprnamespace: PgCatalog.Types.Oid.parse(from.oprnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyAmNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamilyAmNameNspIndex.is(from)) {
  return {
opfmethod: PgCatalog.Types.Oid.parse(from.opfmethod),
opfname: PgCatalog.Types.Name.parse(from.opfname),
opfnamespace: PgCatalog.Types.Oid.parse(from.opfnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamilyOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassAmNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclassAmNameNspIndex.is(from)) {
  return {
opcmethod: PgCatalog.Types.Oid.parse(from.opcmethod),
opcname: PgCatalog.Types.Name.parse(from.opcname),
opcnamespace: PgCatalog.Types.Oid.parse(from.opcnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclassOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmNameIndex.is(from)) {
  return {
amname: PgCatalog.Types.Name.parse(from.amname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopFamStratIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopFamStratIndex.is(from)) {
  return {
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
amoplefttype: PgCatalog.Types.Oid.parse(from.amoplefttype),
amoprighttype: PgCatalog.Types.Oid.parse(from.amoprighttype),
amopstrategy: PgCatalog.Types.Int2.parse(from.amopstrategy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopOprFamIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopOprFamIndex.is(from)) {
  return {
amopopr: PgCatalog.Types.Oid.parse(from.amopopr),
amoppurpose: PgCatalog.Types.Char.parse(from.amoppurpose),
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocFamProcIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmprocFamProcIndex.is(from)) {
  return {
amprocfamily: PgCatalog.Types.Oid.parse(from.amprocfamily),
amproclefttype: PgCatalog.Types.Oid.parse(from.amproclefttype),
amprocrighttype: PgCatalog.Types.Oid.parse(from.amprocrighttype),
amprocnum: PgCatalog.Types.Int2.parse(from.amprocnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmprocOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguageNameIndex.is(from)) {
  return {
lanname: PgCatalog.Types.Name.parse(from.lanname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguageOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectMetadataOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectMetadataOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectLoidPnIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectLoidPnIndex.is(from)) {
  return {
loid: PgCatalog.Types.Oid.parse(from.loid),
pageno: PgCatalog.Types.Int4.parse(from.pageno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAggregateFnoidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAggregateFnoidIndex.is(from)) {
  return {
aggfnoid: PgCatalog.Types.Regproc.parse(from.aggfnoid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticRelidAttInhIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticRelidAttInhIndex.is(from)) {
  return {
starelid: PgCatalog.Types.Oid.parse(from.starelid),
staattnum: PgCatalog.Types.Int2.parse(from.staattnum),
stainherit: PgCatalog.Types.Bool.parse(from.stainherit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtNameIndex.is(from)) {
  return {
stxname: PgCatalog.Types.Name.parse(from.stxname),
stxnamespace: PgCatalog.Types.Oid.parse(from.stxnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtRelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtRelidIndex.is(from)) {
  return {
stxrelid: PgCatalog.Types.Oid.parse(from.stxrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtDataStxoidInhIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtDataStxoidInhIndex.is(from)) {
  return {
stxoid: PgCatalog.Types.Oid.parse(from.stxoid),
stxdinherit: PgCatalog.Types.Bool.parse(from.stxdinherit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewriteOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteRelRulenameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewriteRelRulenameIndex.is(from)) {
  return {
evClass: PgCatalog.Types.Oid.parse(from.evClass),
rulename: PgCatalog.Types.Name.parse(from.rulename),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerTgconstraintIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerTgconstraintIndex.is(from)) {
  return {
tgconstraint: PgCatalog.Types.Oid.parse(from.tgconstraint),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerTgrelidTgnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerTgrelidTgnameIndex.is(from)) {
  return {
tgrelid: PgCatalog.Types.Oid.parse(from.tgrelid),
tgname: PgCatalog.Types.Name.parse(from.tgname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerEvtnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTriggerEvtnameIndex.is(from)) {
  return {
evtname: PgCatalog.Types.Name.parse(from.evtname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTriggerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDescriptionOCOIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDescriptionOCOIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCastOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastSourceTargetIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCastSourceTargetIndex.is(from)) {
  return {
castsource: PgCatalog.Types.Oid.parse(from.castsource),
casttarget: PgCatalog.Types.Oid.parse(from.casttarget),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumTypidLabelIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumTypidLabelIndex.is(from)) {
  return {
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumlabel: PgCatalog.Types.Name.parse(from.enumlabel),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumTypidSortorderIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumTypidSortorderIndex.is(from)) {
  return {
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumsortorder: PgCatalog.Types.Float4.parse(from.enumsortorder),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceNspnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespaceNspnameIndex.is(from)) {
  return {
nspname: PgCatalog.Types.Name.parse(from.nspname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionDefaultIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionDefaultIndex.is(from)) {
  return {
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
conforencoding: PgCatalog.Types.Int4.parse(from.conforencoding),
contoencoding: PgCatalog.Types.Int4.parse(from.contoencoding),
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionNameNspIndex.is(from)) {
  return {
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependDependerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDependDependerIndex.is(from)) {
  return {
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependReferenceIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDependReferenceIndex.is(from)) {
  return {
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
refobjsubid: PgCatalog.Types.Int4.parse(from.refobjsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseDatnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabaseDatnameIndex.is(from)) {
  return {
datname: PgCatalog.Types.Name.parse(from.datname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabaseOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDbRoleSettingDatabaseidRolIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex.is(from)) {
  return {
setdatabase: PgCatalog.Types.Oid.parse(from.setdatabase),
setrole: PgCatalog.Types.Oid.parse(from.setrole),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceSpcnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespaceSpcnameIndex.is(from)) {
  return {
spcname: PgCatalog.Types.Name.parse(from.spcname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidRolnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthidRolnameIndex.is(from)) {
  return {
rolname: PgCatalog.Types.Name.parse(from.rolname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthidOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersRoleMemberIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersRoleMemberIndex.is(from)) {
  return {
roleid: PgCatalog.Types.Oid.parse(from.roleid),
member: PgCatalog.Types.Oid.parse(from.member),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersMemberRoleIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersMemberRoleIndex.is(from)) {
  return {
member: PgCatalog.Types.Oid.parse(from.member),
roleid: PgCatalog.Types.Oid.parse(from.roleid),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersGrantorIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersGrantorIndex.is(from)) {
  return {
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependDependerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdependDependerIndex.is(from)) {
  return {
dbid: PgCatalog.Types.Oid.parse(from.dbid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependReferenceIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdependReferenceIndex.is(from)) {
  return {
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdescriptionOCIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdescriptionOCIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigCfgnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigCfgnameIndex.is(from)) {
  return {
cfgname: PgCatalog.Types.Name.parse(from.cfgname),
cfgnamespace: PgCatalog.Types.Oid.parse(from.cfgnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigMapIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigMapIndex.is(from)) {
  return {
mapcfg: PgCatalog.Types.Oid.parse(from.mapcfg),
maptokentype: PgCatalog.Types.Int4.parse(from.maptokentype),
mapseqno: PgCatalog.Types.Int4.parse(from.mapseqno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictDictnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDictDictnameIndex.is(from)) {
  return {
dictname: PgCatalog.Types.Name.parse(from.dictname),
dictnamespace: PgCatalog.Types.Oid.parse(from.dictnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDictOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserPrsnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParserPrsnameIndex.is(from)) {
  return {
prsname: PgCatalog.Types.Name.parse(from.prsname),
prsnamespace: PgCatalog.Types.Oid.parse(from.prsnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParserOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateTmplnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplateTmplnameIndex.is(from)) {
  return {
tmplname: PgCatalog.Types.Name.parse(from.tmplname),
tmplnamespace: PgCatalog.Types.Oid.parse(from.tmplnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplateOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtensionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtensionNameIndex.is(from)) {
  return {
extname: PgCatalog.Types.Name.parse(from.extname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapperOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapperNameIndex.is(from)) {
  return {
fdwname: PgCatalog.Types.Name.parse(from.fdwname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServerNameIndex.is(from)) {
  return {
srvname: PgCatalog.Types.Name.parse(from.srvname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappingOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingUserServerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappingUserServerIndex.is(from)) {
  return {
umuser: PgCatalog.Types.Oid.parse(from.umuser),
umserver: PgCatalog.Types.Oid.parse(from.umserver),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignTableRelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignTableRelidIndex.is(from)) {
  return {
ftrelid: PgCatalog.Types.Oid.parse(from.ftrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicyOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyPolrelidPolnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicyPolrelidPolnameIndex.is(from)) {
  return {
polrelid: PgCatalog.Types.Oid.parse(from.polrelid),
polname: PgCatalog.Types.Name.parse(from.polname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginRoiidentIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginRoiidentIndex.is(from)) {
  return {
roident: PgCatalog.Types.Oid.parse(from.roident),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginRonameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginRonameIndex.is(from)) {
  return {
roname: PgCatalog.Types.Text.parse(from.roname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclRoleNspObjIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAclRoleNspObjIndex.is(from)) {
  return {
defaclrole: PgCatalog.Types.Oid.parse(from.defaclrole),
defaclnamespace: PgCatalog.Types.Oid.parse(from.defaclnamespace),
defaclobjtype: PgCatalog.Types.Char.parse(from.defaclobjtype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAclOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInitPrivsOCOIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInitPrivsOCOIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelObjectIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabelObjectIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
provider: PgCatalog.Types.Text.parse(from.provider),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShseclabelObjectIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShseclabelObjectIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
provider: PgCatalog.Types.Text.parse(from.provider),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationNameEncNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollationNameEncNspIndex.is(from)) {
  return {
collname: PgCatalog.Types.Name.parse(from.collname),
collencoding: PgCatalog.Types.Int4.parse(from.collencoding),
collnamespace: PgCatalog.Types.Oid.parse(from.collnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollationOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclParnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAclParnameIndex.is(from)) {
  return {
parname: PgCatalog.Types.Text.parse(from.parname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAclOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPartitionedTablePartrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPartitionedTablePartrelidIndex.is(from)) {
  return {
partrelid: PgCatalog.Types.Oid.parse(from.partrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeRngtypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRangeRngtypidIndex.is(from)) {
  return {
rngtypid: PgCatalog.Types.Oid.parse(from.rngtypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeRngmultitypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRangeRngmultitypidIndex.is(from)) {
  return {
rngmultitypid: PgCatalog.Types.Oid.parse(from.rngmultitypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransformOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformTypeLangIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransformTypeLangIndex.is(from)) {
  return {
trftype: PgCatalog.Types.Oid.parse(from.trftype),
trflang: PgCatalog.Types.Oid.parse(from.trflang),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequenceSeqrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequenceSeqrelidIndex.is(from)) {
  return {
seqrelid: PgCatalog.Types.Oid.parse(from.seqrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationPubnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationPubnameIndex.is(from)) {
  return {
pubname: PgCatalog.Types.Name.parse(from.pubname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex.is(from)) {
  return {
pnnspid: PgCatalog.Types.Oid.parse(from.pnnspid),
pnpubid: PgCatalog.Types.Oid.parse(from.pnpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelPrrelidPrpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex.is(from)) {
  return {
prrelid: PgCatalog.Types.Oid.parse(from.prrelid),
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelPrpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelPrpubidIndex.is(from)) {
  return {
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionSubnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionSubnameIndex.is(from)) {
  return {
subdbid: PgCatalog.Types.Oid.parse(from.subdbid),
subname: PgCatalog.Types.Name.parse(from.subname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex.is(from)) {
  return {
srrelid: PgCatalog.Types.Oid.parse(from.srrelid),
srsubid: PgCatalog.Types.Oid.parse(from.srsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgType {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignTable {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAuthid {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgStatisticExtData {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgUserMapping {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSubscription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAttribute {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgProc {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgClass {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAttrdef {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgConstraint {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgInherits {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgIndex {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOperator {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOpfamily {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOpclass {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAm {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAmop {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAmproc {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLanguage {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLargeobjectMetadata {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAggregate {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgStatisticExt {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgRewrite {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTrigger {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgEventTrigger {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDescription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgCast {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgEnum {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgNamespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgConversion {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDepend {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDatabase {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDbRoleSetting {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTablespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAuthMembers {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShdepend {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShdescription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsConfig {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsConfigMap {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsDict {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsParser {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsTemplate {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgExtension {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignDataWrapper {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignServer {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPolicy {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgReplicationOrigin {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDefaultAcl {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgInitPrivs {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSeclabel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShseclabel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgCollation {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgParameterAcl {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPartitionedTable {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgRange {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTransform {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSequence {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublication {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublicationNamespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublicationRel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSubscriptionRel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLargeobject {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace CardinalNumber {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Int4.parse(from);
}


}
export namespace CardinalNumberArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CardinalNumber.parse(e));
    
}


}
export namespace CharacterData {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Varchar.parse(from);
}


}
export namespace CharacterDataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CharacterData.parse(e));
    
}


}
export namespace SqlIdentifier {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Name.parse(from);
}


}
export namespace SqlIdentifierArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlIdentifier.parse(e));
    
}


}
export namespace InformationSchemaCatalogName {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.InformationSchemaCatalogName.is(from)) {
  return {
catalogName: InformationSchema.Types.SqlIdentifier.parse(from.catalogName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace InformationSchemaCatalogNameArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => InformationSchemaCatalogName.parse(e));
    
}


}
export namespace TimeStamp {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Timestamptz.parse(from);
}


}
export namespace TimeStampArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TimeStamp.parse(e));
    
}


}
export namespace YesOrNo {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Varchar.parse(from);
}


}
export namespace YesOrNoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => YesOrNo.parse(e));
    
}


}
export namespace ApplicableRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ApplicableRoles.is(from)) {
  return {
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ApplicableRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ApplicableRoles.parse(e));
    
}


}
export namespace AdministrableRoleAuthorizations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.AdministrableRoleAuthorizations.is(from)) {
  return {
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace AdministrableRoleAuthorizationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => AdministrableRoleAuthorizations.parse(e));
    
}


}
export namespace Attributes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Attributes.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
attributeName: InformationSchema.Types.SqlIdentifier.parse(from.attributeName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
attributeDefault: InformationSchema.Types.CharacterData.parse(from.attributeDefault),
isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
attributeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtCatalog),
attributeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtSchema),
attributeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
isDerivedReferenceAttribute: InformationSchema.Types.YesOrNo.parse(from.isDerivedReferenceAttribute),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace AttributesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Attributes.parse(e));
    
}


}
export namespace CharacterSets {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CharacterSets.is(from)) {
  return {
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
characterRepertoire: InformationSchema.Types.SqlIdentifier.parse(from.characterRepertoire),
formOfUse: InformationSchema.Types.SqlIdentifier.parse(from.formOfUse),
defaultCollateCatalog: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateCatalog),
defaultCollateSchema: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateSchema),
defaultCollateName: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CharacterSetsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CharacterSets.parse(e));
    
}


}
export namespace CheckConstraintRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CheckConstraintRoutineUsage.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CheckConstraintRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CheckConstraintRoutineUsage.parse(e));
    
}


}
export namespace CheckConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CheckConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
checkClause: InformationSchema.Types.CharacterData.parse(from.checkClause),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CheckConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CheckConstraints.parse(e));
    
}


}
export namespace Collations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Collations.is(from)) {
  return {
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
padAttribute: InformationSchema.Types.CharacterData.parse(from.padAttribute),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CollationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Collations.parse(e));
    
}


}
export namespace CollationCharacterSetApplicability {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CollationCharacterSetApplicability.is(from)) {
  return {
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CollationCharacterSetApplicabilityArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CollationCharacterSetApplicability.parse(e));
    
}


}
export namespace ColumnColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnColumnUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
dependentColumn: InformationSchema.Types.SqlIdentifier.parse(from.dependentColumn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnColumnUsage.parse(e));
    
}


}
export namespace ColumnDomainUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnDomainUsage.is(from)) {
  return {
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnDomainUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnDomainUsage.parse(e));
    
}


}
export namespace ColumnPrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnPrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnPrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnPrivileges.parse(e));
    
}


}
export namespace ColumnUdtUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnUdtUsage.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnUdtUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnUdtUsage.parse(e));
    
}


}
export namespace Columns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Columns.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
columnDefault: InformationSchema.Types.CharacterData.parse(from.columnDefault),
isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
isSelfReferencing: InformationSchema.Types.YesOrNo.parse(from.isSelfReferencing),
isIdentity: InformationSchema.Types.YesOrNo.parse(from.isIdentity),
identityGeneration: InformationSchema.Types.CharacterData.parse(from.identityGeneration),
identityStart: InformationSchema.Types.CharacterData.parse(from.identityStart),
identityIncrement: InformationSchema.Types.CharacterData.parse(from.identityIncrement),
identityMaximum: InformationSchema.Types.CharacterData.parse(from.identityMaximum),
identityMinimum: InformationSchema.Types.CharacterData.parse(from.identityMinimum),
identityCycle: InformationSchema.Types.YesOrNo.parse(from.identityCycle),
isGenerated: InformationSchema.Types.CharacterData.parse(from.isGenerated),
generationExpression: InformationSchema.Types.CharacterData.parse(from.generationExpression),
isUpdatable: InformationSchema.Types.YesOrNo.parse(from.isUpdatable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Columns.parse(e));
    
}


}
export namespace ConstraintColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ConstraintColumnUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ConstraintColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ConstraintColumnUsage.parse(e));
    
}


}
export namespace ConstraintTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ConstraintTableUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ConstraintTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ConstraintTableUsage.parse(e));
    
}


}
export namespace DomainConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DomainConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
isDeferrable: InformationSchema.Types.YesOrNo.parse(from.isDeferrable),
initiallyDeferred: InformationSchema.Types.YesOrNo.parse(from.initiallyDeferred),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DomainConstraints.parse(e));
    
}


}
export namespace DomainUdtUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DomainUdtUsage.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainUdtUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DomainUdtUsage.parse(e));
    
}


}
export namespace Domains {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Domains.is(from)) {
  return {
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
domainDefault: InformationSchema.Types.CharacterData.parse(from.domainDefault),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Domains.parse(e));
    
}


}
export namespace EnabledRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.EnabledRoles.is(from)) {
  return {
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace EnabledRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => EnabledRoles.parse(e));
    
}


}
export namespace KeyColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.KeyColumnUsage.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
positionInUniqueConstraint: InformationSchema.Types.CardinalNumber.parse(from.positionInUniqueConstraint),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace KeyColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => KeyColumnUsage.parse(e));
    
}


}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Parameters.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
parameterMode: InformationSchema.Types.CharacterData.parse(from.parameterMode),
isResult: InformationSchema.Types.YesOrNo.parse(from.isResult),
asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
parameterName: InformationSchema.Types.SqlIdentifier.parse(from.parameterName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
parameterDefault: InformationSchema.Types.CharacterData.parse(from.parameterDefault),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ParametersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Parameters.parse(e));
    
}


}
export namespace ReferentialConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ReferentialConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
uniqueConstraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintCatalog),
uniqueConstraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintSchema),
uniqueConstraintName: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintName),
matchOption: InformationSchema.Types.CharacterData.parse(from.matchOption),
updateRule: InformationSchema.Types.CharacterData.parse(from.updateRule),
deleteRule: InformationSchema.Types.CharacterData.parse(from.deleteRule),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ReferentialConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ReferentialConstraints.parse(e));
    
}


}
export namespace RoleColumnGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleColumnGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleColumnGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleColumnGrants.parse(e));
    
}


}
export namespace RoutineColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineColumnUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineColumnUsage.parse(e));
    
}


}
export namespace RoutinePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutinePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutinePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutinePrivileges.parse(e));
    
}


}
export namespace RoleRoutineGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleRoutineGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleRoutineGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleRoutineGrants.parse(e));
    
}


}
export namespace RoutineRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineRoutineUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineRoutineUsage.parse(e));
    
}


}
export namespace RoutineSequenceUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineSequenceUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(from.sequenceCatalog),
sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(from.sequenceSchema),
sequenceName: InformationSchema.Types.SqlIdentifier.parse(from.sequenceName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineSequenceUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineSequenceUsage.parse(e));
    
}


}
export namespace RoutineTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineTableUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineTableUsage.parse(e));
    
}


}
export namespace Routines {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Routines.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
routineType: InformationSchema.Types.CharacterData.parse(from.routineType),
moduleCatalog: InformationSchema.Types.SqlIdentifier.parse(from.moduleCatalog),
moduleSchema: InformationSchema.Types.SqlIdentifier.parse(from.moduleSchema),
moduleName: InformationSchema.Types.SqlIdentifier.parse(from.moduleName),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
typeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtCatalog),
typeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtSchema),
typeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
routineBody: InformationSchema.Types.CharacterData.parse(from.routineBody),
routineDefinition: InformationSchema.Types.CharacterData.parse(from.routineDefinition),
externalName: InformationSchema.Types.CharacterData.parse(from.externalName),
externalLanguage: InformationSchema.Types.CharacterData.parse(from.externalLanguage),
parameterStyle: InformationSchema.Types.CharacterData.parse(from.parameterStyle),
isDeterministic: InformationSchema.Types.YesOrNo.parse(from.isDeterministic),
sqlDataAccess: InformationSchema.Types.CharacterData.parse(from.sqlDataAccess),
isNullCall: InformationSchema.Types.YesOrNo.parse(from.isNullCall),
sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
schemaLevelRoutine: InformationSchema.Types.YesOrNo.parse(from.schemaLevelRoutine),
maxDynamicResultSets: InformationSchema.Types.CardinalNumber.parse(from.maxDynamicResultSets),
isUserDefinedCast: InformationSchema.Types.YesOrNo.parse(from.isUserDefinedCast),
isImplicitlyInvocable: InformationSchema.Types.YesOrNo.parse(from.isImplicitlyInvocable),
securityType: InformationSchema.Types.CharacterData.parse(from.securityType),
toSqlSpecificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificCatalog),
toSqlSpecificSchema: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificSchema),
toSqlSpecificName: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificName),
asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
created: InformationSchema.Types.TimeStamp.parse(from.created),
lastAltered: InformationSchema.Types.TimeStamp.parse(from.lastAltered),
newSavepointLevel: InformationSchema.Types.YesOrNo.parse(from.newSavepointLevel),
isUdtDependent: InformationSchema.Types.YesOrNo.parse(from.isUdtDependent),
resultCastFromDataType: InformationSchema.Types.CharacterData.parse(from.resultCastFromDataType),
resultCastAsLocator: InformationSchema.Types.YesOrNo.parse(from.resultCastAsLocator),
resultCastCharMaxLength: InformationSchema.Types.CardinalNumber.parse(from.resultCastCharMaxLength),
resultCastCharOctetLength: InformationSchema.Types.CardinalNumber.parse(from.resultCastCharOctetLength),
resultCastCharSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetCatalog),
resultCastCharSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetSchema),
resultCastCharSetName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetName),
resultCastCollationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationCatalog),
resultCastCollationSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationSchema),
resultCastCollationName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationName),
resultCastNumericPrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericPrecision),
resultCastNumericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericPrecisionRadix),
resultCastNumericScale: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericScale),
resultCastDatetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastDatetimePrecision),
resultCastIntervalType: InformationSchema.Types.CharacterData.parse(from.resultCastIntervalType),
resultCastIntervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastIntervalPrecision),
resultCastTypeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtCatalog),
resultCastTypeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtSchema),
resultCastTypeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtName),
resultCastScopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeCatalog),
resultCastScopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeSchema),
resultCastScopeName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeName),
resultCastMaximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.resultCastMaximumCardinality),
resultCastDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.resultCastDtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutinesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Routines.parse(e));
    
}


}
export namespace Schemata {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Schemata.is(from)) {
  return {
catalogName: InformationSchema.Types.SqlIdentifier.parse(from.catalogName),
schemaName: InformationSchema.Types.SqlIdentifier.parse(from.schemaName),
schemaOwner: InformationSchema.Types.SqlIdentifier.parse(from.schemaOwner),
defaultCharacterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetCatalog),
defaultCharacterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetSchema),
defaultCharacterSetName: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetName),
sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SchemataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Schemata.parse(e));
    
}


}
export namespace Sequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Sequences.is(from)) {
  return {
sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(from.sequenceCatalog),
sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(from.sequenceSchema),
sequenceName: InformationSchema.Types.SqlIdentifier.parse(from.sequenceName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
startValue: InformationSchema.Types.CharacterData.parse(from.startValue),
minimumValue: InformationSchema.Types.CharacterData.parse(from.minimumValue),
maximumValue: InformationSchema.Types.CharacterData.parse(from.maximumValue),
increment: InformationSchema.Types.CharacterData.parse(from.increment),
cycleOption: InformationSchema.Types.YesOrNo.parse(from.cycleOption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Sequences.parse(e));
    
}


}
export namespace SqlFeatures {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlFeatures.is(from)) {
  return {
featureId: InformationSchema.Types.CharacterData.parse(from.featureId),
featureName: InformationSchema.Types.CharacterData.parse(from.featureName),
subFeatureId: InformationSchema.Types.CharacterData.parse(from.subFeatureId),
subFeatureName: InformationSchema.Types.CharacterData.parse(from.subFeatureName),
isSupported: InformationSchema.Types.YesOrNo.parse(from.isSupported),
isVerifiedBy: InformationSchema.Types.CharacterData.parse(from.isVerifiedBy),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlFeaturesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlFeatures.parse(e));
    
}


}
export namespace SqlImplementationInfo {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlImplementationInfo.is(from)) {
  return {
implementationInfoId: InformationSchema.Types.CharacterData.parse(from.implementationInfoId),
implementationInfoName: InformationSchema.Types.CharacterData.parse(from.implementationInfoName),
integerValue: InformationSchema.Types.CardinalNumber.parse(from.integerValue),
characterValue: InformationSchema.Types.CharacterData.parse(from.characterValue),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlImplementationInfoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlImplementationInfo.parse(e));
    
}


}
export namespace SqlParts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlParts.is(from)) {
  return {
featureId: InformationSchema.Types.CharacterData.parse(from.featureId),
featureName: InformationSchema.Types.CharacterData.parse(from.featureName),
isSupported: InformationSchema.Types.YesOrNo.parse(from.isSupported),
isVerifiedBy: InformationSchema.Types.CharacterData.parse(from.isVerifiedBy),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlPartsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlParts.parse(e));
    
}


}
export namespace SqlSizing {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlSizing.is(from)) {
  return {
sizingId: InformationSchema.Types.CardinalNumber.parse(from.sizingId),
sizingName: InformationSchema.Types.CharacterData.parse(from.sizingName),
supportedValue: InformationSchema.Types.CardinalNumber.parse(from.supportedValue),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlSizingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlSizing.parse(e));
    
}


}
export namespace TableConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TableConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
constraintType: InformationSchema.Types.CharacterData.parse(from.constraintType),
isDeferrable: InformationSchema.Types.YesOrNo.parse(from.isDeferrable),
initiallyDeferred: InformationSchema.Types.YesOrNo.parse(from.initiallyDeferred),
enforced: InformationSchema.Types.YesOrNo.parse(from.enforced),
nullsDistinct: InformationSchema.Types.YesOrNo.parse(from.nullsDistinct),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TableConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TableConstraints.parse(e));
    
}


}
export namespace TablePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TablePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
withHierarchy: InformationSchema.Types.YesOrNo.parse(from.withHierarchy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TablePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TablePrivileges.parse(e));
    
}


}
export namespace RoleTableGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleTableGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
withHierarchy: InformationSchema.Types.YesOrNo.parse(from.withHierarchy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleTableGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleTableGrants.parse(e));
    
}


}
export namespace Tables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Tables.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
tableType: InformationSchema.Types.CharacterData.parse(from.tableType),
selfReferencingColumnName: InformationSchema.Types.SqlIdentifier.parse(from.selfReferencingColumnName),
referenceGeneration: InformationSchema.Types.CharacterData.parse(from.referenceGeneration),
userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeCatalog),
userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeSchema),
userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeName),
isInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isInsertableInto),
isTyped: InformationSchema.Types.YesOrNo.parse(from.isTyped),
commitAction: InformationSchema.Types.CharacterData.parse(from.commitAction),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tables.parse(e));
    
}


}
export namespace Transforms {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Transforms.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
groupName: InformationSchema.Types.SqlIdentifier.parse(from.groupName),
transformType: InformationSchema.Types.CharacterData.parse(from.transformType),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TransformsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Transforms.parse(e));
    
}


}
export namespace TriggeredUpdateColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TriggeredUpdateColumns.is(from)) {
  return {
triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.triggerCatalog),
triggerSchema: InformationSchema.Types.SqlIdentifier.parse(from.triggerSchema),
triggerName: InformationSchema.Types.SqlIdentifier.parse(from.triggerName),
eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectCatalog),
eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectSchema),
eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectTable),
eventObjectColumn: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectColumn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TriggeredUpdateColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TriggeredUpdateColumns.parse(e));
    
}


}
export namespace Triggers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Triggers.is(from)) {
  return {
triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.triggerCatalog),
triggerSchema: InformationSchema.Types.SqlIdentifier.parse(from.triggerSchema),
triggerName: InformationSchema.Types.SqlIdentifier.parse(from.triggerName),
eventManipulation: InformationSchema.Types.CharacterData.parse(from.eventManipulation),
eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectCatalog),
eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectSchema),
eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectTable),
actionOrder: InformationSchema.Types.CardinalNumber.parse(from.actionOrder),
actionCondition: InformationSchema.Types.CharacterData.parse(from.actionCondition),
actionStatement: InformationSchema.Types.CharacterData.parse(from.actionStatement),
actionOrientation: InformationSchema.Types.CharacterData.parse(from.actionOrientation),
actionTiming: InformationSchema.Types.CharacterData.parse(from.actionTiming),
actionReferenceOldTable: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceOldTable),
actionReferenceNewTable: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceNewTable),
actionReferenceOldRow: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceOldRow),
actionReferenceNewRow: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceNewRow),
created: InformationSchema.Types.TimeStamp.parse(from.created),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TriggersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Triggers.parse(e));
    
}


}
export namespace UdtPrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UdtPrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UdtPrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UdtPrivileges.parse(e));
    
}


}
export namespace RoleUdtGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleUdtGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleUdtGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleUdtGrants.parse(e));
    
}


}
export namespace UsagePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UsagePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UsagePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UsagePrivileges.parse(e));
    
}


}
export namespace RoleUsageGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleUsageGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleUsageGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleUsageGrants.parse(e));
    
}


}
export namespace UserDefinedTypes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserDefinedTypes.is(from)) {
  return {
userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeCatalog),
userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeSchema),
userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeName),
userDefinedTypeCategory: InformationSchema.Types.CharacterData.parse(from.userDefinedTypeCategory),
isInstantiable: InformationSchema.Types.YesOrNo.parse(from.isInstantiable),
isFinal: InformationSchema.Types.YesOrNo.parse(from.isFinal),
orderingForm: InformationSchema.Types.CharacterData.parse(from.orderingForm),
orderingCategory: InformationSchema.Types.CharacterData.parse(from.orderingCategory),
orderingRoutineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineCatalog),
orderingRoutineSchema: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineSchema),
orderingRoutineName: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineName),
referenceType: InformationSchema.Types.CharacterData.parse(from.referenceType),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
sourceDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.sourceDtdIdentifier),
refDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.refDtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserDefinedTypesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserDefinedTypes.parse(e));
    
}


}
export namespace ViewColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewColumnUsage.is(from)) {
  return {
viewCatalog: InformationSchema.Types.SqlIdentifier.parse(from.viewCatalog),
viewSchema: InformationSchema.Types.SqlIdentifier.parse(from.viewSchema),
viewName: InformationSchema.Types.SqlIdentifier.parse(from.viewName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewColumnUsage.parse(e));
    
}


}
export namespace ViewRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewRoutineUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewRoutineUsage.parse(e));
    
}


}
export namespace ViewTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewTableUsage.is(from)) {
  return {
viewCatalog: InformationSchema.Types.SqlIdentifier.parse(from.viewCatalog),
viewSchema: InformationSchema.Types.SqlIdentifier.parse(from.viewSchema),
viewName: InformationSchema.Types.SqlIdentifier.parse(from.viewName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewTableUsage.parse(e));
    
}


}
export namespace Views {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Views.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
viewDefinition: InformationSchema.Types.CharacterData.parse(from.viewDefinition),
checkOption: InformationSchema.Types.CharacterData.parse(from.checkOption),
isUpdatable: InformationSchema.Types.YesOrNo.parse(from.isUpdatable),
isInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isInsertableInto),
isTriggerUpdatable: InformationSchema.Types.YesOrNo.parse(from.isTriggerUpdatable),
isTriggerDeletable: InformationSchema.Types.YesOrNo.parse(from.isTriggerDeletable),
isTriggerInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isTriggerInsertableInto),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Views.parse(e));
    
}


}
export namespace DataTypePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DataTypePrivileges.is(from)) {
  return {
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DataTypePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DataTypePrivileges.parse(e));
    
}


}
export namespace ElementTypes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ElementTypes.is(from)) {
  return {
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
collectionTypeIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.collectionTypeIdentifier),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
domainDefault: InformationSchema.Types.CharacterData.parse(from.domainDefault),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ElementTypesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ElementTypes.parse(e));
    
}


}
export namespace PgForeignTableColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignTableColumns.is(from)) {
  return {
nspname: PgCatalog.Types.Name.parse(from.nspname),
relname: PgCatalog.Types.Name.parse(from.relname),
attname: PgCatalog.Types.Name.parse(from.attname),
attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnOptions.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnOptions.parse(e));
    
}


}
export namespace PgForeignDataWrappers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignDataWrappers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignDataWrapperLanguage: InformationSchema.Types.CharacterData.parse(from.foreignDataWrapperLanguage),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrapperOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignDataWrapperOptions.is(from)) {
  return {
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrapperOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignDataWrapperOptions.parse(e));
    
}


}
export namespace ForeignDataWrappers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignDataWrappers.is(from)) {
  return {
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
libraryName: InformationSchema.Types.CharacterData.parse(from.libraryName),
foreignDataWrapperLanguage: InformationSchema.Types.CharacterData.parse(from.foreignDataWrapperLanguage),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrappersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignDataWrappers.parse(e));
    
}


}
export namespace PgForeignServers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignServers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
foreignServerType: InformationSchema.Types.CharacterData.parse(from.foreignServerType),
foreignServerVersion: InformationSchema.Types.CharacterData.parse(from.foreignServerVersion),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServerOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignServerOptions.is(from)) {
  return {
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServerOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignServerOptions.parse(e));
    
}


}
export namespace ForeignServers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignServers.is(from)) {
  return {
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
foreignServerType: InformationSchema.Types.CharacterData.parse(from.foreignServerType),
foreignServerVersion: InformationSchema.Types.CharacterData.parse(from.foreignServerVersion),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignServers.parse(e));
    
}


}
export namespace PgForeignTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignTables.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTableOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignTableOptions.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTableOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignTableOptions.parse(e));
    
}


}
export namespace ForeignTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignTables.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignTables.parse(e));
    
}


}
export namespace PgUserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgUserMappings.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
srvowner: InformationSchema.Types.SqlIdentifier.parse(from.srvowner),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserMappingOptions.is(from)) {
  return {
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserMappingOptions.parse(e));
    
}


}
export namespace UserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserMappings.is(from)) {
  return {
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserMappings.parse(e));
    
}


}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlImplementationInfo {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlParts {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlSizing {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace Public {
export namespace Types {
export namespace Spheroid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace SpheroidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Spheroid.parse(e));
    
}


}
export namespace Geometry {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace GeometryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Geometry.parse(e));
    
}


}
export namespace Box3d {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Box3dArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box3d.parse(e));
    
}


}
export namespace Box2d {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Box2dArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box2d.parse(e));
    
}


}
export namespace Box2df {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Box2dfArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box2df.parse(e));
    
}


}
export namespace Gidx {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace GidxArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Gidx.parse(e));
    
}


}
export namespace GeometryDump {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeometryDump.is(from)) {
  return {
path: PgCatalog.Types.Int4Array.parse(from.path),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeometryDumpArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeometryDump.parse(e));
    
}


}
export namespace SpatialRefSys {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.SpatialRefSys.is(from)) {
  return {
srid: PgCatalog.Types.Int4.parse(from.srid),
authName: PgCatalog.Types.Varchar.parse(from.authName),
authSrid: PgCatalog.Types.Int4.parse(from.authSrid),
srtext: PgCatalog.Types.Varchar.parse(from.srtext),
proj4text: PgCatalog.Types.Varchar.parse(from.proj4text),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SpatialRefSysArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SpatialRefSys.parse(e));
    
}


}
export namespace ValidDetail {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.ValidDetail.is(from)) {
  return {
valid: PgCatalog.Types.Bool.parse(from.valid),
reason: PgCatalog.Types.Varchar.parse(from.reason),
location: Public.Types.Geometry.parse(from.location),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ValidDetailArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ValidDetail.parse(e));
    
}


}
export namespace Geography {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace GeographyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Geography.parse(e));
    
}


}
export namespace GeographyColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeographyColumns.is(from)) {
  return {
fTableCatalog: PgCatalog.Types.Name.parse(from.fTableCatalog),
fTableSchema: PgCatalog.Types.Name.parse(from.fTableSchema),
fTableName: PgCatalog.Types.Name.parse(from.fTableName),
fGeographyColumn: PgCatalog.Types.Name.parse(from.fGeographyColumn),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
srid: PgCatalog.Types.Int4.parse(from.srid),
type: PgCatalog.Types.Text.parse(from.type),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeographyColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeographyColumns.parse(e));
    
}


}
export namespace GeometryColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeometryColumns.is(from)) {
  return {
fTableCatalog: PgCatalog.Types.Varchar.parse(from.fTableCatalog),
fTableSchema: PgCatalog.Types.Name.parse(from.fTableSchema),
fTableName: PgCatalog.Types.Name.parse(from.fTableName),
fGeometryColumn: PgCatalog.Types.Name.parse(from.fGeometryColumn),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
srid: PgCatalog.Types.Int4.parse(from.srid),
type: PgCatalog.Types.Varchar.parse(from.type),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeometryColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeometryColumns.parse(e));
    
}


}
export namespace NycCensusBlocks {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocks.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
blkid: PgCatalog.Types.Varchar.parse(from.blkid),
popnTotal: PgCatalog.Types.Float8.parse(from.popnTotal),
popnWhite: PgCatalog.Types.Float8.parse(from.popnWhite),
popnBlack: PgCatalog.Types.Float8.parse(from.popnBlack),
popnNativ: PgCatalog.Types.Float8.parse(from.popnNativ),
popnAsian: PgCatalog.Types.Float8.parse(from.popnAsian),
popnOther: PgCatalog.Types.Float8.parse(from.popnOther),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycCensusBlocks.parse(e));
    
}


}
export namespace NycHomicides {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicides.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
incidentD: PgCatalog.Types.Date.parse(from.incidentD),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
numVictim: PgCatalog.Types.Varchar.parse(from.numVictim),
primaryMo: PgCatalog.Types.Varchar.parse(from.primaryMo),
id: PgCatalog.Types.Float8.parse(from.id),
weapon: PgCatalog.Types.Varchar.parse(from.weapon),
lightDark: PgCatalog.Types.Varchar.parse(from.lightDark),
year: PgCatalog.Types.Float8.parse(from.year),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycHomicides.parse(e));
    
}


}
export namespace NycNeighborhoods {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoods.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
name: PgCatalog.Types.Varchar.parse(from.name),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycNeighborhoods.parse(e));
    
}


}
export namespace NycStreets {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreets.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
id: PgCatalog.Types.Float8.parse(from.id),
name: PgCatalog.Types.Varchar.parse(from.name),
oneway: PgCatalog.Types.Varchar.parse(from.oneway),
type: PgCatalog.Types.Varchar.parse(from.type),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycStreets.parse(e));
    
}


}
export namespace NycSubwayStations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStations.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
objectid: PgCatalog.Types.Numeric.parse(from.objectid),
id: PgCatalog.Types.Numeric.parse(from.id),
name: PgCatalog.Types.Varchar.parse(from.name),
altName: PgCatalog.Types.Varchar.parse(from.altName),
crossSt: PgCatalog.Types.Varchar.parse(from.crossSt),
longName: PgCatalog.Types.Varchar.parse(from.longName),
label: PgCatalog.Types.Varchar.parse(from.label),
borough: PgCatalog.Types.Varchar.parse(from.borough),
nghbhd: PgCatalog.Types.Varchar.parse(from.nghbhd),
routes: PgCatalog.Types.Varchar.parse(from.routes),
transfers: PgCatalog.Types.Varchar.parse(from.transfers),
color: PgCatalog.Types.Varchar.parse(from.color),
express: PgCatalog.Types.Varchar.parse(from.express),
closed: PgCatalog.Types.Varchar.parse(from.closed),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycSubwayStations.parse(e));
    
}


}
export namespace SpatialRefSysPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.SpatialRefSysPkey.is(from)) {
  return {
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocksPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicidesPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoodsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreetsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStationsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocksGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicidesGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoodsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreetsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStationsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrs.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrsAll {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrsAll.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrsSearch {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrsSearch.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StMinimumboundingradius {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StMinimumboundingradius.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StMaximuminscribedcircle {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StMaximuminscribedcircle.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
nearest: Public.Types.Geometry.parse(from.nearest),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StLargestemptycircle {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StLargestemptycircle.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
nearest: Public.Types.Geometry.parse(from.nearest),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StHexagongrid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StHexagongrid.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
i: PgCatalog.Types.Int4.parse(from.i),
j: PgCatalog.Types.Int4.parse(from.j),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StSquaregrid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StSquaregrid.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
i: PgCatalog.Types.Int4.parse(from.i),
j: PgCatalog.Types.Int4.parse(from.j),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcepolygoncw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace SpheroidIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.SpheroidIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace SpheroidOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.SpheroidOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Spheroid.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryTypmodIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryTypmodIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.CstringArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryTypmodOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryTypmodOut.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryAnalyze {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryAnalyze.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryRecv {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryRecv.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySend.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_4946 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_4946.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_8997 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_8997.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Point.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Point {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Point.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryB0d8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryB0d8.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Path.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Path {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Path.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryF1be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryF1be.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Polygon.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Polygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Polygon.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StX {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StX.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StY {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StY.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZ {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZ.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StM {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StM.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dfIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dfIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dfOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dfOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GidxIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GidxIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GidxOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GidxOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLt.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLe.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGt.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGe.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryEq {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryEq.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryCmp {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryCmp.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySortsupport {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySortsupport.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryHash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryHash.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDistance_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDistance_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistCompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistCompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPenalty_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPenalty_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPicksplit_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPicksplit_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistUnion_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistUnion_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSame_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSame_2d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDecompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDecompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSortsupport_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSortsupport_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcerhr {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcerhr.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisNoop {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisNoop.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcepolygonccw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcepolygonccw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistSel_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistSel_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistSelNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistSelNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistJoinsel_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistJoinsel_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int2.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistJoinselNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistJoinselNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int2.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlaps.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySame {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySame.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCentroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCentroid.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceBox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceBox.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContains {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContains.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryWithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryWithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLeft {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLeft.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverleft {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverleft.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryBelow {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryBelow.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverbelow {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverbelow.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverright {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverright.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryRight {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryRight.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverabove {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverabove.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryAbove {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryAbove.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPenaltyNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPenaltyNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistUnionNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistUnionNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSameNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSameNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDecompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDecompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlapsNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlapsNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContainsNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContainsNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryWithinNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryWithinNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySameNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySameNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCentroidNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCentroidNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCpa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCpa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDistanceNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDistanceNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShiftlongitude {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShiftlongitude.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWrapx {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWrapx.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
wrap: PgCatalog.Types.Float8.parse(from.wrap),
move: PgCatalog.Types.Float8.parse(from.move),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StXmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StXmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StYmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StYmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StXmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StXmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StYmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StYmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_3044 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_3044.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_3ea7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_3ea7.Parameters.is(from)) {
  return {
box: Public.Types.Box2d.parse(from.box),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisGetbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisGetbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakebox2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakebox2d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextentD2f5 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextentD2f5.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Bool.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextent_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextent_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextent_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextent_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFindextent_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFindextent_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFindextent_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFindextent_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisAddbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisAddbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisDropbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisDropbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisHasbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisHasbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StQuantizecoordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StQuantizecoordinates.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
precX: PgCatalog.Types.Int4.parse(from.precX),
precY: PgCatalog.Types.Int4.parse(from.precY),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMemsize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMemsize.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSummary_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSummary_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNpoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNrings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNrings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlength {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlength.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthspheroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthspheroid.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Spheroid.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength2dspheroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength2dspheroid.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Spheroid.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dperimeter {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dperimeter.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeter2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeter2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeter_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeter_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StArea2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StArea2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StArea_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StArea_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIspolygoncw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIspolygoncw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIspolygonccw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIspolygonccw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancespheroid_0cb2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancespheroid_0cb2.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: Public.Types.Spheroid.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancespheroidEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancespheroidEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistanceEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistanceEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointinsidecircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointinsidecircle.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAzimuthEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAzimuthEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProject_2077 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProject_2077.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
distance: PgCatalog.Types.Float8.parse(from.distance),
azimuth: PgCatalog.Types.Float8.parse(from.azimuth),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProjectE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProjectE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
distance: PgCatalog.Types.Float8.parse(from.distance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAngleA4a1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAngleA4a1.Parameters.is(from)) {
  return {
pt1: Public.Types.Geometry.parse(from.pt1),
pt2: Public.Types.Geometry.parse(from.pt2),
pt3: Public.Types.Geometry.parse(from.pt3),
pt4: Public.Types.Geometry.parse(from.pt4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineextend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineextend.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
distanceForward: PgCatalog.Types.Float8.parse(from.distanceForward),
distanceBackward: PgCatalog.Types.Float8.parse(from.distanceBackward),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3dz {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3dz.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3dm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3dm.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
mvalue: PgCatalog.Types.Float8.parse(from.mvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce4d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce4d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
mvalue: PgCatalog.Types.Float8.parse(from.mvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcecollection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcecollection.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionextractEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionextractEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionextract_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionextract_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionhomogenize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionhomogenize.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMulti {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMulti.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcecurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcecurve.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcesfs_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcesfs_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcesfsF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcesfsF1e2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
version: PgCatalog.Types.Text.parse(from.version),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_95d4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_95d4.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpandF49e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpandF49e.Parameters.is(from)) {
  return {
box: Public.Types.Box3d.parse(from.box),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
dz: PgCatalog.Types.Float8.parse(from.dz),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpandDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpandDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpandBf72 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpandBf72.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
dz: PgCatalog.Types.Float8.parse(from.dz),
dm: PgCatalog.Types.Float8.parse(from.dm),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEnvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEnvelope.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBoundingdiagonal {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBoundingdiagonal.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fits: PgCatalog.Types.Bool.parse(from.fits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StReverse {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StReverse.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScroll {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScroll.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisGeosNoop {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisGeosNoop.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNormalize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNormalize.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmflag {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmflag.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNdims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNdims.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewktEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewktEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstwkb_8607 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstwkb_8607.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
prec: PgCatalog.Types.Int4.parse(from.prec),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
withSizes: PgCatalog.Types.Bool.parse(from.withSizes),
withBoxes: PgCatalog.Types.Bool.parse(from.withBoxes),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstwkb_1445 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstwkb_1445.Parameters.is(from)) {
  return {
geom: Public.Types.GeometryArray.parse(from.geom),
ids: PgCatalog.Types.Int8Array.parse(from.ids),
prec: PgCatalog.Types.Int4.parse(from.prec),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
withSizes: PgCatalog.Types.Bool.parse(from.withSizes),
withBoxes: PgCatalog.Types.Bool.parse(from.withBoxes),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkb_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkb_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAshexewkb_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAshexewkb_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAshexewkbF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAshexewkbF1e2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkbF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkbF1e2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAslatlontext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAslatlontext.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tmpl: PgCatalog.Types.Text.parse(from.tmpl),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geomfromewkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geomfromewkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromewkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromewkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geomfromewkt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geomfromewkt.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromewkt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromewkt.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisCacheBbox {
export namespace Results {
}
}
export namespace StMakepoint_0aec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_0aec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepoint_81ec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_81ec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepoint_570b {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_570b.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepointm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepointm.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dmakebox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dmakebox.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakelineF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakelineF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefrommultipoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefrommultipoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakelineEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakelineEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddpointEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddpointEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_2077 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_2077.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddpointCc0f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddpointCc0f.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRemovepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRemovepoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: Public.Types.Geometry.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakeenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakeenvelope.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Int4.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTileenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTileenvelope.Parameters.is(from)) {
  return {
zoom: PgCatalog.Types.Int4.parse(from.zoom),
x: PgCatalog.Types.Int4.parse(from.x),
y: PgCatalog.Types.Int4.parse(from.y),
bounds: Public.Types.Geometry.parse(from.bounds),
margin: PgCatalog.Types.Float8.parse(from.margin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepolygon_0543 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepolygon_0543.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.GeometryArray.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepolygon_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepolygon_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuildarea {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuildarea.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonizeF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonizeF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClusterintersectingF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClusterintersectingF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClusterwithin_2892 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClusterwithin_2892.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinemerge_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinemerge_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinemergeCad2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinemergeCad2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Bool.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAffineA659 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAffineA659.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
argument_6: PgCatalog.Types.Float8.parse(from.argument_6),
argument_7: PgCatalog.Types.Float8.parse(from.argument_7),
argument_8: PgCatalog.Types.Float8.parse(from.argument_8),
argument_9: PgCatalog.Types.Float8.parse(from.argument_9),
argument_10: PgCatalog.Types.Float8.parse(from.argument_10),
argument_11: PgCatalog.Types.Float8.parse(from.argument_11),
argument_12: PgCatalog.Types.Float8.parse(from.argument_12),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAffine_0997 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAffine_0997.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
argument_6: PgCatalog.Types.Float8.parse(from.argument_6),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotateDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotateDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotate_6aac {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotate_6aac.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotate_8af1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotate_8af1.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: Public.Types.Geometry.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatez {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatez.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatex {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatex.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatey {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatey.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTranslate_6aac {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTranslate_6aac.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTranslate_2077 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTranslate_2077.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScaleEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScaleEb6a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_8af1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_8af1.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_6aac {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_6aac.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransscale {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransscale.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDump {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDump.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumprings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumprings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumppoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumppoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumpsegments {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumpsegments.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PopulateGeometryColumns_23fc.Parameters.is(from)) {
  return {
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PopulateGeometryColumns_4174.Parameters.is(from)) {
  return {
tblOid: PgCatalog.Types.Oid.parse(from.tblOid),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_8fbb.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSridIn: PgCatalog.Types.Int4.parse(from.newSridIn),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_4617 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_4617.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSrid: PgCatalog.Types.Int4.parse(from.newSrid),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_093c {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_093c.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSrid: PgCatalog.Types.Int4.parse(from.newSrid),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrycolumn_0412.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrycolumn_2253.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrycolumnF11a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrycolumnF11a.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrytable_2253 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrytable_2253.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSegmentizeDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSegmentizeDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrytableF11a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrytableF11a.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrytableBfde {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrytableBfde.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace UpdategeometrysridB2ee {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.UpdategeometrysridB2ee.Parameters.is(from)) {
  return {
catalognName: PgCatalog.Types.Varchar.parse(from.catalognName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSridIn: PgCatalog.Types.Int4.parse(from.newSridIn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Updategeometrysrid_7b58 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Updategeometrysrid_7b58.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Varchar.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Updategeometrysrid_11c8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Updategeometrysrid_11c8.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace FindSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.FindSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Varchar.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GetProj4FromSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GetProj4FromSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetsridEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetsridEd82.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSrid_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSrid_0faa.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTransformGeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTransformGeometry.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrsCodes {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrsCodes.Parameters.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrs {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrs.Parameters.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrsAll {
export namespace Results {
}
}
export namespace PostgisSrsSearch {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrsSearch.Parameters.is(from)) {
  return {
bounds: Public.Types.Geometry.parse(from.bounds),
authname: PgCatalog.Types.Text.parse(from.authname),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransformEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransformEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransformF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransformF1e2.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
toProj: PgCatalog.Types.Text.parse(from.toProj),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransformEfe6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransformEfe6.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fromProj: PgCatalog.Types.Text.parse(from.fromProj),
toProj: PgCatalog.Types.Text.parse(from.toProj),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransform_3ad9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransform_3ad9.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fromProj: PgCatalog.Types.Text.parse(from.fromProj),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTransformPipelineGeometry.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
forward: PgCatalog.Types.Bool.parse(from.forward),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransformpipeline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransformpipeline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInversetransformpipeline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInversetransformpipeline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisVersion {
export namespace Results {
}
}
export namespace PostgisLiblwgeomVersion {
export namespace Results {
}
}
export namespace PostgisProjVersion {
export namespace Results {
}
}
export namespace PostgisWagyuVersion {
export namespace Results {
}
}
export namespace PostgisScriptsInstalled {
export namespace Results {
}
}
export namespace PostgisLibVersion {
export namespace Results {
}
}
export namespace PostgisScriptsReleased {
export namespace Results {
}
}
export namespace PostgisGeosVersion {
export namespace Results {
}
}
export namespace PostgisGeosCompiledVersion {
export namespace Results {
}
}
export namespace PostgisLibRevision {
export namespace Results {
}
}
export namespace PostgisSvnVersion {
export namespace Results {
}
}
export namespace PostgisLibxmlVersion {
export namespace Results {
}
}
export namespace PostgisScriptsBuildDate {
export namespace Results {
}
}
export namespace PostgisLibBuildDate {
export namespace Results {
}
}
export namespace PostgisExtensionsUpgrade {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisExtensionsUpgrade.Parameters.is(from)) {
  return {
targetVersion: PgCatalog.Types.Text.parse(from.targetVersion),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoints_1c13 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoints_1c13.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
repeat: PgCatalog.Types.Bool.parse(from.repeat),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstring_2077 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstring_2077.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepointEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepointEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddmeasure {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddmeasure.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpointofapproach {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpointofapproach.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisFullVersion {
export namespace Results {
}
}
export namespace Box2d_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2d_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3d_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3d_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2d_8784 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2d_8784.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dF5fa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dF5fa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box_8784 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box_8784.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Text {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Text.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dtobox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dtobox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryF5fa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryF5fa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_8784 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_8784.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Bytea_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Bytea_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifyDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifyDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplify_1c13 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplify_1c13.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifyvw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifyvw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSeteffectivearea {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSeteffectivearea.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFilterbym {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFilterbym.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Bool.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StChaikinsmoothing {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StChaikinsmoothing.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogridBf72 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogridBf72.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogrid_2077 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogrid_2077.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogridDeb6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogridDeb6.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogrid_7713 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogrid_7713.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancecpa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancecpa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCpawithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCpawithin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidtrajectory {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidtrajectory.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectionE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectionE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferDcba {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferDcba.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
radius: PgCatalog.Types.Float8.parse(from.radius),
options: PgCatalog.Types.Text.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_3222 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_3222.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
radius: PgCatalog.Types.Float8.parse(from.radius),
quadsegs: PgCatalog.Types.Int4.parse(from.quadsegs),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumboundingradius {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumboundingradius.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumboundingcircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumboundingcircle.Parameters.is(from)) {
  return {
inputgeom: Public.Types.Geometry.parse(from.inputgeom),
segsPerQuarter: PgCatalog.Types.Int4.parse(from.segsPerQuarter),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOrientedenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOrientedenvelope.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOffsetcurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOffsetcurve.Parameters.is(from)) {
  return {
line: Public.Types.Geometry.parse(from.line),
distance: PgCatalog.Types.Float8.parse(from.distance),
params: PgCatalog.Types.Text.parse(from.params),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeneratepointsEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeneratepointsEd82.Parameters.is(from)) {
  return {
area: Public.Types.Geometry.parse(from.area),
npoints: PgCatalog.Types.Int4.parse(from.npoints),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeneratepointsA8be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeneratepointsA8be.Parameters.is(from)) {
  return {
area: Public.Types.Geometry.parse(from.area),
npoints: PgCatalog.Types.Int4.parse(from.npoints),
seed: PgCatalog.Types.Int4.parse(from.seed),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StConvexhull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StConvexhull.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifypreservetopology {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifypreservetopology.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidreason_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidreason_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvaliddetail {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvaliddetail.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidreasonEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidreasonEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHausdorffdistanceEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHausdorffdistanceEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHausdorffdistanceE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHausdorffdistanceE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFrechetdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFrechetdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMaximuminscribedcircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMaximuminscribedcircle.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLargestemptycircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLargestemptycircle.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
boundary: Public.Types.Geometry.parse(from.boundary),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBoundary {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBoundary.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSymdifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSymdifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSymmetricdifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSymmetricdifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnionEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnionEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnionE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnionE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnaryunion {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnaryunion.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRemoverepeatedpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRemoverepeatedpoints.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClipbybox2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClipbybox2d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
box: Public.Types.Box2d.parse(from.box),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSubdivide {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSubdivide.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxvertices: PgCatalog.Types.Int4.parse(from.maxvertices),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StReduceprecision {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StReduceprecision.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakevalid_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakevalid_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakevalidF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakevalidF1e2.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
params: PgCatalog.Types.Text.parse(from.params),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCleangeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCleangeometry.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSplit {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSplit.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSharedpaths {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSharedpaths.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnap {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnap.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelatematch {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelatematch.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNode {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNode.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDelaunaytriangles {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDelaunaytriangles.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTriangulatepolygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTriangulatepolygon.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StVoronoipolygons {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StVoronoipolygons.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
extendTo: Public.Types.Geometry.parse(from.extendTo),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StVoronoilines {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StVoronoilines.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
extendTo: Public.Types.Geometry.parse(from.extendTo),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebbox_2c84 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebbox_2c84.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebboxEe61 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebboxEe61.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: Public.Types.Box3d.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebbox_7c5a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebbox_7c5a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfnE941 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfnE941.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfnDd3f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfn_0a1f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryCollectFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryMakelineFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelTransfnE941 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelTransfnDd3f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnionF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnionF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoverageunionF393 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoverageunionF393.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelateEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelateEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelateCc0f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelateCc0f.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelate_6458 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelate_6458.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDisjoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDisjoint.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisIndexSupportfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisIndexSupportfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinecrossingdirection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinecrossingdirection.Parameters.is(from)) {
  return {
line1: Public.Types.Geometry.parse(from.line1),
line2: Public.Types.Geometry.parse(from.line2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithinE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithinE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTouches {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTouches.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectsEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectsEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCrosses {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCrosses.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StContains {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StContains.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StContainsproperly {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StContainsproperly.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoversEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoversEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredbyEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredbyEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOverlaps.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDfullywithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDfullywithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddwithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddwithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddfullywithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddfullywithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dintersects {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dintersects.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOrderingequals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOrderingequals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEquals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEquals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalid_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalid_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumclearance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumclearance.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumclearanceline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumclearanceline.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroid_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroid_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometricmedian {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometricmedian.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
maxIter: PgCatalog.Types.Int4.parse(from.maxIter),
failIfNotConverged: PgCatalog.Types.Bool.parse(from.failIfNotConverged),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointonsurface {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointonsurface.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIssimple {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIssimple.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIscollection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIscollection.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Equals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Equals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgml_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgml_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGmltosqlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGmltosqlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGmltosql_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGmltosql_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromkml {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromkml.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfrommarc21 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfrommarc21.Parameters.is(from)) {
  return {
marc21xml: PgCatalog.Types.Text.parse(from.marc21xml),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsmarc21 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsmarc21.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
format: PgCatalog.Types.Text.parse(from.format),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojsonE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojsonE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojson_608f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojson_608f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Json.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojson_3c9d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Jsonb.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisLibjsonVersion {
export namespace Results {
}
}
export namespace StLinefromencodedpolyline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromencodedpolyline.Parameters.is(from)) {
  return {
txtin: PgCatalog.Types.Text.parse(from.txtin),
nprecision: PgCatalog.Types.Int4.parse(from.nprecision),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsencodedpolyline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsencodedpolyline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
nprecision: PgCatalog.Types.Int4.parse(from.nprecision),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvgA8be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvgA8be.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
rel: PgCatalog.Types.Int4.parse(from.rel),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlA8be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlA8be.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgml_2621 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgml_2621.Parameters.is(from)) {
  return {
version: PgCatalog.Types.Int4.parse(from.version),
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskmlE3da {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskmlE3da.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonA8be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonA8be.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonF2c6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonF2c6.Parameters.is(from)) {
  return {
r: PgCatalog.Types.Record.parse(from.r),
geomColumn: PgCatalog.Types.Text.parse(from.geomColumn),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
prettyBool: PgCatalog.Types.Bool.parse(from.prettyBool),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Json {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Json.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Jsonb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Jsonb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_27f4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfnF57f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_92c1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
argument_4: PgCatalog.Types.Text.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfnF5be.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
argument_4: PgCatalog.Types.Text.parse(from.argument_4),
argument_5: PgCatalog.Types.Text.parse(from.argument_5),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtCombinefn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtCombinefn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtSerialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtSerialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtDeserialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtDeserialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsmvtgeom {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsmvtgeom.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
bounds: Public.Types.Box2d.parse(from.bounds),
extent: PgCatalog.Types.Int4.parse(from.extent),
buffer: PgCatalog.Types.Int4.parse(from.buffer),
clipGeom: PgCatalog.Types.Bool.parse(from.clipGeom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisLibprotobufVersion {
export namespace Results {
}
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsgeobufFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFromflatgeobuftotable {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFromflatgeobuftotable.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Bytea.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFromflatgeobuf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFromflatgeobuf.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Anyelement.parse(from.argument_0),
argument_1: PgCatalog.Types.Bytea.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeohashEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeohashEd82.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxchars: PgCatalog.Types.Int4.parse(from.maxchars),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBox2dfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBox2dfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumpoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumgeometries {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumgeometries.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDimension {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDimension.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExteriorring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExteriorring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNuminteriorrings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNuminteriorrings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNuminteriorring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNuminteriorring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInteriorringn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInteriorringn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometrytype_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometrytype_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometrytype {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometrytype.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumpatches {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumpatches.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPatchn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPatchn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StStartpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StStartpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEndpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEndpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsclosed {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsclosed.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsempty {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsempty.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinaryF1e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinaryF1e2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstextEd82 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstextEd82.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWkttosql {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWkttosql.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinestringfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinestringfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinestringfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolygonfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolygonfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolygonfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinestringfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinestringfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinestringfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyAnalyze {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyAnalyze.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinefromwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinefromwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMaxdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMaxdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpointEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpointEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestlineEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestlineEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLongestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLongestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSwapordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSwapordinates.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
ords: PgCatalog.Types.Cstring.parse(from.ords),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFlipcoordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFlipcoordinates.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBdpolyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBdpolyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBdmpolyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBdmpolyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Unlockrows {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Unlockrows.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_675a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_675a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Bytea_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Bytea_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_75a2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_75a2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace LockrowE9aa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.LockrowE9aa.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
argument_4: PgCatalog.Types.Timestamp.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_02b4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_02b4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_9a8a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_9a8a.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Timestamp.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addauth {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addauth.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauth_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Checkauth_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauth_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Checkauth_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauthtrigger {
export namespace Results {
}
}
export namespace Gettransactionid {
export namespace Results {
}
}
export namespace Enablelongtransactions {
export namespace Results {
}
}
export namespace Longtransactionsenabled {
export namespace Results {
}
}
export namespace Disablelongtransactions {
export namespace Results {
}
}
export namespace GeographyTypmodIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyTypmodIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.CstringArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyTypmodOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyTypmodOut.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyRecv {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyRecv.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySend.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeographyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeographyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeogfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeogfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeogfromwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeogfromwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodDims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodDims.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodType {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodType.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_0faa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_0faa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistConsistent {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistConsistent.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistCompress {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistCompress.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistPenalty {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistPenalty.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistPicksplit {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistPicksplit.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistUnion {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistUnion.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistSame {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistSame.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: Public.Types.Box2d.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistDecompress {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistDecompress.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyOverlaps.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyDistanceKnn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyDistanceKnn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistDistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistDistance.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeog_5a37 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeog_5a37.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeogBd57 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeogBd57.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeog_1597 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeog_1597.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeogBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeogBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyLt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyLt.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyLe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyLe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGt.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyEq {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyEq.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyCmp {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyCmp.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvg_8ddb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvg_8ddb.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
rel: PgCatalog.Types.Int4.parse(from.rel),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvgE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvgE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProjectE61a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProjectE61a.Parameters.is(from)) {
  return {
geogFrom: Public.Types.Geography.parse(from.geogFrom),
geogTo: Public.Types.Geography.parse(from.geogTo),
distance: PgCatalog.Types.Float8.parse(from.distance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAzimuthA587 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAzimuthA587.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_49f7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_49f7.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlCe11 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlCe11.Parameters.is(from)) {
  return {
version: PgCatalog.Types.Int4.parse(from.version),
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgml_98d7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgml_98d7.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskml_48da {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskml_48da.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojson_8ddb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojson_8ddb.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistance_89b8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistance_89b8.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistance_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistance_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAreaAc0a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAreaAc0a.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAreaE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAreaE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthAc0a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthAc0a.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProject_665e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProject_665e.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
distance: PgCatalog.Types.Float8.parse(from.distance),
azimuth: PgCatalog.Types.Float8.parse(from.azimuth),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeterAc0a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeterAc0a.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSegmentize_772c {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSegmentize_772c.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxSegmentLength: PgCatalog.Types.Float8.parse(from.maxSegmentLength),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinaryF815 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinaryF815.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_75a2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_75a2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewktE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewktE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometrytype_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometrytype_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSummary_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSummary_38ca.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeohash_75a2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeohash_75a2.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxchars: PgCatalog.Types.Int4.parse(from.maxchars),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSrid_38ca {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSrid_38ca.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetsrid_75a2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetsrid_75a2.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroidAc0a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroidAc0a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroidE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroidE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoversA587 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoversA587.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithin_5395 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithin_5395.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredbyA587 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredbyA587.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectsA587 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectsA587.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_772c {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_772c.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_2117 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_2117.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_3a01 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_3a01.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferF7c6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferF7c6.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectionA587 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectionA587.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersection_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersection_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCovers_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCovers_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredby_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredby_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithinEfc0 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithinEfc0.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersects_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersects_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpoint_89b8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpoint_89b8.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpoint_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpoint_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestline_89b8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestline_89b8.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestline_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestline_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstring_665e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstring_665e.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstringE586 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstringE586.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepoint_89b8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepoint_89b8.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepoint_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoints_5d11 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoints_5d11.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
repeat: PgCatalog.Types.Bool.parse(from.repeat),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointsC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointsC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointCee3 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointCee3.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancesphereEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancesphereEb6a.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancesphereE059 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancesphereE059.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypeName {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypeName.Parameters.is(from)) {
  return {
geomname: PgCatalog.Types.Varchar.parse(from.geomname),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
useNewName: PgCatalog.Types.Bool.parse(from.useNewName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintSrid.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintDims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintDims.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintType {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintType.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dmaxdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dmaxdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dclosestpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dclosestpoint.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dshortestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dshortestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlongestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlongestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoorddim {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoorddim.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCurvetoline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCurvetoline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tol: PgCatalog.Types.Float8.parse(from.tol),
toltype: PgCatalog.Types.Int4.parse(from.toltype),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHasarc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHasarc.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinetocurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinetocurve.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoint_0aec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoint_0aec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoint_0b7f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoint_0b7f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointz {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointz.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
zcoordinate: PgCatalog.Types.Float8.parse(from.zcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointm.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
mcoordinate: PgCatalog.Types.Float8.parse(from.mcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointzm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointzm.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
zcoordinate: PgCatalog.Types.Float8.parse(from.zcoordinate),
mcoordinate: PgCatalog.Types.Float8.parse(from.mcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygon.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWkbtosql {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWkbtosql.Parameters.is(from)) {
  return {
wkb: PgCatalog.Types.Bytea.parse(from.wkb),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatebetween {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatebetween.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
frommeasure: PgCatalog.Types.Float8.parse(from.frommeasure),
tomeasure: PgCatalog.Types.Float8.parse(from.tomeasure),
leftrightoffset: PgCatalog.Types.Float8.parse(from.leftrightoffset),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatealong {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatealong.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
measure: PgCatalog.Types.Float8.parse(from.measure),
leftrightoffset: PgCatalog.Types.Float8.parse(from.leftrightoffset),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatebetweenelevations {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatebetweenelevations.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
fromelevation: PgCatalog.Types.Float8.parse(from.fromelevation),
toelevation: PgCatalog.Types.Float8.parse(from.toelevation),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInterpolatepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInterpolatepoint.Parameters.is(from)) {
  return {
line: Public.Types.Geometry.parse(from.line),
point: Public.Types.Geometry.parse(from.point),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHexagon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHexagon.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
cellI: PgCatalog.Types.Int4.parse(from.cellI),
cellJ: PgCatalog.Types.Int4.parse(from.cellJ),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSquare {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSquare.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
cellI: PgCatalog.Types.Int4.parse(from.cellI),
cellJ: PgCatalog.Types.Int4.parse(from.cellJ),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHexagongrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHexagongrid.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
bounds: Public.Types.Geometry.parse(from.bounds),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSquaregrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSquaregrid.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
bounds: Public.Types.Geometry.parse(from.bounds),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2dD703 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2dD703.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2dD703 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2dD703.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2dD703 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2dD703.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2d_1585 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2d_1585.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2d_1585 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2d_1585.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2d_1585 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2d_1585.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2d_3f94 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2d_3f94.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2d_3f94 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2d_3f94.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2d_3f94 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2d_3f94.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNd_44c4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNd_44c4.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNdBd57 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNdBd57.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNd_19dd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNd_19dd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom2dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom3dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom4dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifypolygonhull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifypolygonhull.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
vertexFraction: PgCatalog.Types.Float8.parse(from.vertexFraction),
isOuter: PgCatalog.Types.Bool.parse(from.isOuter),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StConcavehull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StConcavehull.Parameters.is(from)) {
  return {
paramGeom: Public.Types.Geometry.parse(from.paramGeom),
paramPctconvex: PgCatalog.Types.Float8.parse(from.paramPctconvex),
paramAllowHoles: PgCatalog.Types.Bool.parse(from.paramAllowHoles),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsx3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsx3d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAngleEb6a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAngleEb6a.Parameters.is(from)) {
  return {
line1: Public.Types.Geometry.parse(from.line1),
line2: Public.Types.Geometry.parse(from.line2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlineinterpolatepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlineinterpolatepoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfig_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfig_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChoose_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChoose_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplit_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlaps_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlaps_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContains_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContains_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContained_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContained_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySame_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySame_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfig_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfig_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChoose_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChoose_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplit_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompress_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompress_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfigNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfigNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChooseNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChooseNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistConfigNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistConfigNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistChooseNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistChooseNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistInnerConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistLeafConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLetters {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLetters.Parameters.is(from)) {
  return {
letters: PgCatalog.Types.Text.parse(from.letters),
font: PgCatalog.Types.Json.parse(from.font),
};
}
throw new Error(JSON.stringify(from))
}


}
}
}
export namespace Tables {
export namespace SpatialRefSys {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycCensusBlocks {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycHomicides {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycNeighborhoods {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycStreets {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycSubwayStations {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_49556Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_49556Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_50314Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_50314Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_50320Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_50320Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1255Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1255Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1247Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1247Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2604Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2604Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2606Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2606Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2612Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2612Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2600Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2600Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2619Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2619Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3381Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3381Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3429Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3429Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2618Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2618Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2620Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2620Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3466Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3466Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2609Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2609Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_50326Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_50326Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2615Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2615Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1262Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1262Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2964Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2964Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1213Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1213Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1260Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1260Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2396Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2396Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3600Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3600Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3079Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3079Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2328Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2328Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1417Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1417Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1418Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1418Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3118Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3118Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3256Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3256Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6000Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6000Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_826Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_826Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3394Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3394Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3596Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3596Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3592Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3592Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3456Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3456Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6243Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6243Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3350Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3350Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6106Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6106Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6100Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6100Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_50332Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_50332Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_50338Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_50338Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13658Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13658Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13663Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13663Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13668Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13668Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13673Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13673Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
}
export namespace Tables {
}
}
// begin table column parser mapping
export namespace PgCatalog {
export namespace Tables {
export namespace PgStatistic {
export namespace Starelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staattnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stainherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Stanullfrac {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Stawidth {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Stadistinct {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Stakind1 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind2 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind3 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind4 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind5 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Staop1 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop2 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop3 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop4 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop5 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll1 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll2 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll3 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll4 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll5 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stanumbers1 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers2 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers3 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers4 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers5 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stavalues1 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues2 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues3 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues4 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues5 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
}
export namespace PgType {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Typnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typlen {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Typbyval {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typcategory {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typispreferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typisdefined {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typdelim {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typsubscript {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typelem {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typarray {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typinput {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typoutput {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typreceive {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typsend {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typmodin {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typmodout {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typanalyze {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typalign {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typstorage {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typnotnull {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typbasetype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typtypmod {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Typndims {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Typcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typdefaultbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Typdefault {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Typacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgForeignTable {
export namespace Ftrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Ftserver {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Ftoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgAuthid {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rolname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Rolsuper {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcreaterole {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcreatedb {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcanlogin {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolreplication {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolbypassrls {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolconnlimit {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Rolpassword {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Rolvaliduntil {
export const parse = PgCatalog.Types.Timestamptz.parse;
}
}
export namespace PgStatisticExtData {
export namespace Stxoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxdinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Stxdndistinct {
export const parse = PgCatalog.Types.PgNdistinct.parse;
}
export namespace Stxddependencies {
export const parse = PgCatalog.Types.PgDependencies.parse;
}
export namespace Stxdmcv {
export const parse = PgCatalog.Types.PgMcvList.parse;
}
export namespace Stxdexpr {
export const parse = PgCatalog.Types.PgStatisticArray.parse;
}
}
export namespace PgUserMapping {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umuser {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umserver {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgSubscription {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subdbid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subskiplsn {
export const parse = PgCatalog.Types.PgLsn.parse;
}
export namespace Subname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Subowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subenabled {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subbinary {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Substream {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Subtwophasestate {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Subdisableonerr {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subpasswordrequired {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subrunasowner {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subconninfo {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Subslotname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Subsynccommit {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Subpublications {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Suborigin {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgAttribute {
export namespace Attrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Atttypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attlen {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attcacheoff {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Atttypmod {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Attndims {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attbyval {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attalign {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attstorage {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attcompression {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attnotnull {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Atthasdef {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Atthasmissing {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attidentity {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attgenerated {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attisdropped {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attislocal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attinhcount {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attstattarget {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Attoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Attfdwoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Attmissingval {
export const parse = PgCatalog.Types.Anyarray.parse;
}
}
export namespace PgProc {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Pronamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prolang {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Procost {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Prorows {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Provariadic {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prosupport {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prokind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Prosecdef {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proleakproof {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proisstrict {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proretset {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Provolatile {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Proparallel {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Pronargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Pronargdefaults {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Prorettype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proargtypes {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Proallargtypes {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Proargmodes {
export const parse = PgCatalog.Types.CharArray.parse;
}
export namespace Proargnames {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Proargdefaults {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Protrftypes {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Prosrc {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Probin {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Prosqlbody {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Proconfig {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Proacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgClass {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Relnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reltype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reloftype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relam {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relfilenode {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reltablespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relpages {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Reltuples {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Relallvisible {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Reltoastrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relhasindex {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relisshared {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relpersistence {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Relchecks {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Relhasrules {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relhastriggers {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relhassubclass {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relrowsecurity {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relforcerowsecurity {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relispopulated {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relreplident {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relispartition {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relrewrite {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relfrozenxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Relminmxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Relacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Reloptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Relpartbound {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgAttrdef {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Adrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Adnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Adbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgConstraint {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Connamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Contype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Condeferrable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Condeferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Convalidated {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Conrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Contypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conindid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conparentid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Confrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Confupdtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Confdeltype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Confmatchtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Conislocal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Coninhcount {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Connoinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Conkey {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Confkey {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Conpfeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conppeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conffeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Confdelsetcols {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Conexclop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgInherits {
export namespace Inhrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Inhparent {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Inhseqno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Inhdetachpending {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgIndex {
export namespace Indexrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Indrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Indnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Indnkeyatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Indisunique {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indnullsnotdistinct {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisprimary {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisexclusion {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indimmediate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisclustered {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisvalid {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indcheckxmin {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisready {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indislive {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisreplident {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indkey {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Indcollation {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Indclass {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Indoption {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Indexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Indpred {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgOperator {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Oprnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Oprcanmerge {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Oprcanhash {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Oprleft {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprright {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprresult {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprcom {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprnegate {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprcode {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Oprrest {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Oprjoin {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgOpfamily {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Opfnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfowner {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgOpclass {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Opcnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcintype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcdefault {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Opckeytype {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgAm {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Amhandler {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Amtype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgAmop {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amoplefttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amoprighttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopstrategy {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Amoppurpose {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Amopopr {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopsortfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgAmproc {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amproclefttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocrighttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Amproc {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgLanguage {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Lanowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanispl {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Lanpltrusted {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Lanplcallfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Laninline {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanvalidator {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgLargeobjectMetadata {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lomowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lomacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgAggregate {
export namespace Aggfnoid {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggnumdirectargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Aggtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggfinalfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggcombinefn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggserialfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggdeserialfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggmtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggminvtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggmfinalfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggfinalextra {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Aggmfinalextra {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Aggfinalmodify {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggmfinalmodify {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggsortop {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggtranstype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggtransspace {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Aggmtranstype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggmtransspace {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Agginitval {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Aggminitval {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgStatisticExt {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Stxnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxstattarget {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Stxkeys {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Stxkind {
export const parse = PgCatalog.Types.CharArray.parse;
}
export namespace Stxexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgRewrite {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rulename {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace EvClass {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace EvType {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace EvEnabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace IsInstead {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace EvQual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace EvAction {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgTrigger {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgparentid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tgfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgtype {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Tgenabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Tgisinternal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tgconstrrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgconstrindid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgconstraint {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgdeferrable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tginitdeferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tgnargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Tgattr {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Tgargs {
export const parse = PgCatalog.Types.Bytea.parse;
}
export namespace Tgqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Tgoldtable {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tgnewtable {
export const parse = PgCatalog.Types.Name.parse;
}
}
export namespace PgEventTrigger {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Evtevent {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Evtowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtenabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Evttags {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgDescription {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Description {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgCast {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castsource {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Casttarget {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castfunc {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castcontext {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Castmethod {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgEnum {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Enumtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Enumsortorder {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Enumlabel {
export const parse = PgCatalog.Types.Name.parse;
}
}
export namespace PgNamespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Nspname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Nspowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Nspacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgConversion {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Connamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conforencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Contoencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Conproc {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Condefault {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgDepend {
export namespace Classid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Refclassid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Deptype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgDatabase {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Datname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Datdba {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Encoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Datlocprovider {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Datistemplate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Datallowconn {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Datconnlimit {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Datfrozenxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Datminmxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Dattablespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Datcollate {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datctype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Daticulocale {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Daticurules {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datcollversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgDbRoleSetting {
export namespace Setdatabase {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Setrole {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Setconfig {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgTablespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Spcname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Spcowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Spcacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Spcoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgAuthMembers {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Roleid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Member {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Grantor {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace AdminOption {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace InheritOption {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace SetOption {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgShdepend {
export namespace Dbid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Refclassid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Deptype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgShdescription {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Description {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgTsConfig {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Cfgnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgparser {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgTsConfigMap {
export namespace Mapcfg {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Maptokentype {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Mapseqno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Mapdict {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgTsDict {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Dictnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dicttemplate {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictinitoption {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgTsParser {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prsname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Prsnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prsstart {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prstoken {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prsend {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prsheadline {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prslextype {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgTsTemplate {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tmplname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tmplnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tmplinit {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Tmpllexize {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgExtension {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Extowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extrelocatable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Extversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Extconfig {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Extcondition {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgForeignDataWrapper {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Fdwowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwhandler {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwvalidator {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Fdwoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgForeignServer {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Srvowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvfdw {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvtype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Srvversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Srvacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Srvoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgPolicy {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Polname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Polrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Polcmd {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Polpermissive {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Polroles {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Polqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Polwithcheck {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgReplicationOrigin {
export namespace Roident {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Roname {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgDefaultAcl {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclrole {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclobjtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Defaclacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgInitPrivs {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Privtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Initprivs {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgSeclabel {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Provider {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgShseclabel {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Provider {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgCollation {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Collnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collprovider {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Collisdeterministic {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Collencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Collcollate {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collctype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Colliculocale {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collicurules {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collversion {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgParameterAcl {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Parname {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Paracl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgPartitionedTable {
export namespace Partrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Partstrat {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Partnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Partdefid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Partattrs {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Partclass {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Partcollation {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Partexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgRange {
export namespace Rngtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngsubtype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngmultitypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngsubopc {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngcanonical {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Rngsubdiff {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgTransform {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trftype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trflang {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trffromsql {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Trftosql {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgSequence {
export namespace Seqrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Seqtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Seqstart {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqincrement {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqmax {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqmin {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqcache {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqcycle {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgPublication {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pubname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Pubowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Puballtables {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubinsert {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubupdate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubdelete {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubtruncate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubviaroot {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgPublicationNamespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pnpubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pnnspid {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgPublicationRel {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prpubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Prattrs {
export const parse = PgCatalog.Types.Int2vector.parse;
}
}
export namespace PgSubscriptionRel {
export namespace Srsubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srsubstate {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Srsublsn {
export const parse = PgCatalog.Types.PgLsn.parse;
}
}
export namespace PgLargeobject {
export namespace Loid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pageno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Data {
export const parse = PgCatalog.Types.Bytea.parse;
}
}
}
}
export namespace InformationSchema {
export namespace Tables {
export namespace SqlFeatures {
export namespace FeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace FeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SubFeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SubFeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IsSupported {
export const parse = InformationSchema.Types.YesOrNo.parse;
}
export namespace IsVerifiedBy {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlImplementationInfo {
export namespace ImplementationInfoId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace ImplementationInfoName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IntegerValue {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace CharacterValue {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlParts {
export namespace FeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace FeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IsSupported {
export const parse = InformationSchema.Types.YesOrNo.parse;
}
export namespace IsVerifiedBy {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlSizing {
export namespace SizingId {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace SizingName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SupportedValue {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
}
}
export namespace Public {
export namespace Tables {
export namespace SpatialRefSys {
export namespace Srid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace AuthName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace AuthSrid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Srtext {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Proj4text {
export const parse = PgCatalog.Types.Varchar.parse;
}
}
export namespace NycCensusBlocks {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Blkid {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace PopnTotal {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnWhite {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnBlack {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnNativ {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnAsian {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnOther {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycHomicides {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace IncidentD {
export const parse = PgCatalog.Types.Date.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace NumVictim {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace PrimaryMo {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Weapon {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace LightDark {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Year {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycNeighborhoods {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycStreets {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Oneway {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Type {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycSubwayStations {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Objectid {
export const parse = PgCatalog.Types.Numeric.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Numeric.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace AltName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace CrossSt {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace LongName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Borough {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Nghbhd {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Routes {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Transfers {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Color {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Express {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Closed {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
}
}
export namespace PgToast {
export namespace Tables {
}
}

// begin primary key pickers
export namespace Public {
export namespace Tables {
export namespace SpatialRefSys {
export function primaryKeyFrom(value: Public.Types.SpatialRefSys) : string {
return JSON.stringify({
srid: value.srid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.SpatialRefSys>){
        return value.srid !== undefined
      }
      
}
export namespace NycCensusBlocks {
export function primaryKeyFrom(value: Public.Types.NycCensusBlocks) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycCensusBlocks>){
        return value.gid !== undefined
      }
      
}
export namespace NycHomicides {
export function primaryKeyFrom(value: Public.Types.NycHomicides) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycHomicides>){
        return value.gid !== undefined
      }
      
}
export namespace NycNeighborhoods {
export function primaryKeyFrom(value: Public.Types.NycNeighborhoods) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycNeighborhoods>){
        return value.gid !== undefined
      }
      
}
export namespace NycStreets {
export function primaryKeyFrom(value: Public.Types.NycStreets) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycStreets>){
        return value.gid !== undefined
      }
      
}
export namespace NycSubwayStations {
export function primaryKeyFrom(value: Public.Types.NycSubwayStations) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycSubwayStations>){
        return value.gid !== undefined
      }
      
}
}
}
export namespace PgToast {
export namespace Tables {
}
}

export namespace PgCatalog {
export namespace Types {
export namespace PgType {
export function is(value: any) : value is PgCatalog.Types.PgType {
if (
(value.oid !== undefined) && (value.typname !== undefined) && (value.typnamespace !== undefined) && (value.typowner !== undefined) && (value.typlen !== undefined) && (value.typbyval !== undefined) && (value.typtype !== undefined) && (value.typcategory !== undefined) && (value.typispreferred !== undefined) && (value.typisdefined !== undefined) && (value.typdelim !== undefined) && (value.typrelid !== undefined) && (value.typsubscript !== undefined) && (value.typelem !== undefined) && (value.typarray !== undefined) && (value.typinput !== undefined) && (value.typoutput !== undefined) && (value.typreceive !== undefined) && (value.typsend !== undefined) && (value.typmodin !== undefined) && (value.typmodout !== undefined) && (value.typanalyze !== undefined) && (value.typalign !== undefined) && (value.typstorage !== undefined) && (value.typnotnull !== undefined) && (value.typbasetype !== undefined) && (value.typtypmod !== undefined) && (value.typndims !== undefined) && (value.typcollation !== undefined) && (value.typdefaultbin !== undefined) && (value.typdefault !== undefined) && (value.typacl !== undefined)
) return true;
return false;
}
}
export namespace PgAttribute {
export function is(value: any) : value is PgCatalog.Types.PgAttribute {
if (
(value.attrelid !== undefined) && (value.attname !== undefined) && (value.atttypid !== undefined) && (value.attlen !== undefined) && (value.attnum !== undefined) && (value.attcacheoff !== undefined) && (value.atttypmod !== undefined) && (value.attndims !== undefined) && (value.attbyval !== undefined) && (value.attalign !== undefined) && (value.attstorage !== undefined) && (value.attcompression !== undefined) && (value.attnotnull !== undefined) && (value.atthasdef !== undefined) && (value.atthasmissing !== undefined) && (value.attidentity !== undefined) && (value.attgenerated !== undefined) && (value.attisdropped !== undefined) && (value.attislocal !== undefined) && (value.attinhcount !== undefined) && (value.attstattarget !== undefined) && (value.attcollation !== undefined) && (value.attacl !== undefined) && (value.attoptions !== undefined) && (value.attfdwoptions !== undefined) && (value.attmissingval !== undefined)
) return true;
return false;
}
}
export namespace PgProc {
export function is(value: any) : value is PgCatalog.Types.PgProc {
if (
(value.oid !== undefined) && (value.proname !== undefined) && (value.pronamespace !== undefined) && (value.proowner !== undefined) && (value.prolang !== undefined) && (value.procost !== undefined) && (value.prorows !== undefined) && (value.provariadic !== undefined) && (value.prosupport !== undefined) && (value.prokind !== undefined) && (value.prosecdef !== undefined) && (value.proleakproof !== undefined) && (value.proisstrict !== undefined) && (value.proretset !== undefined) && (value.provolatile !== undefined) && (value.proparallel !== undefined) && (value.pronargs !== undefined) && (value.pronargdefaults !== undefined) && (value.prorettype !== undefined) && (value.proargtypes !== undefined) && (value.proallargtypes !== undefined) && (value.proargmodes !== undefined) && (value.proargnames !== undefined) && (value.proargdefaults !== undefined) && (value.protrftypes !== undefined) && (value.prosrc !== undefined) && (value.probin !== undefined) && (value.prosqlbody !== undefined) && (value.proconfig !== undefined) && (value.proacl !== undefined)
) return true;
return false;
}
}
export namespace PgClass {
export function is(value: any) : value is PgCatalog.Types.PgClass {
if (
(value.oid !== undefined) && (value.relname !== undefined) && (value.relnamespace !== undefined) && (value.reltype !== undefined) && (value.reloftype !== undefined) && (value.relowner !== undefined) && (value.relam !== undefined) && (value.relfilenode !== undefined) && (value.reltablespace !== undefined) && (value.relpages !== undefined) && (value.reltuples !== undefined) && (value.relallvisible !== undefined) && (value.reltoastrelid !== undefined) && (value.relhasindex !== undefined) && (value.relisshared !== undefined) && (value.relpersistence !== undefined) && (value.relkind !== undefined) && (value.relnatts !== undefined) && (value.relchecks !== undefined) && (value.relhasrules !== undefined) && (value.relhastriggers !== undefined) && (value.relhassubclass !== undefined) && (value.relrowsecurity !== undefined) && (value.relforcerowsecurity !== undefined) && (value.relispopulated !== undefined) && (value.relreplident !== undefined) && (value.relispartition !== undefined) && (value.relrewrite !== undefined) && (value.relfrozenxid !== undefined) && (value.relminmxid !== undefined) && (value.relacl !== undefined) && (value.reloptions !== undefined) && (value.relpartbound !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdef {
export function is(value: any) : value is PgCatalog.Types.PgAttrdef {
if (
(value.oid !== undefined) && (value.adrelid !== undefined) && (value.adnum !== undefined) && (value.adbin !== undefined)
) return true;
return false;
}
}
export namespace PgConstraint {
export function is(value: any) : value is PgCatalog.Types.PgConstraint {
if (
(value.oid !== undefined) && (value.conname !== undefined) && (value.connamespace !== undefined) && (value.contype !== undefined) && (value.condeferrable !== undefined) && (value.condeferred !== undefined) && (value.convalidated !== undefined) && (value.conrelid !== undefined) && (value.contypid !== undefined) && (value.conindid !== undefined) && (value.conparentid !== undefined) && (value.confrelid !== undefined) && (value.confupdtype !== undefined) && (value.confdeltype !== undefined) && (value.confmatchtype !== undefined) && (value.conislocal !== undefined) && (value.coninhcount !== undefined) && (value.connoinherit !== undefined) && (value.conkey !== undefined) && (value.confkey !== undefined) && (value.conpfeqop !== undefined) && (value.conppeqop !== undefined) && (value.conffeqop !== undefined) && (value.confdelsetcols !== undefined) && (value.conexclop !== undefined) && (value.conbin !== undefined)
) return true;
return false;
}
}
export namespace PgInherits {
export function is(value: any) : value is PgCatalog.Types.PgInherits {
if (
(value.inhrelid !== undefined) && (value.inhparent !== undefined) && (value.inhseqno !== undefined) && (value.inhdetachpending !== undefined)
) return true;
return false;
}
}
export namespace PgIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndex {
if (
(value.indexrelid !== undefined) && (value.indrelid !== undefined) && (value.indnatts !== undefined) && (value.indnkeyatts !== undefined) && (value.indisunique !== undefined) && (value.indnullsnotdistinct !== undefined) && (value.indisprimary !== undefined) && (value.indisexclusion !== undefined) && (value.indimmediate !== undefined) && (value.indisclustered !== undefined) && (value.indisvalid !== undefined) && (value.indcheckxmin !== undefined) && (value.indisready !== undefined) && (value.indislive !== undefined) && (value.indisreplident !== undefined) && (value.indkey !== undefined) && (value.indcollation !== undefined) && (value.indclass !== undefined) && (value.indoption !== undefined) && (value.indexprs !== undefined) && (value.indpred !== undefined)
) return true;
return false;
}
}
export namespace PgOperator {
export function is(value: any) : value is PgCatalog.Types.PgOperator {
if (
(value.oid !== undefined) && (value.oprname !== undefined) && (value.oprnamespace !== undefined) && (value.oprowner !== undefined) && (value.oprkind !== undefined) && (value.oprcanmerge !== undefined) && (value.oprcanhash !== undefined) && (value.oprleft !== undefined) && (value.oprright !== undefined) && (value.oprresult !== undefined) && (value.oprcom !== undefined) && (value.oprnegate !== undefined) && (value.oprcode !== undefined) && (value.oprrest !== undefined) && (value.oprjoin !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamily {
export function is(value: any) : value is PgCatalog.Types.PgOpfamily {
if (
(value.oid !== undefined) && (value.opfmethod !== undefined) && (value.opfname !== undefined) && (value.opfnamespace !== undefined) && (value.opfowner !== undefined)
) return true;
return false;
}
}
export namespace PgOpclass {
export function is(value: any) : value is PgCatalog.Types.PgOpclass {
if (
(value.oid !== undefined) && (value.opcmethod !== undefined) && (value.opcname !== undefined) && (value.opcnamespace !== undefined) && (value.opcowner !== undefined) && (value.opcfamily !== undefined) && (value.opcintype !== undefined) && (value.opcdefault !== undefined) && (value.opckeytype !== undefined)
) return true;
return false;
}
}
export namespace PgAm {
export function is(value: any) : value is PgCatalog.Types.PgAm {
if (
(value.oid !== undefined) && (value.amname !== undefined) && (value.amhandler !== undefined) && (value.amtype !== undefined)
) return true;
return false;
}
}
export namespace PgAmop {
export function is(value: any) : value is PgCatalog.Types.PgAmop {
if (
(value.oid !== undefined) && (value.amopfamily !== undefined) && (value.amoplefttype !== undefined) && (value.amoprighttype !== undefined) && (value.amopstrategy !== undefined) && (value.amoppurpose !== undefined) && (value.amopopr !== undefined) && (value.amopmethod !== undefined) && (value.amopsortfamily !== undefined)
) return true;
return false;
}
}
export namespace PgAmproc {
export function is(value: any) : value is PgCatalog.Types.PgAmproc {
if (
(value.oid !== undefined) && (value.amprocfamily !== undefined) && (value.amproclefttype !== undefined) && (value.amprocrighttype !== undefined) && (value.amprocnum !== undefined) && (value.amproc !== undefined)
) return true;
return false;
}
}
export namespace PgLanguage {
export function is(value: any) : value is PgCatalog.Types.PgLanguage {
if (
(value.oid !== undefined) && (value.lanname !== undefined) && (value.lanowner !== undefined) && (value.lanispl !== undefined) && (value.lanpltrusted !== undefined) && (value.lanplcallfoid !== undefined) && (value.laninline !== undefined) && (value.lanvalidator !== undefined) && (value.lanacl !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectMetadata {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectMetadata {
if (
(value.oid !== undefined) && (value.lomowner !== undefined) && (value.lomacl !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobject {
export function is(value: any) : value is PgCatalog.Types.PgLargeobject {
if (
(value.loid !== undefined) && (value.pageno !== undefined) && (value.data !== undefined)
) return true;
return false;
}
}
export namespace PgAggregate {
export function is(value: any) : value is PgCatalog.Types.PgAggregate {
if (
(value.aggfnoid !== undefined) && (value.aggkind !== undefined) && (value.aggnumdirectargs !== undefined) && (value.aggtransfn !== undefined) && (value.aggfinalfn !== undefined) && (value.aggcombinefn !== undefined) && (value.aggserialfn !== undefined) && (value.aggdeserialfn !== undefined) && (value.aggmtransfn !== undefined) && (value.aggminvtransfn !== undefined) && (value.aggmfinalfn !== undefined) && (value.aggfinalextra !== undefined) && (value.aggmfinalextra !== undefined) && (value.aggfinalmodify !== undefined) && (value.aggmfinalmodify !== undefined) && (value.aggsortop !== undefined) && (value.aggtranstype !== undefined) && (value.aggtransspace !== undefined) && (value.aggmtranstype !== undefined) && (value.aggmtransspace !== undefined) && (value.agginitval !== undefined) && (value.aggminitval !== undefined)
) return true;
return false;
}
}
export namespace PgStatistic {
export function is(value: any) : value is PgCatalog.Types.PgStatistic {
if (
(value.starelid !== undefined) && (value.staattnum !== undefined) && (value.stainherit !== undefined) && (value.stanullfrac !== undefined) && (value.stawidth !== undefined) && (value.stadistinct !== undefined) && (value.stakind1 !== undefined) && (value.stakind2 !== undefined) && (value.stakind3 !== undefined) && (value.stakind4 !== undefined) && (value.stakind5 !== undefined) && (value.staop1 !== undefined) && (value.staop2 !== undefined) && (value.staop3 !== undefined) && (value.staop4 !== undefined) && (value.staop5 !== undefined) && (value.stacoll1 !== undefined) && (value.stacoll2 !== undefined) && (value.stacoll3 !== undefined) && (value.stacoll4 !== undefined) && (value.stacoll5 !== undefined) && (value.stanumbers1 !== undefined) && (value.stanumbers2 !== undefined) && (value.stanumbers3 !== undefined) && (value.stanumbers4 !== undefined) && (value.stanumbers5 !== undefined) && (value.stavalues1 !== undefined) && (value.stavalues2 !== undefined) && (value.stavalues3 !== undefined) && (value.stavalues4 !== undefined) && (value.stavalues5 !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExt {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExt {
if (
(value.oid !== undefined) && (value.stxrelid !== undefined) && (value.stxname !== undefined) && (value.stxnamespace !== undefined) && (value.stxowner !== undefined) && (value.stxstattarget !== undefined) && (value.stxkeys !== undefined) && (value.stxkind !== undefined) && (value.stxexprs !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtData {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtData {
if (
(value.stxoid !== undefined) && (value.stxdinherit !== undefined) && (value.stxdndistinct !== undefined) && (value.stxddependencies !== undefined) && (value.stxdmcv !== undefined) && (value.stxdexpr !== undefined)
) return true;
return false;
}
}
export namespace PgRewrite {
export function is(value: any) : value is PgCatalog.Types.PgRewrite {
if (
(value.oid !== undefined) && (value.rulename !== undefined) && (value.evClass !== undefined) && (value.evType !== undefined) && (value.evEnabled !== undefined) && (value.isInstead !== undefined) && (value.evQual !== undefined) && (value.evAction !== undefined)
) return true;
return false;
}
}
export namespace PgTrigger {
export function is(value: any) : value is PgCatalog.Types.PgTrigger {
if (
(value.oid !== undefined) && (value.tgrelid !== undefined) && (value.tgparentid !== undefined) && (value.tgname !== undefined) && (value.tgfoid !== undefined) && (value.tgtype !== undefined) && (value.tgenabled !== undefined) && (value.tgisinternal !== undefined) && (value.tgconstrrelid !== undefined) && (value.tgconstrindid !== undefined) && (value.tgconstraint !== undefined) && (value.tgdeferrable !== undefined) && (value.tginitdeferred !== undefined) && (value.tgnargs !== undefined) && (value.tgattr !== undefined) && (value.tgargs !== undefined) && (value.tgqual !== undefined) && (value.tgoldtable !== undefined) && (value.tgnewtable !== undefined)
) return true;
return false;
}
}
export namespace PgEventTrigger {
export function is(value: any) : value is PgCatalog.Types.PgEventTrigger {
if (
(value.oid !== undefined) && (value.evtname !== undefined) && (value.evtevent !== undefined) && (value.evtowner !== undefined) && (value.evtfoid !== undefined) && (value.evtenabled !== undefined) && (value.evttags !== undefined)
) return true;
return false;
}
}
export namespace PgDescription {
export function is(value: any) : value is PgCatalog.Types.PgDescription {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.description !== undefined)
) return true;
return false;
}
}
export namespace PgCast {
export function is(value: any) : value is PgCatalog.Types.PgCast {
if (
(value.oid !== undefined) && (value.castsource !== undefined) && (value.casttarget !== undefined) && (value.castfunc !== undefined) && (value.castcontext !== undefined) && (value.castmethod !== undefined)
) return true;
return false;
}
}
export namespace PgEnum {
export function is(value: any) : value is PgCatalog.Types.PgEnum {
if (
(value.oid !== undefined) && (value.enumtypid !== undefined) && (value.enumsortorder !== undefined) && (value.enumlabel !== undefined)
) return true;
return false;
}
}
export namespace PgNamespace {
export function is(value: any) : value is PgCatalog.Types.PgNamespace {
if (
(value.oid !== undefined) && (value.nspname !== undefined) && (value.nspowner !== undefined) && (value.nspacl !== undefined)
) return true;
return false;
}
}
export namespace PgConversion {
export function is(value: any) : value is PgCatalog.Types.PgConversion {
if (
(value.oid !== undefined) && (value.conname !== undefined) && (value.connamespace !== undefined) && (value.conowner !== undefined) && (value.conforencoding !== undefined) && (value.contoencoding !== undefined) && (value.conproc !== undefined) && (value.condefault !== undefined)
) return true;
return false;
}
}
export namespace PgDepend {
export function is(value: any) : value is PgCatalog.Types.PgDepend {
if (
(value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.refobjsubid !== undefined) && (value.deptype !== undefined)
) return true;
return false;
}
}
export namespace PgDatabase {
export function is(value: any) : value is PgCatalog.Types.PgDatabase {
if (
(value.oid !== undefined) && (value.datname !== undefined) && (value.datdba !== undefined) && (value.encoding !== undefined) && (value.datlocprovider !== undefined) && (value.datistemplate !== undefined) && (value.datallowconn !== undefined) && (value.datconnlimit !== undefined) && (value.datfrozenxid !== undefined) && (value.datminmxid !== undefined) && (value.dattablespace !== undefined) && (value.datcollate !== undefined) && (value.datctype !== undefined) && (value.daticulocale !== undefined) && (value.daticurules !== undefined) && (value.datcollversion !== undefined) && (value.datacl !== undefined)
) return true;
return false;
}
}
export namespace PgDbRoleSetting {
export function is(value: any) : value is PgCatalog.Types.PgDbRoleSetting {
if (
(value.setdatabase !== undefined) && (value.setrole !== undefined) && (value.setconfig !== undefined)
) return true;
return false;
}
}
export namespace PgTablespace {
export function is(value: any) : value is PgCatalog.Types.PgTablespace {
if (
(value.oid !== undefined) && (value.spcname !== undefined) && (value.spcowner !== undefined) && (value.spcacl !== undefined) && (value.spcoptions !== undefined)
) return true;
return false;
}
}
export namespace PgAuthid {
export function is(value: any) : value is PgCatalog.Types.PgAuthid {
if (
(value.oid !== undefined) && (value.rolname !== undefined) && (value.rolsuper !== undefined) && (value.rolinherit !== undefined) && (value.rolcreaterole !== undefined) && (value.rolcreatedb !== undefined) && (value.rolcanlogin !== undefined) && (value.rolreplication !== undefined) && (value.rolbypassrls !== undefined) && (value.rolconnlimit !== undefined) && (value.rolpassword !== undefined) && (value.rolvaliduntil !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembers {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembers {
if (
(value.oid !== undefined) && (value.roleid !== undefined) && (value.member !== undefined) && (value.grantor !== undefined) && (value.adminOption !== undefined) && (value.inheritOption !== undefined) && (value.setOption !== undefined)
) return true;
return false;
}
}
export namespace PgShdepend {
export function is(value: any) : value is PgCatalog.Types.PgShdepend {
if (
(value.dbid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.deptype !== undefined)
) return true;
return false;
}
}
export namespace PgShdescription {
export function is(value: any) : value is PgCatalog.Types.PgShdescription {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.description !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfig {
export function is(value: any) : value is PgCatalog.Types.PgTsConfig {
if (
(value.oid !== undefined) && (value.cfgname !== undefined) && (value.cfgnamespace !== undefined) && (value.cfgowner !== undefined) && (value.cfgparser !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigMap {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigMap {
if (
(value.mapcfg !== undefined) && (value.maptokentype !== undefined) && (value.mapseqno !== undefined) && (value.mapdict !== undefined)
) return true;
return false;
}
}
export namespace PgTsDict {
export function is(value: any) : value is PgCatalog.Types.PgTsDict {
if (
(value.oid !== undefined) && (value.dictname !== undefined) && (value.dictnamespace !== undefined) && (value.dictowner !== undefined) && (value.dicttemplate !== undefined) && (value.dictinitoption !== undefined)
) return true;
return false;
}
}
export namespace PgTsParser {
export function is(value: any) : value is PgCatalog.Types.PgTsParser {
if (
(value.oid !== undefined) && (value.prsname !== undefined) && (value.prsnamespace !== undefined) && (value.prsstart !== undefined) && (value.prstoken !== undefined) && (value.prsend !== undefined) && (value.prsheadline !== undefined) && (value.prslextype !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplate {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplate {
if (
(value.oid !== undefined) && (value.tmplname !== undefined) && (value.tmplnamespace !== undefined) && (value.tmplinit !== undefined) && (value.tmpllexize !== undefined)
) return true;
return false;
}
}
export namespace PgExtension {
export function is(value: any) : value is PgCatalog.Types.PgExtension {
if (
(value.oid !== undefined) && (value.extname !== undefined) && (value.extowner !== undefined) && (value.extnamespace !== undefined) && (value.extrelocatable !== undefined) && (value.extversion !== undefined) && (value.extconfig !== undefined) && (value.extcondition !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapper {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapper {
if (
(value.oid !== undefined) && (value.fdwname !== undefined) && (value.fdwowner !== undefined) && (value.fdwhandler !== undefined) && (value.fdwvalidator !== undefined) && (value.fdwacl !== undefined) && (value.fdwoptions !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServer {
export function is(value: any) : value is PgCatalog.Types.PgForeignServer {
if (
(value.oid !== undefined) && (value.srvname !== undefined) && (value.srvowner !== undefined) && (value.srvfdw !== undefined) && (value.srvtype !== undefined) && (value.srvversion !== undefined) && (value.srvacl !== undefined) && (value.srvoptions !== undefined)
) return true;
return false;
}
}
export namespace PgUserMapping {
export function is(value: any) : value is PgCatalog.Types.PgUserMapping {
if (
(value.oid !== undefined) && (value.umuser !== undefined) && (value.umserver !== undefined) && (value.umoptions !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTable {
export function is(value: any) : value is PgCatalog.Types.PgForeignTable {
if (
(value.ftrelid !== undefined) && (value.ftserver !== undefined) && (value.ftoptions !== undefined)
) return true;
return false;
}
}
export namespace PgPolicy {
export function is(value: any) : value is PgCatalog.Types.PgPolicy {
if (
(value.oid !== undefined) && (value.polname !== undefined) && (value.polrelid !== undefined) && (value.polcmd !== undefined) && (value.polpermissive !== undefined) && (value.polroles !== undefined) && (value.polqual !== undefined) && (value.polwithcheck !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOrigin {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOrigin {
if (
(value.roident !== undefined) && (value.roname !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAcl {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAcl {
if (
(value.oid !== undefined) && (value.defaclrole !== undefined) && (value.defaclnamespace !== undefined) && (value.defaclobjtype !== undefined) && (value.defaclacl !== undefined)
) return true;
return false;
}
}
export namespace PgInitPrivs {
export function is(value: any) : value is PgCatalog.Types.PgInitPrivs {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.privtype !== undefined) && (value.initprivs !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabel {
export function is(value: any) : value is PgCatalog.Types.PgSeclabel {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgShseclabel {
export function is(value: any) : value is PgCatalog.Types.PgShseclabel {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgCollation {
export function is(value: any) : value is PgCatalog.Types.PgCollation {
if (
(value.oid !== undefined) && (value.collname !== undefined) && (value.collnamespace !== undefined) && (value.collowner !== undefined) && (value.collprovider !== undefined) && (value.collisdeterministic !== undefined) && (value.collencoding !== undefined) && (value.collcollate !== undefined) && (value.collctype !== undefined) && (value.colliculocale !== undefined) && (value.collicurules !== undefined) && (value.collversion !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAcl {
export function is(value: any) : value is PgCatalog.Types.PgParameterAcl {
if (
(value.oid !== undefined) && (value.parname !== undefined) && (value.paracl !== undefined)
) return true;
return false;
}
}
export namespace PgPartitionedTable {
export function is(value: any) : value is PgCatalog.Types.PgPartitionedTable {
if (
(value.partrelid !== undefined) && (value.partstrat !== undefined) && (value.partnatts !== undefined) && (value.partdefid !== undefined) && (value.partattrs !== undefined) && (value.partclass !== undefined) && (value.partcollation !== undefined) && (value.partexprs !== undefined)
) return true;
return false;
}
}
export namespace PgRange {
export function is(value: any) : value is PgCatalog.Types.PgRange {
if (
(value.rngtypid !== undefined) && (value.rngsubtype !== undefined) && (value.rngmultitypid !== undefined) && (value.rngcollation !== undefined) && (value.rngsubopc !== undefined) && (value.rngcanonical !== undefined) && (value.rngsubdiff !== undefined)
) return true;
return false;
}
}
export namespace PgTransform {
export function is(value: any) : value is PgCatalog.Types.PgTransform {
if (
(value.oid !== undefined) && (value.trftype !== undefined) && (value.trflang !== undefined) && (value.trffromsql !== undefined) && (value.trftosql !== undefined)
) return true;
return false;
}
}
export namespace PgSequence {
export function is(value: any) : value is PgCatalog.Types.PgSequence {
if (
(value.seqrelid !== undefined) && (value.seqtypid !== undefined) && (value.seqstart !== undefined) && (value.seqincrement !== undefined) && (value.seqmax !== undefined) && (value.seqmin !== undefined) && (value.seqcache !== undefined) && (value.seqcycle !== undefined)
) return true;
return false;
}
}
export namespace PgPublication {
export function is(value: any) : value is PgCatalog.Types.PgPublication {
if (
(value.oid !== undefined) && (value.pubname !== undefined) && (value.pubowner !== undefined) && (value.puballtables !== undefined) && (value.pubinsert !== undefined) && (value.pubupdate !== undefined) && (value.pubdelete !== undefined) && (value.pubtruncate !== undefined) && (value.pubviaroot !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespace {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespace {
if (
(value.oid !== undefined) && (value.pnpubid !== undefined) && (value.pnnspid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRel {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRel {
if (
(value.oid !== undefined) && (value.prpubid !== undefined) && (value.prrelid !== undefined) && (value.prqual !== undefined) && (value.prattrs !== undefined)
) return true;
return false;
}
}
export namespace PgSubscription {
export function is(value: any) : value is PgCatalog.Types.PgSubscription {
if (
(value.oid !== undefined) && (value.subdbid !== undefined) && (value.subskiplsn !== undefined) && (value.subname !== undefined) && (value.subowner !== undefined) && (value.subenabled !== undefined) && (value.subbinary !== undefined) && (value.substream !== undefined) && (value.subtwophasestate !== undefined) && (value.subdisableonerr !== undefined) && (value.subpasswordrequired !== undefined) && (value.subrunasowner !== undefined) && (value.subconninfo !== undefined) && (value.subslotname !== undefined) && (value.subsynccommit !== undefined) && (value.subpublications !== undefined) && (value.suborigin !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionRel {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionRel {
if (
(value.srsubid !== undefined) && (value.srrelid !== undefined) && (value.srsubstate !== undefined) && (value.srsublsn !== undefined)
) return true;
return false;
}
}
export namespace PgRoles {
export function is(value: any) : value is PgCatalog.Types.PgRoles {
if (
(value.rolname !== undefined) && (value.rolsuper !== undefined) && (value.rolinherit !== undefined) && (value.rolcreaterole !== undefined) && (value.rolcreatedb !== undefined) && (value.rolcanlogin !== undefined) && (value.rolreplication !== undefined) && (value.rolconnlimit !== undefined) && (value.rolpassword !== undefined) && (value.rolvaliduntil !== undefined) && (value.rolbypassrls !== undefined) && (value.rolconfig !== undefined) && (value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgShadow {
export function is(value: any) : value is PgCatalog.Types.PgShadow {
if (
(value.usename !== undefined) && (value.usesysid !== undefined) && (value.usecreatedb !== undefined) && (value.usesuper !== undefined) && (value.userepl !== undefined) && (value.usebypassrls !== undefined) && (value.passwd !== undefined) && (value.valuntil !== undefined) && (value.useconfig !== undefined)
) return true;
return false;
}
}
export namespace PgGroup {
export function is(value: any) : value is PgCatalog.Types.PgGroup {
if (
(value.groname !== undefined) && (value.grosysid !== undefined) && (value.grolist !== undefined)
) return true;
return false;
}
}
export namespace PgUser {
export function is(value: any) : value is PgCatalog.Types.PgUser {
if (
(value.usename !== undefined) && (value.usesysid !== undefined) && (value.usecreatedb !== undefined) && (value.usesuper !== undefined) && (value.userepl !== undefined) && (value.usebypassrls !== undefined) && (value.passwd !== undefined) && (value.valuntil !== undefined) && (value.useconfig !== undefined)
) return true;
return false;
}
}
export namespace PgPolicies {
export function is(value: any) : value is PgCatalog.Types.PgPolicies {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.policyname !== undefined) && (value.permissive !== undefined) && (value.roles !== undefined) && (value.cmd !== undefined) && (value.qual !== undefined) && (value.withCheck !== undefined)
) return true;
return false;
}
}
export namespace PgRules {
export function is(value: any) : value is PgCatalog.Types.PgRules {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.rulename !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgViews {
export function is(value: any) : value is PgCatalog.Types.PgViews {
if (
(value.schemaname !== undefined) && (value.viewname !== undefined) && (value.viewowner !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgTables {
export function is(value: any) : value is PgCatalog.Types.PgTables {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.tableowner !== undefined) && (value.tablespace !== undefined) && (value.hasindexes !== undefined) && (value.hasrules !== undefined) && (value.hastriggers !== undefined) && (value.rowsecurity !== undefined)
) return true;
return false;
}
}
export namespace PgMatviews {
export function is(value: any) : value is PgCatalog.Types.PgMatviews {
if (
(value.schemaname !== undefined) && (value.matviewname !== undefined) && (value.matviewowner !== undefined) && (value.tablespace !== undefined) && (value.hasindexes !== undefined) && (value.ispopulated !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgIndexes {
export function is(value: any) : value is PgCatalog.Types.PgIndexes {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.indexname !== undefined) && (value.tablespace !== undefined) && (value.indexdef !== undefined)
) return true;
return false;
}
}
export namespace PgSequences {
export function is(value: any) : value is PgCatalog.Types.PgSequences {
if (
(value.schemaname !== undefined) && (value.sequencename !== undefined) && (value.sequenceowner !== undefined) && (value.dataType !== undefined) && (value.startValue !== undefined) && (value.minValue !== undefined) && (value.maxValue !== undefined) && (value.incrementBy !== undefined) && (value.cycle !== undefined) && (value.cacheSize !== undefined) && (value.lastValue !== undefined)
) return true;
return false;
}
}
export namespace PgStats {
export function is(value: any) : value is PgCatalog.Types.PgStats {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.attname !== undefined) && (value.inherited !== undefined) && (value.nullFrac !== undefined) && (value.avgWidth !== undefined) && (value.nDistinct !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonFreqs !== undefined) && (value.histogramBounds !== undefined) && (value.correlation !== undefined) && (value.mostCommonElems !== undefined) && (value.mostCommonElemFreqs !== undefined) && (value.elemCountHistogram !== undefined)
) return true;
return false;
}
}
export namespace PgStatsExt {
export function is(value: any) : value is PgCatalog.Types.PgStatsExt {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.statisticsSchemaname !== undefined) && (value.statisticsName !== undefined) && (value.statisticsOwner !== undefined) && (value.attnames !== undefined) && (value.exprs !== undefined) && (value.kinds !== undefined) && (value.inherited !== undefined) && (value.nDistinct !== undefined) && (value.dependencies !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonValNulls !== undefined) && (value.mostCommonFreqs !== undefined) && (value.mostCommonBaseFreqs !== undefined)
) return true;
return false;
}
}
export namespace PgStatsExtExprs {
export function is(value: any) : value is PgCatalog.Types.PgStatsExtExprs {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.statisticsSchemaname !== undefined) && (value.statisticsName !== undefined) && (value.statisticsOwner !== undefined) && (value.expr !== undefined) && (value.inherited !== undefined) && (value.nullFrac !== undefined) && (value.avgWidth !== undefined) && (value.nDistinct !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonFreqs !== undefined) && (value.histogramBounds !== undefined) && (value.correlation !== undefined) && (value.mostCommonElems !== undefined) && (value.mostCommonElemFreqs !== undefined) && (value.elemCountHistogram !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationTables {
export function is(value: any) : value is PgCatalog.Types.PgPublicationTables {
if (
(value.pubname !== undefined) && (value.schemaname !== undefined) && (value.tablename !== undefined) && (value.attnames !== undefined) && (value.rowfilter !== undefined)
) return true;
return false;
}
}
export namespace PgLocks {
export function is(value: any) : value is PgCatalog.Types.PgLocks {
if (
(value.locktype !== undefined) && (value.database !== undefined) && (value.relation !== undefined) && (value.page !== undefined) && (value.tuple !== undefined) && (value.virtualxid !== undefined) && (value.transactionid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.virtualtransaction !== undefined) && (value.pid !== undefined) && (value.mode !== undefined) && (value.granted !== undefined) && (value.fastpath !== undefined) && (value.waitstart !== undefined)
) return true;
return false;
}
}
export namespace PgCursors {
export function is(value: any) : value is PgCatalog.Types.PgCursors {
if (
(value.name !== undefined) && (value.statement !== undefined) && (value.isHoldable !== undefined) && (value.isBinary !== undefined) && (value.isScrollable !== undefined) && (value.creationTime !== undefined)
) return true;
return false;
}
}
export namespace PgAvailableExtensions {
export function is(value: any) : value is PgCatalog.Types.PgAvailableExtensions {
if (
(value.name !== undefined) && (value.defaultVersion !== undefined) && (value.installedVersion !== undefined) && (value.comment !== undefined)
) return true;
return false;
}
}
export namespace PgAvailableExtensionVersions {
export function is(value: any) : value is PgCatalog.Types.PgAvailableExtensionVersions {
if (
(value.name !== undefined) && (value.version !== undefined) && (value.installed !== undefined) && (value.superuser !== undefined) && (value.trusted !== undefined) && (value.relocatable !== undefined) && (value.schema !== undefined) && (value.requires !== undefined) && (value.comment !== undefined)
) return true;
return false;
}
}
export namespace PgPreparedXacts {
export function is(value: any) : value is PgCatalog.Types.PgPreparedXacts {
if (
(value.transaction !== undefined) && (value.gid !== undefined) && (value.prepared !== undefined) && (value.owner !== undefined) && (value.database !== undefined)
) return true;
return false;
}
}
export namespace PgPreparedStatements {
export function is(value: any) : value is PgCatalog.Types.PgPreparedStatements {
if (
(value.name !== undefined) && (value.statement !== undefined) && (value.prepareTime !== undefined) && (value.parameterTypes !== undefined) && (value.resultTypes !== undefined) && (value.fromSql !== undefined) && (value.genericPlans !== undefined) && (value.customPlans !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabels {
export function is(value: any) : value is PgCatalog.Types.PgSeclabels {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.objtype !== undefined) && (value.objnamespace !== undefined) && (value.objname !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgSettings {
export function is(value: any) : value is PgCatalog.Types.PgSettings {
if (
(value.name !== undefined) && (value.setting !== undefined) && (value.unit !== undefined) && (value.category !== undefined) && (value.shortDesc !== undefined) && (value.extraDesc !== undefined) && (value.context !== undefined) && (value.vartype !== undefined) && (value.source !== undefined) && (value.minVal !== undefined) && (value.maxVal !== undefined) && (value.enumvals !== undefined) && (value.bootVal !== undefined) && (value.resetVal !== undefined) && (value.sourcefile !== undefined) && (value.sourceline !== undefined) && (value.pendingRestart !== undefined)
) return true;
return false;
}
}
export namespace PgFileSettings {
export function is(value: any) : value is PgCatalog.Types.PgFileSettings {
if (
(value.sourcefile !== undefined) && (value.sourceline !== undefined) && (value.seqno !== undefined) && (value.name !== undefined) && (value.setting !== undefined) && (value.applied !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgHbaFileRules {
export function is(value: any) : value is PgCatalog.Types.PgHbaFileRules {
if (
(value.ruleNumber !== undefined) && (value.fileName !== undefined) && (value.lineNumber !== undefined) && (value.type !== undefined) && (value.database !== undefined) && (value.userName !== undefined) && (value.address !== undefined) && (value.netmask !== undefined) && (value.authMethod !== undefined) && (value.options !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgIdentFileMappings {
export function is(value: any) : value is PgCatalog.Types.PgIdentFileMappings {
if (
(value.mapNumber !== undefined) && (value.fileName !== undefined) && (value.lineNumber !== undefined) && (value.mapName !== undefined) && (value.sysName !== undefined) && (value.pgUsername !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgTimezoneAbbrevs {
export function is(value: any) : value is PgCatalog.Types.PgTimezoneAbbrevs {
if (
(value.abbrev !== undefined) && (value.utcOffset !== undefined) && (value.isDst !== undefined)
) return true;
return false;
}
}
export namespace PgTimezoneNames {
export function is(value: any) : value is PgCatalog.Types.PgTimezoneNames {
if (
(value.name !== undefined) && (value.abbrev !== undefined) && (value.utcOffset !== undefined) && (value.isDst !== undefined)
) return true;
return false;
}
}
export namespace PgConfig {
export function is(value: any) : value is PgCatalog.Types.PgConfig {
if (
(value.name !== undefined) && (value.setting !== undefined)
) return true;
return false;
}
}
export namespace PgShmemAllocations {
export function is(value: any) : value is PgCatalog.Types.PgShmemAllocations {
if (
(value.name !== undefined) && (value.off !== undefined) && (value.size !== undefined) && (value.allocatedSize !== undefined)
) return true;
return false;
}
}
export namespace PgBackendMemoryContexts {
export function is(value: any) : value is PgCatalog.Types.PgBackendMemoryContexts {
if (
(value.name !== undefined) && (value.ident !== undefined) && (value.parent !== undefined) && (value.level !== undefined) && (value.totalBytes !== undefined) && (value.totalNblocks !== undefined) && (value.freeBytes !== undefined) && (value.freeChunks !== undefined) && (value.usedBytes !== undefined)
) return true;
return false;
}
}
export namespace PgStatAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatAllIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatAllIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatSysIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatSysIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatUserIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatActivity {
export function is(value: any) : value is PgCatalog.Types.PgStatActivity {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.pid !== undefined) && (value.leaderPid !== undefined) && (value.usesysid !== undefined) && (value.usename !== undefined) && (value.applicationName !== undefined) && (value.clientAddr !== undefined) && (value.clientHostname !== undefined) && (value.clientPort !== undefined) && (value.backendStart !== undefined) && (value.xactStart !== undefined) && (value.queryStart !== undefined) && (value.stateChange !== undefined) && (value.waitEventType !== undefined) && (value.waitEvent !== undefined) && (value.state !== undefined) && (value.backendXid !== undefined) && (value.backendXmin !== undefined) && (value.queryId !== undefined) && (value.query !== undefined) && (value.backendType !== undefined)
) return true;
return false;
}
}
export namespace PgStatReplication {
export function is(value: any) : value is PgCatalog.Types.PgStatReplication {
if (
(value.pid !== undefined) && (value.usesysid !== undefined) && (value.usename !== undefined) && (value.applicationName !== undefined) && (value.clientAddr !== undefined) && (value.clientHostname !== undefined) && (value.clientPort !== undefined) && (value.backendStart !== undefined) && (value.backendXmin !== undefined) && (value.state !== undefined) && (value.sentLsn !== undefined) && (value.writeLsn !== undefined) && (value.flushLsn !== undefined) && (value.replayLsn !== undefined) && (value.writeLag !== undefined) && (value.flushLag !== undefined) && (value.replayLag !== undefined) && (value.syncPriority !== undefined) && (value.syncState !== undefined) && (value.replyTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatSlru {
export function is(value: any) : value is PgCatalog.Types.PgStatSlru {
if (
(value.name !== undefined) && (value.blksZeroed !== undefined) && (value.blksHit !== undefined) && (value.blksRead !== undefined) && (value.blksWritten !== undefined) && (value.blksExists !== undefined) && (value.flushes !== undefined) && (value.truncates !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatWalReceiver {
export function is(value: any) : value is PgCatalog.Types.PgStatWalReceiver {
if (
(value.pid !== undefined) && (value.status !== undefined) && (value.receiveStartLsn !== undefined) && (value.receiveStartTli !== undefined) && (value.writtenLsn !== undefined) && (value.flushedLsn !== undefined) && (value.receivedTli !== undefined) && (value.lastMsgSendTime !== undefined) && (value.lastMsgReceiptTime !== undefined) && (value.latestEndLsn !== undefined) && (value.latestEndTime !== undefined) && (value.slotName !== undefined) && (value.senderHost !== undefined) && (value.senderPort !== undefined) && (value.conninfo !== undefined)
) return true;
return false;
}
}
export namespace PgStatRecoveryPrefetch {
export function is(value: any) : value is PgCatalog.Types.PgStatRecoveryPrefetch {
if (
(value.statsReset !== undefined) && (value.prefetch !== undefined) && (value.hit !== undefined) && (value.skipInit !== undefined) && (value.skipNew !== undefined) && (value.skipFpw !== undefined) && (value.skipRep !== undefined) && (value.walDistance !== undefined) && (value.blockDistance !== undefined) && (value.ioDepth !== undefined)
) return true;
return false;
}
}
export namespace PgStatSubscription {
export function is(value: any) : value is PgCatalog.Types.PgStatSubscription {
if (
(value.subid !== undefined) && (value.subname !== undefined) && (value.pid !== undefined) && (value.leaderPid !== undefined) && (value.relid !== undefined) && (value.receivedLsn !== undefined) && (value.lastMsgSendTime !== undefined) && (value.lastMsgReceiptTime !== undefined) && (value.latestEndLsn !== undefined) && (value.latestEndTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatSsl {
export function is(value: any) : value is PgCatalog.Types.PgStatSsl {
if (
(value.pid !== undefined) && (value.ssl !== undefined) && (value.version !== undefined) && (value.cipher !== undefined) && (value.bits !== undefined) && (value.clientDn !== undefined) && (value.clientSerial !== undefined) && (value.issuerDn !== undefined)
) return true;
return false;
}
}
export namespace PgStatGssapi {
export function is(value: any) : value is PgCatalog.Types.PgStatGssapi {
if (
(value.pid !== undefined) && (value.gssAuthenticated !== undefined) && (value.principal !== undefined) && (value.encrypted !== undefined) && (value.credentialsDelegated !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationSlots {
export function is(value: any) : value is PgCatalog.Types.PgReplicationSlots {
if (
(value.slotName !== undefined) && (value.plugin !== undefined) && (value.slotType !== undefined) && (value.datoid !== undefined) && (value.database !== undefined) && (value.temporary !== undefined) && (value.active !== undefined) && (value.activePid !== undefined) && (value.xmin !== undefined) && (value.catalogXmin !== undefined) && (value.restartLsn !== undefined) && (value.confirmedFlushLsn !== undefined) && (value.walStatus !== undefined) && (value.safeWalSize !== undefined) && (value.twoPhase !== undefined) && (value.conflicting !== undefined)
) return true;
return false;
}
}
export namespace PgStatReplicationSlots {
export function is(value: any) : value is PgCatalog.Types.PgStatReplicationSlots {
if (
(value.slotName !== undefined) && (value.spillTxns !== undefined) && (value.spillCount !== undefined) && (value.spillBytes !== undefined) && (value.streamTxns !== undefined) && (value.streamCount !== undefined) && (value.streamBytes !== undefined) && (value.totalTxns !== undefined) && (value.totalBytes !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatDatabase {
export function is(value: any) : value is PgCatalog.Types.PgStatDatabase {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.numbackends !== undefined) && (value.xactCommit !== undefined) && (value.xactRollback !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined) && (value.tupReturned !== undefined) && (value.tupFetched !== undefined) && (value.tupInserted !== undefined) && (value.tupUpdated !== undefined) && (value.tupDeleted !== undefined) && (value.conflicts !== undefined) && (value.tempFiles !== undefined) && (value.tempBytes !== undefined) && (value.deadlocks !== undefined) && (value.checksumFailures !== undefined) && (value.checksumLastFailure !== undefined) && (value.blkReadTime !== undefined) && (value.blkWriteTime !== undefined) && (value.sessionTime !== undefined) && (value.activeTime !== undefined) && (value.idleInTransactionTime !== undefined) && (value.sessions !== undefined) && (value.sessionsAbandoned !== undefined) && (value.sessionsFatal !== undefined) && (value.sessionsKilled !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatDatabaseConflicts {
export function is(value: any) : value is PgCatalog.Types.PgStatDatabaseConflicts {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.conflTablespace !== undefined) && (value.conflLock !== undefined) && (value.conflSnapshot !== undefined) && (value.conflBufferpin !== undefined) && (value.conflDeadlock !== undefined) && (value.conflActiveLogicalslot !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserFunctions {
export function is(value: any) : value is PgCatalog.Types.PgStatUserFunctions {
if (
(value.funcid !== undefined) && (value.schemaname !== undefined) && (value.funcname !== undefined) && (value.calls !== undefined) && (value.totalTime !== undefined) && (value.selfTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactUserFunctions {
export function is(value: any) : value is PgCatalog.Types.PgStatXactUserFunctions {
if (
(value.funcid !== undefined) && (value.schemaname !== undefined) && (value.funcname !== undefined) && (value.calls !== undefined) && (value.totalTime !== undefined) && (value.selfTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatArchiver {
export function is(value: any) : value is PgCatalog.Types.PgStatArchiver {
if (
(value.archivedCount !== undefined) && (value.lastArchivedWal !== undefined) && (value.lastArchivedTime !== undefined) && (value.failedCount !== undefined) && (value.lastFailedWal !== undefined) && (value.lastFailedTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatBgwriter {
export function is(value: any) : value is PgCatalog.Types.PgStatBgwriter {
if (
(value.checkpointsTimed !== undefined) && (value.checkpointsReq !== undefined) && (value.checkpointWriteTime !== undefined) && (value.checkpointSyncTime !== undefined) && (value.buffersCheckpoint !== undefined) && (value.buffersClean !== undefined) && (value.maxwrittenClean !== undefined) && (value.buffersBackend !== undefined) && (value.buffersBackendFsync !== undefined) && (value.buffersAlloc !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatIo {
export function is(value: any) : value is PgCatalog.Types.PgStatIo {
if (
(value.backendType !== undefined) && (value.object !== undefined) && (value.context !== undefined) && (value.reads !== undefined) && (value.readTime !== undefined) && (value.writes !== undefined) && (value.writeTime !== undefined) && (value.writebacks !== undefined) && (value.writebackTime !== undefined) && (value.extends !== undefined) && (value.extendTime !== undefined) && (value.opBytes !== undefined) && (value.hits !== undefined) && (value.evictions !== undefined) && (value.reuses !== undefined) && (value.fsyncs !== undefined) && (value.fsyncTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatWal {
export function is(value: any) : value is PgCatalog.Types.PgStatWal {
if (
(value.walRecords !== undefined) && (value.walFpi !== undefined) && (value.walBytes !== undefined) && (value.walBuffersFull !== undefined) && (value.walWrite !== undefined) && (value.walSync !== undefined) && (value.walWriteTime !== undefined) && (value.walSyncTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressAnalyze {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressAnalyze {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.phase !== undefined) && (value.sampleBlksTotal !== undefined) && (value.sampleBlksScanned !== undefined) && (value.extStatsTotal !== undefined) && (value.extStatsComputed !== undefined) && (value.childTablesTotal !== undefined) && (value.childTablesDone !== undefined) && (value.currentChildTableRelid !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressVacuum {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressVacuum {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.phase !== undefined) && (value.heapBlksTotal !== undefined) && (value.heapBlksScanned !== undefined) && (value.heapBlksVacuumed !== undefined) && (value.indexVacuumCount !== undefined) && (value.maxDeadTuples !== undefined) && (value.numDeadTuples !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCluster {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCluster {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.command !== undefined) && (value.phase !== undefined) && (value.clusterIndexRelid !== undefined) && (value.heapTuplesScanned !== undefined) && (value.heapTuplesWritten !== undefined) && (value.heapBlksTotal !== undefined) && (value.heapBlksScanned !== undefined) && (value.indexRebuildCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCreateIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCreateIndex {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.indexRelid !== undefined) && (value.command !== undefined) && (value.phase !== undefined) && (value.lockersTotal !== undefined) && (value.lockersDone !== undefined) && (value.currentLockerPid !== undefined) && (value.blocksTotal !== undefined) && (value.blocksDone !== undefined) && (value.tuplesTotal !== undefined) && (value.tuplesDone !== undefined) && (value.partitionsTotal !== undefined) && (value.partitionsDone !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressBasebackup {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressBasebackup {
if (
(value.pid !== undefined) && (value.phase !== undefined) && (value.backupTotal !== undefined) && (value.backupStreamed !== undefined) && (value.tablespacesTotal !== undefined) && (value.tablespacesStreamed !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCopy {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCopy {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.command !== undefined) && (value.type !== undefined) && (value.bytesProcessed !== undefined) && (value.bytesTotal !== undefined) && (value.tuplesProcessed !== undefined) && (value.tuplesExcluded !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappings {
export function is(value: any) : value is PgCatalog.Types.PgUserMappings {
if (
(value.umid !== undefined) && (value.srvid !== undefined) && (value.srvname !== undefined) && (value.umuser !== undefined) && (value.usename !== undefined) && (value.umoptions !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginStatus {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginStatus {
if (
(value.localId !== undefined) && (value.externalId !== undefined) && (value.remoteLsn !== undefined) && (value.localLsn !== undefined)
) return true;
return false;
}
}
export namespace PgStatSubscriptionStats {
export function is(value: any) : value is PgCatalog.Types.PgStatSubscriptionStats {
if (
(value.subid !== undefined) && (value.subname !== undefined) && (value.applyErrorCount !== undefined) && (value.syncErrorCount !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgProcOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgProcOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgProcPronameArgsNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgProcPronameArgsNspIndex {
if (
(value.proname !== undefined) && (value.proargtypes !== undefined) && (value.pronamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTypeOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTypeOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTypeTypnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgTypeTypnameNspIndex {
if (
(value.typname !== undefined) && (value.typnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgAttributeRelidAttnamIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttributeRelidAttnamIndex {
if (
(value.attrelid !== undefined) && (value.attname !== undefined)
) return true;
return false;
}
}
export namespace PgAttributeRelidAttnumIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttributeRelidAttnumIndex {
if (
(value.attrelid !== undefined) && (value.attnum !== undefined)
) return true;
return false;
}
}
export namespace PgClassOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgClassRelnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassRelnameNspIndex {
if (
(value.relname !== undefined) && (value.relnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgClassTblspcRelfilenodeIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassTblspcRelfilenodeIndex {
if (
(value.reltablespace !== undefined) && (value.relfilenode !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdefAdrelidAdnumIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttrdefAdrelidAdnumIndex {
if (
(value.adrelid !== undefined) && (value.adnum !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdefOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttrdefOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConnameNspIndex {
if (
(value.conname !== undefined) && (value.connamespace !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConrelidContypidConnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConrelidContypidConnameIndex {
if (
(value.conrelid !== undefined) && (value.contypid !== undefined) && (value.conname !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintContypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintContypidIndex {
if (
(value.contypid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConparentidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConparentidIndex {
if (
(value.conparentid !== undefined)
) return true;
return false;
}
}
export namespace PgInheritsRelidSeqnoIndex {
export function is(value: any) : value is PgCatalog.Types.PgInheritsRelidSeqnoIndex {
if (
(value.inhrelid !== undefined) && (value.inhseqno !== undefined)
) return true;
return false;
}
}
export namespace PgInheritsParentIndex {
export function is(value: any) : value is PgCatalog.Types.PgInheritsParentIndex {
if (
(value.inhparent !== undefined)
) return true;
return false;
}
}
export namespace PgIndexIndrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndexIndrelidIndex {
if (
(value.indrelid !== undefined)
) return true;
return false;
}
}
export namespace PgIndexIndexrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndexIndexrelidIndex {
if (
(value.indexrelid !== undefined)
) return true;
return false;
}
}
export namespace PgOperatorOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOperatorOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgOperatorOprnameLRNIndex {
export function is(value: any) : value is PgCatalog.Types.PgOperatorOprnameLRNIndex {
if (
(value.oprname !== undefined) && (value.oprleft !== undefined) && (value.oprright !== undefined) && (value.oprnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamilyAmNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpfamilyAmNameNspIndex {
if (
(value.opfmethod !== undefined) && (value.opfname !== undefined) && (value.opfnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamilyOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpfamilyOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgOpclassAmNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpclassAmNameNspIndex {
if (
(value.opcmethod !== undefined) && (value.opcname !== undefined) && (value.opcnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpclassOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpclassOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmNameIndex {
if (
(value.amname !== undefined)
) return true;
return false;
}
}
export namespace PgAmOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmopFamStratIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopFamStratIndex {
if (
(value.amopfamily !== undefined) && (value.amoplefttype !== undefined) && (value.amoprighttype !== undefined) && (value.amopstrategy !== undefined)
) return true;
return false;
}
}
export namespace PgAmopOprFamIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopOprFamIndex {
if (
(value.amopopr !== undefined) && (value.amoppurpose !== undefined) && (value.amopfamily !== undefined)
) return true;
return false;
}
}
export namespace PgAmopOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmprocFamProcIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmprocFamProcIndex {
if (
(value.amprocfamily !== undefined) && (value.amproclefttype !== undefined) && (value.amprocrighttype !== undefined) && (value.amprocnum !== undefined)
) return true;
return false;
}
}
export namespace PgAmprocOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmprocOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLanguageNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgLanguageNameIndex {
if (
(value.lanname !== undefined)
) return true;
return false;
}
}
export namespace PgLanguageOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgLanguageOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectMetadataOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectMetadataOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectLoidPnIndex {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectLoidPnIndex {
if (
(value.loid !== undefined) && (value.pageno !== undefined)
) return true;
return false;
}
}
export namespace PgAggregateFnoidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAggregateFnoidIndex {
if (
(value.aggfnoid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticRelidAttInhIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticRelidAttInhIndex {
if (
(value.starelid !== undefined) && (value.staattnum !== undefined) && (value.stainherit !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtNameIndex {
if (
(value.stxname !== undefined) && (value.stxnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtRelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtRelidIndex {
if (
(value.stxrelid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtDataStxoidInhIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtDataStxoidInhIndex {
if (
(value.stxoid !== undefined) && (value.stxdinherit !== undefined)
) return true;
return false;
}
}
export namespace PgRewriteOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRewriteOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgRewriteRelRulenameIndex {
export function is(value: any) : value is PgCatalog.Types.PgRewriteRelRulenameIndex {
if (
(value.evClass !== undefined) && (value.rulename !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerTgconstraintIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerTgconstraintIndex {
if (
(value.tgconstraint !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerTgrelidTgnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerTgrelidTgnameIndex {
if (
(value.tgrelid !== undefined) && (value.tgname !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgEventTriggerEvtnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgEventTriggerEvtnameIndex {
if (
(value.evtname !== undefined)
) return true;
return false;
}
}
export namespace PgEventTriggerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgEventTriggerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDescriptionOCOIndex {
export function is(value: any) : value is PgCatalog.Types.PgDescriptionOCOIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgCastOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgCastOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgCastSourceTargetIndex {
export function is(value: any) : value is PgCatalog.Types.PgCastSourceTargetIndex {
if (
(value.castsource !== undefined) && (value.casttarget !== undefined)
) return true;
return false;
}
}
export namespace PgEnumOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgEnumTypidLabelIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumTypidLabelIndex {
if (
(value.enumtypid !== undefined) && (value.enumlabel !== undefined)
) return true;
return false;
}
}
export namespace PgEnumTypidSortorderIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumTypidSortorderIndex {
if (
(value.enumtypid !== undefined) && (value.enumsortorder !== undefined)
) return true;
return false;
}
}
export namespace PgNamespaceNspnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgNamespaceNspnameIndex {
if (
(value.nspname !== undefined)
) return true;
return false;
}
}
export namespace PgNamespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgNamespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConversionDefaultIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionDefaultIndex {
if (
(value.connamespace !== undefined) && (value.conforencoding !== undefined) && (value.contoencoding !== undefined) && (value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConversionNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionNameNspIndex {
if (
(value.conname !== undefined) && (value.connamespace !== undefined)
) return true;
return false;
}
}
export namespace PgConversionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDependDependerIndex {
export function is(value: any) : value is PgCatalog.Types.PgDependDependerIndex {
if (
(value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgDependReferenceIndex {
export function is(value: any) : value is PgCatalog.Types.PgDependReferenceIndex {
if (
(value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.refobjsubid !== undefined)
) return true;
return false;
}
}
export namespace PgDatabaseDatnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgDatabaseDatnameIndex {
if (
(value.datname !== undefined)
) return true;
return false;
}
}
export namespace PgDatabaseOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgDatabaseOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDbRoleSettingDatabaseidRolIndex {
export function is(value: any) : value is PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex {
if (
(value.setdatabase !== undefined) && (value.setrole !== undefined)
) return true;
return false;
}
}
export namespace PgTablespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTablespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTablespaceSpcnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTablespaceSpcnameIndex {
if (
(value.spcname !== undefined)
) return true;
return false;
}
}
export namespace PgAuthidRolnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthidRolnameIndex {
if (
(value.rolname !== undefined)
) return true;
return false;
}
}
export namespace PgAuthidOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthidOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersRoleMemberIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersRoleMemberIndex {
if (
(value.roleid !== undefined) && (value.member !== undefined) && (value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersMemberRoleIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersMemberRoleIndex {
if (
(value.member !== undefined) && (value.roleid !== undefined) && (value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersGrantorIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersGrantorIndex {
if (
(value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgShdependDependerIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdependDependerIndex {
if (
(value.dbid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgShdependReferenceIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdependReferenceIndex {
if (
(value.refclassid !== undefined) && (value.refobjid !== undefined)
) return true;
return false;
}
}
export namespace PgShdescriptionOCIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdescriptionOCIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigCfgnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigCfgnameIndex {
if (
(value.cfgname !== undefined) && (value.cfgnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigMapIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigMapIndex {
if (
(value.mapcfg !== undefined) && (value.maptokentype !== undefined) && (value.mapseqno !== undefined)
) return true;
return false;
}
}
export namespace PgTsDictDictnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsDictDictnameIndex {
if (
(value.dictname !== undefined) && (value.dictnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsDictOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsDictOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsParserPrsnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsParserPrsnameIndex {
if (
(value.prsname !== undefined) && (value.prsnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsParserOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsParserOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplateTmplnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplateTmplnameIndex {
if (
(value.tmplname !== undefined) && (value.tmplnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplateOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplateOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgExtensionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgExtensionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgExtensionNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgExtensionNameIndex {
if (
(value.extname !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapperOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapperOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapperNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapperNameIndex {
if (
(value.fdwname !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignServerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServerNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignServerNameIndex {
if (
(value.srvname !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappingOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgUserMappingOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappingUserServerIndex {
export function is(value: any) : value is PgCatalog.Types.PgUserMappingUserServerIndex {
if (
(value.umuser !== undefined) && (value.umserver !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTableRelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignTableRelidIndex {
if (
(value.ftrelid !== undefined)
) return true;
return false;
}
}
export namespace PgPolicyOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPolicyOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPolicyPolrelidPolnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgPolicyPolrelidPolnameIndex {
if (
(value.polrelid !== undefined) && (value.polname !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginRoiidentIndex {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginRoiidentIndex {
if (
(value.roident !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginRonameIndex {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginRonameIndex {
if (
(value.roname !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAclRoleNspObjIndex {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAclRoleNspObjIndex {
if (
(value.defaclrole !== undefined) && (value.defaclnamespace !== undefined) && (value.defaclobjtype !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAclOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAclOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgInitPrivsOCOIndex {
export function is(value: any) : value is PgCatalog.Types.PgInitPrivsOCOIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabelObjectIndex {
export function is(value: any) : value is PgCatalog.Types.PgSeclabelObjectIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.provider !== undefined)
) return true;
return false;
}
}
export namespace PgShseclabelObjectIndex {
export function is(value: any) : value is PgCatalog.Types.PgShseclabelObjectIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.provider !== undefined)
) return true;
return false;
}
}
export namespace PgCollationNameEncNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgCollationNameEncNspIndex {
if (
(value.collname !== undefined) && (value.collencoding !== undefined) && (value.collnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgCollationOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgCollationOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAclParnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgParameterAclParnameIndex {
if (
(value.parname !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAclOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgParameterAclOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPartitionedTablePartrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPartitionedTablePartrelidIndex {
if (
(value.partrelid !== undefined)
) return true;
return false;
}
}
export namespace PgRangeRngtypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRangeRngtypidIndex {
if (
(value.rngtypid !== undefined)
) return true;
return false;
}
}
export namespace PgRangeRngmultitypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRangeRngmultitypidIndex {
if (
(value.rngmultitypid !== undefined)
) return true;
return false;
}
}
export namespace PgTransformOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTransformOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTransformTypeLangIndex {
export function is(value: any) : value is PgCatalog.Types.PgTransformTypeLangIndex {
if (
(value.trftype !== undefined) && (value.trflang !== undefined)
) return true;
return false;
}
}
export namespace PgSequenceSeqrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSequenceSeqrelidIndex {
if (
(value.seqrelid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationPubnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationPubnameIndex {
if (
(value.pubname !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex {
if (
(value.pnnspid !== undefined) && (value.pnpubid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelPrrelidPrpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex {
if (
(value.prrelid !== undefined) && (value.prpubid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelPrpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelPrpubidIndex {
if (
(value.prpubid !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionSubnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionSubnameIndex {
if (
(value.subdbid !== undefined) && (value.subname !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex {
if (
(value.srrelid !== undefined) && (value.srsubid !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
}
export namespace PgType {
}
export namespace PgForeignTable {
}
export namespace PgAuthid {
}
export namespace PgStatisticExtData {
}
export namespace PgUserMapping {
}
export namespace PgSubscription {
}
export namespace PgAttribute {
}
export namespace PgProc {
}
export namespace PgClass {
}
export namespace PgAttrdef {
}
export namespace PgConstraint {
}
export namespace PgInherits {
}
export namespace PgIndex {
}
export namespace PgOperator {
}
export namespace PgOpfamily {
}
export namespace PgOpclass {
}
export namespace PgAm {
}
export namespace PgAmop {
}
export namespace PgAmproc {
}
export namespace PgLanguage {
}
export namespace PgLargeobjectMetadata {
}
export namespace PgAggregate {
}
export namespace PgStatisticExt {
}
export namespace PgRewrite {
}
export namespace PgTrigger {
}
export namespace PgEventTrigger {
}
export namespace PgDescription {
}
export namespace PgCast {
}
export namespace PgEnum {
}
export namespace PgNamespace {
}
export namespace PgConversion {
}
export namespace PgDepend {
}
export namespace PgDatabase {
}
export namespace PgDbRoleSetting {
}
export namespace PgTablespace {
}
export namespace PgAuthMembers {
}
export namespace PgShdepend {
}
export namespace PgShdescription {
}
export namespace PgTsConfig {
}
export namespace PgTsConfigMap {
}
export namespace PgTsDict {
}
export namespace PgTsParser {
}
export namespace PgTsTemplate {
}
export namespace PgExtension {
}
export namespace PgForeignDataWrapper {
}
export namespace PgForeignServer {
}
export namespace PgPolicy {
}
export namespace PgReplicationOrigin {
}
export namespace PgDefaultAcl {
}
export namespace PgInitPrivs {
}
export namespace PgSeclabel {
}
export namespace PgShseclabel {
}
export namespace PgCollation {
}
export namespace PgParameterAcl {
}
export namespace PgPartitionedTable {
}
export namespace PgRange {
}
export namespace PgTransform {
}
export namespace PgSequence {
}
export namespace PgPublication {
}
export namespace PgPublicationNamespace {
}
export namespace PgPublicationRel {
}
export namespace PgSubscriptionRel {
}
export namespace PgLargeobject {
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace InformationSchemaCatalogName {
export function is(value: any) : value is InformationSchema.Types.InformationSchemaCatalogName {
if (
(value.catalogName !== undefined)
) return true;
return false;
}
}
export namespace ApplicableRoles {
export function is(value: any) : value is InformationSchema.Types.ApplicableRoles {
if (
(value.grantee !== undefined) && (value.roleName !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace AdministrableRoleAuthorizations {
export function is(value: any) : value is InformationSchema.Types.AdministrableRoleAuthorizations {
if (
(value.grantee !== undefined) && (value.roleName !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace Attributes {
export function is(value: any) : value is InformationSchema.Types.Attributes {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.attributeName !== undefined) && (value.ordinalPosition !== undefined) && (value.attributeDefault !== undefined) && (value.isNullable !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.attributeUdtCatalog !== undefined) && (value.attributeUdtSchema !== undefined) && (value.attributeUdtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.isDerivedReferenceAttribute !== undefined)
) return true;
return false;
}
}
export namespace CharacterSets {
export function is(value: any) : value is InformationSchema.Types.CharacterSets {
if (
(value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.characterRepertoire !== undefined) && (value.formOfUse !== undefined) && (value.defaultCollateCatalog !== undefined) && (value.defaultCollateSchema !== undefined) && (value.defaultCollateName !== undefined)
) return true;
return false;
}
}
export namespace CheckConstraintRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.CheckConstraintRoutineUsage {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined)
) return true;
return false;
}
}
export namespace CheckConstraints {
export function is(value: any) : value is InformationSchema.Types.CheckConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.checkClause !== undefined)
) return true;
return false;
}
}
export namespace Collations {
export function is(value: any) : value is InformationSchema.Types.Collations {
if (
(value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.padAttribute !== undefined)
) return true;
return false;
}
}
export namespace CollationCharacterSetApplicability {
export function is(value: any) : value is InformationSchema.Types.CollationCharacterSetApplicability {
if (
(value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined)
) return true;
return false;
}
}
export namespace ColumnColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnColumnUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.dependentColumn !== undefined)
) return true;
return false;
}
}
export namespace ColumnDomainUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnDomainUsage {
if (
(value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace ColumnPrivileges {
export function is(value: any) : value is InformationSchema.Types.ColumnPrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace ColumnUdtUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnUdtUsage {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace Columns {
export function is(value: any) : value is InformationSchema.Types.Columns {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.ordinalPosition !== undefined) && (value.columnDefault !== undefined) && (value.isNullable !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.isSelfReferencing !== undefined) && (value.isIdentity !== undefined) && (value.identityGeneration !== undefined) && (value.identityStart !== undefined) && (value.identityIncrement !== undefined) && (value.identityMaximum !== undefined) && (value.identityMinimum !== undefined) && (value.identityCycle !== undefined) && (value.isGenerated !== undefined) && (value.generationExpression !== undefined) && (value.isUpdatable !== undefined)
) return true;
return false;
}
}
export namespace ConstraintColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ConstraintColumnUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined)
) return true;
return false;
}
}
export namespace ConstraintTableUsage {
export function is(value: any) : value is InformationSchema.Types.ConstraintTableUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined)
) return true;
return false;
}
}
export namespace DomainConstraints {
export function is(value: any) : value is InformationSchema.Types.DomainConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.isDeferrable !== undefined) && (value.initiallyDeferred !== undefined)
) return true;
return false;
}
}
export namespace DomainUdtUsage {
export function is(value: any) : value is InformationSchema.Types.DomainUdtUsage {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined)
) return true;
return false;
}
}
export namespace Domains {
export function is(value: any) : value is InformationSchema.Types.Domains {
if (
(value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.domainDefault !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace EnabledRoles {
export function is(value: any) : value is InformationSchema.Types.EnabledRoles {
if (
(value.roleName !== undefined)
) return true;
return false;
}
}
export namespace KeyColumnUsage {
export function is(value: any) : value is InformationSchema.Types.KeyColumnUsage {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.ordinalPosition !== undefined) && (value.positionInUniqueConstraint !== undefined)
) return true;
return false;
}
}
export namespace Parameters {
export function is(value: any) : value is InformationSchema.Types.Parameters {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.ordinalPosition !== undefined) && (value.parameterMode !== undefined) && (value.isResult !== undefined) && (value.asLocator !== undefined) && (value.parameterName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.parameterDefault !== undefined)
) return true;
return false;
}
}
export namespace ReferentialConstraints {
export function is(value: any) : value is InformationSchema.Types.ReferentialConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.uniqueConstraintCatalog !== undefined) && (value.uniqueConstraintSchema !== undefined) && (value.uniqueConstraintName !== undefined) && (value.matchOption !== undefined) && (value.updateRule !== undefined) && (value.deleteRule !== undefined)
) return true;
return false;
}
}
export namespace RoleColumnGrants {
export function is(value: any) : value is InformationSchema.Types.RoleColumnGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoutineColumnUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineColumnUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace RoutinePrivileges {
export function is(value: any) : value is InformationSchema.Types.RoutinePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleRoutineGrants {
export function is(value: any) : value is InformationSchema.Types.RoleRoutineGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoutineRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineRoutineUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined)
) return true;
return false;
}
}
export namespace RoutineSequenceUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineSequenceUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.sequenceCatalog !== undefined) && (value.sequenceSchema !== undefined) && (value.sequenceName !== undefined)
) return true;
return false;
}
}
export namespace RoutineTableUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineTableUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
export namespace Routines {
export function is(value: any) : value is InformationSchema.Types.Routines {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.routineType !== undefined) && (value.moduleCatalog !== undefined) && (value.moduleSchema !== undefined) && (value.moduleName !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.typeUdtCatalog !== undefined) && (value.typeUdtSchema !== undefined) && (value.typeUdtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.routineBody !== undefined) && (value.routineDefinition !== undefined) && (value.externalName !== undefined) && (value.externalLanguage !== undefined) && (value.parameterStyle !== undefined) && (value.isDeterministic !== undefined) && (value.sqlDataAccess !== undefined) && (value.isNullCall !== undefined) && (value.sqlPath !== undefined) && (value.schemaLevelRoutine !== undefined) && (value.maxDynamicResultSets !== undefined) && (value.isUserDefinedCast !== undefined) && (value.isImplicitlyInvocable !== undefined) && (value.securityType !== undefined) && (value.toSqlSpecificCatalog !== undefined) && (value.toSqlSpecificSchema !== undefined) && (value.toSqlSpecificName !== undefined) && (value.asLocator !== undefined) && (value.created !== undefined) && (value.lastAltered !== undefined) && (value.newSavepointLevel !== undefined) && (value.isUdtDependent !== undefined) && (value.resultCastFromDataType !== undefined) && (value.resultCastAsLocator !== undefined) && (value.resultCastCharMaxLength !== undefined) && (value.resultCastCharOctetLength !== undefined) && (value.resultCastCharSetCatalog !== undefined) && (value.resultCastCharSetSchema !== undefined) && (value.resultCastCharSetName !== undefined) && (value.resultCastCollationCatalog !== undefined) && (value.resultCastCollationSchema !== undefined) && (value.resultCastCollationName !== undefined) && (value.resultCastNumericPrecision !== undefined) && (value.resultCastNumericPrecisionRadix !== undefined) && (value.resultCastNumericScale !== undefined) && (value.resultCastDatetimePrecision !== undefined) && (value.resultCastIntervalType !== undefined) && (value.resultCastIntervalPrecision !== undefined) && (value.resultCastTypeUdtCatalog !== undefined) && (value.resultCastTypeUdtSchema !== undefined) && (value.resultCastTypeUdtName !== undefined) && (value.resultCastScopeCatalog !== undefined) && (value.resultCastScopeSchema !== undefined) && (value.resultCastScopeName !== undefined) && (value.resultCastMaximumCardinality !== undefined) && (value.resultCastDtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace Schemata {
export function is(value: any) : value is InformationSchema.Types.Schemata {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.schemaOwner !== undefined) && (value.defaultCharacterSetCatalog !== undefined) && (value.defaultCharacterSetSchema !== undefined) && (value.defaultCharacterSetName !== undefined) && (value.sqlPath !== undefined)
) return true;
return false;
}
}
export namespace Sequences {
export function is(value: any) : value is InformationSchema.Types.Sequences {
if (
(value.sequenceCatalog !== undefined) && (value.sequenceSchema !== undefined) && (value.sequenceName !== undefined) && (value.dataType !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.startValue !== undefined) && (value.minimumValue !== undefined) && (value.maximumValue !== undefined) && (value.increment !== undefined) && (value.cycleOption !== undefined)
) return true;
return false;
}
}
export namespace SqlFeatures {
export function is(value: any) : value is InformationSchema.Types.SqlFeatures {
if (
(value.featureId !== undefined) && (value.featureName !== undefined) && (value.subFeatureId !== undefined) && (value.subFeatureName !== undefined) && (value.isSupported !== undefined) && (value.isVerifiedBy !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlImplementationInfo {
export function is(value: any) : value is InformationSchema.Types.SqlImplementationInfo {
if (
(value.implementationInfoId !== undefined) && (value.implementationInfoName !== undefined) && (value.integerValue !== undefined) && (value.characterValue !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlParts {
export function is(value: any) : value is InformationSchema.Types.SqlParts {
if (
(value.featureId !== undefined) && (value.featureName !== undefined) && (value.isSupported !== undefined) && (value.isVerifiedBy !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlSizing {
export function is(value: any) : value is InformationSchema.Types.SqlSizing {
if (
(value.sizingId !== undefined) && (value.sizingName !== undefined) && (value.supportedValue !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace TableConstraints {
export function is(value: any) : value is InformationSchema.Types.TableConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.constraintType !== undefined) && (value.isDeferrable !== undefined) && (value.initiallyDeferred !== undefined) && (value.enforced !== undefined) && (value.nullsDistinct !== undefined)
) return true;
return false;
}
}
export namespace TablePrivileges {
export function is(value: any) : value is InformationSchema.Types.TablePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined) && (value.withHierarchy !== undefined)
) return true;
return false;
}
}
export namespace RoleTableGrants {
export function is(value: any) : value is InformationSchema.Types.RoleTableGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined) && (value.withHierarchy !== undefined)
) return true;
return false;
}
}
export namespace Tables {
export function is(value: any) : value is InformationSchema.Types.Tables {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.tableType !== undefined) && (value.selfReferencingColumnName !== undefined) && (value.referenceGeneration !== undefined) && (value.userDefinedTypeCatalog !== undefined) && (value.userDefinedTypeSchema !== undefined) && (value.userDefinedTypeName !== undefined) && (value.isInsertableInto !== undefined) && (value.isTyped !== undefined) && (value.commitAction !== undefined)
) return true;
return false;
}
}
export namespace Transforms {
export function is(value: any) : value is InformationSchema.Types.Transforms {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.groupName !== undefined) && (value.transformType !== undefined)
) return true;
return false;
}
}
export namespace TriggeredUpdateColumns {
export function is(value: any) : value is InformationSchema.Types.TriggeredUpdateColumns {
if (
(value.triggerCatalog !== undefined) && (value.triggerSchema !== undefined) && (value.triggerName !== undefined) && (value.eventObjectCatalog !== undefined) && (value.eventObjectSchema !== undefined) && (value.eventObjectTable !== undefined) && (value.eventObjectColumn !== undefined)
) return true;
return false;
}
}
export namespace Triggers {
export function is(value: any) : value is InformationSchema.Types.Triggers {
if (
(value.triggerCatalog !== undefined) && (value.triggerSchema !== undefined) && (value.triggerName !== undefined) && (value.eventManipulation !== undefined) && (value.eventObjectCatalog !== undefined) && (value.eventObjectSchema !== undefined) && (value.eventObjectTable !== undefined) && (value.actionOrder !== undefined) && (value.actionCondition !== undefined) && (value.actionStatement !== undefined) && (value.actionOrientation !== undefined) && (value.actionTiming !== undefined) && (value.actionReferenceOldTable !== undefined) && (value.actionReferenceNewTable !== undefined) && (value.actionReferenceOldRow !== undefined) && (value.actionReferenceNewRow !== undefined) && (value.created !== undefined)
) return true;
return false;
}
}
export namespace UdtPrivileges {
export function is(value: any) : value is InformationSchema.Types.UdtPrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleUdtGrants {
export function is(value: any) : value is InformationSchema.Types.RoleUdtGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace UsagePrivileges {
export function is(value: any) : value is InformationSchema.Types.UsagePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleUsageGrants {
export function is(value: any) : value is InformationSchema.Types.RoleUsageGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace UserDefinedTypes {
export function is(value: any) : value is InformationSchema.Types.UserDefinedTypes {
if (
(value.userDefinedTypeCatalog !== undefined) && (value.userDefinedTypeSchema !== undefined) && (value.userDefinedTypeName !== undefined) && (value.userDefinedTypeCategory !== undefined) && (value.isInstantiable !== undefined) && (value.isFinal !== undefined) && (value.orderingForm !== undefined) && (value.orderingCategory !== undefined) && (value.orderingRoutineCatalog !== undefined) && (value.orderingRoutineSchema !== undefined) && (value.orderingRoutineName !== undefined) && (value.referenceType !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.sourceDtdIdentifier !== undefined) && (value.refDtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ViewColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ViewColumnUsage {
if (
(value.viewCatalog !== undefined) && (value.viewSchema !== undefined) && (value.viewName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace ViewRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.ViewRoutineUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined)
) return true;
return false;
}
}
export namespace ViewTableUsage {
export function is(value: any) : value is InformationSchema.Types.ViewTableUsage {
if (
(value.viewCatalog !== undefined) && (value.viewSchema !== undefined) && (value.viewName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
export namespace Views {
export function is(value: any) : value is InformationSchema.Types.Views {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.viewDefinition !== undefined) && (value.checkOption !== undefined) && (value.isUpdatable !== undefined) && (value.isInsertableInto !== undefined) && (value.isTriggerUpdatable !== undefined) && (value.isTriggerDeletable !== undefined) && (value.isTriggerInsertableInto !== undefined)
) return true;
return false;
}
}
export namespace DataTypePrivileges {
export function is(value: any) : value is InformationSchema.Types.DataTypePrivileges {
if (
(value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ElementTypes {
export function is(value: any) : value is InformationSchema.Types.ElementTypes {
if (
(value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.collectionTypeIdentifier !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.domainDefault !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTableColumns {
export function is(value: any) : value is InformationSchema.Types.PgForeignTableColumns {
if (
(value.nspname !== undefined) && (value.relname !== undefined) && (value.attname !== undefined) && (value.attfdwoptions !== undefined)
) return true;
return false;
}
}
export namespace ColumnOptions {
export function is(value: any) : value is InformationSchema.Types.ColumnOptions {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrappers {
export function is(value: any) : value is InformationSchema.Types.PgForeignDataWrappers {
if (
(value.oid !== undefined) && (value.fdwowner !== undefined) && (value.fdwoptions !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.authorizationIdentifier !== undefined) && (value.foreignDataWrapperLanguage !== undefined)
) return true;
return false;
}
}
export namespace ForeignDataWrapperOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignDataWrapperOptions {
if (
(value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignDataWrappers {
export function is(value: any) : value is InformationSchema.Types.ForeignDataWrappers {
if (
(value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.authorizationIdentifier !== undefined) && (value.libraryName !== undefined) && (value.foreignDataWrapperLanguage !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServers {
export function is(value: any) : value is InformationSchema.Types.PgForeignServers {
if (
(value.oid !== undefined) && (value.srvoptions !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.foreignServerType !== undefined) && (value.foreignServerVersion !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ForeignServerOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignServerOptions {
if (
(value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignServers {
export function is(value: any) : value is InformationSchema.Types.ForeignServers {
if (
(value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.foreignServerType !== undefined) && (value.foreignServerVersion !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTables {
export function is(value: any) : value is InformationSchema.Types.PgForeignTables {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.ftoptions !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ForeignTableOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignTableOptions {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignTables {
export function is(value: any) : value is InformationSchema.Types.ForeignTables {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappings {
export function is(value: any) : value is InformationSchema.Types.PgUserMappings {
if (
(value.oid !== undefined) && (value.umoptions !== undefined) && (value.umuser !== undefined) && (value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.srvowner !== undefined)
) return true;
return false;
}
}
export namespace UserMappingOptions {
export function is(value: any) : value is InformationSchema.Types.UserMappingOptions {
if (
(value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace UserMappings {
export function is(value: any) : value is InformationSchema.Types.UserMappings {
if (
(value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
}
export namespace SqlImplementationInfo {
}
export namespace SqlParts {
}
export namespace SqlSizing {
}
}
}
export namespace Public {
export namespace Types {
export namespace GeometryDump {
export function is(value: any) : value is Public.Types.GeometryDump {
if (
(value.path !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace SpatialRefSys {
export function is(value: any) : value is Public.Types.SpatialRefSys {
if (
(value.srid !== undefined) && (value.authName !== undefined) && (value.authSrid !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined)
) return true;
return false;
}
}
export namespace ValidDetail {
export function is(value: any) : value is Public.Types.ValidDetail {
if (
(value.valid !== undefined) && (value.reason !== undefined) && (value.location !== undefined)
) return true;
return false;
}
}
export namespace GeographyColumns {
export function is(value: any) : value is Public.Types.GeographyColumns {
if (
(value.fTableCatalog !== undefined) && (value.fTableSchema !== undefined) && (value.fTableName !== undefined) && (value.fGeographyColumn !== undefined) && (value.coordDimension !== undefined) && (value.srid !== undefined) && (value.type !== undefined)
) return true;
return false;
}
}
export namespace GeometryColumns {
export function is(value: any) : value is Public.Types.GeometryColumns {
if (
(value.fTableCatalog !== undefined) && (value.fTableSchema !== undefined) && (value.fTableName !== undefined) && (value.fGeometryColumn !== undefined) && (value.coordDimension !== undefined) && (value.srid !== undefined) && (value.type !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocks {
export function is(value: any) : value is Public.Types.NycCensusBlocks {
if (
(value.gid !== undefined) && (value.blkid !== undefined) && (value.popnTotal !== undefined) && (value.popnWhite !== undefined) && (value.popnBlack !== undefined) && (value.popnNativ !== undefined) && (value.popnAsian !== undefined) && (value.popnOther !== undefined) && (value.boroname !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycHomicides {
export function is(value: any) : value is Public.Types.NycHomicides {
if (
(value.gid !== undefined) && (value.incidentD !== undefined) && (value.boroname !== undefined) && (value.numVictim !== undefined) && (value.primaryMo !== undefined) && (value.id !== undefined) && (value.weapon !== undefined) && (value.lightDark !== undefined) && (value.year !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoods {
export function is(value: any) : value is Public.Types.NycNeighborhoods {
if (
(value.gid !== undefined) && (value.boroname !== undefined) && (value.name !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycStreets {
export function is(value: any) : value is Public.Types.NycStreets {
if (
(value.gid !== undefined) && (value.id !== undefined) && (value.name !== undefined) && (value.oneway !== undefined) && (value.type !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStations {
export function is(value: any) : value is Public.Types.NycSubwayStations {
if (
(value.gid !== undefined) && (value.objectid !== undefined) && (value.id !== undefined) && (value.name !== undefined) && (value.altName !== undefined) && (value.crossSt !== undefined) && (value.longName !== undefined) && (value.label !== undefined) && (value.borough !== undefined) && (value.nghbhd !== undefined) && (value.routes !== undefined) && (value.transfers !== undefined) && (value.color !== undefined) && (value.express !== undefined) && (value.closed !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace SpatialRefSysPkey {
export function is(value: any) : value is Public.Types.SpatialRefSysPkey {
if (
(value.srid !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocksPkey {
export function is(value: any) : value is Public.Types.NycCensusBlocksPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycHomicidesPkey {
export function is(value: any) : value is Public.Types.NycHomicidesPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoodsPkey {
export function is(value: any) : value is Public.Types.NycNeighborhoodsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycStreetsPkey {
export function is(value: any) : value is Public.Types.NycStreetsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStationsPkey {
export function is(value: any) : value is Public.Types.NycSubwayStationsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocksGeomIdx {
export function is(value: any) : value is Public.Types.NycCensusBlocksGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycHomicidesGeomIdx {
export function is(value: any) : value is Public.Types.NycHomicidesGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoodsGeomIdx {
export function is(value: any) : value is Public.Types.NycNeighborhoodsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycStreetsGeomIdx {
export function is(value: any) : value is Public.Types.NycStreetsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStationsGeomIdx {
export function is(value: any) : value is Public.Types.NycSubwayStationsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrs {
export function is(value: any) : value is Public.Types.PostgisSrs {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrsAll {
export function is(value: any) : value is Public.Types.PostgisSrsAll {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrsSearch {
export function is(value: any) : value is Public.Types.PostgisSrsSearch {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace StMinimumboundingradius {
export function is(value: any) : value is Public.Types.StMinimumboundingradius {
if (
(value.center !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StMaximuminscribedcircle {
export function is(value: any) : value is Public.Types.StMaximuminscribedcircle {
if (
(value.center !== undefined) && (value.nearest !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StLargestemptycircle {
export function is(value: any) : value is Public.Types.StLargestemptycircle {
if (
(value.center !== undefined) && (value.nearest !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StHexagongrid {
export function is(value: any) : value is Public.Types.StHexagongrid {
if (
(value.geom !== undefined) && (value.i !== undefined) && (value.j !== undefined)
) return true;
return false;
}
}
export namespace StSquaregrid {
export function is(value: any) : value is Public.Types.StSquaregrid {
if (
(value.geom !== undefined) && (value.i !== undefined) && (value.j !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcepolygoncw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace SpheroidIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.SpheroidIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace SpheroidOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.SpheroidOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryTypmodIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryTypmodIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryTypmodOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryTypmodOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryAnalyze {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryAnalyze.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryRecv {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryRecv.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySend.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_4946 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_4946.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_8997 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_8997.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Point {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Point.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryB0d8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryB0d8.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Path {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Path.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryF1be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryF1be.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Polygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Polygon.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StX {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StX.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StY {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StY.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZ {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZ.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StM {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StM.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dfIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dfIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dfOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dfOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GidxIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GidxIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GidxOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GidxOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLt.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLe.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGt.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGe.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryEq {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryEq.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryCmp {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryCmp.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySortsupport {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySortsupport.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryHash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryHash.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDistance_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDistance_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistCompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistCompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPenalty_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPenalty_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPicksplit_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPicksplit_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistUnion_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistUnion_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSame_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSame_2d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDecompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDecompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSortsupport_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSortsupport_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcerhr {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcerhr.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisNoop {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisNoop.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcepolygonccw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcepolygonccw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistSel_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistSel_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistSelNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistSelNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistJoinsel_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistJoinsel_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistJoinselNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistJoinselNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlaps.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySame {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySame.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCentroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCentroid.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceBox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceBox.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContains {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContains.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryWithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryWithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLeft {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLeft.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverleft {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverleft.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryBelow {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryBelow.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverbelow {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverbelow.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverright {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverright.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryRight {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryRight.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverabove {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverabove.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryAbove {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryAbove.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPenaltyNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPenaltyNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistUnionNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistUnionNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSameNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSameNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDecompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDecompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlapsNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlapsNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContainsNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContainsNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryWithinNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryWithinNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySameNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySameNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCentroidNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCentroidNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCpa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCpa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDistanceNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDistanceNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StShiftlongitude {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShiftlongitude.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StWrapx {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWrapx.Parameters {
if (
(value.geom !== undefined) && (value.wrap !== undefined) && (value.move !== undefined)
) return true;
return false;
}
}
}
export namespace StXmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StXmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StYmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StYmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StXmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StXmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StYmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StYmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_3044 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_3044.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_3ea7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_3ea7.Parameters {
if (
(value.box !== undefined) && (value.dx !== undefined) && (value.dy !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisGetbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisGetbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakebox2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakebox2d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextentD2f5 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextentD2f5.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextent_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextent_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextent_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextent_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StFindextent_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFindextent_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFindextent_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFindextent_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisAddbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisAddbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisDropbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisDropbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisHasbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisHasbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StQuantizecoordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StQuantizecoordinates.Parameters {
if (
(value.g !== undefined) && (value.precX !== undefined) && (value.precY !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined)
) return true;
return false;
}
}
}
export namespace StMemsize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMemsize.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSummary_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSummary_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNpoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNrings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNrings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlength {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlength.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthspheroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthspheroid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength2dspheroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength2dspheroid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dperimeter {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dperimeter.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeter2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeter2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeter_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeter_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StArea2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StArea2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StArea_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StArea_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIspolygoncw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIspolygoncw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIspolygonccw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIspolygonccw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancespheroid_0cb2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancespheroid_0cb2.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancespheroidEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancespheroidEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistanceEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistanceEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointinsidecircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointinsidecircle.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StAzimuthEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAzimuthEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StProject_2077 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProject_2077.Parameters {
if (
(value.geom1 !== undefined) && (value.distance !== undefined) && (value.azimuth !== undefined)
) return true;
return false;
}
}
}
export namespace StProjectE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProjectE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.distance !== undefined)
) return true;
return false;
}
}
}
export namespace StAngleA4a1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAngleA4a1.Parameters {
if (
(value.pt1 !== undefined) && (value.pt2 !== undefined) && (value.pt3 !== undefined) && (value.pt4 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineextend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineextend.Parameters {
if (
(value.geom !== undefined) && (value.distanceForward !== undefined) && (value.distanceBackward !== undefined)
) return true;
return false;
}
}
}
export namespace StForce2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3dz {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3dz.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3d.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3dm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3dm.Parameters {
if (
(value.geom !== undefined) && (value.mvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce4d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce4d.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined) && (value.mvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForcecollection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcecollection.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionextractEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionextractEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionextract_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionextract_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionhomogenize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionhomogenize.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMulti {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMulti.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcecurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcecurve.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcesfs_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcesfs_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcesfsF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcesfsF1e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.version !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_95d4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_95d4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpandF49e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpandF49e.Parameters {
if (
(value.box !== undefined) && (value.dx !== undefined) && (value.dy !== undefined) && (value.dz !== undefined)
) return true;
return false;
}
}
}
export namespace StExpandDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpandDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpandBf72 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpandBf72.Parameters {
if (
(value.geom !== undefined) && (value.dx !== undefined) && (value.dy !== undefined) && (value.dz !== undefined) && (value.dm !== undefined)
) return true;
return false;
}
}
}
export namespace StEnvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEnvelope.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBoundingdiagonal {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBoundingdiagonal.Parameters {
if (
(value.geom !== undefined) && (value.fits !== undefined)
) return true;
return false;
}
}
}
export namespace StReverse {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StReverse.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StScroll {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScroll.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisGeosNoop {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisGeosNoop.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNormalize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNormalize.Parameters {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
}
export namespace StZmflag {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmflag.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNdims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNdims.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewktEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewktEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstwkb_8607 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstwkb_8607.Parameters {
if (
(value.geom !== undefined) && (value.prec !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined) && (value.withSizes !== undefined) && (value.withBoxes !== undefined)
) return true;
return false;
}
}
}
export namespace StAstwkb_1445 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstwkb_1445.Parameters {
if (
(value.geom !== undefined) && (value.ids !== undefined) && (value.prec !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined) && (value.withSizes !== undefined) && (value.withBoxes !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkb_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkb_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAshexewkb_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAshexewkb_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAshexewkbF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAshexewkbF1e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkbF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkbF1e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAslatlontext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAslatlontext.Parameters {
if (
(value.geom !== undefined) && (value.tmpl !== undefined)
) return true;
return false;
}
}
}
export namespace Geomfromewkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geomfromewkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromewkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromewkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geomfromewkt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geomfromewkt.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromewkt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromewkt.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisCacheBbox {
}
export namespace StMakepoint_0aec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_0aec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepoint_81ec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_81ec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepoint_570b {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_570b.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepointm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepointm.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dmakebox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dmakebox.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakelineF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakelineF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefrommultipoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefrommultipoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakelineEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakelineEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddpointEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddpointEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_2077 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_2077.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddpointCc0f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddpointCc0f.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRemovepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRemovepoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSetpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetpoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakeenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakeenvelope.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StTileenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTileenvelope.Parameters {
if (
(value.zoom !== undefined) && (value.x !== undefined) && (value.y !== undefined) && (value.bounds !== undefined) && (value.margin !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepolygon_0543 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepolygon_0543.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepolygon_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepolygon_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuildarea {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuildarea.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonizeF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonizeF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StClusterintersectingF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClusterintersectingF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StClusterwithin_2892 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClusterwithin_2892.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinemerge_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinemerge_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinemergeCad2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinemergeCad2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAffineA659 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAffineA659.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined) && (value.argument_6 !== undefined) && (value.argument_7 !== undefined) && (value.argument_8 !== undefined) && (value.argument_9 !== undefined) && (value.argument_10 !== undefined) && (value.argument_11 !== undefined) && (value.argument_12 !== undefined)
) return true;
return false;
}
}
}
export namespace StAffine_0997 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAffine_0997.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined) && (value.argument_6 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotateDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotateDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotate_6aac {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotate_6aac.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotate_8af1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotate_8af1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatez {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatez.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatex {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatex.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatey {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatey.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StTranslate_6aac {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTranslate_6aac.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StTranslate_2077 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTranslate_2077.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StScaleEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScaleEb6a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_8af1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_8af1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_6aac {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_6aac.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StTransscale {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransscale.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StDump {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDump.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumprings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumprings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumppoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumppoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumpsegments {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumpsegments.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PopulateGeometryColumns_23fc.Parameters {
if (
(value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PopulateGeometryColumns_4174.Parameters {
if (
(value.tblOid !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_8fbb.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSridIn !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_4617 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_4617.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSrid !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_093c {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_093c.Parameters {
if (
(value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSrid !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrycolumn_0412.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrycolumn_2253.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrycolumnF11a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrycolumnF11a.Parameters {
if (
(value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrytable_2253 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrytable_2253.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace StSegmentizeDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSegmentizeDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrytableF11a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrytableF11a.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrytableBfde {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrytableBfde.Parameters {
if (
(value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace UpdategeometrysridB2ee {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.UpdategeometrysridB2ee.Parameters {
if (
(value.catalognName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSridIn !== undefined)
) return true;
return false;
}
}
}
export namespace Updategeometrysrid_7b58 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Updategeometrysrid_7b58.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Updategeometrysrid_11c8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Updategeometrysrid_11c8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace FindSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.FindSrid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GetProj4FromSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GetProj4FromSrid.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSetsridEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetsridEd82.Parameters {
if (
(value.geom !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StSrid_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSrid_0faa.Parameters {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTransformGeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTransformGeometry.Parameters {
if (
(value.geom !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrsCodes {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrsCodes.Parameters {
if (
(value.authName !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrs {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrs.Parameters {
if (
(value.authName !== undefined) && (value.authSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrsAll {
}
export namespace PostgisSrsSearch {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrsSearch.Parameters {
if (
(value.bounds !== undefined) && (value.authname !== undefined)
) return true;
return false;
}
}
}
export namespace StTransformEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransformEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StTransformF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransformF1e2.Parameters {
if (
(value.geom !== undefined) && (value.toProj !== undefined)
) return true;
return false;
}
}
}
export namespace StTransformEfe6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransformEfe6.Parameters {
if (
(value.geom !== undefined) && (value.fromProj !== undefined) && (value.toProj !== undefined)
) return true;
return false;
}
}
}
export namespace StTransform_3ad9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransform_3ad9.Parameters {
if (
(value.geom !== undefined) && (value.fromProj !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTransformPipelineGeometry.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.forward !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace StTransformpipeline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransformpipeline.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace StInversetransformpipeline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInversetransformpipeline.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisVersion {
}
export namespace PostgisLiblwgeomVersion {
}
export namespace PostgisProjVersion {
}
export namespace PostgisWagyuVersion {
}
export namespace PostgisScriptsInstalled {
}
export namespace PostgisLibVersion {
}
export namespace PostgisScriptsReleased {
}
export namespace PostgisGeosVersion {
}
export namespace PostgisGeosCompiledVersion {
}
export namespace PostgisLibRevision {
}
export namespace PostgisSvnVersion {
}
export namespace PostgisLibxmlVersion {
}
export namespace PostgisScriptsBuildDate {
}
export namespace PostgisLibBuildDate {
}
export namespace PostgisExtensionsUpgrade {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisExtensionsUpgrade.Parameters {
if (
(value.targetVersion !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoints_1c13 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoints_1c13.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.repeat !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstring_2077 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstring_2077.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepointEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepointEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddmeasure {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddmeasure.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpointofapproach {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpointofapproach.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisFullVersion {
}
export namespace Box2d_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2d_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3d_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3d_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2d_8784 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2d_8784.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dF5fa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dF5fa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box_8784 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box_8784.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Text {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Text.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dtobox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dtobox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryF5fa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryF5fa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_8784 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_8784.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Bytea_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Bytea_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifyDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifyDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplify_1c13 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplify_1c13.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifyvw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifyvw.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSeteffectivearea {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSeteffectivearea.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFilterbym {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFilterbym.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StChaikinsmoothing {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StChaikinsmoothing.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogridBf72 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogridBf72.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogrid_2077 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogrid_2077.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogridDeb6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogridDeb6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogrid_7713 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogrid_7713.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancecpa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancecpa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCpawithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCpawithin.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidtrajectory {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidtrajectory.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectionE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectionE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferDcba {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferDcba.Parameters {
if (
(value.geom !== undefined) && (value.radius !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_3222 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_3222.Parameters {
if (
(value.geom !== undefined) && (value.radius !== undefined) && (value.quadsegs !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumboundingradius {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumboundingradius.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumboundingcircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumboundingcircle.Parameters {
if (
(value.inputgeom !== undefined) && (value.segsPerQuarter !== undefined)
) return true;
return false;
}
}
}
export namespace StOrientedenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOrientedenvelope.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StOffsetcurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOffsetcurve.Parameters {
if (
(value.line !== undefined) && (value.distance !== undefined) && (value.params !== undefined)
) return true;
return false;
}
}
}
export namespace StGeneratepointsEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeneratepointsEd82.Parameters {
if (
(value.area !== undefined) && (value.npoints !== undefined)
) return true;
return false;
}
}
}
export namespace StGeneratepointsA8be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeneratepointsA8be.Parameters {
if (
(value.area !== undefined) && (value.npoints !== undefined) && (value.seed !== undefined)
) return true;
return false;
}
}
}
export namespace StConvexhull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StConvexhull.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifypreservetopology {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifypreservetopology.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidreason_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidreason_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvaliddetail {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvaliddetail.Parameters {
if (
(value.geom !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidreasonEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidreasonEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StHausdorffdistanceEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHausdorffdistanceEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StHausdorffdistanceE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHausdorffdistanceE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFrechetdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFrechetdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMaximuminscribedcircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMaximuminscribedcircle.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLargestemptycircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLargestemptycircle.Parameters {
if (
(value.geom !== undefined) && (value.tolerance !== undefined) && (value.boundary !== undefined)
) return true;
return false;
}
}
}
export namespace StDifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StBoundary {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBoundary.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSymdifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSymdifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StSymmetricdifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSymmetricdifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnionEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnionEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnionE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnionE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StUnaryunion {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnaryunion.Parameters {
if (
(value.argument_0 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StRemoverepeatedpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRemoverepeatedpoints.Parameters {
if (
(value.geom !== undefined) && (value.tolerance !== undefined)
) return true;
return false;
}
}
}
export namespace StClipbybox2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClipbybox2d.Parameters {
if (
(value.geom !== undefined) && (value.box !== undefined)
) return true;
return false;
}
}
}
export namespace StSubdivide {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSubdivide.Parameters {
if (
(value.geom !== undefined) && (value.maxvertices !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StReduceprecision {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StReduceprecision.Parameters {
if (
(value.geom !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StMakevalid_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakevalid_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakevalidF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakevalidF1e2.Parameters {
if (
(value.geom !== undefined) && (value.params !== undefined)
) return true;
return false;
}
}
}
export namespace StCleangeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCleangeometry.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSplit {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSplit.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSharedpaths {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSharedpaths.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnap {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnap.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelatematch {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelatematch.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNode {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNode.Parameters {
if (
(value.g !== undefined)
) return true;
return false;
}
}
}
export namespace StDelaunaytriangles {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDelaunaytriangles.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StTriangulatepolygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTriangulatepolygon.Parameters {
if (
(value.g1 !== undefined)
) return true;
return false;
}
}
}
export namespace StVoronoipolygons {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StVoronoipolygons.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.extendTo !== undefined)
) return true;
return false;
}
}
}
export namespace StVoronoilines {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StVoronoilines.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.extendTo !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebbox_2c84 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebbox_2c84.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebboxEe61 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebboxEe61.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebbox_7c5a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebbox_7c5a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfnE941 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfnE941.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfnDd3f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfn_0a1f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryCollectFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryMakelineFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelTransfnE941 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelTransfnDd3f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnionF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnionF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoverageunionF393 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoverageunionF393.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelateEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelateEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelateCc0f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelateCc0f.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelate_6458 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelate_6458.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDisjoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDisjoint.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisIndexSupportfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisIndexSupportfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinecrossingdirection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinecrossingdirection.Parameters {
if (
(value.line1 !== undefined) && (value.line2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithinE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithinE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StTouches {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTouches.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectsEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectsEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCrosses {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCrosses.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StContains {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StContains.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StContainsproperly {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StContainsproperly.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StWithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoversEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoversEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredbyEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredbyEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOverlaps.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDfullywithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDfullywithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddwithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddwithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddfullywithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddfullywithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dintersects {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dintersects.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StOrderingequals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOrderingequals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEquals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEquals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalid_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalid_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumclearance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumclearance.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumclearanceline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumclearanceline.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroid_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroid_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometricmedian {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometricmedian.Parameters {
if (
(value.g !== undefined) && (value.tolerance !== undefined) && (value.maxIter !== undefined) && (value.failIfNotConverged !== undefined)
) return true;
return false;
}
}
}
export namespace StIsring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointonsurface {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointonsurface.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIssimple {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIssimple.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIscollection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIscollection.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Equals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Equals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgml_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgml_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGmltosqlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGmltosqlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGmltosql_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGmltosql_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromkml {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromkml.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfrommarc21 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfrommarc21.Parameters {
if (
(value.marc21xml !== undefined)
) return true;
return false;
}
}
}
export namespace StAsmarc21 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsmarc21.Parameters {
if (
(value.geom !== undefined) && (value.format !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojsonE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojsonE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojson_608f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojson_608f.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojson_3c9d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisLibjsonVersion {
}
export namespace StLinefromencodedpolyline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromencodedpolyline.Parameters {
if (
(value.txtin !== undefined) && (value.nprecision !== undefined)
) return true;
return false;
}
}
}
export namespace StAsencodedpolyline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsencodedpolyline.Parameters {
if (
(value.geom !== undefined) && (value.nprecision !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvgA8be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvgA8be.Parameters {
if (
(value.geom !== undefined) && (value.rel !== undefined) && (value.maxdecimaldigits !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlA8be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlA8be.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgml_2621 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgml_2621.Parameters {
if (
(value.version !== undefined) && (value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAskmlE3da {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskmlE3da.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.nprefix !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonA8be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonA8be.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonF2c6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonF2c6.Parameters {
if (
(value.r !== undefined) && (value.geomColumn !== undefined) && (value.maxdecimaldigits !== undefined) && (value.prettyBool !== undefined)
) return true;
return false;
}
}
}
export namespace Json {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Json.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Jsonb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Jsonb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_27f4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfnF57f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_92c1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfnF5be.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtCombinefn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtCombinefn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtSerialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtSerialfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtDeserialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtDeserialfn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsmvtgeom {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsmvtgeom.Parameters {
if (
(value.geom !== undefined) && (value.bounds !== undefined) && (value.extent !== undefined) && (value.buffer !== undefined) && (value.clipGeom !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisLibprotobufVersion {
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsgeobufFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StFromflatgeobuftotable {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFromflatgeobuftotable.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFromflatgeobuf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFromflatgeobuf.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeohashEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeohashEd82.Parameters {
if (
(value.geom !== undefined) && (value.maxchars !== undefined)
) return true;
return false;
}
}
}
export namespace StBox2dfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBox2dfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumpoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumgeometries {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumgeometries.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDimension {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDimension.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StExteriorring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExteriorring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNuminteriorrings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNuminteriorrings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNuminteriorring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNuminteriorring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StInteriorringn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInteriorringn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometrytype_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometrytype_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometrytype {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometrytype.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumpatches {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumpatches.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPatchn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPatchn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StStartpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StStartpoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StEndpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEndpoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsclosed {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsclosed.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsempty {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsempty.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinaryF1e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinaryF1e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstextEd82 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstextEd82.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StWkttosql {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWkttosql.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinestringfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinestringfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinestringfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolygonfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolygonfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolygonfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinestringfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinestringfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinestringfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyAnalyze {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyAnalyze.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinefromwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinefromwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMaxdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMaxdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpointEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpointEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestlineEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestlineEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLongestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLongestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSwapordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSwapordinates.Parameters {
if (
(value.geom !== undefined) && (value.ords !== undefined)
) return true;
return false;
}
}
}
export namespace StFlipcoordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFlipcoordinates.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBdpolyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBdpolyfromtext.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBdmpolyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBdmpolyfromtext.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Unlockrows {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Unlockrows.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_675a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_675a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Bytea_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Bytea_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_75a2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_75a2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace LockrowE9aa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.LockrowE9aa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_02b4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_02b4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_9a8a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_9a8a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Addauth {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addauth.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauth_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Checkauth_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauth_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Checkauth_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauthtrigger {
}
export namespace Gettransactionid {
}
export namespace Enablelongtransactions {
}
export namespace Longtransactionsenabled {
}
export namespace Disablelongtransactions {
}
export namespace GeographyTypmodIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyTypmodIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyTypmodOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyTypmodOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyIn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyRecv {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyRecv.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySend.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeographyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeographyfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeogfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeogfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeogfromwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeogfromwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodDims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodDims.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodSrid.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodType {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodType.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_0faa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_0faa.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistConsistent {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistConsistent.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistCompress {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistCompress.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistPenalty {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistPenalty.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistPicksplit {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistPicksplit.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistUnion {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistUnion.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistSame {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistSame.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistDecompress {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistDecompress.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyOverlaps.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyDistanceKnn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyDistanceKnn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistDistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistDistance.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeog_5a37 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeog_5a37.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeogBd57 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeogBd57.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeog_1597 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeog_1597.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeogBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeogBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyLt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyLt.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyLe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyLe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGt.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyEq {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyEq.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyCmp {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyCmp.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvg_8ddb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvg_8ddb.Parameters {
if (
(value.geog !== undefined) && (value.rel !== undefined) && (value.maxdecimaldigits !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvgE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvgE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StProjectE61a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProjectE61a.Parameters {
if (
(value.geogFrom !== undefined) && (value.geogTo !== undefined) && (value.distance !== undefined)
) return true;
return false;
}
}
}
export namespace StAzimuthA587 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAzimuthA587.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_49f7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_49f7.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlCe11 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlCe11.Parameters {
if (
(value.version !== undefined) && (value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgml_98d7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgml_98d7.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAskml_48da {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskml_48da.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.nprefix !== undefined)
) return true;
return false;
}
}
}
export namespace StAskmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojson_8ddb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojson_8ddb.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistance_89b8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistance_89b8.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StDistance_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistance_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAreaAc0a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAreaAc0a.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StAreaE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAreaE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthAc0a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthAc0a.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StProject_665e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProject_665e.Parameters {
if (
(value.geog !== undefined) && (value.distance !== undefined) && (value.azimuth !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeterAc0a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeterAc0a.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StSegmentize_772c {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSegmentize_772c.Parameters {
if (
(value.geog !== undefined) && (value.maxSegmentLength !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinaryF815 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinaryF815.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_75a2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_75a2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewktE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewktE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometrytype_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometrytype_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSummary_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSummary_38ca.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeohash_75a2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeohash_75a2.Parameters {
if (
(value.geog !== undefined) && (value.maxchars !== undefined)
) return true;
return false;
}
}
}
export namespace StSrid_38ca {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSrid_38ca.Parameters {
if (
(value.geog !== undefined)
) return true;
return false;
}
}
}
export namespace StSetsrid_75a2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetsrid_75a2.Parameters {
if (
(value.geog !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroidAc0a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroidAc0a.Parameters {
if (
(value.argument_0 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroidE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroidE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoversA587 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoversA587.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithin_5395 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithin_5395.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined) && (value.tolerance !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredbyA587 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredbyA587.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectsA587 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectsA587.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_772c {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_772c.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_2117 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_2117.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_3a01 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_3a01.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferF7c6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferF7c6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectionA587 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectionA587.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersection_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersection_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCovers_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCovers_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredby_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredby_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithinEfc0 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithinEfc0.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersects_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersects_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpoint_89b8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpoint_89b8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpoint_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpoint_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestline_89b8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestline_89b8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestline_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestline_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstring_665e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstring_665e.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstringE586 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstringE586.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepoint_89b8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepoint_89b8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepoint_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoints_5d11 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoints_5d11.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined) && (value.repeat !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointsC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointsC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointCee3 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointCee3.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancesphereEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancesphereEb6a.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancesphereE059 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancesphereE059.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypeName {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypeName.Parameters {
if (
(value.geomname !== undefined) && (value.coordDimension !== undefined) && (value.useNewName !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintSrid.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintDims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintDims.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintType {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintType.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dmaxdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dmaxdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dclosestpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dclosestpoint.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dshortestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dshortestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlongestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlongestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoorddim {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoorddim.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StCurvetoline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCurvetoline.Parameters {
if (
(value.geom !== undefined) && (value.tol !== undefined) && (value.toltype !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StHasarc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHasarc.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StLinetocurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinetocurve.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StPoint_0aec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoint_0aec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPoint_0b7f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoint_0b7f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointz {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointz.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.zcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointm.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.mcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointzm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointzm.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.zcoordinate !== undefined) && (value.mcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygon.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StWkbtosql {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWkbtosql.Parameters {
if (
(value.wkb !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatebetween {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatebetween.Parameters {
if (
(value.geometry !== undefined) && (value.frommeasure !== undefined) && (value.tomeasure !== undefined) && (value.leftrightoffset !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatealong {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatealong.Parameters {
if (
(value.geometry !== undefined) && (value.measure !== undefined) && (value.leftrightoffset !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatebetweenelevations {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatebetweenelevations.Parameters {
if (
(value.geometry !== undefined) && (value.fromelevation !== undefined) && (value.toelevation !== undefined)
) return true;
return false;
}
}
}
export namespace StInterpolatepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInterpolatepoint.Parameters {
if (
(value.line !== undefined) && (value.point !== undefined)
) return true;
return false;
}
}
}
export namespace StHexagon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHexagon.Parameters {
if (
(value.size !== undefined) && (value.cellI !== undefined) && (value.cellJ !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StSquare {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSquare.Parameters {
if (
(value.size !== undefined) && (value.cellI !== undefined) && (value.cellJ !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StHexagongrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHexagongrid.Parameters {
if (
(value.size !== undefined) && (value.bounds !== undefined)
) return true;
return false;
}
}
}
export namespace StSquaregrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSquaregrid.Parameters {
if (
(value.size !== undefined) && (value.bounds !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2dD703 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2dD703.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2dD703 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2dD703.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2dD703 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2dD703.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2d_1585 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2d_1585.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2d_1585 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2d_1585.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2d_1585 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2d_1585.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2d_3f94 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2d_3f94.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2d_3f94 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2d_3f94.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2d_3f94 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2d_3f94.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNd_44c4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNd_44c4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNdBd57 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNdBd57.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNd_19dd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNd_19dd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom2dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom3dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom4dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifypolygonhull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifypolygonhull.Parameters {
if (
(value.geom !== undefined) && (value.vertexFraction !== undefined) && (value.isOuter !== undefined)
) return true;
return false;
}
}
}
export namespace StConcavehull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StConcavehull.Parameters {
if (
(value.paramGeom !== undefined) && (value.paramPctconvex !== undefined) && (value.paramAllowHoles !== undefined)
) return true;
return false;
}
}
}
export namespace StAsx3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsx3d.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAngleEb6a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAngleEb6a.Parameters {
if (
(value.line1 !== undefined) && (value.line2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlineinterpolatepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlineinterpolatepoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfig_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfig_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChoose_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChoose_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplit_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlaps_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlaps_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContains_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContains_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContained_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContained_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySame_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySame_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfig_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfig_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChoose_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChoose_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplit_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompress_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompress_3d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfigNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfigNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChooseNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChooseNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistConfigNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistConfigNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistChooseNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistChooseNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistInnerConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistLeafConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLetters {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLetters.Parameters {
if (
(value.letters !== undefined) && (value.font !== undefined)
) return true;
return false;
}
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
}
export namespace NycCensusBlocks {
}
export namespace NycHomicides {
}
export namespace NycNeighborhoods {
}
export namespace NycStreets {
}
export namespace NycSubwayStations {
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_49556Index {
export function is(value: any) : value is PgToast.Types.PgToast_49556Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_50314Index {
export function is(value: any) : value is PgToast.Types.PgToast_50314Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_50320Index {
export function is(value: any) : value is PgToast.Types.PgToast_50320Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1255Index {
export function is(value: any) : value is PgToast.Types.PgToast_1255Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1247Index {
export function is(value: any) : value is PgToast.Types.PgToast_1247Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2604Index {
export function is(value: any) : value is PgToast.Types.PgToast_2604Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2606Index {
export function is(value: any) : value is PgToast.Types.PgToast_2606Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2612Index {
export function is(value: any) : value is PgToast.Types.PgToast_2612Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2600Index {
export function is(value: any) : value is PgToast.Types.PgToast_2600Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2619Index {
export function is(value: any) : value is PgToast.Types.PgToast_2619Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3381Index {
export function is(value: any) : value is PgToast.Types.PgToast_3381Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3429Index {
export function is(value: any) : value is PgToast.Types.PgToast_3429Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2618Index {
export function is(value: any) : value is PgToast.Types.PgToast_2618Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2620Index {
export function is(value: any) : value is PgToast.Types.PgToast_2620Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3466Index {
export function is(value: any) : value is PgToast.Types.PgToast_3466Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2609Index {
export function is(value: any) : value is PgToast.Types.PgToast_2609Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_50326Index {
export function is(value: any) : value is PgToast.Types.PgToast_50326Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2615Index {
export function is(value: any) : value is PgToast.Types.PgToast_2615Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1262Index {
export function is(value: any) : value is PgToast.Types.PgToast_1262Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2964Index {
export function is(value: any) : value is PgToast.Types.PgToast_2964Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1213Index {
export function is(value: any) : value is PgToast.Types.PgToast_1213Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1260Index {
export function is(value: any) : value is PgToast.Types.PgToast_1260Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2396Index {
export function is(value: any) : value is PgToast.Types.PgToast_2396Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3600Index {
export function is(value: any) : value is PgToast.Types.PgToast_3600Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3079Index {
export function is(value: any) : value is PgToast.Types.PgToast_3079Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2328Index {
export function is(value: any) : value is PgToast.Types.PgToast_2328Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1417Index {
export function is(value: any) : value is PgToast.Types.PgToast_1417Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1418Index {
export function is(value: any) : value is PgToast.Types.PgToast_1418Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3118Index {
export function is(value: any) : value is PgToast.Types.PgToast_3118Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3256Index {
export function is(value: any) : value is PgToast.Types.PgToast_3256Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6000Index {
export function is(value: any) : value is PgToast.Types.PgToast_6000Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_826Index {
export function is(value: any) : value is PgToast.Types.PgToast_826Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3394Index {
export function is(value: any) : value is PgToast.Types.PgToast_3394Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3596Index {
export function is(value: any) : value is PgToast.Types.PgToast_3596Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3592Index {
export function is(value: any) : value is PgToast.Types.PgToast_3592Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3456Index {
export function is(value: any) : value is PgToast.Types.PgToast_3456Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6243Index {
export function is(value: any) : value is PgToast.Types.PgToast_6243Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3350Index {
export function is(value: any) : value is PgToast.Types.PgToast_3350Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6106Index {
export function is(value: any) : value is PgToast.Types.PgToast_6106Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6100Index {
export function is(value: any) : value is PgToast.Types.PgToast_6100Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_50332Index {
export function is(value: any) : value is PgToast.Types.PgToast_50332Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_50338Index {
export function is(value: any) : value is PgToast.Types.PgToast_50338Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13658Index {
export function is(value: any) : value is PgToast.Types.PgToast_13658Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13663Index {
export function is(value: any) : value is PgToast.Types.PgToast_13663Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13668Index {
export function is(value: any) : value is PgToast.Types.PgToast_13668Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13673Index {
export function is(value: any) : value is PgToast.Types.PgToast_13673Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
}
}
export namespace PgCatalog {
export namespace Types {
export namespace Bool {
 export function equals(l: PgCatalog.Types.Bool|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bytea {
 export function equals(l: PgCatalog.Types.Bytea|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Char {
 export function equals(l: PgCatalog.Types.Char|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Name {
 export function equals(l: PgCatalog.Types.Name|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8 {
 export function equals(l: PgCatalog.Types.Int8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2 {
 export function equals(l: PgCatalog.Types.Int2|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2vector {
 export function equals(l: PgCatalog.Types.Int2vector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4 {
 export function equals(l: PgCatalog.Types.Int4|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regproc {
 export function equals(l: PgCatalog.Types.Regproc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Text {
 export function equals(l: PgCatalog.Types.Text|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Oid {
 export function equals(l: PgCatalog.Types.Oid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tid {
 export function equals(l: PgCatalog.Types.Tid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid {
 export function equals(l: PgCatalog.Types.Xid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cid {
 export function equals(l: PgCatalog.Types.Cid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Oidvector {
 export function equals(l: PgCatalog.Types.Oidvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgType {
 export function equals(l: PgCatalog.Types.PgType|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttribute {
 export function equals(l: PgCatalog.Types.PgAttribute|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProc {
 export function equals(l: PgCatalog.Types.PgProc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClass {
 export function equals(l: PgCatalog.Types.PgClass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Json {
 export function equals(l: PgCatalog.Types.Json|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xml {
 export function equals(l: PgCatalog.Types.Xml|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNodeTree {
 export function equals(l: PgCatalog.Types.PgNodeTree|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNdistinct {
 export function equals(l: PgCatalog.Types.PgNdistinct|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependencies {
 export function equals(l: PgCatalog.Types.PgDependencies|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMcvList {
 export function equals(l: PgCatalog.Types.PgMcvList|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDdlCommand {
 export function equals(l: PgCatalog.Types.PgDdlCommand|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid8 {
 export function equals(l: PgCatalog.Types.Xid8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Point {
 export function equals(l: PgCatalog.Types.Point|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Lseg {
 export function equals(l: PgCatalog.Types.Lseg|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Path {
 export function equals(l: PgCatalog.Types.Path|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box {
 export function equals(l: PgCatalog.Types.Box|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Polygon {
 export function equals(l: PgCatalog.Types.Polygon|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Line {
 export function equals(l: PgCatalog.Types.Line|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float4 {
 export function equals(l: PgCatalog.Types.Float4|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float8 {
 export function equals(l: PgCatalog.Types.Float8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Unknown {
 export function equals(l: PgCatalog.Types.Unknown|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Circle {
 export function equals(l: PgCatalog.Types.Circle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Money {
 export function equals(l: PgCatalog.Types.Money|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr {
 export function equals(l: PgCatalog.Types.Macaddr|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Inet {
 export function equals(l: PgCatalog.Types.Inet|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cidr {
 export function equals(l: PgCatalog.Types.Cidr|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr8 {
 export function equals(l: PgCatalog.Types.Macaddr8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Aclitem {
 export function equals(l: PgCatalog.Types.Aclitem|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bpchar {
 export function equals(l: PgCatalog.Types.Bpchar|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Varchar {
 export function equals(l: PgCatalog.Types.Varchar|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Date {
 export function equals(l: PgCatalog.Types.Date|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Time {
 export function equals(l: PgCatalog.Types.Time|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timestamp {
 export function equals(l: PgCatalog.Types.Timestamp|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timestamptz {
 export function equals(l: PgCatalog.Types.Timestamptz|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Interval {
 export function equals(l: PgCatalog.Types.Interval|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timetz {
 export function equals(l: PgCatalog.Types.Timetz|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bit {
 export function equals(l: PgCatalog.Types.Bit|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Varbit {
 export function equals(l: PgCatalog.Types.Varbit|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Numeric {
 export function equals(l: PgCatalog.Types.Numeric|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Refcursor {
 export function equals(l: PgCatalog.Types.Refcursor|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regprocedure {
 export function equals(l: PgCatalog.Types.Regprocedure|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regoper {
 export function equals(l: PgCatalog.Types.Regoper|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regoperator {
 export function equals(l: PgCatalog.Types.Regoperator|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regclass {
 export function equals(l: PgCatalog.Types.Regclass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regcollation {
 export function equals(l: PgCatalog.Types.Regcollation|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regtype {
 export function equals(l: PgCatalog.Types.Regtype|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regrole {
 export function equals(l: PgCatalog.Types.Regrole|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regnamespace {
 export function equals(l: PgCatalog.Types.Regnamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Uuid {
 export function equals(l: PgCatalog.Types.Uuid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLsn {
 export function equals(l: PgCatalog.Types.PgLsn|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsvector {
 export function equals(l: PgCatalog.Types.Tsvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Gtsvector {
 export function equals(l: PgCatalog.Types.Gtsvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsquery {
 export function equals(l: PgCatalog.Types.Tsquery|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regconfig {
 export function equals(l: PgCatalog.Types.Regconfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regdictionary {
 export function equals(l: PgCatalog.Types.Regdictionary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Jsonb {
 export function equals(l: PgCatalog.Types.Jsonb|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Jsonpath {
 export function equals(l: PgCatalog.Types.Jsonpath|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TxidSnapshot {
 export function equals(l: PgCatalog.Types.TxidSnapshot|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSnapshot {
 export function equals(l: PgCatalog.Types.PgSnapshot|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4range {
 export function equals(l: PgCatalog.Types.Int4range|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Numrange {
 export function equals(l: PgCatalog.Types.Numrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsrange {
 export function equals(l: PgCatalog.Types.Tsrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tstzrange {
 export function equals(l: PgCatalog.Types.Tstzrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Daterange {
 export function equals(l: PgCatalog.Types.Daterange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8range {
 export function equals(l: PgCatalog.Types.Int8range|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4multirange {
 export function equals(l: PgCatalog.Types.Int4multirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Nummultirange {
 export function equals(l: PgCatalog.Types.Nummultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsmultirange {
 export function equals(l: PgCatalog.Types.Tsmultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tstzmultirange {
 export function equals(l: PgCatalog.Types.Tstzmultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Datemultirange {
 export function equals(l: PgCatalog.Types.Datemultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8multirange {
 export function equals(l: PgCatalog.Types.Int8multirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Record {
 export function equals(l: PgCatalog.Types.Record|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RecordArray {
 export function equals(l: PgCatalog.Types.RecordArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cstring {
 export function equals(l: PgCatalog.Types.Cstring|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Any {
 export function equals(l: PgCatalog.Types.Any|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyarray {
 export function equals(l: PgCatalog.Types.Anyarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Void {
 export function equals(l: PgCatalog.Types.Void|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Trigger {
 export function equals(l: PgCatalog.Types.Trigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EventTrigger {
 export function equals(l: PgCatalog.Types.EventTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LanguageHandler {
 export function equals(l: PgCatalog.Types.LanguageHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Internal {
 export function equals(l: PgCatalog.Types.Internal|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyelement {
 export function equals(l: PgCatalog.Types.Anyelement|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anynonarray {
 export function equals(l: PgCatalog.Types.Anynonarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyenum {
 export function equals(l: PgCatalog.Types.Anyenum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace FdwHandler {
 export function equals(l: PgCatalog.Types.FdwHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace IndexAmHandler {
 export function equals(l: PgCatalog.Types.IndexAmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsmHandler {
 export function equals(l: PgCatalog.Types.TsmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableAmHandler {
 export function equals(l: PgCatalog.Types.TableAmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyrange {
 export function equals(l: PgCatalog.Types.Anyrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatible {
 export function equals(l: PgCatalog.Types.Anycompatible|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblearray {
 export function equals(l: PgCatalog.Types.Anycompatiblearray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblenonarray {
 export function equals(l: PgCatalog.Types.Anycompatiblenonarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblerange {
 export function equals(l: PgCatalog.Types.Anycompatiblerange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anymultirange {
 export function equals(l: PgCatalog.Types.Anymultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblemultirange {
 export function equals(l: PgCatalog.Types.Anycompatiblemultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBrinBloomSummary {
 export function equals(l: PgCatalog.Types.PgBrinBloomSummary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBrinMinmaxMultiSummary {
 export function equals(l: PgCatalog.Types.PgBrinMinmaxMultiSummary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BoolArray {
 export function equals(l: PgCatalog.Types.BoolArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ByteaArray {
 export function equals(l: PgCatalog.Types.ByteaArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharArray {
 export function equals(l: PgCatalog.Types.CharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NameArray {
 export function equals(l: PgCatalog.Types.NameArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8Array {
 export function equals(l: PgCatalog.Types.Int8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2Array {
 export function equals(l: PgCatalog.Types.Int2Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2vectorArray {
 export function equals(l: PgCatalog.Types.Int2vectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4Array {
 export function equals(l: PgCatalog.Types.Int4Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegprocArray {
 export function equals(l: PgCatalog.Types.RegprocArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TextArray {
 export function equals(l: PgCatalog.Types.TextArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace OidArray {
 export function equals(l: PgCatalog.Types.OidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TidArray {
 export function equals(l: PgCatalog.Types.TidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace XidArray {
 export function equals(l: PgCatalog.Types.XidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CidArray {
 export function equals(l: PgCatalog.Types.CidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace OidvectorArray {
 export function equals(l: PgCatalog.Types.OidvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeArray {
 export function equals(l: PgCatalog.Types.PgTypeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeArray {
 export function equals(l: PgCatalog.Types.PgAttributeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcArray {
 export function equals(l: PgCatalog.Types.PgProcArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassArray {
 export function equals(l: PgCatalog.Types.PgClassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonArray {
 export function equals(l: PgCatalog.Types.JsonArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace XmlArray {
 export function equals(l: PgCatalog.Types.XmlArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid8Array {
 export function equals(l: PgCatalog.Types.Xid8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PointArray {
 export function equals(l: PgCatalog.Types.PointArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LsegArray {
 export function equals(l: PgCatalog.Types.LsegArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PathArray {
 export function equals(l: PgCatalog.Types.PathArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BoxArray {
 export function equals(l: PgCatalog.Types.BoxArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PolygonArray {
 export function equals(l: PgCatalog.Types.PolygonArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LineArray {
 export function equals(l: PgCatalog.Types.LineArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float4Array {
 export function equals(l: PgCatalog.Types.Float4Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float8Array {
 export function equals(l: PgCatalog.Types.Float8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CircleArray {
 export function equals(l: PgCatalog.Types.CircleArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace MoneyArray {
 export function equals(l: PgCatalog.Types.MoneyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace MacaddrArray {
 export function equals(l: PgCatalog.Types.MacaddrArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InetArray {
 export function equals(l: PgCatalog.Types.InetArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CidrArray {
 export function equals(l: PgCatalog.Types.CidrArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr8Array {
 export function equals(l: PgCatalog.Types.Macaddr8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AclitemArray {
 export function equals(l: PgCatalog.Types.AclitemArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BpcharArray {
 export function equals(l: PgCatalog.Types.BpcharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace VarcharArray {
 export function equals(l: PgCatalog.Types.VarcharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DateArray {
 export function equals(l: PgCatalog.Types.DateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeArray {
 export function equals(l: PgCatalog.Types.TimeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimestampArray {
 export function equals(l: PgCatalog.Types.TimestampArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimestamptzArray {
 export function equals(l: PgCatalog.Types.TimestamptzArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace IntervalArray {
 export function equals(l: PgCatalog.Types.IntervalArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimetzArray {
 export function equals(l: PgCatalog.Types.TimetzArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BitArray {
 export function equals(l: PgCatalog.Types.BitArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace VarbitArray {
 export function equals(l: PgCatalog.Types.VarbitArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NumericArray {
 export function equals(l: PgCatalog.Types.NumericArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RefcursorArray {
 export function equals(l: PgCatalog.Types.RefcursorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegprocedureArray {
 export function equals(l: PgCatalog.Types.RegprocedureArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegoperArray {
 export function equals(l: PgCatalog.Types.RegoperArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegoperatorArray {
 export function equals(l: PgCatalog.Types.RegoperatorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegclassArray {
 export function equals(l: PgCatalog.Types.RegclassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegcollationArray {
 export function equals(l: PgCatalog.Types.RegcollationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegtypeArray {
 export function equals(l: PgCatalog.Types.RegtypeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegroleArray {
 export function equals(l: PgCatalog.Types.RegroleArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegnamespaceArray {
 export function equals(l: PgCatalog.Types.RegnamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UuidArray {
 export function equals(l: PgCatalog.Types.UuidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLsnArray {
 export function equals(l: PgCatalog.Types.PgLsnArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsvectorArray {
 export function equals(l: PgCatalog.Types.TsvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GtsvectorArray {
 export function equals(l: PgCatalog.Types.GtsvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsqueryArray {
 export function equals(l: PgCatalog.Types.TsqueryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegconfigArray {
 export function equals(l: PgCatalog.Types.RegconfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegdictionaryArray {
 export function equals(l: PgCatalog.Types.RegdictionaryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonbArray {
 export function equals(l: PgCatalog.Types.JsonbArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonpathArray {
 export function equals(l: PgCatalog.Types.JsonpathArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TxidSnapshotArray {
 export function equals(l: PgCatalog.Types.TxidSnapshotArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSnapshotArray {
 export function equals(l: PgCatalog.Types.PgSnapshotArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4rangeArray {
 export function equals(l: PgCatalog.Types.Int4rangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NumrangeArray {
 export function equals(l: PgCatalog.Types.NumrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsrangeArray {
 export function equals(l: PgCatalog.Types.TsrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TstzrangeArray {
 export function equals(l: PgCatalog.Types.TstzrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DaterangeArray {
 export function equals(l: PgCatalog.Types.DaterangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8rangeArray {
 export function equals(l: PgCatalog.Types.Int8rangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4multirangeArray {
 export function equals(l: PgCatalog.Types.Int4multirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NummultirangeArray {
 export function equals(l: PgCatalog.Types.NummultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsmultirangeArray {
 export function equals(l: PgCatalog.Types.TsmultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TstzmultirangeArray {
 export function equals(l: PgCatalog.Types.TstzmultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DatemultirangeArray {
 export function equals(l: PgCatalog.Types.DatemultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8multirangeArray {
 export function equals(l: PgCatalog.Types.Int8multirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CstringArray {
 export function equals(l: PgCatalog.Types.CstringArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdef {
 export function equals(l: PgCatalog.Types.PgAttrdef|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefArray {
 export function equals(l: PgCatalog.Types.PgAttrdefArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraint {
 export function equals(l: PgCatalog.Types.PgConstraint|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintArray {
 export function equals(l: PgCatalog.Types.PgConstraintArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInherits {
 export function equals(l: PgCatalog.Types.PgInherits|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsArray {
 export function equals(l: PgCatalog.Types.PgInheritsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndex {
 export function equals(l: PgCatalog.Types.PgIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexArray {
 export function equals(l: PgCatalog.Types.PgIndexArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperator {
 export function equals(l: PgCatalog.Types.PgOperator|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorArray {
 export function equals(l: PgCatalog.Types.PgOperatorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamily {
 export function equals(l: PgCatalog.Types.PgOpfamily|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyArray {
 export function equals(l: PgCatalog.Types.PgOpfamilyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclass {
 export function equals(l: PgCatalog.Types.PgOpclass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassArray {
 export function equals(l: PgCatalog.Types.PgOpclassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAm {
 export function equals(l: PgCatalog.Types.PgAm|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmArray {
 export function equals(l: PgCatalog.Types.PgAmArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmop {
 export function equals(l: PgCatalog.Types.PgAmop|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopArray {
 export function equals(l: PgCatalog.Types.PgAmopArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmproc {
 export function equals(l: PgCatalog.Types.PgAmproc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocArray {
 export function equals(l: PgCatalog.Types.PgAmprocArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguage {
 export function equals(l: PgCatalog.Types.PgLanguage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageArray {
 export function equals(l: PgCatalog.Types.PgLanguageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadata {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadata|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadataArray {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobject {
 export function equals(l: PgCatalog.Types.PgLargeobject|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectArray {
 export function equals(l: PgCatalog.Types.PgLargeobjectArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregate {
 export function equals(l: PgCatalog.Types.PgAggregate|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregateArray {
 export function equals(l: PgCatalog.Types.PgAggregateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatistic {
 export function equals(l: PgCatalog.Types.PgStatistic|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticArray {
 export function equals(l: PgCatalog.Types.PgStatisticArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExt {
 export function equals(l: PgCatalog.Types.PgStatisticExt|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtArray {
 export function equals(l: PgCatalog.Types.PgStatisticExtArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtData {
 export function equals(l: PgCatalog.Types.PgStatisticExtData|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtDataArray {
 export function equals(l: PgCatalog.Types.PgStatisticExtDataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewrite {
 export function equals(l: PgCatalog.Types.PgRewrite|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteArray {
 export function equals(l: PgCatalog.Types.PgRewriteArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTrigger {
 export function equals(l: PgCatalog.Types.PgTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerArray {
 export function equals(l: PgCatalog.Types.PgTriggerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTrigger {
 export function equals(l: PgCatalog.Types.PgEventTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerArray {
 export function equals(l: PgCatalog.Types.PgEventTriggerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescription {
 export function equals(l: PgCatalog.Types.PgDescription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescriptionArray {
 export function equals(l: PgCatalog.Types.PgDescriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCast {
 export function equals(l: PgCatalog.Types.PgCast|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastArray {
 export function equals(l: PgCatalog.Types.PgCastArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnum {
 export function equals(l: PgCatalog.Types.PgEnum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumArray {
 export function equals(l: PgCatalog.Types.PgEnumArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespace {
 export function equals(l: PgCatalog.Types.PgNamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceArray {
 export function equals(l: PgCatalog.Types.PgNamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversion {
 export function equals(l: PgCatalog.Types.PgConversion|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionArray {
 export function equals(l: PgCatalog.Types.PgConversionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDepend {
 export function equals(l: PgCatalog.Types.PgDepend|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependArray {
 export function equals(l: PgCatalog.Types.PgDependArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabase {
 export function equals(l: PgCatalog.Types.PgDatabase|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseArray {
 export function equals(l: PgCatalog.Types.PgDatabaseArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSetting {
 export function equals(l: PgCatalog.Types.PgDbRoleSetting|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSettingArray {
 export function equals(l: PgCatalog.Types.PgDbRoleSettingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespace {
 export function equals(l: PgCatalog.Types.PgTablespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceArray {
 export function equals(l: PgCatalog.Types.PgTablespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthid {
 export function equals(l: PgCatalog.Types.PgAuthid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidArray {
 export function equals(l: PgCatalog.Types.PgAuthidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembers {
 export function equals(l: PgCatalog.Types.PgAuthMembers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersArray {
 export function equals(l: PgCatalog.Types.PgAuthMembersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdepend {
 export function equals(l: PgCatalog.Types.PgShdepend|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependArray {
 export function equals(l: PgCatalog.Types.PgShdependArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescription {
 export function equals(l: PgCatalog.Types.PgShdescription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescriptionArray {
 export function equals(l: PgCatalog.Types.PgShdescriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfig {
 export function equals(l: PgCatalog.Types.PgTsConfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigArray {
 export function equals(l: PgCatalog.Types.PgTsConfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMap {
 export function equals(l: PgCatalog.Types.PgTsConfigMap|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMapArray {
 export function equals(l: PgCatalog.Types.PgTsConfigMapArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDict {
 export function equals(l: PgCatalog.Types.PgTsDict|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictArray {
 export function equals(l: PgCatalog.Types.PgTsDictArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParser {
 export function equals(l: PgCatalog.Types.PgTsParser|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserArray {
 export function equals(l: PgCatalog.Types.PgTsParserArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplate {
 export function equals(l: PgCatalog.Types.PgTsTemplate|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateArray {
 export function equals(l: PgCatalog.Types.PgTsTemplateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtension {
 export function equals(l: PgCatalog.Types.PgExtension|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionArray {
 export function equals(l: PgCatalog.Types.PgExtensionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapper {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapper|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperArray {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServer {
 export function equals(l: PgCatalog.Types.PgForeignServer|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerArray {
 export function equals(l: PgCatalog.Types.PgForeignServerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMapping {
 export function equals(l: PgCatalog.Types.PgUserMapping|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingArray {
 export function equals(l: PgCatalog.Types.PgUserMappingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTable {
 export function equals(l: PgCatalog.Types.PgForeignTable|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableArray {
 export function equals(l: PgCatalog.Types.PgForeignTableArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicy {
 export function equals(l: PgCatalog.Types.PgPolicy|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyArray {
 export function equals(l: PgCatalog.Types.PgPolicyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOrigin {
 export function equals(l: PgCatalog.Types.PgReplicationOrigin|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginArray {
 export function equals(l: PgCatalog.Types.PgReplicationOriginArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAcl {
 export function equals(l: PgCatalog.Types.PgDefaultAcl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclArray {
 export function equals(l: PgCatalog.Types.PgDefaultAclArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivs {
 export function equals(l: PgCatalog.Types.PgInitPrivs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivsArray {
 export function equals(l: PgCatalog.Types.PgInitPrivsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabel {
 export function equals(l: PgCatalog.Types.PgSeclabel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelArray {
 export function equals(l: PgCatalog.Types.PgSeclabelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabel {
 export function equals(l: PgCatalog.Types.PgShseclabel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabelArray {
 export function equals(l: PgCatalog.Types.PgShseclabelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollation {
 export function equals(l: PgCatalog.Types.PgCollation|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationArray {
 export function equals(l: PgCatalog.Types.PgCollationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAcl {
 export function equals(l: PgCatalog.Types.PgParameterAcl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclArray {
 export function equals(l: PgCatalog.Types.PgParameterAclArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTable {
 export function equals(l: PgCatalog.Types.PgPartitionedTable|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTableArray {
 export function equals(l: PgCatalog.Types.PgPartitionedTableArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRange {
 export function equals(l: PgCatalog.Types.PgRange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeArray {
 export function equals(l: PgCatalog.Types.PgRangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransform {
 export function equals(l: PgCatalog.Types.PgTransform|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformArray {
 export function equals(l: PgCatalog.Types.PgTransformArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequence {
 export function equals(l: PgCatalog.Types.PgSequence|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequenceArray {
 export function equals(l: PgCatalog.Types.PgSequenceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublication {
 export function equals(l: PgCatalog.Types.PgPublication|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationArray {
 export function equals(l: PgCatalog.Types.PgPublicationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespace {
 export function equals(l: PgCatalog.Types.PgPublicationNamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespaceArray {
 export function equals(l: PgCatalog.Types.PgPublicationNamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRel {
 export function equals(l: PgCatalog.Types.PgPublicationRel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelArray {
 export function equals(l: PgCatalog.Types.PgPublicationRelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscription {
 export function equals(l: PgCatalog.Types.PgSubscription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionArray {
 export function equals(l: PgCatalog.Types.PgSubscriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRel {
 export function equals(l: PgCatalog.Types.PgSubscriptionRel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRelArray {
 export function equals(l: PgCatalog.Types.PgSubscriptionRelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRoles {
 export function equals(l: PgCatalog.Types.PgRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRolesArray {
 export function equals(l: PgCatalog.Types.PgRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShadow {
 export function equals(l: PgCatalog.Types.PgShadow|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShadowArray {
 export function equals(l: PgCatalog.Types.PgShadowArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgGroup {
 export function equals(l: PgCatalog.Types.PgGroup|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgGroupArray {
 export function equals(l: PgCatalog.Types.PgGroupArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUser {
 export function equals(l: PgCatalog.Types.PgUser|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserArray {
 export function equals(l: PgCatalog.Types.PgUserArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicies {
 export function equals(l: PgCatalog.Types.PgPolicies|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPoliciesArray {
 export function equals(l: PgCatalog.Types.PgPoliciesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRules {
 export function equals(l: PgCatalog.Types.PgRules|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRulesArray {
 export function equals(l: PgCatalog.Types.PgRulesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgViews {
 export function equals(l: PgCatalog.Types.PgViews|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgViewsArray {
 export function equals(l: PgCatalog.Types.PgViewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTables {
 export function equals(l: PgCatalog.Types.PgTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablesArray {
 export function equals(l: PgCatalog.Types.PgTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMatviews {
 export function equals(l: PgCatalog.Types.PgMatviews|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMatviewsArray {
 export function equals(l: PgCatalog.Types.PgMatviewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexes {
 export function equals(l: PgCatalog.Types.PgIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexesArray {
 export function equals(l: PgCatalog.Types.PgIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequences {
 export function equals(l: PgCatalog.Types.PgSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequencesArray {
 export function equals(l: PgCatalog.Types.PgSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStats {
 export function equals(l: PgCatalog.Types.PgStats|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsArray {
 export function equals(l: PgCatalog.Types.PgStatsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExt {
 export function equals(l: PgCatalog.Types.PgStatsExt|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtArray {
 export function equals(l: PgCatalog.Types.PgStatsExtArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtExprs {
 export function equals(l: PgCatalog.Types.PgStatsExtExprs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtExprsArray {
 export function equals(l: PgCatalog.Types.PgStatsExtExprsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationTables {
 export function equals(l: PgCatalog.Types.PgPublicationTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationTablesArray {
 export function equals(l: PgCatalog.Types.PgPublicationTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLocks {
 export function equals(l: PgCatalog.Types.PgLocks|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLocksArray {
 export function equals(l: PgCatalog.Types.PgLocksArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCursors {
 export function equals(l: PgCatalog.Types.PgCursors|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCursorsArray {
 export function equals(l: PgCatalog.Types.PgCursorsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensions {
 export function equals(l: PgCatalog.Types.PgAvailableExtensions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionsArray {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionVersions {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionVersions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionVersionsArray {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionVersionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedXacts {
 export function equals(l: PgCatalog.Types.PgPreparedXacts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedXactsArray {
 export function equals(l: PgCatalog.Types.PgPreparedXactsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedStatements {
 export function equals(l: PgCatalog.Types.PgPreparedStatements|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedStatementsArray {
 export function equals(l: PgCatalog.Types.PgPreparedStatementsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabels {
 export function equals(l: PgCatalog.Types.PgSeclabels|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelsArray {
 export function equals(l: PgCatalog.Types.PgSeclabelsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSettings {
 export function equals(l: PgCatalog.Types.PgSettings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSettingsArray {
 export function equals(l: PgCatalog.Types.PgSettingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgFileSettings {
 export function equals(l: PgCatalog.Types.PgFileSettings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgFileSettingsArray {
 export function equals(l: PgCatalog.Types.PgFileSettingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgHbaFileRules {
 export function equals(l: PgCatalog.Types.PgHbaFileRules|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgHbaFileRulesArray {
 export function equals(l: PgCatalog.Types.PgHbaFileRulesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIdentFileMappings {
 export function equals(l: PgCatalog.Types.PgIdentFileMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIdentFileMappingsArray {
 export function equals(l: PgCatalog.Types.PgIdentFileMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneAbbrevs {
 export function equals(l: PgCatalog.Types.PgTimezoneAbbrevs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneAbbrevsArray {
 export function equals(l: PgCatalog.Types.PgTimezoneAbbrevsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneNames {
 export function equals(l: PgCatalog.Types.PgTimezoneNames|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneNamesArray {
 export function equals(l: PgCatalog.Types.PgTimezoneNamesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConfig {
 export function equals(l: PgCatalog.Types.PgConfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConfigArray {
 export function equals(l: PgCatalog.Types.PgConfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShmemAllocations {
 export function equals(l: PgCatalog.Types.PgShmemAllocations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShmemAllocationsArray {
 export function equals(l: PgCatalog.Types.PgShmemAllocationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBackendMemoryContexts {
 export function equals(l: PgCatalog.Types.PgBackendMemoryContexts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBackendMemoryContextsArray {
 export function equals(l: PgCatalog.Types.PgBackendMemoryContextsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllTables {
 export function equals(l: PgCatalog.Types.PgStatAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactAllTables {
 export function equals(l: PgCatalog.Types.PgStatXactAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysTables {
 export function equals(l: PgCatalog.Types.PgStatSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactSysTables {
 export function equals(l: PgCatalog.Types.PgStatXactSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserTables {
 export function equals(l: PgCatalog.Types.PgStatUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserTables {
 export function equals(l: PgCatalog.Types.PgStatXactUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllTables {
 export function equals(l: PgCatalog.Types.PgStatioAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysTables {
 export function equals(l: PgCatalog.Types.PgStatioSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserTables {
 export function equals(l: PgCatalog.Types.PgStatioUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllIndexes {
 export function equals(l: PgCatalog.Types.PgStatAllIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatAllIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysIndexes {
 export function equals(l: PgCatalog.Types.PgStatSysIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatSysIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserIndexes {
 export function equals(l: PgCatalog.Types.PgStatUserIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatUserIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllIndexes {
 export function equals(l: PgCatalog.Types.PgStatioAllIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysIndexes {
 export function equals(l: PgCatalog.Types.PgStatioSysIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserIndexes {
 export function equals(l: PgCatalog.Types.PgStatioUserIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllSequences {
 export function equals(l: PgCatalog.Types.PgStatioAllSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysSequences {
 export function equals(l: PgCatalog.Types.PgStatioSysSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserSequences {
 export function equals(l: PgCatalog.Types.PgStatioUserSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatActivity {
 export function equals(l: PgCatalog.Types.PgStatActivity|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatActivityArray {
 export function equals(l: PgCatalog.Types.PgStatActivityArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplication {
 export function equals(l: PgCatalog.Types.PgStatReplication|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationArray {
 export function equals(l: PgCatalog.Types.PgStatReplicationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSlru {
 export function equals(l: PgCatalog.Types.PgStatSlru|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSlruArray {
 export function equals(l: PgCatalog.Types.PgStatSlruArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalReceiver {
 export function equals(l: PgCatalog.Types.PgStatWalReceiver|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalReceiverArray {
 export function equals(l: PgCatalog.Types.PgStatWalReceiverArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatRecoveryPrefetch {
 export function equals(l: PgCatalog.Types.PgStatRecoveryPrefetch|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatRecoveryPrefetchArray {
 export function equals(l: PgCatalog.Types.PgStatRecoveryPrefetchArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscription {
 export function equals(l: PgCatalog.Types.PgStatSubscription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionArray {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSsl {
 export function equals(l: PgCatalog.Types.PgStatSsl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSslArray {
 export function equals(l: PgCatalog.Types.PgStatSslArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatGssapi {
 export function equals(l: PgCatalog.Types.PgStatGssapi|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatGssapiArray {
 export function equals(l: PgCatalog.Types.PgStatGssapiArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationSlots {
 export function equals(l: PgCatalog.Types.PgReplicationSlots|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationSlotsArray {
 export function equals(l: PgCatalog.Types.PgReplicationSlotsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationSlots {
 export function equals(l: PgCatalog.Types.PgStatReplicationSlots|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationSlotsArray {
 export function equals(l: PgCatalog.Types.PgStatReplicationSlotsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabase {
 export function equals(l: PgCatalog.Types.PgStatDatabase|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseArray {
 export function equals(l: PgCatalog.Types.PgStatDatabaseArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseConflicts {
 export function equals(l: PgCatalog.Types.PgStatDatabaseConflicts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseConflictsArray {
 export function equals(l: PgCatalog.Types.PgStatDatabaseConflictsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserFunctions {
 export function equals(l: PgCatalog.Types.PgStatUserFunctions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserFunctionsArray {
 export function equals(l: PgCatalog.Types.PgStatUserFunctionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserFunctions {
 export function equals(l: PgCatalog.Types.PgStatXactUserFunctions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserFunctionsArray {
 export function equals(l: PgCatalog.Types.PgStatXactUserFunctionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatArchiver {
 export function equals(l: PgCatalog.Types.PgStatArchiver|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatArchiverArray {
 export function equals(l: PgCatalog.Types.PgStatArchiverArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatBgwriter {
 export function equals(l: PgCatalog.Types.PgStatBgwriter|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatBgwriterArray {
 export function equals(l: PgCatalog.Types.PgStatBgwriterArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatIo {
 export function equals(l: PgCatalog.Types.PgStatIo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatIoArray {
 export function equals(l: PgCatalog.Types.PgStatIoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWal {
 export function equals(l: PgCatalog.Types.PgStatWal|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalArray {
 export function equals(l: PgCatalog.Types.PgStatWalArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressAnalyze {
 export function equals(l: PgCatalog.Types.PgStatProgressAnalyze|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressAnalyzeArray {
 export function equals(l: PgCatalog.Types.PgStatProgressAnalyzeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressVacuum {
 export function equals(l: PgCatalog.Types.PgStatProgressVacuum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressVacuumArray {
 export function equals(l: PgCatalog.Types.PgStatProgressVacuumArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCluster {
 export function equals(l: PgCatalog.Types.PgStatProgressCluster|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressClusterArray {
 export function equals(l: PgCatalog.Types.PgStatProgressClusterArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCreateIndex {
 export function equals(l: PgCatalog.Types.PgStatProgressCreateIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCreateIndexArray {
 export function equals(l: PgCatalog.Types.PgStatProgressCreateIndexArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressBasebackup {
 export function equals(l: PgCatalog.Types.PgStatProgressBasebackup|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressBasebackupArray {
 export function equals(l: PgCatalog.Types.PgStatProgressBasebackupArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCopy {
 export function equals(l: PgCatalog.Types.PgStatProgressCopy|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCopyArray {
 export function equals(l: PgCatalog.Types.PgStatProgressCopyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappings {
 export function equals(l: PgCatalog.Types.PgUserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingsArray {
 export function equals(l: PgCatalog.Types.PgUserMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginStatus {
 export function equals(l: PgCatalog.Types.PgReplicationOriginStatus|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginStatusArray {
 export function equals(l: PgCatalog.Types.PgReplicationOriginStatusArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionStats {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionStats|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionStatsArray {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionStatsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcOidIndex {
 export function equals(l: PgCatalog.Types.PgProcOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcPronameArgsNspIndex {
 export function equals(l: PgCatalog.Types.PgProcPronameArgsNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeOidIndex {
 export function equals(l: PgCatalog.Types.PgTypeOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeTypnameNspIndex {
 export function equals(l: PgCatalog.Types.PgTypeTypnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeRelidAttnamIndex {
 export function equals(l: PgCatalog.Types.PgAttributeRelidAttnamIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeRelidAttnumIndex {
 export function equals(l: PgCatalog.Types.PgAttributeRelidAttnumIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassOidIndex {
 export function equals(l: PgCatalog.Types.PgClassOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassRelnameNspIndex {
 export function equals(l: PgCatalog.Types.PgClassRelnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassTblspcRelfilenodeIndex {
 export function equals(l: PgCatalog.Types.PgClassTblspcRelfilenodeIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefAdrelidAdnumIndex {
 export function equals(l: PgCatalog.Types.PgAttrdefAdrelidAdnumIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefOidIndex {
 export function equals(l: PgCatalog.Types.PgAttrdefOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConnameNspIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConrelidContypidConnameIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConrelidContypidConnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintContypidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintContypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintOidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConparentidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConparentidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsRelidSeqnoIndex {
 export function equals(l: PgCatalog.Types.PgInheritsRelidSeqnoIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsParentIndex {
 export function equals(l: PgCatalog.Types.PgInheritsParentIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexIndrelidIndex {
 export function equals(l: PgCatalog.Types.PgIndexIndrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexIndexrelidIndex {
 export function equals(l: PgCatalog.Types.PgIndexIndexrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorOidIndex {
 export function equals(l: PgCatalog.Types.PgOperatorOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorOprnameLRNIndex {
 export function equals(l: PgCatalog.Types.PgOperatorOprnameLRNIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyAmNameNspIndex {
 export function equals(l: PgCatalog.Types.PgOpfamilyAmNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyOidIndex {
 export function equals(l: PgCatalog.Types.PgOpfamilyOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassAmNameNspIndex {
 export function equals(l: PgCatalog.Types.PgOpclassAmNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassOidIndex {
 export function equals(l: PgCatalog.Types.PgOpclassOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmNameIndex {
 export function equals(l: PgCatalog.Types.PgAmNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmOidIndex {
 export function equals(l: PgCatalog.Types.PgAmOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopFamStratIndex {
 export function equals(l: PgCatalog.Types.PgAmopFamStratIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopOprFamIndex {
 export function equals(l: PgCatalog.Types.PgAmopOprFamIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopOidIndex {
 export function equals(l: PgCatalog.Types.PgAmopOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocFamProcIndex {
 export function equals(l: PgCatalog.Types.PgAmprocFamProcIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocOidIndex {
 export function equals(l: PgCatalog.Types.PgAmprocOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageNameIndex {
 export function equals(l: PgCatalog.Types.PgLanguageNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageOidIndex {
 export function equals(l: PgCatalog.Types.PgLanguageOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadataOidIndex {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadataOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectLoidPnIndex {
 export function equals(l: PgCatalog.Types.PgLargeobjectLoidPnIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregateFnoidIndex {
 export function equals(l: PgCatalog.Types.PgAggregateFnoidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticRelidAttInhIndex {
 export function equals(l: PgCatalog.Types.PgStatisticRelidAttInhIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtOidIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtNameIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtRelidIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtRelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtDataStxoidInhIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtDataStxoidInhIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteOidIndex {
 export function equals(l: PgCatalog.Types.PgRewriteOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteRelRulenameIndex {
 export function equals(l: PgCatalog.Types.PgRewriteRelRulenameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerTgconstraintIndex {
 export function equals(l: PgCatalog.Types.PgTriggerTgconstraintIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerTgrelidTgnameIndex {
 export function equals(l: PgCatalog.Types.PgTriggerTgrelidTgnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerOidIndex {
 export function equals(l: PgCatalog.Types.PgTriggerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerEvtnameIndex {
 export function equals(l: PgCatalog.Types.PgEventTriggerEvtnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerOidIndex {
 export function equals(l: PgCatalog.Types.PgEventTriggerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescriptionOCOIndex {
 export function equals(l: PgCatalog.Types.PgDescriptionOCOIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastOidIndex {
 export function equals(l: PgCatalog.Types.PgCastOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastSourceTargetIndex {
 export function equals(l: PgCatalog.Types.PgCastSourceTargetIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumOidIndex {
 export function equals(l: PgCatalog.Types.PgEnumOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumTypidLabelIndex {
 export function equals(l: PgCatalog.Types.PgEnumTypidLabelIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumTypidSortorderIndex {
 export function equals(l: PgCatalog.Types.PgEnumTypidSortorderIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceNspnameIndex {
 export function equals(l: PgCatalog.Types.PgNamespaceNspnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgNamespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionDefaultIndex {
 export function equals(l: PgCatalog.Types.PgConversionDefaultIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionNameNspIndex {
 export function equals(l: PgCatalog.Types.PgConversionNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionOidIndex {
 export function equals(l: PgCatalog.Types.PgConversionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependDependerIndex {
 export function equals(l: PgCatalog.Types.PgDependDependerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependReferenceIndex {
 export function equals(l: PgCatalog.Types.PgDependReferenceIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseDatnameIndex {
 export function equals(l: PgCatalog.Types.PgDatabaseDatnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseOidIndex {
 export function equals(l: PgCatalog.Types.PgDatabaseOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSettingDatabaseidRolIndex {
 export function equals(l: PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgTablespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceSpcnameIndex {
 export function equals(l: PgCatalog.Types.PgTablespaceSpcnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidRolnameIndex {
 export function equals(l: PgCatalog.Types.PgAuthidRolnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidOidIndex {
 export function equals(l: PgCatalog.Types.PgAuthidOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersOidIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersRoleMemberIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersRoleMemberIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersMemberRoleIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersMemberRoleIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersGrantorIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersGrantorIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependDependerIndex {
 export function equals(l: PgCatalog.Types.PgShdependDependerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependReferenceIndex {
 export function equals(l: PgCatalog.Types.PgShdependReferenceIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescriptionOCIndex {
 export function equals(l: PgCatalog.Types.PgShdescriptionOCIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigCfgnameIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigCfgnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigOidIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMapIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigMapIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictDictnameIndex {
 export function equals(l: PgCatalog.Types.PgTsDictDictnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictOidIndex {
 export function equals(l: PgCatalog.Types.PgTsDictOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserPrsnameIndex {
 export function equals(l: PgCatalog.Types.PgTsParserPrsnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserOidIndex {
 export function equals(l: PgCatalog.Types.PgTsParserOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateTmplnameIndex {
 export function equals(l: PgCatalog.Types.PgTsTemplateTmplnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateOidIndex {
 export function equals(l: PgCatalog.Types.PgTsTemplateOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionOidIndex {
 export function equals(l: PgCatalog.Types.PgExtensionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionNameIndex {
 export function equals(l: PgCatalog.Types.PgExtensionNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperOidIndex {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperNameIndex {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerOidIndex {
 export function equals(l: PgCatalog.Types.PgForeignServerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerNameIndex {
 export function equals(l: PgCatalog.Types.PgForeignServerNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingOidIndex {
 export function equals(l: PgCatalog.Types.PgUserMappingOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingUserServerIndex {
 export function equals(l: PgCatalog.Types.PgUserMappingUserServerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableRelidIndex {
 export function equals(l: PgCatalog.Types.PgForeignTableRelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyOidIndex {
 export function equals(l: PgCatalog.Types.PgPolicyOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyPolrelidPolnameIndex {
 export function equals(l: PgCatalog.Types.PgPolicyPolrelidPolnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginRoiidentIndex {
 export function equals(l: PgCatalog.Types.PgReplicationOriginRoiidentIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginRonameIndex {
 export function equals(l: PgCatalog.Types.PgReplicationOriginRonameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclRoleNspObjIndex {
 export function equals(l: PgCatalog.Types.PgDefaultAclRoleNspObjIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclOidIndex {
 export function equals(l: PgCatalog.Types.PgDefaultAclOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivsOCOIndex {
 export function equals(l: PgCatalog.Types.PgInitPrivsOCOIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelObjectIndex {
 export function equals(l: PgCatalog.Types.PgSeclabelObjectIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabelObjectIndex {
 export function equals(l: PgCatalog.Types.PgShseclabelObjectIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationNameEncNspIndex {
 export function equals(l: PgCatalog.Types.PgCollationNameEncNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationOidIndex {
 export function equals(l: PgCatalog.Types.PgCollationOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclParnameIndex {
 export function equals(l: PgCatalog.Types.PgParameterAclParnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclOidIndex {
 export function equals(l: PgCatalog.Types.PgParameterAclOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTablePartrelidIndex {
 export function equals(l: PgCatalog.Types.PgPartitionedTablePartrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeRngtypidIndex {
 export function equals(l: PgCatalog.Types.PgRangeRngtypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeRngmultitypidIndex {
 export function equals(l: PgCatalog.Types.PgRangeRngmultitypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformOidIndex {
 export function equals(l: PgCatalog.Types.PgTransformOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformTypeLangIndex {
 export function equals(l: PgCatalog.Types.PgTransformTypeLangIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequenceSeqrelidIndex {
 export function equals(l: PgCatalog.Types.PgSequenceSeqrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationPubnameIndex {
 export function equals(l: PgCatalog.Types.PgPublicationPubnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationNamespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelPrrelidPrpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelPrpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelPrpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionOidIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionSubnameIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionSubnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
}
export namespace PgType {
}
export namespace PgForeignTable {
}
export namespace PgAuthid {
}
export namespace PgStatisticExtData {
}
export namespace PgUserMapping {
}
export namespace PgSubscription {
}
export namespace PgAttribute {
}
export namespace PgProc {
}
export namespace PgClass {
}
export namespace PgAttrdef {
}
export namespace PgConstraint {
}
export namespace PgInherits {
}
export namespace PgIndex {
}
export namespace PgOperator {
}
export namespace PgOpfamily {
}
export namespace PgOpclass {
}
export namespace PgAm {
}
export namespace PgAmop {
}
export namespace PgAmproc {
}
export namespace PgLanguage {
}
export namespace PgLargeobjectMetadata {
}
export namespace PgAggregate {
}
export namespace PgStatisticExt {
}
export namespace PgRewrite {
}
export namespace PgTrigger {
}
export namespace PgEventTrigger {
}
export namespace PgDescription {
}
export namespace PgCast {
}
export namespace PgEnum {
}
export namespace PgNamespace {
}
export namespace PgConversion {
}
export namespace PgDepend {
}
export namespace PgDatabase {
}
export namespace PgDbRoleSetting {
}
export namespace PgTablespace {
}
export namespace PgAuthMembers {
}
export namespace PgShdepend {
}
export namespace PgShdescription {
}
export namespace PgTsConfig {
}
export namespace PgTsConfigMap {
}
export namespace PgTsDict {
}
export namespace PgTsParser {
}
export namespace PgTsTemplate {
}
export namespace PgExtension {
}
export namespace PgForeignDataWrapper {
}
export namespace PgForeignServer {
}
export namespace PgPolicy {
}
export namespace PgReplicationOrigin {
}
export namespace PgDefaultAcl {
}
export namespace PgInitPrivs {
}
export namespace PgSeclabel {
}
export namespace PgShseclabel {
}
export namespace PgCollation {
}
export namespace PgParameterAcl {
}
export namespace PgPartitionedTable {
}
export namespace PgRange {
}
export namespace PgTransform {
}
export namespace PgSequence {
}
export namespace PgPublication {
}
export namespace PgPublicationNamespace {
}
export namespace PgPublicationRel {
}
export namespace PgSubscriptionRel {
}
export namespace PgLargeobject {
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace CardinalNumber {
 export function equals(l: InformationSchema.Types.CardinalNumber|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CardinalNumberArray {
 export function equals(l: InformationSchema.Types.CardinalNumberArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterData {
 export function equals(l: InformationSchema.Types.CharacterData|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterDataArray {
 export function equals(l: InformationSchema.Types.CharacterDataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlIdentifier {
 export function equals(l: InformationSchema.Types.SqlIdentifier|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlIdentifierArray {
 export function equals(l: InformationSchema.Types.SqlIdentifierArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InformationSchemaCatalogName {
 export function equals(l: InformationSchema.Types.InformationSchemaCatalogName|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InformationSchemaCatalogNameArray {
 export function equals(l: InformationSchema.Types.InformationSchemaCatalogNameArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeStamp {
 export function equals(l: InformationSchema.Types.TimeStamp|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeStampArray {
 export function equals(l: InformationSchema.Types.TimeStampArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace YesOrNo {
 export function equals(l: InformationSchema.Types.YesOrNo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace YesOrNoArray {
 export function equals(l: InformationSchema.Types.YesOrNoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ApplicableRoles {
 export function equals(l: InformationSchema.Types.ApplicableRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ApplicableRolesArray {
 export function equals(l: InformationSchema.Types.ApplicableRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AdministrableRoleAuthorizations {
 export function equals(l: InformationSchema.Types.AdministrableRoleAuthorizations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AdministrableRoleAuthorizationsArray {
 export function equals(l: InformationSchema.Types.AdministrableRoleAuthorizationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Attributes {
 export function equals(l: InformationSchema.Types.Attributes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AttributesArray {
 export function equals(l: InformationSchema.Types.AttributesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterSets {
 export function equals(l: InformationSchema.Types.CharacterSets|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterSetsArray {
 export function equals(l: InformationSchema.Types.CharacterSetsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintRoutineUsage {
 export function equals(l: InformationSchema.Types.CheckConstraintRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintRoutineUsageArray {
 export function equals(l: InformationSchema.Types.CheckConstraintRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraints {
 export function equals(l: InformationSchema.Types.CheckConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintsArray {
 export function equals(l: InformationSchema.Types.CheckConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Collations {
 export function equals(l: InformationSchema.Types.Collations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationsArray {
 export function equals(l: InformationSchema.Types.CollationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationCharacterSetApplicability {
 export function equals(l: InformationSchema.Types.CollationCharacterSetApplicability|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationCharacterSetApplicabilityArray {
 export function equals(l: InformationSchema.Types.CollationCharacterSetApplicabilityArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnColumnUsage {
 export function equals(l: InformationSchema.Types.ColumnColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnColumnUsageArray {
 export function equals(l: InformationSchema.Types.ColumnColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnDomainUsage {
 export function equals(l: InformationSchema.Types.ColumnDomainUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnDomainUsageArray {
 export function equals(l: InformationSchema.Types.ColumnDomainUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnPrivileges {
 export function equals(l: InformationSchema.Types.ColumnPrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnPrivilegesArray {
 export function equals(l: InformationSchema.Types.ColumnPrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnUdtUsage {
 export function equals(l: InformationSchema.Types.ColumnUdtUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnUdtUsageArray {
 export function equals(l: InformationSchema.Types.ColumnUdtUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Columns {
 export function equals(l: InformationSchema.Types.Columns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnsArray {
 export function equals(l: InformationSchema.Types.ColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintColumnUsage {
 export function equals(l: InformationSchema.Types.ConstraintColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintColumnUsageArray {
 export function equals(l: InformationSchema.Types.ConstraintColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintTableUsage {
 export function equals(l: InformationSchema.Types.ConstraintTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintTableUsageArray {
 export function equals(l: InformationSchema.Types.ConstraintTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainConstraints {
 export function equals(l: InformationSchema.Types.DomainConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainConstraintsArray {
 export function equals(l: InformationSchema.Types.DomainConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainUdtUsage {
 export function equals(l: InformationSchema.Types.DomainUdtUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainUdtUsageArray {
 export function equals(l: InformationSchema.Types.DomainUdtUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Domains {
 export function equals(l: InformationSchema.Types.Domains|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainsArray {
 export function equals(l: InformationSchema.Types.DomainsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EnabledRoles {
 export function equals(l: InformationSchema.Types.EnabledRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EnabledRolesArray {
 export function equals(l: InformationSchema.Types.EnabledRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace KeyColumnUsage {
 export function equals(l: InformationSchema.Types.KeyColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace KeyColumnUsageArray {
 export function equals(l: InformationSchema.Types.KeyColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Parameters {
 export function equals(l: InformationSchema.Types.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ParametersArray {
 export function equals(l: InformationSchema.Types.ParametersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ReferentialConstraints {
 export function equals(l: InformationSchema.Types.ReferentialConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ReferentialConstraintsArray {
 export function equals(l: InformationSchema.Types.ReferentialConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleColumnGrants {
 export function equals(l: InformationSchema.Types.RoleColumnGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleColumnGrantsArray {
 export function equals(l: InformationSchema.Types.RoleColumnGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineColumnUsage {
 export function equals(l: InformationSchema.Types.RoutineColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineColumnUsageArray {
 export function equals(l: InformationSchema.Types.RoutineColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinePrivileges {
 export function equals(l: InformationSchema.Types.RoutinePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinePrivilegesArray {
 export function equals(l: InformationSchema.Types.RoutinePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleRoutineGrants {
 export function equals(l: InformationSchema.Types.RoleRoutineGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleRoutineGrantsArray {
 export function equals(l: InformationSchema.Types.RoleRoutineGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineRoutineUsage {
 export function equals(l: InformationSchema.Types.RoutineRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineRoutineUsageArray {
 export function equals(l: InformationSchema.Types.RoutineRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineSequenceUsage {
 export function equals(l: InformationSchema.Types.RoutineSequenceUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineSequenceUsageArray {
 export function equals(l: InformationSchema.Types.RoutineSequenceUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineTableUsage {
 export function equals(l: InformationSchema.Types.RoutineTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineTableUsageArray {
 export function equals(l: InformationSchema.Types.RoutineTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Routines {
 export function equals(l: InformationSchema.Types.Routines|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinesArray {
 export function equals(l: InformationSchema.Types.RoutinesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Schemata {
 export function equals(l: InformationSchema.Types.Schemata|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SchemataArray {
 export function equals(l: InformationSchema.Types.SchemataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Sequences {
 export function equals(l: InformationSchema.Types.Sequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SequencesArray {
 export function equals(l: InformationSchema.Types.SequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlFeatures {
 export function equals(l: InformationSchema.Types.SqlFeatures|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlFeaturesArray {
 export function equals(l: InformationSchema.Types.SqlFeaturesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlImplementationInfo {
 export function equals(l: InformationSchema.Types.SqlImplementationInfo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlImplementationInfoArray {
 export function equals(l: InformationSchema.Types.SqlImplementationInfoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlParts {
 export function equals(l: InformationSchema.Types.SqlParts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlPartsArray {
 export function equals(l: InformationSchema.Types.SqlPartsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlSizing {
 export function equals(l: InformationSchema.Types.SqlSizing|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlSizingArray {
 export function equals(l: InformationSchema.Types.SqlSizingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableConstraints {
 export function equals(l: InformationSchema.Types.TableConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableConstraintsArray {
 export function equals(l: InformationSchema.Types.TableConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablePrivileges {
 export function equals(l: InformationSchema.Types.TablePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablePrivilegesArray {
 export function equals(l: InformationSchema.Types.TablePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleTableGrants {
 export function equals(l: InformationSchema.Types.RoleTableGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleTableGrantsArray {
 export function equals(l: InformationSchema.Types.RoleTableGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tables {
 export function equals(l: InformationSchema.Types.Tables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablesArray {
 export function equals(l: InformationSchema.Types.TablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Transforms {
 export function equals(l: InformationSchema.Types.Transforms|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TransformsArray {
 export function equals(l: InformationSchema.Types.TransformsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggeredUpdateColumns {
 export function equals(l: InformationSchema.Types.TriggeredUpdateColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggeredUpdateColumnsArray {
 export function equals(l: InformationSchema.Types.TriggeredUpdateColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Triggers {
 export function equals(l: InformationSchema.Types.Triggers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggersArray {
 export function equals(l: InformationSchema.Types.TriggersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UdtPrivileges {
 export function equals(l: InformationSchema.Types.UdtPrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UdtPrivilegesArray {
 export function equals(l: InformationSchema.Types.UdtPrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUdtGrants {
 export function equals(l: InformationSchema.Types.RoleUdtGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUdtGrantsArray {
 export function equals(l: InformationSchema.Types.RoleUdtGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UsagePrivileges {
 export function equals(l: InformationSchema.Types.UsagePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UsagePrivilegesArray {
 export function equals(l: InformationSchema.Types.UsagePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUsageGrants {
 export function equals(l: InformationSchema.Types.RoleUsageGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUsageGrantsArray {
 export function equals(l: InformationSchema.Types.RoleUsageGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserDefinedTypes {
 export function equals(l: InformationSchema.Types.UserDefinedTypes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserDefinedTypesArray {
 export function equals(l: InformationSchema.Types.UserDefinedTypesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewColumnUsage {
 export function equals(l: InformationSchema.Types.ViewColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewColumnUsageArray {
 export function equals(l: InformationSchema.Types.ViewColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewRoutineUsage {
 export function equals(l: InformationSchema.Types.ViewRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewRoutineUsageArray {
 export function equals(l: InformationSchema.Types.ViewRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewTableUsage {
 export function equals(l: InformationSchema.Types.ViewTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewTableUsageArray {
 export function equals(l: InformationSchema.Types.ViewTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Views {
 export function equals(l: InformationSchema.Types.Views|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewsArray {
 export function equals(l: InformationSchema.Types.ViewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DataTypePrivileges {
 export function equals(l: InformationSchema.Types.DataTypePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DataTypePrivilegesArray {
 export function equals(l: InformationSchema.Types.DataTypePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ElementTypes {
 export function equals(l: InformationSchema.Types.ElementTypes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ElementTypesArray {
 export function equals(l: InformationSchema.Types.ElementTypesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableColumns {
 export function equals(l: InformationSchema.Types.PgForeignTableColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnOptions {
 export function equals(l: InformationSchema.Types.ColumnOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnOptionsArray {
 export function equals(l: InformationSchema.Types.ColumnOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrappers {
 export function equals(l: InformationSchema.Types.PgForeignDataWrappers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrapperOptions {
 export function equals(l: InformationSchema.Types.ForeignDataWrapperOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrapperOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignDataWrapperOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrappers {
 export function equals(l: InformationSchema.Types.ForeignDataWrappers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrappersArray {
 export function equals(l: InformationSchema.Types.ForeignDataWrappersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServers {
 export function equals(l: InformationSchema.Types.PgForeignServers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServerOptions {
 export function equals(l: InformationSchema.Types.ForeignServerOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServerOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignServerOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServers {
 export function equals(l: InformationSchema.Types.ForeignServers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServersArray {
 export function equals(l: InformationSchema.Types.ForeignServersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTables {
 export function equals(l: InformationSchema.Types.PgForeignTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTableOptions {
 export function equals(l: InformationSchema.Types.ForeignTableOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTableOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignTableOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTables {
 export function equals(l: InformationSchema.Types.ForeignTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTablesArray {
 export function equals(l: InformationSchema.Types.ForeignTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappings {
 export function equals(l: InformationSchema.Types.PgUserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingOptions {
 export function equals(l: InformationSchema.Types.UserMappingOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingOptionsArray {
 export function equals(l: InformationSchema.Types.UserMappingOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappings {
 export function equals(l: InformationSchema.Types.UserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingsArray {
 export function equals(l: InformationSchema.Types.UserMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
}
export namespace SqlImplementationInfo {
}
export namespace SqlParts {
}
export namespace SqlSizing {
}
}
}
export namespace Public {
export namespace Types {
export namespace Spheroid {
 export function equals(l: Public.Types.Spheroid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpheroidArray {
 export function equals(l: Public.Types.SpheroidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Geometry {
 export function equals(l: Public.Types.Geometry|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryArray {
 export function equals(l: Public.Types.GeometryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box3d {
 export function equals(l: Public.Types.Box3d|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box3dArray {
 export function equals(l: Public.Types.Box3dArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2d {
 export function equals(l: Public.Types.Box2d|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2dArray {
 export function equals(l: Public.Types.Box2dArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2df {
 export function equals(l: Public.Types.Box2df|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2dfArray {
 export function equals(l: Public.Types.Box2dfArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Gidx {
 export function equals(l: Public.Types.Gidx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GidxArray {
 export function equals(l: Public.Types.GidxArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryDump {
 export function equals(l: Public.Types.GeometryDump|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryDumpArray {
 export function equals(l: Public.Types.GeometryDumpArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSys {
 export function equals(l: Public.Types.SpatialRefSys|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSysArray {
 export function equals(l: Public.Types.SpatialRefSysArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ValidDetail {
 export function equals(l: Public.Types.ValidDetail|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ValidDetailArray {
 export function equals(l: Public.Types.ValidDetailArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Geography {
 export function equals(l: Public.Types.Geography|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyArray {
 export function equals(l: Public.Types.GeographyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyColumns {
 export function equals(l: Public.Types.GeographyColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyColumnsArray {
 export function equals(l: Public.Types.GeographyColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryColumns {
 export function equals(l: Public.Types.GeometryColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryColumnsArray {
 export function equals(l: Public.Types.GeometryColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocks {
 export function equals(l: Public.Types.NycCensusBlocks|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksArray {
 export function equals(l: Public.Types.NycCensusBlocksArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicides {
 export function equals(l: Public.Types.NycHomicides|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesArray {
 export function equals(l: Public.Types.NycHomicidesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoods {
 export function equals(l: Public.Types.NycNeighborhoods|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsArray {
 export function equals(l: Public.Types.NycNeighborhoodsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreets {
 export function equals(l: Public.Types.NycStreets|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsArray {
 export function equals(l: Public.Types.NycStreetsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStations {
 export function equals(l: Public.Types.NycSubwayStations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsArray {
 export function equals(l: Public.Types.NycSubwayStationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSysPkey {
 export function equals(l: Public.Types.SpatialRefSysPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksPkey {
 export function equals(l: Public.Types.NycCensusBlocksPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesPkey {
 export function equals(l: Public.Types.NycHomicidesPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsPkey {
 export function equals(l: Public.Types.NycNeighborhoodsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsPkey {
 export function equals(l: Public.Types.NycStreetsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsPkey {
 export function equals(l: Public.Types.NycSubwayStationsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksGeomIdx {
 export function equals(l: Public.Types.NycCensusBlocksGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesGeomIdx {
 export function equals(l: Public.Types.NycHomicidesGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsGeomIdx {
 export function equals(l: Public.Types.NycNeighborhoodsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsGeomIdx {
 export function equals(l: Public.Types.NycStreetsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsGeomIdx {
 export function equals(l: Public.Types.NycSubwayStationsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrs {
 export function equals(l: Public.Types.PostgisSrs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrsAll {
 export function equals(l: Public.Types.PostgisSrsAll|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrsSearch {
 export function equals(l: Public.Types.PostgisSrsSearch|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StMinimumboundingradius {
 export function equals(l: Public.Types.StMinimumboundingradius|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StMaximuminscribedcircle {
 export function equals(l: Public.Types.StMaximuminscribedcircle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StLargestemptycircle {
 export function equals(l: Public.Types.StLargestemptycircle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StHexagongrid {
 export function equals(l: Public.Types.StHexagongrid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StSquaregrid {
 export function equals(l: Public.Types.StSquaregrid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcepolygoncw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace SpheroidIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.SpheroidIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace SpheroidOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.SpheroidOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryTypmodIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryTypmodIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryTypmodOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryTypmodOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryAnalyze {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryAnalyze.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryRecv {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryRecv.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySend {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_4946 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_4946.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_8997 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_8997.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Point {
export namespace Parameters {
 export function equals(l: Public.Procedures.Point.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryB0d8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryB0d8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Path {
export namespace Parameters {
 export function equals(l: Public.Procedures.Path.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryF1be {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryF1be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Polygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.Polygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StX {
export namespace Parameters {
 export function equals(l: Public.Procedures.StX.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StY {
export namespace Parameters {
 export function equals(l: Public.Procedures.StY.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZ {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZ.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StM {
export namespace Parameters {
 export function equals(l: Public.Procedures.StM.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dfIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dfIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dfOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dfOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GidxIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GidxIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GidxOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GidxOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryEq {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryEq.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryCmp {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryCmp.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySortsupport {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySortsupport.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryHash {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryHash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDistance_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDistance_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistCompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistCompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPenalty_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPenalty_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPicksplit_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPicksplit_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistUnion_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistUnion_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSame_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSame_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDecompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDecompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSortsupport_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSortsupport_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcerhr {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcerhr.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisNoop {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisNoop.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcepolygonccw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcepolygonccw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistSel_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistSel_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistSelNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistSelNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistJoinsel_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistJoinsel_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistJoinselNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistJoinselNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySame {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySame.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCentroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCentroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceBox {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceBox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContains {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContains.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryWithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryWithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLeft {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLeft.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverleft {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverleft.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryBelow {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryBelow.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverbelow {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverbelow.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverright {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverright.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryRight {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryRight.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverabove {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverabove.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryAbove {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryAbove.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPenaltyNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPenaltyNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistUnionNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistUnionNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSameNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSameNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDecompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDecompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlapsNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlapsNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContainsNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContainsNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryWithinNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryWithinNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySameNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySameNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCentroidNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCentroidNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCpa {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCpa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDistanceNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDistanceNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShiftlongitude {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShiftlongitude.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWrapx {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWrapx.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StXmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StXmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StYmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StYmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StXmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StXmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StYmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StYmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_3044 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_3044.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_3ea7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_3ea7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisGetbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisGetbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakebox2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakebox2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextentD2f5 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextentD2f5.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextent_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextent_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextent_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextent_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFindextent_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFindextent_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFindextent_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFindextent_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisAddbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisAddbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisDropbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisDropbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisHasbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisHasbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StQuantizecoordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StQuantizecoordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMemsize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMemsize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSummary_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSummary_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNrings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNrings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlength {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlength.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthspheroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthspheroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength2dspheroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength2dspheroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dperimeter {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dperimeter.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeter2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeter2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeter_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeter_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StArea2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StArea2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StArea_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StArea_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIspolygoncw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIspolygoncw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIspolygonccw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIspolygonccw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancespheroid_0cb2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancespheroid_0cb2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancespheroidEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancespheroidEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistanceEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistanceEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointinsidecircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointinsidecircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAzimuthEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAzimuthEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProject_2077 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProject_2077.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProjectE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProjectE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAngleA4a1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAngleA4a1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineextend {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineextend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3dz {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3dz.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3dm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3dm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce4d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce4d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcecollection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcecollection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionextractEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionextractEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionextract_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionextract_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionhomogenize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionhomogenize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMulti {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMulti.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcecurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcecurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcesfs_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcesfs_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcesfsF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcesfsF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_95d4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_95d4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpandF49e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpandF49e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpandDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpandDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpandBf72 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpandBf72.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEnvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEnvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBoundingdiagonal {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBoundingdiagonal.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StReverse {
export namespace Parameters {
 export function equals(l: Public.Procedures.StReverse.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScroll {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScroll.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisGeosNoop {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisGeosNoop.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNormalize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNormalize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmflag {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmflag.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNdims {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNdims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewktEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewktEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstwkb_8607 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstwkb_8607.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstwkb_1445 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstwkb_1445.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkb_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkb_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAshexewkb_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAshexewkb_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAshexewkbF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAshexewkbF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkbF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkbF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAslatlontext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAslatlontext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geomfromewkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geomfromewkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromewkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromewkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geomfromewkt {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geomfromewkt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromewkt {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromewkt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisCacheBbox {
}
export namespace StMakepoint_0aec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_0aec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepoint_81ec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_81ec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepoint_570b {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_570b.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepointm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepointm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dmakebox {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dmakebox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakelineF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakelineF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefrommultipoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefrommultipoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakelineEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakelineEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddpointEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddpointEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_2077 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_2077.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddpointCc0f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddpointCc0f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRemovepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRemovepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakeenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakeenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTileenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTileenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepolygon_0543 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepolygon_0543.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepolygon_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepolygon_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuildarea {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuildarea.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonizeF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonizeF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClusterintersectingF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClusterintersectingF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClusterwithin_2892 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClusterwithin_2892.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinemerge_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinemerge_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinemergeCad2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinemergeCad2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAffineA659 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAffineA659.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAffine_0997 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAffine_0997.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotateDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotateDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotate_6aac {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotate_6aac.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotate_8af1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotate_8af1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatez {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatez.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatex {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatex.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatey {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatey.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTranslate_6aac {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTranslate_6aac.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTranslate_2077 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTranslate_2077.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScaleEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScaleEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_8af1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_8af1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_6aac {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_6aac.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransscale {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransscale.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDump {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDump.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumprings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumprings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumppoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumppoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumpsegments {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumpsegments.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Parameters {
 export function equals(l: Public.Procedures.PopulateGeometryColumns_23fc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PopulateGeometryColumns_4174.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_8fbb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_4617 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_4617.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_093c {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_093c.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrycolumn_0412.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrycolumn_2253.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrycolumnF11a {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrycolumnF11a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrytable_2253 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrytable_2253.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSegmentizeDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSegmentizeDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrytableF11a {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrytableF11a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrytableBfde {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrytableBfde.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace UpdategeometrysridB2ee {
export namespace Parameters {
 export function equals(l: Public.Procedures.UpdategeometrysridB2ee.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Updategeometrysrid_7b58 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Updategeometrysrid_7b58.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Updategeometrysrid_11c8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Updategeometrysrid_11c8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace FindSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.FindSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GetProj4FromSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.GetProj4FromSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetsridEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetsridEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSrid_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSrid_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTransformGeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTransformGeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrsCodes {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrsCodes.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrs {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrs.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrsAll {
}
export namespace PostgisSrsSearch {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrsSearch.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransformEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransformEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransformF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransformF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransformEfe6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransformEfe6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransform_3ad9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransform_3ad9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTransformPipelineGeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransformpipeline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransformpipeline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInversetransformpipeline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInversetransformpipeline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisVersion {
}
export namespace PostgisLiblwgeomVersion {
}
export namespace PostgisProjVersion {
}
export namespace PostgisWagyuVersion {
}
export namespace PostgisScriptsInstalled {
}
export namespace PostgisLibVersion {
}
export namespace PostgisScriptsReleased {
}
export namespace PostgisGeosVersion {
}
export namespace PostgisGeosCompiledVersion {
}
export namespace PostgisLibRevision {
}
export namespace PostgisSvnVersion {
}
export namespace PostgisLibxmlVersion {
}
export namespace PostgisScriptsBuildDate {
}
export namespace PostgisLibBuildDate {
}
export namespace PostgisExtensionsUpgrade {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisExtensionsUpgrade.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoints_1c13 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoints_1c13.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstring_2077 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstring_2077.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepointEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepointEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddmeasure {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddmeasure.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpointofapproach {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpointofapproach.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisFullVersion {
}
export namespace Box2d_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2d_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3d_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3d_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2d_8784 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2d_8784.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dF5fa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dF5fa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box_8784 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box_8784.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Text {
export namespace Parameters {
 export function equals(l: Public.Procedures.Text.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dtobox {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dtobox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryF5fa {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryF5fa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_8784 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_8784.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Bytea_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Bytea_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifyDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifyDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplify_1c13 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplify_1c13.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifyvw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifyvw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSeteffectivearea {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSeteffectivearea.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFilterbym {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFilterbym.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StChaikinsmoothing {
export namespace Parameters {
 export function equals(l: Public.Procedures.StChaikinsmoothing.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogridBf72 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogridBf72.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogrid_2077 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogrid_2077.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogridDeb6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogridDeb6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogrid_7713 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogrid_7713.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancecpa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancecpa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCpawithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCpawithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidtrajectory {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidtrajectory.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectionE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectionE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferDcba {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferDcba.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_3222 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_3222.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumboundingradius {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumboundingradius.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumboundingcircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumboundingcircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOrientedenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOrientedenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOffsetcurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOffsetcurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeneratepointsEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeneratepointsEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeneratepointsA8be {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeneratepointsA8be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StConvexhull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StConvexhull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifypreservetopology {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifypreservetopology.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidreason_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidreason_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvaliddetail {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvaliddetail.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidreasonEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidreasonEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHausdorffdistanceEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHausdorffdistanceEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHausdorffdistanceE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHausdorffdistanceE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFrechetdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFrechetdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMaximuminscribedcircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMaximuminscribedcircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLargestemptycircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLargestemptycircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBoundary {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBoundary.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSymdifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSymdifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSymmetricdifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSymmetricdifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnionEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnionEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnionE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnionE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnaryunion {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnaryunion.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRemoverepeatedpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRemoverepeatedpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClipbybox2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClipbybox2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSubdivide {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSubdivide.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StReduceprecision {
export namespace Parameters {
 export function equals(l: Public.Procedures.StReduceprecision.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakevalid_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakevalid_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakevalidF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakevalidF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCleangeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCleangeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSplit {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSplit.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSharedpaths {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSharedpaths.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnap {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnap.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelatematch {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelatematch.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNode {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNode.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDelaunaytriangles {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDelaunaytriangles.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTriangulatepolygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTriangulatepolygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StVoronoipolygons {
export namespace Parameters {
 export function equals(l: Public.Procedures.StVoronoipolygons.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StVoronoilines {
export namespace Parameters {
 export function equals(l: Public.Procedures.StVoronoilines.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebbox_2c84 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebbox_2c84.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebboxEe61 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebboxEe61.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebbox_7c5a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebbox_7c5a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfnE941 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfnE941.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfnDd3f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfn_0a1f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryCollectFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryMakelineFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelTransfnE941 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelTransfnDd3f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnionF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnionF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoverageunionF393 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoverageunionF393.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelateEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelateEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelateCc0f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelateCc0f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelate_6458 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelate_6458.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDisjoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDisjoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisIndexSupportfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisIndexSupportfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinecrossingdirection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinecrossingdirection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithinE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithinE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTouches {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTouches.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectsEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectsEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCrosses {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCrosses.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StContains {
export namespace Parameters {
 export function equals(l: Public.Procedures.StContains.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StContainsproperly {
export namespace Parameters {
 export function equals(l: Public.Procedures.StContainsproperly.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoversEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoversEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredbyEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredbyEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDfullywithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDfullywithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddwithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddwithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddfullywithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddfullywithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dintersects {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dintersects.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOrderingequals {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOrderingequals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEquals {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEquals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalid_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalid_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumclearance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumclearance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumclearanceline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumclearanceline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroid_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroid_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometricmedian {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometricmedian.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointonsurface {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointonsurface.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIssimple {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIssimple.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIscollection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIscollection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Equals {
export namespace Parameters {
 export function equals(l: Public.Procedures.Equals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgml_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgml_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGmltosqlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGmltosqlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGmltosql_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGmltosql_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromkml {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromkml.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfrommarc21 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfrommarc21.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsmarc21 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsmarc21.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojsonE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojsonE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojson_608f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojson_608f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojson_3c9d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisLibjsonVersion {
}
export namespace StLinefromencodedpolyline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromencodedpolyline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsencodedpolyline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsencodedpolyline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvgA8be {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvgA8be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlA8be {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlA8be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgml_2621 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgml_2621.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskmlE3da {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskmlE3da.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonA8be {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonA8be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonF2c6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonF2c6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Json {
export namespace Parameters {
 export function equals(l: Public.Procedures.Json.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Jsonb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Jsonb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_27f4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfnF57f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_92c1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfnF5be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtCombinefn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtCombinefn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtSerialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtSerialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtDeserialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtDeserialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsmvtgeom {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsmvtgeom.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisLibprotobufVersion {
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsgeobufFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFromflatgeobuftotable {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFromflatgeobuftotable.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFromflatgeobuf {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFromflatgeobuf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeohashEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeohashEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBox2dfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBox2dfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumgeometries {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumgeometries.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDimension {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDimension.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExteriorring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExteriorring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNuminteriorrings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNuminteriorrings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNuminteriorring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNuminteriorring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInteriorringn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInteriorringn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometrytype_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometrytype_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometrytype {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometrytype.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumpatches {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumpatches.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPatchn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPatchn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StStartpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StStartpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEndpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEndpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsclosed {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsclosed.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsempty {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsempty.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinaryF1e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinaryF1e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstextEd82 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstextEd82.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWkttosql {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWkttosql.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinestringfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinestringfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinestringfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolygonfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolygonfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolygonfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinestringfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinestringfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinestringfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyAnalyze {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyAnalyze.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinefromwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinefromwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMaxdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMaxdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpointEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpointEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestlineEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestlineEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLongestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLongestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSwapordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSwapordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFlipcoordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFlipcoordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBdpolyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBdpolyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBdmpolyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBdmpolyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Unlockrows {
export namespace Parameters {
 export function equals(l: Public.Procedures.Unlockrows.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_675a {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_675a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Bytea_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.Bytea_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_75a2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_75a2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace LockrowE9aa {
export namespace Parameters {
 export function equals(l: Public.Procedures.LockrowE9aa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_02b4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_02b4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_9a8a {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_9a8a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addauth {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addauth.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauth_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Checkauth_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauth_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Checkauth_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauthtrigger {
}
export namespace Gettransactionid {
}
export namespace Enablelongtransactions {
}
export namespace Longtransactionsenabled {
}
export namespace Disablelongtransactions {
}
export namespace GeographyTypmodIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyTypmodIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyTypmodOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyTypmodOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyRecv {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyRecv.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySend {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeographyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeographyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeogfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeogfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeogfromwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeogfromwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodDims {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodDims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodType {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodType.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_0faa {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_0faa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistConsistent {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistConsistent.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistCompress {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistCompress.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistPenalty {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistPenalty.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistPicksplit {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistPicksplit.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistUnion {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistUnion.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistSame {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistSame.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistDecompress {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistDecompress.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyDistanceKnn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyDistanceKnn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistDistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistDistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeog_5a37 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeog_5a37.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeogBd57 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeogBd57.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeog_1597 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeog_1597.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeogBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeogBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyLt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyLt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyLe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyLe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyEq {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyEq.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyCmp {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyCmp.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvg_8ddb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvg_8ddb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvgE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvgE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProjectE61a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProjectE61a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAzimuthA587 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAzimuthA587.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_49f7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_49f7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlCe11 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlCe11.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgml_98d7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgml_98d7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskml_48da {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskml_48da.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojson_8ddb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojson_8ddb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistance_89b8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistance_89b8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistance_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistance_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAreaAc0a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAreaAc0a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAreaE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAreaE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthAc0a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthAc0a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProject_665e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProject_665e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeterAc0a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeterAc0a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSegmentize_772c {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSegmentize_772c.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinaryF815 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinaryF815.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_75a2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_75a2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewktE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewktE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometrytype_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometrytype_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSummary_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSummary_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeohash_75a2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeohash_75a2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSrid_38ca {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSrid_38ca.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetsrid_75a2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetsrid_75a2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroidAc0a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroidAc0a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroidE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroidE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoversA587 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoversA587.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithin_5395 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithin_5395.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredbyA587 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredbyA587.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectsA587 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectsA587.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_772c {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_772c.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_2117 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_2117.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_3a01 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_3a01.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferF7c6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferF7c6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectionA587 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectionA587.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersection_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersection_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCovers_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCovers_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredby_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredby_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithinEfc0 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithinEfc0.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersects_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersects_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpoint_89b8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpoint_89b8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpoint_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpoint_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestline_89b8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestline_89b8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestline_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestline_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstring_665e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstring_665e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstringE586 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstringE586.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepoint_89b8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepoint_89b8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepoint_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoints_5d11 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoints_5d11.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointsC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointsC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointCee3 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointCee3.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancesphereEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancesphereEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancesphereE059 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancesphereE059.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypeName {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypeName.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintDims {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintDims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintType {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintType.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dmaxdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dmaxdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dclosestpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dclosestpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dshortestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dshortestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlongestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlongestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoorddim {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoorddim.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCurvetoline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCurvetoline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHasarc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHasarc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinetocurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinetocurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoint_0aec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoint_0aec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoint_0b7f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoint_0b7f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointz {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointz.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointzm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointzm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWkbtosql {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWkbtosql.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatebetween {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatebetween.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatealong {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatealong.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatebetweenelevations {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatebetweenelevations.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInterpolatepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInterpolatepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHexagon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHexagon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSquare {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSquare.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHexagongrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHexagongrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSquaregrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSquaregrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2dD703 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2dD703.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2dD703 {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2dD703.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2dD703 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2dD703.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2d_1585 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2d_1585.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2d_1585 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2d_1585.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2d_1585 {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2d_1585.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2d_3f94 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2d_3f94.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2d_3f94 {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2d_3f94.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2d_3f94 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2d_3f94.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNd_44c4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNd_44c4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNdBd57 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNdBd57.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNd_19dd {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNd_19dd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom2dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom3dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom4dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifypolygonhull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifypolygonhull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StConcavehull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StConcavehull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsx3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsx3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAngleEb6a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAngleEb6a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlineinterpolatepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlineinterpolatepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfig_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfig_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChoose_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChoose_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplit_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlaps_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlaps_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContains_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContains_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContained_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContained_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySame_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySame_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfig_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfig_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChoose_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChoose_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplit_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompress_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompress_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfigNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfigNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChooseNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChooseNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistConfigNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistConfigNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistChooseNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistChooseNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistInnerConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistLeafConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLetters {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLetters.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
}
export namespace NycCensusBlocks {
}
export namespace NycHomicides {
}
export namespace NycNeighborhoods {
}
export namespace NycStreets {
}
export namespace NycSubwayStations {
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_49556Index {
 export function equals(l: PgToast.Types.PgToast_49556Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_50314Index {
 export function equals(l: PgToast.Types.PgToast_50314Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_50320Index {
 export function equals(l: PgToast.Types.PgToast_50320Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1255Index {
 export function equals(l: PgToast.Types.PgToast_1255Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1247Index {
 export function equals(l: PgToast.Types.PgToast_1247Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2604Index {
 export function equals(l: PgToast.Types.PgToast_2604Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2606Index {
 export function equals(l: PgToast.Types.PgToast_2606Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2612Index {
 export function equals(l: PgToast.Types.PgToast_2612Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2600Index {
 export function equals(l: PgToast.Types.PgToast_2600Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2619Index {
 export function equals(l: PgToast.Types.PgToast_2619Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3381Index {
 export function equals(l: PgToast.Types.PgToast_3381Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3429Index {
 export function equals(l: PgToast.Types.PgToast_3429Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2618Index {
 export function equals(l: PgToast.Types.PgToast_2618Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2620Index {
 export function equals(l: PgToast.Types.PgToast_2620Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3466Index {
 export function equals(l: PgToast.Types.PgToast_3466Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2609Index {
 export function equals(l: PgToast.Types.PgToast_2609Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_50326Index {
 export function equals(l: PgToast.Types.PgToast_50326Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2615Index {
 export function equals(l: PgToast.Types.PgToast_2615Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1262Index {
 export function equals(l: PgToast.Types.PgToast_1262Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2964Index {
 export function equals(l: PgToast.Types.PgToast_2964Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1213Index {
 export function equals(l: PgToast.Types.PgToast_1213Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1260Index {
 export function equals(l: PgToast.Types.PgToast_1260Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2396Index {
 export function equals(l: PgToast.Types.PgToast_2396Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3600Index {
 export function equals(l: PgToast.Types.PgToast_3600Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3079Index {
 export function equals(l: PgToast.Types.PgToast_3079Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2328Index {
 export function equals(l: PgToast.Types.PgToast_2328Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1417Index {
 export function equals(l: PgToast.Types.PgToast_1417Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1418Index {
 export function equals(l: PgToast.Types.PgToast_1418Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3118Index {
 export function equals(l: PgToast.Types.PgToast_3118Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3256Index {
 export function equals(l: PgToast.Types.PgToast_3256Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6000Index {
 export function equals(l: PgToast.Types.PgToast_6000Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_826Index {
 export function equals(l: PgToast.Types.PgToast_826Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3394Index {
 export function equals(l: PgToast.Types.PgToast_3394Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3596Index {
 export function equals(l: PgToast.Types.PgToast_3596Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3592Index {
 export function equals(l: PgToast.Types.PgToast_3592Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3456Index {
 export function equals(l: PgToast.Types.PgToast_3456Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6243Index {
 export function equals(l: PgToast.Types.PgToast_6243Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3350Index {
 export function equals(l: PgToast.Types.PgToast_3350Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6106Index {
 export function equals(l: PgToast.Types.PgToast_6106Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6100Index {
 export function equals(l: PgToast.Types.PgToast_6100Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_50332Index {
 export function equals(l: PgToast.Types.PgToast_50332Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_50338Index {
 export function equals(l: PgToast.Types.PgToast_50338Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13658Index {
 export function equals(l: PgToast.Types.PgToast_13658Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13663Index {
 export function equals(l: PgToast.Types.PgToast_13663Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13668Index {
 export function equals(l: PgToast.Types.PgToast_13668Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13673Index {
 export function equals(l: PgToast.Types.PgToast_13673Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
}
}

            import { Context, initializeContext, PostgresDatabase } from "@embracesql/postgres";
            import postgres from "postgres";
          

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        type ArgumentToPostgres = any;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        type ArgumentFromPostgres = any;
        type Typecast = (x: ArgumentToPostgres) => ArgumentFromPostgres;
        export interface PostgresTypecasts { 
      
[16]: Typecast;
["PgCatalog.Types.Bool"]: Typecast
[17]: Typecast;
["PgCatalog.Types.Bytea"]: Typecast
[18]: Typecast;
["PgCatalog.Types.Char"]: Typecast
[19]: Typecast;
["PgCatalog.Types.Name"]: Typecast
[20]: Typecast;
["PgCatalog.Types.Int8"]: Typecast
[21]: Typecast;
["PgCatalog.Types.Int2"]: Typecast
[22]: Typecast;
["PgCatalog.Types.Int2vector"]: Typecast
[23]: Typecast;
["PgCatalog.Types.Int4"]: Typecast
[24]: Typecast;
["PgCatalog.Types.Regproc"]: Typecast
[25]: Typecast;
["PgCatalog.Types.Text"]: Typecast
[26]: Typecast;
["PgCatalog.Types.Oid"]: Typecast
[27]: Typecast;
["PgCatalog.Types.Tid"]: Typecast
[28]: Typecast;
["PgCatalog.Types.Xid"]: Typecast
[29]: Typecast;
["PgCatalog.Types.Cid"]: Typecast
[30]: Typecast;
["PgCatalog.Types.Oidvector"]: Typecast
[71]: Typecast;
["PgCatalog.Types.PgType"]: Typecast
[75]: Typecast;
["PgCatalog.Types.PgAttribute"]: Typecast
[81]: Typecast;
["PgCatalog.Types.PgProc"]: Typecast
[83]: Typecast;
["PgCatalog.Types.PgClass"]: Typecast
[114]: Typecast;
["PgCatalog.Types.Json"]: Typecast
[142]: Typecast;
["PgCatalog.Types.Xml"]: Typecast
[194]: Typecast;
["PgCatalog.Types.PgNodeTree"]: Typecast
[3361]: Typecast;
["PgCatalog.Types.PgNdistinct"]: Typecast
[3402]: Typecast;
["PgCatalog.Types.PgDependencies"]: Typecast
[5017]: Typecast;
["PgCatalog.Types.PgMcvList"]: Typecast
[32]: Typecast;
["PgCatalog.Types.PgDdlCommand"]: Typecast
[5069]: Typecast;
["PgCatalog.Types.Xid8"]: Typecast
[600]: Typecast;
["PgCatalog.Types.Point"]: Typecast
[601]: Typecast;
["PgCatalog.Types.Lseg"]: Typecast
[602]: Typecast;
["PgCatalog.Types.Path"]: Typecast
[603]: Typecast;
["PgCatalog.Types.Box"]: Typecast
[604]: Typecast;
["PgCatalog.Types.Polygon"]: Typecast
[628]: Typecast;
["PgCatalog.Types.Line"]: Typecast
[700]: Typecast;
["PgCatalog.Types.Float4"]: Typecast
[701]: Typecast;
["PgCatalog.Types.Float8"]: Typecast
[705]: Typecast;
["PgCatalog.Types.Unknown"]: Typecast
[718]: Typecast;
["PgCatalog.Types.Circle"]: Typecast
[790]: Typecast;
["PgCatalog.Types.Money"]: Typecast
[829]: Typecast;
["PgCatalog.Types.Macaddr"]: Typecast
[869]: Typecast;
["PgCatalog.Types.Inet"]: Typecast
[650]: Typecast;
["PgCatalog.Types.Cidr"]: Typecast
[774]: Typecast;
["PgCatalog.Types.Macaddr8"]: Typecast
[1033]: Typecast;
["PgCatalog.Types.Aclitem"]: Typecast
[1042]: Typecast;
["PgCatalog.Types.Bpchar"]: Typecast
[1043]: Typecast;
["PgCatalog.Types.Varchar"]: Typecast
[1082]: Typecast;
["PgCatalog.Types.Date"]: Typecast
[1083]: Typecast;
["PgCatalog.Types.Time"]: Typecast
[1114]: Typecast;
["PgCatalog.Types.Timestamp"]: Typecast
[1184]: Typecast;
["PgCatalog.Types.Timestamptz"]: Typecast
[1186]: Typecast;
["PgCatalog.Types.Interval"]: Typecast
[1266]: Typecast;
["PgCatalog.Types.Timetz"]: Typecast
[1560]: Typecast;
["PgCatalog.Types.Bit"]: Typecast
[1562]: Typecast;
["PgCatalog.Types.Varbit"]: Typecast
[1700]: Typecast;
["PgCatalog.Types.Numeric"]: Typecast
[1790]: Typecast;
["PgCatalog.Types.Refcursor"]: Typecast
[2202]: Typecast;
["PgCatalog.Types.Regprocedure"]: Typecast
[2203]: Typecast;
["PgCatalog.Types.Regoper"]: Typecast
[2204]: Typecast;
["PgCatalog.Types.Regoperator"]: Typecast
[2205]: Typecast;
["PgCatalog.Types.Regclass"]: Typecast
[4191]: Typecast;
["PgCatalog.Types.Regcollation"]: Typecast
[2206]: Typecast;
["PgCatalog.Types.Regtype"]: Typecast
[4096]: Typecast;
["PgCatalog.Types.Regrole"]: Typecast
[4089]: Typecast;
["PgCatalog.Types.Regnamespace"]: Typecast
[2950]: Typecast;
["PgCatalog.Types.Uuid"]: Typecast
[3220]: Typecast;
["PgCatalog.Types.PgLsn"]: Typecast
[3614]: Typecast;
["PgCatalog.Types.Tsvector"]: Typecast
[3642]: Typecast;
["PgCatalog.Types.Gtsvector"]: Typecast
[3615]: Typecast;
["PgCatalog.Types.Tsquery"]: Typecast
[3734]: Typecast;
["PgCatalog.Types.Regconfig"]: Typecast
[3769]: Typecast;
["PgCatalog.Types.Regdictionary"]: Typecast
[3802]: Typecast;
["PgCatalog.Types.Jsonb"]: Typecast
[4072]: Typecast;
["PgCatalog.Types.Jsonpath"]: Typecast
[2970]: Typecast;
["PgCatalog.Types.TxidSnapshot"]: Typecast
[5038]: Typecast;
["PgCatalog.Types.PgSnapshot"]: Typecast
[3904]: Typecast;
["PgCatalog.Types.Int4range"]: Typecast
[3906]: Typecast;
["PgCatalog.Types.Numrange"]: Typecast
[3908]: Typecast;
["PgCatalog.Types.Tsrange"]: Typecast
[3910]: Typecast;
["PgCatalog.Types.Tstzrange"]: Typecast
[3912]: Typecast;
["PgCatalog.Types.Daterange"]: Typecast
[3926]: Typecast;
["PgCatalog.Types.Int8range"]: Typecast
[4451]: Typecast;
["PgCatalog.Types.Int4multirange"]: Typecast
[4532]: Typecast;
["PgCatalog.Types.Nummultirange"]: Typecast
[4533]: Typecast;
["PgCatalog.Types.Tsmultirange"]: Typecast
[4534]: Typecast;
["PgCatalog.Types.Tstzmultirange"]: Typecast
[4535]: Typecast;
["PgCatalog.Types.Datemultirange"]: Typecast
[4536]: Typecast;
["PgCatalog.Types.Int8multirange"]: Typecast
[2249]: Typecast;
["PgCatalog.Types.Record"]: Typecast
[2287]: Typecast;
["PgCatalog.Types.RecordArray"]: Typecast
[2275]: Typecast;
["PgCatalog.Types.Cstring"]: Typecast
[2276]: Typecast;
["PgCatalog.Types.Any"]: Typecast
[2277]: Typecast;
["PgCatalog.Types.Anyarray"]: Typecast
[2278]: Typecast;
["PgCatalog.Types.Void"]: Typecast
[2279]: Typecast;
["PgCatalog.Types.Trigger"]: Typecast
[3838]: Typecast;
["PgCatalog.Types.EventTrigger"]: Typecast
[2280]: Typecast;
["PgCatalog.Types.LanguageHandler"]: Typecast
[2281]: Typecast;
["PgCatalog.Types.Internal"]: Typecast
[2283]: Typecast;
["PgCatalog.Types.Anyelement"]: Typecast
[2776]: Typecast;
["PgCatalog.Types.Anynonarray"]: Typecast
[3500]: Typecast;
["PgCatalog.Types.Anyenum"]: Typecast
[3115]: Typecast;
["PgCatalog.Types.FdwHandler"]: Typecast
[325]: Typecast;
["PgCatalog.Types.IndexAmHandler"]: Typecast
[3310]: Typecast;
["PgCatalog.Types.TsmHandler"]: Typecast
[269]: Typecast;
["PgCatalog.Types.TableAmHandler"]: Typecast
[3831]: Typecast;
["PgCatalog.Types.Anyrange"]: Typecast
[5077]: Typecast;
["PgCatalog.Types.Anycompatible"]: Typecast
[5078]: Typecast;
["PgCatalog.Types.Anycompatiblearray"]: Typecast
[5079]: Typecast;
["PgCatalog.Types.Anycompatiblenonarray"]: Typecast
[5080]: Typecast;
["PgCatalog.Types.Anycompatiblerange"]: Typecast
[4537]: Typecast;
["PgCatalog.Types.Anymultirange"]: Typecast
[4538]: Typecast;
["PgCatalog.Types.Anycompatiblemultirange"]: Typecast
[4600]: Typecast;
["PgCatalog.Types.PgBrinBloomSummary"]: Typecast
[4601]: Typecast;
["PgCatalog.Types.PgBrinMinmaxMultiSummary"]: Typecast
[1000]: Typecast;
["PgCatalog.Types.BoolArray"]: Typecast
[1001]: Typecast;
["PgCatalog.Types.ByteaArray"]: Typecast
[1002]: Typecast;
["PgCatalog.Types.CharArray"]: Typecast
[1003]: Typecast;
["PgCatalog.Types.NameArray"]: Typecast
[1016]: Typecast;
["PgCatalog.Types.Int8Array"]: Typecast
[1005]: Typecast;
["PgCatalog.Types.Int2Array"]: Typecast
[1006]: Typecast;
["PgCatalog.Types.Int2vectorArray"]: Typecast
[1007]: Typecast;
["PgCatalog.Types.Int4Array"]: Typecast
[1008]: Typecast;
["PgCatalog.Types.RegprocArray"]: Typecast
[1009]: Typecast;
["PgCatalog.Types.TextArray"]: Typecast
[1028]: Typecast;
["PgCatalog.Types.OidArray"]: Typecast
[1010]: Typecast;
["PgCatalog.Types.TidArray"]: Typecast
[1011]: Typecast;
["PgCatalog.Types.XidArray"]: Typecast
[1012]: Typecast;
["PgCatalog.Types.CidArray"]: Typecast
[1013]: Typecast;
["PgCatalog.Types.OidvectorArray"]: Typecast
[210]: Typecast;
["PgCatalog.Types.PgTypeArray"]: Typecast
[270]: Typecast;
["PgCatalog.Types.PgAttributeArray"]: Typecast
[272]: Typecast;
["PgCatalog.Types.PgProcArray"]: Typecast
[273]: Typecast;
["PgCatalog.Types.PgClassArray"]: Typecast
[199]: Typecast;
["PgCatalog.Types.JsonArray"]: Typecast
[143]: Typecast;
["PgCatalog.Types.XmlArray"]: Typecast
[271]: Typecast;
["PgCatalog.Types.Xid8Array"]: Typecast
[1017]: Typecast;
["PgCatalog.Types.PointArray"]: Typecast
[1018]: Typecast;
["PgCatalog.Types.LsegArray"]: Typecast
[1019]: Typecast;
["PgCatalog.Types.PathArray"]: Typecast
[1020]: Typecast;
["PgCatalog.Types.BoxArray"]: Typecast
[1027]: Typecast;
["PgCatalog.Types.PolygonArray"]: Typecast
[629]: Typecast;
["PgCatalog.Types.LineArray"]: Typecast
[1021]: Typecast;
["PgCatalog.Types.Float4Array"]: Typecast
[1022]: Typecast;
["PgCatalog.Types.Float8Array"]: Typecast
[719]: Typecast;
["PgCatalog.Types.CircleArray"]: Typecast
[791]: Typecast;
["PgCatalog.Types.MoneyArray"]: Typecast
[1040]: Typecast;
["PgCatalog.Types.MacaddrArray"]: Typecast
[1041]: Typecast;
["PgCatalog.Types.InetArray"]: Typecast
[651]: Typecast;
["PgCatalog.Types.CidrArray"]: Typecast
[775]: Typecast;
["PgCatalog.Types.Macaddr8Array"]: Typecast
[1034]: Typecast;
["PgCatalog.Types.AclitemArray"]: Typecast
[1014]: Typecast;
["PgCatalog.Types.BpcharArray"]: Typecast
[1015]: Typecast;
["PgCatalog.Types.VarcharArray"]: Typecast
[1182]: Typecast;
["PgCatalog.Types.DateArray"]: Typecast
[1183]: Typecast;
["PgCatalog.Types.TimeArray"]: Typecast
[1115]: Typecast;
["PgCatalog.Types.TimestampArray"]: Typecast
[1185]: Typecast;
["PgCatalog.Types.TimestamptzArray"]: Typecast
[1187]: Typecast;
["PgCatalog.Types.IntervalArray"]: Typecast
[1270]: Typecast;
["PgCatalog.Types.TimetzArray"]: Typecast
[1561]: Typecast;
["PgCatalog.Types.BitArray"]: Typecast
[1563]: Typecast;
["PgCatalog.Types.VarbitArray"]: Typecast
[1231]: Typecast;
["PgCatalog.Types.NumericArray"]: Typecast
[2201]: Typecast;
["PgCatalog.Types.RefcursorArray"]: Typecast
[2207]: Typecast;
["PgCatalog.Types.RegprocedureArray"]: Typecast
[2208]: Typecast;
["PgCatalog.Types.RegoperArray"]: Typecast
[2209]: Typecast;
["PgCatalog.Types.RegoperatorArray"]: Typecast
[2210]: Typecast;
["PgCatalog.Types.RegclassArray"]: Typecast
[4192]: Typecast;
["PgCatalog.Types.RegcollationArray"]: Typecast
[2211]: Typecast;
["PgCatalog.Types.RegtypeArray"]: Typecast
[4097]: Typecast;
["PgCatalog.Types.RegroleArray"]: Typecast
[4090]: Typecast;
["PgCatalog.Types.RegnamespaceArray"]: Typecast
[2951]: Typecast;
["PgCatalog.Types.UuidArray"]: Typecast
[3221]: Typecast;
["PgCatalog.Types.PgLsnArray"]: Typecast
[3643]: Typecast;
["PgCatalog.Types.TsvectorArray"]: Typecast
[3644]: Typecast;
["PgCatalog.Types.GtsvectorArray"]: Typecast
[3645]: Typecast;
["PgCatalog.Types.TsqueryArray"]: Typecast
[3735]: Typecast;
["PgCatalog.Types.RegconfigArray"]: Typecast
[3770]: Typecast;
["PgCatalog.Types.RegdictionaryArray"]: Typecast
[3807]: Typecast;
["PgCatalog.Types.JsonbArray"]: Typecast
[4073]: Typecast;
["PgCatalog.Types.JsonpathArray"]: Typecast
[2949]: Typecast;
["PgCatalog.Types.TxidSnapshotArray"]: Typecast
[5039]: Typecast;
["PgCatalog.Types.PgSnapshotArray"]: Typecast
[3905]: Typecast;
["PgCatalog.Types.Int4rangeArray"]: Typecast
[3907]: Typecast;
["PgCatalog.Types.NumrangeArray"]: Typecast
[3909]: Typecast;
["PgCatalog.Types.TsrangeArray"]: Typecast
[3911]: Typecast;
["PgCatalog.Types.TstzrangeArray"]: Typecast
[3913]: Typecast;
["PgCatalog.Types.DaterangeArray"]: Typecast
[3927]: Typecast;
["PgCatalog.Types.Int8rangeArray"]: Typecast
[6150]: Typecast;
["PgCatalog.Types.Int4multirangeArray"]: Typecast
[6151]: Typecast;
["PgCatalog.Types.NummultirangeArray"]: Typecast
[6152]: Typecast;
["PgCatalog.Types.TsmultirangeArray"]: Typecast
[6153]: Typecast;
["PgCatalog.Types.TstzmultirangeArray"]: Typecast
[6155]: Typecast;
["PgCatalog.Types.DatemultirangeArray"]: Typecast
[6157]: Typecast;
["PgCatalog.Types.Int8multirangeArray"]: Typecast
[1263]: Typecast;
["PgCatalog.Types.CstringArray"]: Typecast
[10001]: Typecast;
["PgCatalog.Types.PgAttrdef"]: Typecast
[10000]: Typecast;
["PgCatalog.Types.PgAttrdefArray"]: Typecast
[10003]: Typecast;
["PgCatalog.Types.PgConstraint"]: Typecast
[10002]: Typecast;
["PgCatalog.Types.PgConstraintArray"]: Typecast
[10005]: Typecast;
["PgCatalog.Types.PgInherits"]: Typecast
[10004]: Typecast;
["PgCatalog.Types.PgInheritsArray"]: Typecast
[10007]: Typecast;
["PgCatalog.Types.PgIndex"]: Typecast
[10006]: Typecast;
["PgCatalog.Types.PgIndexArray"]: Typecast
[10009]: Typecast;
["PgCatalog.Types.PgOperator"]: Typecast
[10008]: Typecast;
["PgCatalog.Types.PgOperatorArray"]: Typecast
[10011]: Typecast;
["PgCatalog.Types.PgOpfamily"]: Typecast
[10010]: Typecast;
["PgCatalog.Types.PgOpfamilyArray"]: Typecast
[10013]: Typecast;
["PgCatalog.Types.PgOpclass"]: Typecast
[10012]: Typecast;
["PgCatalog.Types.PgOpclassArray"]: Typecast
[10015]: Typecast;
["PgCatalog.Types.PgAm"]: Typecast
[10014]: Typecast;
["PgCatalog.Types.PgAmArray"]: Typecast
[10017]: Typecast;
["PgCatalog.Types.PgAmop"]: Typecast
[10016]: Typecast;
["PgCatalog.Types.PgAmopArray"]: Typecast
[10019]: Typecast;
["PgCatalog.Types.PgAmproc"]: Typecast
[10018]: Typecast;
["PgCatalog.Types.PgAmprocArray"]: Typecast
[10021]: Typecast;
["PgCatalog.Types.PgLanguage"]: Typecast
[10020]: Typecast;
["PgCatalog.Types.PgLanguageArray"]: Typecast
[10023]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadata"]: Typecast
[10022]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadataArray"]: Typecast
[10025]: Typecast;
["PgCatalog.Types.PgLargeobject"]: Typecast
[10024]: Typecast;
["PgCatalog.Types.PgLargeobjectArray"]: Typecast
[10027]: Typecast;
["PgCatalog.Types.PgAggregate"]: Typecast
[10026]: Typecast;
["PgCatalog.Types.PgAggregateArray"]: Typecast
[10029]: Typecast;
["PgCatalog.Types.PgStatistic"]: Typecast
[10028]: Typecast;
["PgCatalog.Types.PgStatisticArray"]: Typecast
[10031]: Typecast;
["PgCatalog.Types.PgStatisticExt"]: Typecast
[10030]: Typecast;
["PgCatalog.Types.PgStatisticExtArray"]: Typecast
[10033]: Typecast;
["PgCatalog.Types.PgStatisticExtData"]: Typecast
[10032]: Typecast;
["PgCatalog.Types.PgStatisticExtDataArray"]: Typecast
[10035]: Typecast;
["PgCatalog.Types.PgRewrite"]: Typecast
[10034]: Typecast;
["PgCatalog.Types.PgRewriteArray"]: Typecast
[10037]: Typecast;
["PgCatalog.Types.PgTrigger"]: Typecast
[10036]: Typecast;
["PgCatalog.Types.PgTriggerArray"]: Typecast
[10039]: Typecast;
["PgCatalog.Types.PgEventTrigger"]: Typecast
[10038]: Typecast;
["PgCatalog.Types.PgEventTriggerArray"]: Typecast
[10041]: Typecast;
["PgCatalog.Types.PgDescription"]: Typecast
[10040]: Typecast;
["PgCatalog.Types.PgDescriptionArray"]: Typecast
[10043]: Typecast;
["PgCatalog.Types.PgCast"]: Typecast
[10042]: Typecast;
["PgCatalog.Types.PgCastArray"]: Typecast
[10045]: Typecast;
["PgCatalog.Types.PgEnum"]: Typecast
[10044]: Typecast;
["PgCatalog.Types.PgEnumArray"]: Typecast
[10047]: Typecast;
["PgCatalog.Types.PgNamespace"]: Typecast
[10046]: Typecast;
["PgCatalog.Types.PgNamespaceArray"]: Typecast
[10049]: Typecast;
["PgCatalog.Types.PgConversion"]: Typecast
[10048]: Typecast;
["PgCatalog.Types.PgConversionArray"]: Typecast
[10051]: Typecast;
["PgCatalog.Types.PgDepend"]: Typecast
[10050]: Typecast;
["PgCatalog.Types.PgDependArray"]: Typecast
[1248]: Typecast;
["PgCatalog.Types.PgDatabase"]: Typecast
[10052]: Typecast;
["PgCatalog.Types.PgDatabaseArray"]: Typecast
[10054]: Typecast;
["PgCatalog.Types.PgDbRoleSetting"]: Typecast
[10053]: Typecast;
["PgCatalog.Types.PgDbRoleSettingArray"]: Typecast
[10056]: Typecast;
["PgCatalog.Types.PgTablespace"]: Typecast
[10055]: Typecast;
["PgCatalog.Types.PgTablespaceArray"]: Typecast
[2842]: Typecast;
["PgCatalog.Types.PgAuthid"]: Typecast
[10057]: Typecast;
["PgCatalog.Types.PgAuthidArray"]: Typecast
[2843]: Typecast;
["PgCatalog.Types.PgAuthMembers"]: Typecast
[10058]: Typecast;
["PgCatalog.Types.PgAuthMembersArray"]: Typecast
[10060]: Typecast;
["PgCatalog.Types.PgShdepend"]: Typecast
[10059]: Typecast;
["PgCatalog.Types.PgShdependArray"]: Typecast
[10062]: Typecast;
["PgCatalog.Types.PgShdescription"]: Typecast
[10061]: Typecast;
["PgCatalog.Types.PgShdescriptionArray"]: Typecast
[10064]: Typecast;
["PgCatalog.Types.PgTsConfig"]: Typecast
[10063]: Typecast;
["PgCatalog.Types.PgTsConfigArray"]: Typecast
[10066]: Typecast;
["PgCatalog.Types.PgTsConfigMap"]: Typecast
[10065]: Typecast;
["PgCatalog.Types.PgTsConfigMapArray"]: Typecast
[10068]: Typecast;
["PgCatalog.Types.PgTsDict"]: Typecast
[10067]: Typecast;
["PgCatalog.Types.PgTsDictArray"]: Typecast
[10070]: Typecast;
["PgCatalog.Types.PgTsParser"]: Typecast
[10069]: Typecast;
["PgCatalog.Types.PgTsParserArray"]: Typecast
[10072]: Typecast;
["PgCatalog.Types.PgTsTemplate"]: Typecast
[10071]: Typecast;
["PgCatalog.Types.PgTsTemplateArray"]: Typecast
[10074]: Typecast;
["PgCatalog.Types.PgExtension"]: Typecast
[10073]: Typecast;
["PgCatalog.Types.PgExtensionArray"]: Typecast
[10076]: Typecast;
["PgCatalog.Types.PgForeignDataWrapper"]: Typecast
[10075]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperArray"]: Typecast
[10078]: Typecast;
["PgCatalog.Types.PgForeignServer"]: Typecast
[10077]: Typecast;
["PgCatalog.Types.PgForeignServerArray"]: Typecast
[10080]: Typecast;
["PgCatalog.Types.PgUserMapping"]: Typecast
[10079]: Typecast;
["PgCatalog.Types.PgUserMappingArray"]: Typecast
[10082]: Typecast;
["PgCatalog.Types.PgForeignTable"]: Typecast
[10081]: Typecast;
["PgCatalog.Types.PgForeignTableArray"]: Typecast
[10084]: Typecast;
["PgCatalog.Types.PgPolicy"]: Typecast
[10083]: Typecast;
["PgCatalog.Types.PgPolicyArray"]: Typecast
[10086]: Typecast;
["PgCatalog.Types.PgReplicationOrigin"]: Typecast
[10085]: Typecast;
["PgCatalog.Types.PgReplicationOriginArray"]: Typecast
[10088]: Typecast;
["PgCatalog.Types.PgDefaultAcl"]: Typecast
[10087]: Typecast;
["PgCatalog.Types.PgDefaultAclArray"]: Typecast
[10090]: Typecast;
["PgCatalog.Types.PgInitPrivs"]: Typecast
[10089]: Typecast;
["PgCatalog.Types.PgInitPrivsArray"]: Typecast
[10092]: Typecast;
["PgCatalog.Types.PgSeclabel"]: Typecast
[10091]: Typecast;
["PgCatalog.Types.PgSeclabelArray"]: Typecast
[4066]: Typecast;
["PgCatalog.Types.PgShseclabel"]: Typecast
[10093]: Typecast;
["PgCatalog.Types.PgShseclabelArray"]: Typecast
[10095]: Typecast;
["PgCatalog.Types.PgCollation"]: Typecast
[10094]: Typecast;
["PgCatalog.Types.PgCollationArray"]: Typecast
[10097]: Typecast;
["PgCatalog.Types.PgParameterAcl"]: Typecast
[10096]: Typecast;
["PgCatalog.Types.PgParameterAclArray"]: Typecast
[10099]: Typecast;
["PgCatalog.Types.PgPartitionedTable"]: Typecast
[10098]: Typecast;
["PgCatalog.Types.PgPartitionedTableArray"]: Typecast
[10101]: Typecast;
["PgCatalog.Types.PgRange"]: Typecast
[10100]: Typecast;
["PgCatalog.Types.PgRangeArray"]: Typecast
[10103]: Typecast;
["PgCatalog.Types.PgTransform"]: Typecast
[10102]: Typecast;
["PgCatalog.Types.PgTransformArray"]: Typecast
[10105]: Typecast;
["PgCatalog.Types.PgSequence"]: Typecast
[10104]: Typecast;
["PgCatalog.Types.PgSequenceArray"]: Typecast
[10107]: Typecast;
["PgCatalog.Types.PgPublication"]: Typecast
[10106]: Typecast;
["PgCatalog.Types.PgPublicationArray"]: Typecast
[10109]: Typecast;
["PgCatalog.Types.PgPublicationNamespace"]: Typecast
[10108]: Typecast;
["PgCatalog.Types.PgPublicationNamespaceArray"]: Typecast
[10111]: Typecast;
["PgCatalog.Types.PgPublicationRel"]: Typecast
[10110]: Typecast;
["PgCatalog.Types.PgPublicationRelArray"]: Typecast
[6101]: Typecast;
["PgCatalog.Types.PgSubscription"]: Typecast
[10112]: Typecast;
["PgCatalog.Types.PgSubscriptionArray"]: Typecast
[10114]: Typecast;
["PgCatalog.Types.PgSubscriptionRel"]: Typecast
[10113]: Typecast;
["PgCatalog.Types.PgSubscriptionRelArray"]: Typecast
[12002]: Typecast;
["PgCatalog.Types.PgRoles"]: Typecast
[12001]: Typecast;
["PgCatalog.Types.PgRolesArray"]: Typecast
[12007]: Typecast;
["PgCatalog.Types.PgShadow"]: Typecast
[12006]: Typecast;
["PgCatalog.Types.PgShadowArray"]: Typecast
[12012]: Typecast;
["PgCatalog.Types.PgGroup"]: Typecast
[12011]: Typecast;
["PgCatalog.Types.PgGroupArray"]: Typecast
[12016]: Typecast;
["PgCatalog.Types.PgUser"]: Typecast
[12015]: Typecast;
["PgCatalog.Types.PgUserArray"]: Typecast
[12020]: Typecast;
["PgCatalog.Types.PgPolicies"]: Typecast
[12019]: Typecast;
["PgCatalog.Types.PgPoliciesArray"]: Typecast
[12025]: Typecast;
["PgCatalog.Types.PgRules"]: Typecast
[12024]: Typecast;
["PgCatalog.Types.PgRulesArray"]: Typecast
[12030]: Typecast;
["PgCatalog.Types.PgViews"]: Typecast
[12029]: Typecast;
["PgCatalog.Types.PgViewsArray"]: Typecast
[12035]: Typecast;
["PgCatalog.Types.PgTables"]: Typecast
[12034]: Typecast;
["PgCatalog.Types.PgTablesArray"]: Typecast
[12040]: Typecast;
["PgCatalog.Types.PgMatviews"]: Typecast
[12039]: Typecast;
["PgCatalog.Types.PgMatviewsArray"]: Typecast
[12045]: Typecast;
["PgCatalog.Types.PgIndexes"]: Typecast
[12044]: Typecast;
["PgCatalog.Types.PgIndexesArray"]: Typecast
[12050]: Typecast;
["PgCatalog.Types.PgSequences"]: Typecast
[12049]: Typecast;
["PgCatalog.Types.PgSequencesArray"]: Typecast
[12055]: Typecast;
["PgCatalog.Types.PgStats"]: Typecast
[12054]: Typecast;
["PgCatalog.Types.PgStatsArray"]: Typecast
[12060]: Typecast;
["PgCatalog.Types.PgStatsExt"]: Typecast
[12059]: Typecast;
["PgCatalog.Types.PgStatsExtArray"]: Typecast
[12065]: Typecast;
["PgCatalog.Types.PgStatsExtExprs"]: Typecast
[12064]: Typecast;
["PgCatalog.Types.PgStatsExtExprsArray"]: Typecast
[12070]: Typecast;
["PgCatalog.Types.PgPublicationTables"]: Typecast
[12069]: Typecast;
["PgCatalog.Types.PgPublicationTablesArray"]: Typecast
[12075]: Typecast;
["PgCatalog.Types.PgLocks"]: Typecast
[12074]: Typecast;
["PgCatalog.Types.PgLocksArray"]: Typecast
[12079]: Typecast;
["PgCatalog.Types.PgCursors"]: Typecast
[12078]: Typecast;
["PgCatalog.Types.PgCursorsArray"]: Typecast
[12083]: Typecast;
["PgCatalog.Types.PgAvailableExtensions"]: Typecast
[12082]: Typecast;
["PgCatalog.Types.PgAvailableExtensionsArray"]: Typecast
[12087]: Typecast;
["PgCatalog.Types.PgAvailableExtensionVersions"]: Typecast
[12086]: Typecast;
["PgCatalog.Types.PgAvailableExtensionVersionsArray"]: Typecast
[12092]: Typecast;
["PgCatalog.Types.PgPreparedXacts"]: Typecast
[12091]: Typecast;
["PgCatalog.Types.PgPreparedXactsArray"]: Typecast
[12097]: Typecast;
["PgCatalog.Types.PgPreparedStatements"]: Typecast
[12096]: Typecast;
["PgCatalog.Types.PgPreparedStatementsArray"]: Typecast
[12101]: Typecast;
["PgCatalog.Types.PgSeclabels"]: Typecast
[12100]: Typecast;
["PgCatalog.Types.PgSeclabelsArray"]: Typecast
[12106]: Typecast;
["PgCatalog.Types.PgSettings"]: Typecast
[12105]: Typecast;
["PgCatalog.Types.PgSettingsArray"]: Typecast
[12112]: Typecast;
["PgCatalog.Types.PgFileSettings"]: Typecast
[12111]: Typecast;
["PgCatalog.Types.PgFileSettingsArray"]: Typecast
[12116]: Typecast;
["PgCatalog.Types.PgHbaFileRules"]: Typecast
[12115]: Typecast;
["PgCatalog.Types.PgHbaFileRulesArray"]: Typecast
[12120]: Typecast;
["PgCatalog.Types.PgIdentFileMappings"]: Typecast
[12119]: Typecast;
["PgCatalog.Types.PgIdentFileMappingsArray"]: Typecast
[12124]: Typecast;
["PgCatalog.Types.PgTimezoneAbbrevs"]: Typecast
[12123]: Typecast;
["PgCatalog.Types.PgTimezoneAbbrevsArray"]: Typecast
[12128]: Typecast;
["PgCatalog.Types.PgTimezoneNames"]: Typecast
[12127]: Typecast;
["PgCatalog.Types.PgTimezoneNamesArray"]: Typecast
[12132]: Typecast;
["PgCatalog.Types.PgConfig"]: Typecast
[12131]: Typecast;
["PgCatalog.Types.PgConfigArray"]: Typecast
[12136]: Typecast;
["PgCatalog.Types.PgShmemAllocations"]: Typecast
[12135]: Typecast;
["PgCatalog.Types.PgShmemAllocationsArray"]: Typecast
[12140]: Typecast;
["PgCatalog.Types.PgBackendMemoryContexts"]: Typecast
[12139]: Typecast;
["PgCatalog.Types.PgBackendMemoryContextsArray"]: Typecast
[12144]: Typecast;
["PgCatalog.Types.PgStatAllTables"]: Typecast
[12143]: Typecast;
["PgCatalog.Types.PgStatAllTablesArray"]: Typecast
[12149]: Typecast;
["PgCatalog.Types.PgStatXactAllTables"]: Typecast
[12148]: Typecast;
["PgCatalog.Types.PgStatXactAllTablesArray"]: Typecast
[12154]: Typecast;
["PgCatalog.Types.PgStatSysTables"]: Typecast
[12153]: Typecast;
["PgCatalog.Types.PgStatSysTablesArray"]: Typecast
[12159]: Typecast;
["PgCatalog.Types.PgStatXactSysTables"]: Typecast
[12158]: Typecast;
["PgCatalog.Types.PgStatXactSysTablesArray"]: Typecast
[12163]: Typecast;
["PgCatalog.Types.PgStatUserTables"]: Typecast
[12162]: Typecast;
["PgCatalog.Types.PgStatUserTablesArray"]: Typecast
[12168]: Typecast;
["PgCatalog.Types.PgStatXactUserTables"]: Typecast
[12167]: Typecast;
["PgCatalog.Types.PgStatXactUserTablesArray"]: Typecast
[12172]: Typecast;
["PgCatalog.Types.PgStatioAllTables"]: Typecast
[12171]: Typecast;
["PgCatalog.Types.PgStatioAllTablesArray"]: Typecast
[12177]: Typecast;
["PgCatalog.Types.PgStatioSysTables"]: Typecast
[12176]: Typecast;
["PgCatalog.Types.PgStatioSysTablesArray"]: Typecast
[12181]: Typecast;
["PgCatalog.Types.PgStatioUserTables"]: Typecast
[12180]: Typecast;
["PgCatalog.Types.PgStatioUserTablesArray"]: Typecast
[12185]: Typecast;
["PgCatalog.Types.PgStatAllIndexes"]: Typecast
[12184]: Typecast;
["PgCatalog.Types.PgStatAllIndexesArray"]: Typecast
[12190]: Typecast;
["PgCatalog.Types.PgStatSysIndexes"]: Typecast
[12189]: Typecast;
["PgCatalog.Types.PgStatSysIndexesArray"]: Typecast
[12194]: Typecast;
["PgCatalog.Types.PgStatUserIndexes"]: Typecast
[12193]: Typecast;
["PgCatalog.Types.PgStatUserIndexesArray"]: Typecast
[12198]: Typecast;
["PgCatalog.Types.PgStatioAllIndexes"]: Typecast
[12197]: Typecast;
["PgCatalog.Types.PgStatioAllIndexesArray"]: Typecast
[12203]: Typecast;
["PgCatalog.Types.PgStatioSysIndexes"]: Typecast
[12202]: Typecast;
["PgCatalog.Types.PgStatioSysIndexesArray"]: Typecast
[12207]: Typecast;
["PgCatalog.Types.PgStatioUserIndexes"]: Typecast
[12206]: Typecast;
["PgCatalog.Types.PgStatioUserIndexesArray"]: Typecast
[12211]: Typecast;
["PgCatalog.Types.PgStatioAllSequences"]: Typecast
[12210]: Typecast;
["PgCatalog.Types.PgStatioAllSequencesArray"]: Typecast
[12216]: Typecast;
["PgCatalog.Types.PgStatioSysSequences"]: Typecast
[12215]: Typecast;
["PgCatalog.Types.PgStatioSysSequencesArray"]: Typecast
[12220]: Typecast;
["PgCatalog.Types.PgStatioUserSequences"]: Typecast
[12219]: Typecast;
["PgCatalog.Types.PgStatioUserSequencesArray"]: Typecast
[12224]: Typecast;
["PgCatalog.Types.PgStatActivity"]: Typecast
[12223]: Typecast;
["PgCatalog.Types.PgStatActivityArray"]: Typecast
[12229]: Typecast;
["PgCatalog.Types.PgStatReplication"]: Typecast
[12228]: Typecast;
["PgCatalog.Types.PgStatReplicationArray"]: Typecast
[12234]: Typecast;
["PgCatalog.Types.PgStatSlru"]: Typecast
[12233]: Typecast;
["PgCatalog.Types.PgStatSlruArray"]: Typecast
[12238]: Typecast;
["PgCatalog.Types.PgStatWalReceiver"]: Typecast
[12237]: Typecast;
["PgCatalog.Types.PgStatWalReceiverArray"]: Typecast
[12242]: Typecast;
["PgCatalog.Types.PgStatRecoveryPrefetch"]: Typecast
[12241]: Typecast;
["PgCatalog.Types.PgStatRecoveryPrefetchArray"]: Typecast
[12246]: Typecast;
["PgCatalog.Types.PgStatSubscription"]: Typecast
[12245]: Typecast;
["PgCatalog.Types.PgStatSubscriptionArray"]: Typecast
[12251]: Typecast;
["PgCatalog.Types.PgStatSsl"]: Typecast
[12250]: Typecast;
["PgCatalog.Types.PgStatSslArray"]: Typecast
[12255]: Typecast;
["PgCatalog.Types.PgStatGssapi"]: Typecast
[12254]: Typecast;
["PgCatalog.Types.PgStatGssapiArray"]: Typecast
[12259]: Typecast;
["PgCatalog.Types.PgReplicationSlots"]: Typecast
[12258]: Typecast;
["PgCatalog.Types.PgReplicationSlotsArray"]: Typecast
[12264]: Typecast;
["PgCatalog.Types.PgStatReplicationSlots"]: Typecast
[12263]: Typecast;
["PgCatalog.Types.PgStatReplicationSlotsArray"]: Typecast
[12268]: Typecast;
["PgCatalog.Types.PgStatDatabase"]: Typecast
[12267]: Typecast;
["PgCatalog.Types.PgStatDatabaseArray"]: Typecast
[12273]: Typecast;
["PgCatalog.Types.PgStatDatabaseConflicts"]: Typecast
[12272]: Typecast;
["PgCatalog.Types.PgStatDatabaseConflictsArray"]: Typecast
[12277]: Typecast;
["PgCatalog.Types.PgStatUserFunctions"]: Typecast
[12276]: Typecast;
["PgCatalog.Types.PgStatUserFunctionsArray"]: Typecast
[12282]: Typecast;
["PgCatalog.Types.PgStatXactUserFunctions"]: Typecast
[12281]: Typecast;
["PgCatalog.Types.PgStatXactUserFunctionsArray"]: Typecast
[12287]: Typecast;
["PgCatalog.Types.PgStatArchiver"]: Typecast
[12286]: Typecast;
["PgCatalog.Types.PgStatArchiverArray"]: Typecast
[12291]: Typecast;
["PgCatalog.Types.PgStatBgwriter"]: Typecast
[12290]: Typecast;
["PgCatalog.Types.PgStatBgwriterArray"]: Typecast
[12295]: Typecast;
["PgCatalog.Types.PgStatIo"]: Typecast
[12294]: Typecast;
["PgCatalog.Types.PgStatIoArray"]: Typecast
[12299]: Typecast;
["PgCatalog.Types.PgStatWal"]: Typecast
[12298]: Typecast;
["PgCatalog.Types.PgStatWalArray"]: Typecast
[12303]: Typecast;
["PgCatalog.Types.PgStatProgressAnalyze"]: Typecast
[12302]: Typecast;
["PgCatalog.Types.PgStatProgressAnalyzeArray"]: Typecast
[12308]: Typecast;
["PgCatalog.Types.PgStatProgressVacuum"]: Typecast
[12307]: Typecast;
["PgCatalog.Types.PgStatProgressVacuumArray"]: Typecast
[12313]: Typecast;
["PgCatalog.Types.PgStatProgressCluster"]: Typecast
[12312]: Typecast;
["PgCatalog.Types.PgStatProgressClusterArray"]: Typecast
[12318]: Typecast;
["PgCatalog.Types.PgStatProgressCreateIndex"]: Typecast
[12317]: Typecast;
["PgCatalog.Types.PgStatProgressCreateIndexArray"]: Typecast
[12323]: Typecast;
["PgCatalog.Types.PgStatProgressBasebackup"]: Typecast
[12322]: Typecast;
["PgCatalog.Types.PgStatProgressBasebackupArray"]: Typecast
[12328]: Typecast;
["PgCatalog.Types.PgStatProgressCopy"]: Typecast
[12327]: Typecast;
["PgCatalog.Types.PgStatProgressCopyArray"]: Typecast
[12333]: Typecast;
["PgCatalog.Types.PgUserMappings"]: Typecast
[12332]: Typecast;
["PgCatalog.Types.PgUserMappingsArray"]: Typecast
[12338]: Typecast;
["PgCatalog.Types.PgReplicationOriginStatus"]: Typecast
[12337]: Typecast;
["PgCatalog.Types.PgReplicationOriginStatusArray"]: Typecast
[12342]: Typecast;
["PgCatalog.Types.PgStatSubscriptionStats"]: Typecast
[12341]: Typecast;
["PgCatalog.Types.PgStatSubscriptionStatsArray"]: Typecast
[2690]: Typecast;
["PgCatalog.Types.PgProcOidIndex"]: Typecast
[2691]: Typecast;
["PgCatalog.Types.PgProcPronameArgsNspIndex"]: Typecast
[2703]: Typecast;
["PgCatalog.Types.PgTypeOidIndex"]: Typecast
[2704]: Typecast;
["PgCatalog.Types.PgTypeTypnameNspIndex"]: Typecast
[2658]: Typecast;
["PgCatalog.Types.PgAttributeRelidAttnamIndex"]: Typecast
[2659]: Typecast;
["PgCatalog.Types.PgAttributeRelidAttnumIndex"]: Typecast
[2662]: Typecast;
["PgCatalog.Types.PgClassOidIndex"]: Typecast
[2663]: Typecast;
["PgCatalog.Types.PgClassRelnameNspIndex"]: Typecast
[3455]: Typecast;
["PgCatalog.Types.PgClassTblspcRelfilenodeIndex"]: Typecast
[2656]: Typecast;
["PgCatalog.Types.PgAttrdefAdrelidAdnumIndex"]: Typecast
[2657]: Typecast;
["PgCatalog.Types.PgAttrdefOidIndex"]: Typecast
[2664]: Typecast;
["PgCatalog.Types.PgConstraintConnameNspIndex"]: Typecast
[2665]: Typecast;
["PgCatalog.Types.PgConstraintConrelidContypidConnameIndex"]: Typecast
[2666]: Typecast;
["PgCatalog.Types.PgConstraintContypidIndex"]: Typecast
[2667]: Typecast;
["PgCatalog.Types.PgConstraintOidIndex"]: Typecast
[2579]: Typecast;
["PgCatalog.Types.PgConstraintConparentidIndex"]: Typecast
[2680]: Typecast;
["PgCatalog.Types.PgInheritsRelidSeqnoIndex"]: Typecast
[2187]: Typecast;
["PgCatalog.Types.PgInheritsParentIndex"]: Typecast
[2678]: Typecast;
["PgCatalog.Types.PgIndexIndrelidIndex"]: Typecast
[2679]: Typecast;
["PgCatalog.Types.PgIndexIndexrelidIndex"]: Typecast
[2688]: Typecast;
["PgCatalog.Types.PgOperatorOidIndex"]: Typecast
[2689]: Typecast;
["PgCatalog.Types.PgOperatorOprnameLRNIndex"]: Typecast
[2754]: Typecast;
["PgCatalog.Types.PgOpfamilyAmNameNspIndex"]: Typecast
[2755]: Typecast;
["PgCatalog.Types.PgOpfamilyOidIndex"]: Typecast
[2686]: Typecast;
["PgCatalog.Types.PgOpclassAmNameNspIndex"]: Typecast
[2687]: Typecast;
["PgCatalog.Types.PgOpclassOidIndex"]: Typecast
[2651]: Typecast;
["PgCatalog.Types.PgAmNameIndex"]: Typecast
[2652]: Typecast;
["PgCatalog.Types.PgAmOidIndex"]: Typecast
[2653]: Typecast;
["PgCatalog.Types.PgAmopFamStratIndex"]: Typecast
[2654]: Typecast;
["PgCatalog.Types.PgAmopOprFamIndex"]: Typecast
[2756]: Typecast;
["PgCatalog.Types.PgAmopOidIndex"]: Typecast
[2655]: Typecast;
["PgCatalog.Types.PgAmprocFamProcIndex"]: Typecast
[2757]: Typecast;
["PgCatalog.Types.PgAmprocOidIndex"]: Typecast
[2681]: Typecast;
["PgCatalog.Types.PgLanguageNameIndex"]: Typecast
[2682]: Typecast;
["PgCatalog.Types.PgLanguageOidIndex"]: Typecast
[2996]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadataOidIndex"]: Typecast
[2683]: Typecast;
["PgCatalog.Types.PgLargeobjectLoidPnIndex"]: Typecast
[2650]: Typecast;
["PgCatalog.Types.PgAggregateFnoidIndex"]: Typecast
[2696]: Typecast;
["PgCatalog.Types.PgStatisticRelidAttInhIndex"]: Typecast
[3380]: Typecast;
["PgCatalog.Types.PgStatisticExtOidIndex"]: Typecast
[3997]: Typecast;
["PgCatalog.Types.PgStatisticExtNameIndex"]: Typecast
[3379]: Typecast;
["PgCatalog.Types.PgStatisticExtRelidIndex"]: Typecast
[3433]: Typecast;
["PgCatalog.Types.PgStatisticExtDataStxoidInhIndex"]: Typecast
[2692]: Typecast;
["PgCatalog.Types.PgRewriteOidIndex"]: Typecast
[2693]: Typecast;
["PgCatalog.Types.PgRewriteRelRulenameIndex"]: Typecast
[2699]: Typecast;
["PgCatalog.Types.PgTriggerTgconstraintIndex"]: Typecast
[2701]: Typecast;
["PgCatalog.Types.PgTriggerTgrelidTgnameIndex"]: Typecast
[2702]: Typecast;
["PgCatalog.Types.PgTriggerOidIndex"]: Typecast
[3467]: Typecast;
["PgCatalog.Types.PgEventTriggerEvtnameIndex"]: Typecast
[3468]: Typecast;
["PgCatalog.Types.PgEventTriggerOidIndex"]: Typecast
[2675]: Typecast;
["PgCatalog.Types.PgDescriptionOCOIndex"]: Typecast
[2660]: Typecast;
["PgCatalog.Types.PgCastOidIndex"]: Typecast
[2661]: Typecast;
["PgCatalog.Types.PgCastSourceTargetIndex"]: Typecast
[3502]: Typecast;
["PgCatalog.Types.PgEnumOidIndex"]: Typecast
[3503]: Typecast;
["PgCatalog.Types.PgEnumTypidLabelIndex"]: Typecast
[3534]: Typecast;
["PgCatalog.Types.PgEnumTypidSortorderIndex"]: Typecast
[2684]: Typecast;
["PgCatalog.Types.PgNamespaceNspnameIndex"]: Typecast
[2685]: Typecast;
["PgCatalog.Types.PgNamespaceOidIndex"]: Typecast
[2668]: Typecast;
["PgCatalog.Types.PgConversionDefaultIndex"]: Typecast
[2669]: Typecast;
["PgCatalog.Types.PgConversionNameNspIndex"]: Typecast
[2670]: Typecast;
["PgCatalog.Types.PgConversionOidIndex"]: Typecast
[2673]: Typecast;
["PgCatalog.Types.PgDependDependerIndex"]: Typecast
[2674]: Typecast;
["PgCatalog.Types.PgDependReferenceIndex"]: Typecast
[2671]: Typecast;
["PgCatalog.Types.PgDatabaseDatnameIndex"]: Typecast
[2672]: Typecast;
["PgCatalog.Types.PgDatabaseOidIndex"]: Typecast
[2965]: Typecast;
["PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex"]: Typecast
[2697]: Typecast;
["PgCatalog.Types.PgTablespaceOidIndex"]: Typecast
[2698]: Typecast;
["PgCatalog.Types.PgTablespaceSpcnameIndex"]: Typecast
[2676]: Typecast;
["PgCatalog.Types.PgAuthidRolnameIndex"]: Typecast
[2677]: Typecast;
["PgCatalog.Types.PgAuthidOidIndex"]: Typecast
[6303]: Typecast;
["PgCatalog.Types.PgAuthMembersOidIndex"]: Typecast
[2694]: Typecast;
["PgCatalog.Types.PgAuthMembersRoleMemberIndex"]: Typecast
[2695]: Typecast;
["PgCatalog.Types.PgAuthMembersMemberRoleIndex"]: Typecast
[6302]: Typecast;
["PgCatalog.Types.PgAuthMembersGrantorIndex"]: Typecast
[1232]: Typecast;
["PgCatalog.Types.PgShdependDependerIndex"]: Typecast
[1233]: Typecast;
["PgCatalog.Types.PgShdependReferenceIndex"]: Typecast
[2397]: Typecast;
["PgCatalog.Types.PgShdescriptionOCIndex"]: Typecast
[3608]: Typecast;
["PgCatalog.Types.PgTsConfigCfgnameIndex"]: Typecast
[3712]: Typecast;
["PgCatalog.Types.PgTsConfigOidIndex"]: Typecast
[3609]: Typecast;
["PgCatalog.Types.PgTsConfigMapIndex"]: Typecast
[3604]: Typecast;
["PgCatalog.Types.PgTsDictDictnameIndex"]: Typecast
[3605]: Typecast;
["PgCatalog.Types.PgTsDictOidIndex"]: Typecast
[3606]: Typecast;
["PgCatalog.Types.PgTsParserPrsnameIndex"]: Typecast
[3607]: Typecast;
["PgCatalog.Types.PgTsParserOidIndex"]: Typecast
[3766]: Typecast;
["PgCatalog.Types.PgTsTemplateTmplnameIndex"]: Typecast
[3767]: Typecast;
["PgCatalog.Types.PgTsTemplateOidIndex"]: Typecast
[3080]: Typecast;
["PgCatalog.Types.PgExtensionOidIndex"]: Typecast
[3081]: Typecast;
["PgCatalog.Types.PgExtensionNameIndex"]: Typecast
[112]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperOidIndex"]: Typecast
[548]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperNameIndex"]: Typecast
[113]: Typecast;
["PgCatalog.Types.PgForeignServerOidIndex"]: Typecast
[549]: Typecast;
["PgCatalog.Types.PgForeignServerNameIndex"]: Typecast
[174]: Typecast;
["PgCatalog.Types.PgUserMappingOidIndex"]: Typecast
[175]: Typecast;
["PgCatalog.Types.PgUserMappingUserServerIndex"]: Typecast
[3119]: Typecast;
["PgCatalog.Types.PgForeignTableRelidIndex"]: Typecast
[3257]: Typecast;
["PgCatalog.Types.PgPolicyOidIndex"]: Typecast
[3258]: Typecast;
["PgCatalog.Types.PgPolicyPolrelidPolnameIndex"]: Typecast
[6001]: Typecast;
["PgCatalog.Types.PgReplicationOriginRoiidentIndex"]: Typecast
[6002]: Typecast;
["PgCatalog.Types.PgReplicationOriginRonameIndex"]: Typecast
[827]: Typecast;
["PgCatalog.Types.PgDefaultAclRoleNspObjIndex"]: Typecast
[828]: Typecast;
["PgCatalog.Types.PgDefaultAclOidIndex"]: Typecast
[3395]: Typecast;
["PgCatalog.Types.PgInitPrivsOCOIndex"]: Typecast
[3597]: Typecast;
["PgCatalog.Types.PgSeclabelObjectIndex"]: Typecast
[3593]: Typecast;
["PgCatalog.Types.PgShseclabelObjectIndex"]: Typecast
[3164]: Typecast;
["PgCatalog.Types.PgCollationNameEncNspIndex"]: Typecast
[3085]: Typecast;
["PgCatalog.Types.PgCollationOidIndex"]: Typecast
[6246]: Typecast;
["PgCatalog.Types.PgParameterAclParnameIndex"]: Typecast
[6247]: Typecast;
["PgCatalog.Types.PgParameterAclOidIndex"]: Typecast
[3351]: Typecast;
["PgCatalog.Types.PgPartitionedTablePartrelidIndex"]: Typecast
[3542]: Typecast;
["PgCatalog.Types.PgRangeRngtypidIndex"]: Typecast
[2228]: Typecast;
["PgCatalog.Types.PgRangeRngmultitypidIndex"]: Typecast
[3574]: Typecast;
["PgCatalog.Types.PgTransformOidIndex"]: Typecast
[3575]: Typecast;
["PgCatalog.Types.PgTransformTypeLangIndex"]: Typecast
[5002]: Typecast;
["PgCatalog.Types.PgSequenceSeqrelidIndex"]: Typecast
[6110]: Typecast;
["PgCatalog.Types.PgPublicationOidIndex"]: Typecast
[6111]: Typecast;
["PgCatalog.Types.PgPublicationPubnameIndex"]: Typecast
[6238]: Typecast;
["PgCatalog.Types.PgPublicationNamespaceOidIndex"]: Typecast
[6239]: Typecast;
["PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex"]: Typecast
[6112]: Typecast;
["PgCatalog.Types.PgPublicationRelOidIndex"]: Typecast
[6113]: Typecast;
["PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex"]: Typecast
[6116]: Typecast;
["PgCatalog.Types.PgPublicationRelPrpubidIndex"]: Typecast
[6114]: Typecast;
["PgCatalog.Types.PgSubscriptionOidIndex"]: Typecast
[6115]: Typecast;
["PgCatalog.Types.PgSubscriptionSubnameIndex"]: Typecast
[6117]: Typecast;
["PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex"]: Typecast
[13488]: Typecast;
["InformationSchema.Types.CardinalNumber"]: Typecast
[13487]: Typecast;
["InformationSchema.Types.CardinalNumberArray"]: Typecast
[13491]: Typecast;
["InformationSchema.Types.CharacterData"]: Typecast
[13490]: Typecast;
["InformationSchema.Types.CharacterDataArray"]: Typecast
[13493]: Typecast;
["InformationSchema.Types.SqlIdentifier"]: Typecast
[13492]: Typecast;
["InformationSchema.Types.SqlIdentifierArray"]: Typecast
[13496]: Typecast;
["InformationSchema.Types.InformationSchemaCatalogName"]: Typecast
[13495]: Typecast;
["InformationSchema.Types.InformationSchemaCatalogNameArray"]: Typecast
[13499]: Typecast;
["InformationSchema.Types.TimeStamp"]: Typecast
[13498]: Typecast;
["InformationSchema.Types.TimeStampArray"]: Typecast
[13501]: Typecast;
["InformationSchema.Types.YesOrNo"]: Typecast
[13500]: Typecast;
["InformationSchema.Types.YesOrNoArray"]: Typecast
[13505]: Typecast;
["InformationSchema.Types.ApplicableRoles"]: Typecast
[13504]: Typecast;
["InformationSchema.Types.ApplicableRolesArray"]: Typecast
[13510]: Typecast;
["InformationSchema.Types.AdministrableRoleAuthorizations"]: Typecast
[13509]: Typecast;
["InformationSchema.Types.AdministrableRoleAuthorizationsArray"]: Typecast
[13514]: Typecast;
["InformationSchema.Types.Attributes"]: Typecast
[13513]: Typecast;
["InformationSchema.Types.AttributesArray"]: Typecast
[13519]: Typecast;
["InformationSchema.Types.CharacterSets"]: Typecast
[13518]: Typecast;
["InformationSchema.Types.CharacterSetsArray"]: Typecast
[13524]: Typecast;
["InformationSchema.Types.CheckConstraintRoutineUsage"]: Typecast
[13523]: Typecast;
["InformationSchema.Types.CheckConstraintRoutineUsageArray"]: Typecast
[13529]: Typecast;
["InformationSchema.Types.CheckConstraints"]: Typecast
[13528]: Typecast;
["InformationSchema.Types.CheckConstraintsArray"]: Typecast
[13534]: Typecast;
["InformationSchema.Types.Collations"]: Typecast
[13533]: Typecast;
["InformationSchema.Types.CollationsArray"]: Typecast
[13539]: Typecast;
["InformationSchema.Types.CollationCharacterSetApplicability"]: Typecast
[13538]: Typecast;
["InformationSchema.Types.CollationCharacterSetApplicabilityArray"]: Typecast
[13544]: Typecast;
["InformationSchema.Types.ColumnColumnUsage"]: Typecast
[13543]: Typecast;
["InformationSchema.Types.ColumnColumnUsageArray"]: Typecast
[13549]: Typecast;
["InformationSchema.Types.ColumnDomainUsage"]: Typecast
[13548]: Typecast;
["InformationSchema.Types.ColumnDomainUsageArray"]: Typecast
[13554]: Typecast;
["InformationSchema.Types.ColumnPrivileges"]: Typecast
[13553]: Typecast;
["InformationSchema.Types.ColumnPrivilegesArray"]: Typecast
[13559]: Typecast;
["InformationSchema.Types.ColumnUdtUsage"]: Typecast
[13558]: Typecast;
["InformationSchema.Types.ColumnUdtUsageArray"]: Typecast
[13564]: Typecast;
["InformationSchema.Types.Columns"]: Typecast
[13563]: Typecast;
["InformationSchema.Types.ColumnsArray"]: Typecast
[13569]: Typecast;
["InformationSchema.Types.ConstraintColumnUsage"]: Typecast
[13568]: Typecast;
["InformationSchema.Types.ConstraintColumnUsageArray"]: Typecast
[13574]: Typecast;
["InformationSchema.Types.ConstraintTableUsage"]: Typecast
[13573]: Typecast;
["InformationSchema.Types.ConstraintTableUsageArray"]: Typecast
[13579]: Typecast;
["InformationSchema.Types.DomainConstraints"]: Typecast
[13578]: Typecast;
["InformationSchema.Types.DomainConstraintsArray"]: Typecast
[13584]: Typecast;
["InformationSchema.Types.DomainUdtUsage"]: Typecast
[13583]: Typecast;
["InformationSchema.Types.DomainUdtUsageArray"]: Typecast
[13589]: Typecast;
["InformationSchema.Types.Domains"]: Typecast
[13588]: Typecast;
["InformationSchema.Types.DomainsArray"]: Typecast
[13594]: Typecast;
["InformationSchema.Types.EnabledRoles"]: Typecast
[13593]: Typecast;
["InformationSchema.Types.EnabledRolesArray"]: Typecast
[13598]: Typecast;
["InformationSchema.Types.KeyColumnUsage"]: Typecast
[13597]: Typecast;
["InformationSchema.Types.KeyColumnUsageArray"]: Typecast
[13603]: Typecast;
["InformationSchema.Types.Parameters"]: Typecast
[13602]: Typecast;
["InformationSchema.Types.ParametersArray"]: Typecast
[13608]: Typecast;
["InformationSchema.Types.ReferentialConstraints"]: Typecast
[13607]: Typecast;
["InformationSchema.Types.ReferentialConstraintsArray"]: Typecast
[13613]: Typecast;
["InformationSchema.Types.RoleColumnGrants"]: Typecast
[13612]: Typecast;
["InformationSchema.Types.RoleColumnGrantsArray"]: Typecast
[13617]: Typecast;
["InformationSchema.Types.RoutineColumnUsage"]: Typecast
[13616]: Typecast;
["InformationSchema.Types.RoutineColumnUsageArray"]: Typecast
[13622]: Typecast;
["InformationSchema.Types.RoutinePrivileges"]: Typecast
[13621]: Typecast;
["InformationSchema.Types.RoutinePrivilegesArray"]: Typecast
[13627]: Typecast;
["InformationSchema.Types.RoleRoutineGrants"]: Typecast
[13626]: Typecast;
["InformationSchema.Types.RoleRoutineGrantsArray"]: Typecast
[13631]: Typecast;
["InformationSchema.Types.RoutineRoutineUsage"]: Typecast
[13630]: Typecast;
["InformationSchema.Types.RoutineRoutineUsageArray"]: Typecast
[13636]: Typecast;
["InformationSchema.Types.RoutineSequenceUsage"]: Typecast
[13635]: Typecast;
["InformationSchema.Types.RoutineSequenceUsageArray"]: Typecast
[13641]: Typecast;
["InformationSchema.Types.RoutineTableUsage"]: Typecast
[13640]: Typecast;
["InformationSchema.Types.RoutineTableUsageArray"]: Typecast
[13646]: Typecast;
["InformationSchema.Types.Routines"]: Typecast
[13645]: Typecast;
["InformationSchema.Types.RoutinesArray"]: Typecast
[13651]: Typecast;
["InformationSchema.Types.Schemata"]: Typecast
[13650]: Typecast;
["InformationSchema.Types.SchemataArray"]: Typecast
[13655]: Typecast;
["InformationSchema.Types.Sequences"]: Typecast
[13654]: Typecast;
["InformationSchema.Types.SequencesArray"]: Typecast
[13660]: Typecast;
["InformationSchema.Types.SqlFeatures"]: Typecast
[13659]: Typecast;
["InformationSchema.Types.SqlFeaturesArray"]: Typecast
[13665]: Typecast;
["InformationSchema.Types.SqlImplementationInfo"]: Typecast
[13664]: Typecast;
["InformationSchema.Types.SqlImplementationInfoArray"]: Typecast
[13670]: Typecast;
["InformationSchema.Types.SqlParts"]: Typecast
[13669]: Typecast;
["InformationSchema.Types.SqlPartsArray"]: Typecast
[13675]: Typecast;
["InformationSchema.Types.SqlSizing"]: Typecast
[13674]: Typecast;
["InformationSchema.Types.SqlSizingArray"]: Typecast
[13680]: Typecast;
["InformationSchema.Types.TableConstraints"]: Typecast
[13679]: Typecast;
["InformationSchema.Types.TableConstraintsArray"]: Typecast
[13685]: Typecast;
["InformationSchema.Types.TablePrivileges"]: Typecast
[13684]: Typecast;
["InformationSchema.Types.TablePrivilegesArray"]: Typecast
[13690]: Typecast;
["InformationSchema.Types.RoleTableGrants"]: Typecast
[13689]: Typecast;
["InformationSchema.Types.RoleTableGrantsArray"]: Typecast
[13694]: Typecast;
["InformationSchema.Types.Tables"]: Typecast
[13693]: Typecast;
["InformationSchema.Types.TablesArray"]: Typecast
[13699]: Typecast;
["InformationSchema.Types.Transforms"]: Typecast
[13698]: Typecast;
["InformationSchema.Types.TransformsArray"]: Typecast
[13704]: Typecast;
["InformationSchema.Types.TriggeredUpdateColumns"]: Typecast
[13703]: Typecast;
["InformationSchema.Types.TriggeredUpdateColumnsArray"]: Typecast
[13709]: Typecast;
["InformationSchema.Types.Triggers"]: Typecast
[13708]: Typecast;
["InformationSchema.Types.TriggersArray"]: Typecast
[13714]: Typecast;
["InformationSchema.Types.UdtPrivileges"]: Typecast
[13713]: Typecast;
["InformationSchema.Types.UdtPrivilegesArray"]: Typecast
[13719]: Typecast;
["InformationSchema.Types.RoleUdtGrants"]: Typecast
[13718]: Typecast;
["InformationSchema.Types.RoleUdtGrantsArray"]: Typecast
[13723]: Typecast;
["InformationSchema.Types.UsagePrivileges"]: Typecast
[13722]: Typecast;
["InformationSchema.Types.UsagePrivilegesArray"]: Typecast
[13728]: Typecast;
["InformationSchema.Types.RoleUsageGrants"]: Typecast
[13727]: Typecast;
["InformationSchema.Types.RoleUsageGrantsArray"]: Typecast
[13732]: Typecast;
["InformationSchema.Types.UserDefinedTypes"]: Typecast
[13731]: Typecast;
["InformationSchema.Types.UserDefinedTypesArray"]: Typecast
[13737]: Typecast;
["InformationSchema.Types.ViewColumnUsage"]: Typecast
[13736]: Typecast;
["InformationSchema.Types.ViewColumnUsageArray"]: Typecast
[13742]: Typecast;
["InformationSchema.Types.ViewRoutineUsage"]: Typecast
[13741]: Typecast;
["InformationSchema.Types.ViewRoutineUsageArray"]: Typecast
[13747]: Typecast;
["InformationSchema.Types.ViewTableUsage"]: Typecast
[13746]: Typecast;
["InformationSchema.Types.ViewTableUsageArray"]: Typecast
[13752]: Typecast;
["InformationSchema.Types.Views"]: Typecast
[13751]: Typecast;
["InformationSchema.Types.ViewsArray"]: Typecast
[13757]: Typecast;
["InformationSchema.Types.DataTypePrivileges"]: Typecast
[13756]: Typecast;
["InformationSchema.Types.DataTypePrivilegesArray"]: Typecast
[13762]: Typecast;
["InformationSchema.Types.ElementTypes"]: Typecast
[13761]: Typecast;
["InformationSchema.Types.ElementTypesArray"]: Typecast
[13767]: Typecast;
["InformationSchema.Types.PgForeignTableColumns"]: Typecast
[13772]: Typecast;
["InformationSchema.Types.ColumnOptions"]: Typecast
[13771]: Typecast;
["InformationSchema.Types.ColumnOptionsArray"]: Typecast
[13776]: Typecast;
["InformationSchema.Types.PgForeignDataWrappers"]: Typecast
[13780]: Typecast;
["InformationSchema.Types.ForeignDataWrapperOptions"]: Typecast
[13779]: Typecast;
["InformationSchema.Types.ForeignDataWrapperOptionsArray"]: Typecast
[13784]: Typecast;
["InformationSchema.Types.ForeignDataWrappers"]: Typecast
[13783]: Typecast;
["InformationSchema.Types.ForeignDataWrappersArray"]: Typecast
[13788]: Typecast;
["InformationSchema.Types.PgForeignServers"]: Typecast
[13793]: Typecast;
["InformationSchema.Types.ForeignServerOptions"]: Typecast
[13792]: Typecast;
["InformationSchema.Types.ForeignServerOptionsArray"]: Typecast
[13797]: Typecast;
["InformationSchema.Types.ForeignServers"]: Typecast
[13796]: Typecast;
["InformationSchema.Types.ForeignServersArray"]: Typecast
[13801]: Typecast;
["InformationSchema.Types.PgForeignTables"]: Typecast
[13806]: Typecast;
["InformationSchema.Types.ForeignTableOptions"]: Typecast
[13805]: Typecast;
["InformationSchema.Types.ForeignTableOptionsArray"]: Typecast
[13810]: Typecast;
["InformationSchema.Types.ForeignTables"]: Typecast
[13809]: Typecast;
["InformationSchema.Types.ForeignTablesArray"]: Typecast
[13814]: Typecast;
["InformationSchema.Types.PgUserMappings"]: Typecast
[13819]: Typecast;
["InformationSchema.Types.UserMappingOptions"]: Typecast
[13818]: Typecast;
["InformationSchema.Types.UserMappingOptionsArray"]: Typecast
[13824]: Typecast;
["InformationSchema.Types.UserMappings"]: Typecast
[13823]: Typecast;
["InformationSchema.Types.UserMappingsArray"]: Typecast
[49240]: Typecast;
["Public.Types.Spheroid"]: Typecast
[49243]: Typecast;
["Public.Types.SpheroidArray"]: Typecast
[49244]: Typecast;
["Public.Types.Geometry"]: Typecast
[49252]: Typecast;
["Public.Types.GeometryArray"]: Typecast
[49271]: Typecast;
["Public.Types.Box3d"]: Typecast
[49274]: Typecast;
["Public.Types.Box3dArray"]: Typecast
[49275]: Typecast;
["Public.Types.Box2d"]: Typecast
[49278]: Typecast;
["Public.Types.Box2dArray"]: Typecast
[49279]: Typecast;
["Public.Types.Box2df"]: Typecast
[49282]: Typecast;
["Public.Types.Box2dfArray"]: Typecast
[49283]: Typecast;
["Public.Types.Gidx"]: Typecast
[49286]: Typecast;
["Public.Types.GidxArray"]: Typecast
[49551]: Typecast;
["Public.Types.GeometryDump"]: Typecast
[49550]: Typecast;
["Public.Types.GeometryDumpArray"]: Typecast
[49558]: Typecast;
["Public.Types.SpatialRefSys"]: Typecast
[49557]: Typecast;
["Public.Types.SpatialRefSysArray"]: Typecast
[49673]: Typecast;
["Public.Types.ValidDetail"]: Typecast
[49672]: Typecast;
["Public.Types.ValidDetailArray"]: Typecast
[49950]: Typecast;
["Public.Types.Geography"]: Typecast
[49956]: Typecast;
["Public.Types.GeographyArray"]: Typecast
[49974]: Typecast;
["Public.Types.GeographyColumns"]: Typecast
[49973]: Typecast;
["Public.Types.GeographyColumnsArray"]: Typecast
[50123]: Typecast;
["Public.Types.GeometryColumns"]: Typecast
[50122]: Typecast;
["Public.Types.GeometryColumnsArray"]: Typecast
[50316]: Typecast;
["Public.Types.NycCensusBlocks"]: Typecast
[50315]: Typecast;
["Public.Types.NycCensusBlocksArray"]: Typecast
[50322]: Typecast;
["Public.Types.NycHomicides"]: Typecast
[50321]: Typecast;
["Public.Types.NycHomicidesArray"]: Typecast
[50328]: Typecast;
["Public.Types.NycNeighborhoods"]: Typecast
[50327]: Typecast;
["Public.Types.NycNeighborhoodsArray"]: Typecast
[50334]: Typecast;
["Public.Types.NycStreets"]: Typecast
[50333]: Typecast;
["Public.Types.NycStreetsArray"]: Typecast
[50340]: Typecast;
["Public.Types.NycSubwayStations"]: Typecast
[50339]: Typecast;
["Public.Types.NycSubwayStationsArray"]: Typecast
[49562]: Typecast;
["Public.Types.SpatialRefSysPkey"]: Typecast
[50396]: Typecast;
["Public.Types.NycCensusBlocksPkey"]: Typecast
[50398]: Typecast;
["Public.Types.NycHomicidesPkey"]: Typecast
[50400]: Typecast;
["Public.Types.NycNeighborhoodsPkey"]: Typecast
[50402]: Typecast;
["Public.Types.NycStreetsPkey"]: Typecast
[50404]: Typecast;
["Public.Types.NycSubwayStationsPkey"]: Typecast
[50406]: Typecast;
["Public.Types.NycCensusBlocksGeomIdx"]: Typecast
[50407]: Typecast;
["Public.Types.NycHomicidesGeomIdx"]: Typecast
[50408]: Typecast;
["Public.Types.NycNeighborhoodsGeomIdx"]: Typecast
[50409]: Typecast;
["Public.Types.NycStreetsGeomIdx"]: Typecast
[50410]: Typecast;
["Public.Types.NycSubwayStationsGeomIdx"]: Typecast
[49586]: Typecast;
["Public.Types.PostgisSrs"]: Typecast
[49587]: Typecast;
["Public.Types.PostgisSrsAll"]: Typecast
[49588]: Typecast;
["Public.Types.PostgisSrsSearch"]: Typecast
[49662]: Typecast;
["Public.Types.StMinimumboundingradius"]: Typecast
[49680]: Typecast;
["Public.Types.StMaximuminscribedcircle"]: Typecast
[49681]: Typecast;
["Public.Types.StLargestemptycircle"]: Typecast
[50151]: Typecast;
["Public.Types.StHexagongrid"]: Typecast
[50152]: Typecast;
["Public.Types.StSquaregrid"]: Typecast

["Public.Procedures.StForcepolygoncw.Parameters"]: Typecast

["Public.Procedures.SpheroidIn.Parameters"]: Typecast

["Public.Procedures.SpheroidOut.Parameters"]: Typecast

["Public.Procedures.GeometryIn.Parameters"]: Typecast

["Public.Procedures.GeometryOut.Parameters"]: Typecast

["Public.Procedures.GeometryTypmodIn.Parameters"]: Typecast

["Public.Procedures.GeometryTypmodOut.Parameters"]: Typecast

["Public.Procedures.GeometryAnalyze.Parameters"]: Typecast

["Public.Procedures.GeometryRecv.Parameters"]: Typecast

["Public.Procedures.GeometrySend.Parameters"]: Typecast

["Public.Procedures.Geometry_4946.Parameters"]: Typecast

["Public.Procedures.Geometry_8997.Parameters"]: Typecast

["Public.Procedures.Point.Parameters"]: Typecast

["Public.Procedures.GeometryB0d8.Parameters"]: Typecast

["Public.Procedures.Path.Parameters"]: Typecast

["Public.Procedures.GeometryF1be.Parameters"]: Typecast

["Public.Procedures.Polygon.Parameters"]: Typecast

["Public.Procedures.StX.Parameters"]: Typecast

["Public.Procedures.StY.Parameters"]: Typecast

["Public.Procedures.StZ.Parameters"]: Typecast

["Public.Procedures.StM.Parameters"]: Typecast

["Public.Procedures.Box3dIn.Parameters"]: Typecast

["Public.Procedures.Box3dOut.Parameters"]: Typecast

["Public.Procedures.Box2dIn.Parameters"]: Typecast

["Public.Procedures.Box2dOut.Parameters"]: Typecast

["Public.Procedures.Box2dfIn.Parameters"]: Typecast

["Public.Procedures.Box2dfOut.Parameters"]: Typecast

["Public.Procedures.GidxIn.Parameters"]: Typecast

["Public.Procedures.GidxOut.Parameters"]: Typecast

["Public.Procedures.GeometryLt.Parameters"]: Typecast

["Public.Procedures.GeometryLe.Parameters"]: Typecast

["Public.Procedures.GeometryGt.Parameters"]: Typecast

["Public.Procedures.GeometryGe.Parameters"]: Typecast

["Public.Procedures.GeometryEq.Parameters"]: Typecast

["Public.Procedures.GeometryCmp.Parameters"]: Typecast

["Public.Procedures.GeometrySortsupport.Parameters"]: Typecast

["Public.Procedures.GeometryHash.Parameters"]: Typecast

["Public.Procedures.GeometryGistDistance_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistCompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistPenalty_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistPicksplit_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistUnion_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistSame_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistDecompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistSortsupport_2d.Parameters"]: Typecast

["Public.Procedures.StForcerhr.Parameters"]: Typecast

["Public.Procedures.PostgisNoop.Parameters"]: Typecast

["Public.Procedures.StForcepolygonccw.Parameters"]: Typecast

["Public.Procedures.GserializedGistSel_2d.Parameters"]: Typecast

["Public.Procedures.GserializedGistSelNd.Parameters"]: Typecast

["Public.Procedures.GserializedGistJoinsel_2d.Parameters"]: Typecast

["Public.Procedures.GserializedGistJoinselNd.Parameters"]: Typecast

["Public.Procedures.GeometryOverlaps.Parameters"]: Typecast

["Public.Procedures.GeometrySame.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCentroid.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceBox.Parameters"]: Typecast

["Public.Procedures.GeometryContains.Parameters"]: Typecast

["Public.Procedures.GeometryWithin.Parameters"]: Typecast

["Public.Procedures.GeometryLeft.Parameters"]: Typecast

["Public.Procedures.GeometryOverleft.Parameters"]: Typecast

["Public.Procedures.GeometryBelow.Parameters"]: Typecast

["Public.Procedures.GeometryOverbelow.Parameters"]: Typecast

["Public.Procedures.GeometryOverright.Parameters"]: Typecast

["Public.Procedures.GeometryRight.Parameters"]: Typecast

["Public.Procedures.GeometryOverabove.Parameters"]: Typecast

["Public.Procedures.GeometryAbove.Parameters"]: Typecast

["Public.Procedures.GeometryGistConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistCompressNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistPenaltyNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistUnionNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistSameNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistDecompressNd.Parameters"]: Typecast

["Public.Procedures.GeometryOverlapsNd.Parameters"]: Typecast

["Public.Procedures.GeometryContainsNd.Parameters"]: Typecast

["Public.Procedures.GeometryWithinNd.Parameters"]: Typecast

["Public.Procedures.GeometrySameNd.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCentroidNd.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCpa.Parameters"]: Typecast

["Public.Procedures.GeometryGistDistanceNd.Parameters"]: Typecast

["Public.Procedures.StShiftlongitude.Parameters"]: Typecast

["Public.Procedures.StWrapx.Parameters"]: Typecast

["Public.Procedures.StXmin.Parameters"]: Typecast

["Public.Procedures.StYmin.Parameters"]: Typecast

["Public.Procedures.StZmin.Parameters"]: Typecast

["Public.Procedures.StXmax.Parameters"]: Typecast

["Public.Procedures.StYmax.Parameters"]: Typecast

["Public.Procedures.StZmax.Parameters"]: Typecast

["Public.Procedures.StExpand_3044.Parameters"]: Typecast

["Public.Procedures.StExpand_3ea7.Parameters"]: Typecast

["Public.Procedures.PostgisGetbbox.Parameters"]: Typecast

["Public.Procedures.StMakebox2d.Parameters"]: Typecast

["Public.Procedures.StEstimatedextentD2f5.Parameters"]: Typecast

["Public.Procedures.StEstimatedextent_27e1.Parameters"]: Typecast

["Public.Procedures.StEstimatedextent_2ec2.Parameters"]: Typecast

["Public.Procedures.StFindextent_27e1.Parameters"]: Typecast

["Public.Procedures.StFindextent_2ec2.Parameters"]: Typecast

["Public.Procedures.PostgisAddbbox.Parameters"]: Typecast

["Public.Procedures.PostgisDropbbox.Parameters"]: Typecast

["Public.Procedures.PostgisHasbbox.Parameters"]: Typecast

["Public.Procedures.StQuantizecoordinates.Parameters"]: Typecast

["Public.Procedures.StMemsize.Parameters"]: Typecast

["Public.Procedures.StSummary_0faa.Parameters"]: Typecast

["Public.Procedures.StNpoints.Parameters"]: Typecast

["Public.Procedures.StNrings.Parameters"]: Typecast

["Public.Procedures.St_3dlength.Parameters"]: Typecast

["Public.Procedures.StLength2d.Parameters"]: Typecast

["Public.Procedures.StLength_0faa.Parameters"]: Typecast

["Public.Procedures.StLengthspheroid.Parameters"]: Typecast

["Public.Procedures.StLength2dspheroid.Parameters"]: Typecast

["Public.Procedures.St_3dperimeter.Parameters"]: Typecast

["Public.Procedures.StPerimeter2d.Parameters"]: Typecast

["Public.Procedures.StPerimeter_0faa.Parameters"]: Typecast

["Public.Procedures.StArea2d.Parameters"]: Typecast

["Public.Procedures.StArea_0faa.Parameters"]: Typecast

["Public.Procedures.StIspolygoncw.Parameters"]: Typecast

["Public.Procedures.StIspolygonccw.Parameters"]: Typecast

["Public.Procedures.StDistancespheroid_0cb2.Parameters"]: Typecast

["Public.Procedures.StDistancespheroidEb6a.Parameters"]: Typecast

["Public.Procedures.StDistanceEb6a.Parameters"]: Typecast

["Public.Procedures.StPointinsidecircle.Parameters"]: Typecast

["Public.Procedures.StAzimuthEb6a.Parameters"]: Typecast

["Public.Procedures.StProject_2077.Parameters"]: Typecast

["Public.Procedures.StProjectE059.Parameters"]: Typecast

["Public.Procedures.StAngleA4a1.Parameters"]: Typecast

["Public.Procedures.StLineextend.Parameters"]: Typecast

["Public.Procedures.StForce2d.Parameters"]: Typecast

["Public.Procedures.StForce3dz.Parameters"]: Typecast

["Public.Procedures.StForce3d.Parameters"]: Typecast

["Public.Procedures.StForce3dm.Parameters"]: Typecast

["Public.Procedures.StForce4d.Parameters"]: Typecast

["Public.Procedures.StForcecollection.Parameters"]: Typecast

["Public.Procedures.StCollectionextractEd82.Parameters"]: Typecast

["Public.Procedures.StCollectionextract_0faa.Parameters"]: Typecast

["Public.Procedures.StCollectionhomogenize.Parameters"]: Typecast

["Public.Procedures.StMulti.Parameters"]: Typecast

["Public.Procedures.StForcecurve.Parameters"]: Typecast

["Public.Procedures.StForcesfs_0faa.Parameters"]: Typecast

["Public.Procedures.StForcesfsF1e2.Parameters"]: Typecast

["Public.Procedures.StExpand_95d4.Parameters"]: Typecast

["Public.Procedures.StExpandF49e.Parameters"]: Typecast

["Public.Procedures.StExpandDeb6.Parameters"]: Typecast

["Public.Procedures.StExpandBf72.Parameters"]: Typecast

["Public.Procedures.StEnvelope.Parameters"]: Typecast

["Public.Procedures.StBoundingdiagonal.Parameters"]: Typecast

["Public.Procedures.StReverse.Parameters"]: Typecast

["Public.Procedures.StScroll.Parameters"]: Typecast

["Public.Procedures.PostgisGeosNoop.Parameters"]: Typecast

["Public.Procedures.StNormalize.Parameters"]: Typecast

["Public.Procedures.StZmflag.Parameters"]: Typecast

["Public.Procedures.StNdims.Parameters"]: Typecast

["Public.Procedures.StAsewkt_0faa.Parameters"]: Typecast

["Public.Procedures.StAsewktEd82.Parameters"]: Typecast

["Public.Procedures.StAstwkb_8607.Parameters"]: Typecast

["Public.Procedures.StAstwkb_1445.Parameters"]: Typecast

["Public.Procedures.StAsewkb_0faa.Parameters"]: Typecast

["Public.Procedures.StAshexewkb_0faa.Parameters"]: Typecast

["Public.Procedures.StAshexewkbF1e2.Parameters"]: Typecast

["Public.Procedures.StAsewkbF1e2.Parameters"]: Typecast

["Public.Procedures.StAslatlontext.Parameters"]: Typecast

["Public.Procedures.Geomfromewkb.Parameters"]: Typecast

["Public.Procedures.StGeomfromewkb.Parameters"]: Typecast

["Public.Procedures.StGeomfromtwkb.Parameters"]: Typecast

["Public.Procedures.Geomfromewkt.Parameters"]: Typecast

["Public.Procedures.StGeomfromewkt.Parameters"]: Typecast

["Public.Procedures.StMakepoint_0aec.Parameters"]: Typecast

["Public.Procedures.StMakepoint_81ec.Parameters"]: Typecast

["Public.Procedures.StMakepoint_570b.Parameters"]: Typecast

["Public.Procedures.StMakepointm.Parameters"]: Typecast

["Public.Procedures.St_3dmakebox.Parameters"]: Typecast

["Public.Procedures.StMakelineF393.Parameters"]: Typecast

["Public.Procedures.StLinefrommultipoint.Parameters"]: Typecast

["Public.Procedures.StMakelineEb6a.Parameters"]: Typecast

["Public.Procedures.StAddpointEb6a.Parameters"]: Typecast

["Public.Procedures.StScale_2077.Parameters"]: Typecast

["Public.Procedures.StAddpointCc0f.Parameters"]: Typecast

["Public.Procedures.StRemovepoint.Parameters"]: Typecast

["Public.Procedures.StSetpoint.Parameters"]: Typecast

["Public.Procedures.StMakeenvelope.Parameters"]: Typecast

["Public.Procedures.StTileenvelope.Parameters"]: Typecast

["Public.Procedures.StMakepolygon_0543.Parameters"]: Typecast

["Public.Procedures.StMakepolygon_0faa.Parameters"]: Typecast

["Public.Procedures.StBuildarea.Parameters"]: Typecast

["Public.Procedures.StPolygonizeF393.Parameters"]: Typecast

["Public.Procedures.StClusterintersectingF393.Parameters"]: Typecast

["Public.Procedures.StClusterwithin_2892.Parameters"]: Typecast

["Public.Procedures.StLinemerge_0faa.Parameters"]: Typecast

["Public.Procedures.StLinemergeCad2.Parameters"]: Typecast

["Public.Procedures.StAffineA659.Parameters"]: Typecast

["Public.Procedures.StAffine_0997.Parameters"]: Typecast

["Public.Procedures.StRotateDeb6.Parameters"]: Typecast

["Public.Procedures.StRotate_6aac.Parameters"]: Typecast

["Public.Procedures.StRotate_8af1.Parameters"]: Typecast

["Public.Procedures.StRotatez.Parameters"]: Typecast

["Public.Procedures.StRotatex.Parameters"]: Typecast

["Public.Procedures.StRotatey.Parameters"]: Typecast

["Public.Procedures.StTranslate_6aac.Parameters"]: Typecast

["Public.Procedures.StTranslate_2077.Parameters"]: Typecast

["Public.Procedures.StScaleEb6a.Parameters"]: Typecast

["Public.Procedures.StScale_8af1.Parameters"]: Typecast

["Public.Procedures.StScale_6aac.Parameters"]: Typecast

["Public.Procedures.StTransscale.Parameters"]: Typecast

["Public.Procedures.StDump.Parameters"]: Typecast

["Public.Procedures.StDumprings.Parameters"]: Typecast

["Public.Procedures.StDumppoints.Parameters"]: Typecast

["Public.Procedures.StDumpsegments.Parameters"]: Typecast

["Public.Procedures.PopulateGeometryColumns_23fc.Parameters"]: Typecast

["Public.Procedures.PopulateGeometryColumns_4174.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_8fbb.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_4617.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_093c.Parameters"]: Typecast

["Public.Procedures.Dropgeometrycolumn_0412.Parameters"]: Typecast

["Public.Procedures.Dropgeometrycolumn_2253.Parameters"]: Typecast

["Public.Procedures.DropgeometrycolumnF11a.Parameters"]: Typecast

["Public.Procedures.Dropgeometrytable_2253.Parameters"]: Typecast

["Public.Procedures.StSegmentizeDeb6.Parameters"]: Typecast

["Public.Procedures.DropgeometrytableF11a.Parameters"]: Typecast

["Public.Procedures.DropgeometrytableBfde.Parameters"]: Typecast

["Public.Procedures.UpdategeometrysridB2ee.Parameters"]: Typecast

["Public.Procedures.Updategeometrysrid_7b58.Parameters"]: Typecast

["Public.Procedures.Updategeometrysrid_11c8.Parameters"]: Typecast

["Public.Procedures.FindSrid.Parameters"]: Typecast

["Public.Procedures.GetProj4FromSrid.Parameters"]: Typecast

["Public.Procedures.StSetsridEd82.Parameters"]: Typecast

["Public.Procedures.StSrid_0faa.Parameters"]: Typecast

["Public.Procedures.PostgisTransformGeometry.Parameters"]: Typecast

["Public.Procedures.PostgisSrsCodes.Parameters"]: Typecast

["Public.Procedures.PostgisSrs.Parameters"]: Typecast

["Public.Procedures.PostgisSrsSearch.Parameters"]: Typecast

["Public.Procedures.StTransformEd82.Parameters"]: Typecast

["Public.Procedures.StTransformF1e2.Parameters"]: Typecast

["Public.Procedures.StTransformEfe6.Parameters"]: Typecast

["Public.Procedures.StTransform_3ad9.Parameters"]: Typecast

["Public.Procedures.PostgisTransformPipelineGeometry.Parameters"]: Typecast

["Public.Procedures.StTransformpipeline.Parameters"]: Typecast

["Public.Procedures.StInversetransformpipeline.Parameters"]: Typecast

["Public.Procedures.PostgisExtensionsUpgrade.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointDeb6.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoints_1c13.Parameters"]: Typecast

["Public.Procedures.StLinesubstring_2077.Parameters"]: Typecast

["Public.Procedures.StLinelocatepointEb6a.Parameters"]: Typecast

["Public.Procedures.StAddmeasure.Parameters"]: Typecast

["Public.Procedures.StClosestpointofapproach.Parameters"]: Typecast

["Public.Procedures.Box2d_0faa.Parameters"]: Typecast

["Public.Procedures.Box3d_0faa.Parameters"]: Typecast

["Public.Procedures.Box_0faa.Parameters"]: Typecast

["Public.Procedures.Box2d_8784.Parameters"]: Typecast

["Public.Procedures.Box3dF5fa.Parameters"]: Typecast

["Public.Procedures.Box_8784.Parameters"]: Typecast

["Public.Procedures.Text.Parameters"]: Typecast

["Public.Procedures.Box3dtobox.Parameters"]: Typecast

["Public.Procedures.GeometryF5fa.Parameters"]: Typecast

["Public.Procedures.Geometry_8784.Parameters"]: Typecast

["Public.Procedures.GeometryE728.Parameters"]: Typecast

["Public.Procedures.Geometry_2d19.Parameters"]: Typecast

["Public.Procedures.Bytea_0faa.Parameters"]: Typecast

["Public.Procedures.StSimplifyDeb6.Parameters"]: Typecast

["Public.Procedures.StSimplify_1c13.Parameters"]: Typecast

["Public.Procedures.StSimplifyvw.Parameters"]: Typecast

["Public.Procedures.StSeteffectivearea.Parameters"]: Typecast

["Public.Procedures.StFilterbym.Parameters"]: Typecast

["Public.Procedures.StChaikinsmoothing.Parameters"]: Typecast

["Public.Procedures.StSnaptogridBf72.Parameters"]: Typecast

["Public.Procedures.StSnaptogrid_2077.Parameters"]: Typecast

["Public.Procedures.StSnaptogridDeb6.Parameters"]: Typecast

["Public.Procedures.StSnaptogrid_7713.Parameters"]: Typecast

["Public.Procedures.StDistancecpa.Parameters"]: Typecast

["Public.Procedures.StCpawithin.Parameters"]: Typecast

["Public.Procedures.StIsvalidtrajectory.Parameters"]: Typecast

["Public.Procedures.StIntersectionE059.Parameters"]: Typecast

["Public.Procedures.StBufferDcba.Parameters"]: Typecast

["Public.Procedures.StBuffer_3222.Parameters"]: Typecast

["Public.Procedures.StMinimumboundingradius.Parameters"]: Typecast

["Public.Procedures.StMinimumboundingcircle.Parameters"]: Typecast

["Public.Procedures.StOrientedenvelope.Parameters"]: Typecast

["Public.Procedures.StOffsetcurve.Parameters"]: Typecast

["Public.Procedures.StGeneratepointsEd82.Parameters"]: Typecast

["Public.Procedures.StGeneratepointsA8be.Parameters"]: Typecast

["Public.Procedures.StConvexhull.Parameters"]: Typecast

["Public.Procedures.StSimplifypreservetopology.Parameters"]: Typecast

["Public.Procedures.StIsvalidreason_0faa.Parameters"]: Typecast

["Public.Procedures.StIsvaliddetail.Parameters"]: Typecast

["Public.Procedures.StIsvalidreasonEd82.Parameters"]: Typecast

["Public.Procedures.StIsvalidEd82.Parameters"]: Typecast

["Public.Procedures.StHausdorffdistanceEb6a.Parameters"]: Typecast

["Public.Procedures.StHausdorffdistanceE059.Parameters"]: Typecast

["Public.Procedures.StFrechetdistance.Parameters"]: Typecast

["Public.Procedures.StMaximuminscribedcircle.Parameters"]: Typecast

["Public.Procedures.StLargestemptycircle.Parameters"]: Typecast

["Public.Procedures.StDifference.Parameters"]: Typecast

["Public.Procedures.StBoundary.Parameters"]: Typecast

["Public.Procedures.StPoints.Parameters"]: Typecast

["Public.Procedures.StSymdifference.Parameters"]: Typecast

["Public.Procedures.StSymmetricdifference.Parameters"]: Typecast

["Public.Procedures.StUnionEb6a.Parameters"]: Typecast

["Public.Procedures.StUnionE059.Parameters"]: Typecast

["Public.Procedures.StUnaryunion.Parameters"]: Typecast

["Public.Procedures.StRemoverepeatedpoints.Parameters"]: Typecast

["Public.Procedures.StClipbybox2d.Parameters"]: Typecast

["Public.Procedures.StSubdivide.Parameters"]: Typecast

["Public.Procedures.StReduceprecision.Parameters"]: Typecast

["Public.Procedures.StMakevalid_0faa.Parameters"]: Typecast

["Public.Procedures.StMakevalidF1e2.Parameters"]: Typecast

["Public.Procedures.StCleangeometry.Parameters"]: Typecast

["Public.Procedures.StSplit.Parameters"]: Typecast

["Public.Procedures.StSharedpaths.Parameters"]: Typecast

["Public.Procedures.StSnap.Parameters"]: Typecast

["Public.Procedures.StRelatematch.Parameters"]: Typecast

["Public.Procedures.StNode.Parameters"]: Typecast

["Public.Procedures.StDelaunaytriangles.Parameters"]: Typecast

["Public.Procedures.StTriangulatepolygon.Parameters"]: Typecast

["Public.Procedures.StVoronoipolygons.Parameters"]: Typecast

["Public.Procedures.StVoronoilines.Parameters"]: Typecast

["Public.Procedures.StCombinebbox_2c84.Parameters"]: Typecast

["Public.Procedures.StCombinebboxEe61.Parameters"]: Typecast

["Public.Procedures.StCombinebbox_7c5a.Parameters"]: Typecast

["Public.Procedures.StCollectEb6a.Parameters"]: Typecast

["Public.Procedures.StCollectF393.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfnE941.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters"]: Typecast

["Public.Procedures.PgisGeometryCollectFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryMakelineFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters"]: Typecast

["Public.Procedures.StUnionF393.Parameters"]: Typecast

["Public.Procedures.StCoverageunionF393.Parameters"]: Typecast

["Public.Procedures.StRelateEb6a.Parameters"]: Typecast

["Public.Procedures.StRelateCc0f.Parameters"]: Typecast

["Public.Procedures.StRelate_6458.Parameters"]: Typecast

["Public.Procedures.StDisjoint.Parameters"]: Typecast

["Public.Procedures.PostgisIndexSupportfn.Parameters"]: Typecast

["Public.Procedures.StLinecrossingdirection.Parameters"]: Typecast

["Public.Procedures.StDwithinE059.Parameters"]: Typecast

["Public.Procedures.StTouches.Parameters"]: Typecast

["Public.Procedures.StIntersectsEb6a.Parameters"]: Typecast

["Public.Procedures.StCrosses.Parameters"]: Typecast

["Public.Procedures.StContains.Parameters"]: Typecast

["Public.Procedures.StContainsproperly.Parameters"]: Typecast

["Public.Procedures.StWithin.Parameters"]: Typecast

["Public.Procedures.StCoversEb6a.Parameters"]: Typecast

["Public.Procedures.StCoveredbyEb6a.Parameters"]: Typecast

["Public.Procedures.StOverlaps.Parameters"]: Typecast

["Public.Procedures.StDfullywithin.Parameters"]: Typecast

["Public.Procedures.St_3ddwithin.Parameters"]: Typecast

["Public.Procedures.St_3ddfullywithin.Parameters"]: Typecast

["Public.Procedures.St_3dintersects.Parameters"]: Typecast

["Public.Procedures.StOrderingequals.Parameters"]: Typecast

["Public.Procedures.StEquals.Parameters"]: Typecast

["Public.Procedures.StIsvalid_0faa.Parameters"]: Typecast

["Public.Procedures.StMinimumclearance.Parameters"]: Typecast

["Public.Procedures.StMinimumclearanceline.Parameters"]: Typecast

["Public.Procedures.StCentroid_0faa.Parameters"]: Typecast

["Public.Procedures.StGeometricmedian.Parameters"]: Typecast

["Public.Procedures.StIsring.Parameters"]: Typecast

["Public.Procedures.StPointonsurface.Parameters"]: Typecast

["Public.Procedures.StIssimple.Parameters"]: Typecast

["Public.Procedures.StIscollection.Parameters"]: Typecast

["Public.Procedures.Equals.Parameters"]: Typecast

["Public.Procedures.StGeomfromgml_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromgmlE728.Parameters"]: Typecast

["Public.Procedures.StGmltosqlE728.Parameters"]: Typecast

["Public.Procedures.StGmltosql_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromkml.Parameters"]: Typecast

["Public.Procedures.StGeomfrommarc21.Parameters"]: Typecast

["Public.Procedures.StAsmarc21.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojsonE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojson_608f.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojson_3c9d.Parameters"]: Typecast

["Public.Procedures.StLinefromencodedpolyline.Parameters"]: Typecast

["Public.Procedures.StAsencodedpolyline.Parameters"]: Typecast

["Public.Procedures.StAssvgA8be.Parameters"]: Typecast

["Public.Procedures.StAsgmlA8be.Parameters"]: Typecast

["Public.Procedures.StAsgml_2621.Parameters"]: Typecast

["Public.Procedures.StAskmlE3da.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonA8be.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonF2c6.Parameters"]: Typecast

["Public.Procedures.Json.Parameters"]: Typecast

["Public.Procedures.Jsonb.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_27f4.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfnF57f.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_92c1.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfnF5be.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtCombinefn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtSerialfn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtDeserialfn.Parameters"]: Typecast

["Public.Procedures.StAsmvtgeom.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufFinalfn.Parameters"]: Typecast

["Public.Procedures.StFromflatgeobuftotable.Parameters"]: Typecast

["Public.Procedures.StFromflatgeobuf.Parameters"]: Typecast

["Public.Procedures.StGeohashEd82.Parameters"]: Typecast

["Public.Procedures.StBox2dfromgeohash.Parameters"]: Typecast

["Public.Procedures.StPointfromgeohash.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeohash.Parameters"]: Typecast

["Public.Procedures.StNumpoints.Parameters"]: Typecast

["Public.Procedures.StNumgeometries.Parameters"]: Typecast

["Public.Procedures.StGeometryn.Parameters"]: Typecast

["Public.Procedures.StDimension.Parameters"]: Typecast

["Public.Procedures.StExteriorring.Parameters"]: Typecast

["Public.Procedures.StNuminteriorrings.Parameters"]: Typecast

["Public.Procedures.StNuminteriorring.Parameters"]: Typecast

["Public.Procedures.StInteriorringn.Parameters"]: Typecast

["Public.Procedures.Geometrytype_0faa.Parameters"]: Typecast

["Public.Procedures.StGeometrytype.Parameters"]: Typecast

["Public.Procedures.StPointn.Parameters"]: Typecast

["Public.Procedures.StNumpatches.Parameters"]: Typecast

["Public.Procedures.StPatchn.Parameters"]: Typecast

["Public.Procedures.StStartpoint.Parameters"]: Typecast

["Public.Procedures.StEndpoint.Parameters"]: Typecast

["Public.Procedures.StIsclosed.Parameters"]: Typecast

["Public.Procedures.StIsempty.Parameters"]: Typecast

["Public.Procedures.StAsbinaryF1e2.Parameters"]: Typecast

["Public.Procedures.StAsbinary_0faa.Parameters"]: Typecast

["Public.Procedures.StAstext_0faa.Parameters"]: Typecast

["Public.Procedures.StAstextEd82.Parameters"]: Typecast

["Public.Procedures.StGeometryfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeometryfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StWkttosql.Parameters"]: Typecast

["Public.Procedures.StPointfromtextE728.Parameters"]: Typecast

["Public.Procedures.StPointfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StLinefromtextE728.Parameters"]: Typecast

["Public.Procedures.StLinefromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolyfromtextE728.Parameters"]: Typecast

["Public.Procedures.StPolyfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolygonfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolygonfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMlinefromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMlinefromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultilinestringfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultilinestringfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpointfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpointfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultipointfromtext.Parameters"]: Typecast

["Public.Procedures.StMpolyfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpolyfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultipolygonfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMultipolygonfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StGeomfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StLinefromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StLinefromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StLinestringfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StLinestringfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StPolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StPolygonfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPolygonfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMpointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMpointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultipointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.GeographyAnalyze.Parameters"]: Typecast

["Public.Procedures.StMultipointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultilinefromwkb.Parameters"]: Typecast

["Public.Procedures.StMlinefromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMlinefromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMpolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMpolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultipolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMultipolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMaxdistance.Parameters"]: Typecast

["Public.Procedures.StClosestpointEb6a.Parameters"]: Typecast

["Public.Procedures.StShortestlineEb6a.Parameters"]: Typecast

["Public.Procedures.StLongestline.Parameters"]: Typecast

["Public.Procedures.StSwapordinates.Parameters"]: Typecast

["Public.Procedures.StFlipcoordinates.Parameters"]: Typecast

["Public.Procedures.StBdpolyfromtext.Parameters"]: Typecast

["Public.Procedures.StBdmpolyfromtext.Parameters"]: Typecast

["Public.Procedures.Unlockrows.Parameters"]: Typecast

["Public.Procedures.Geography_675a.Parameters"]: Typecast

["Public.Procedures.Geography_2d19.Parameters"]: Typecast

["Public.Procedures.Bytea_38ca.Parameters"]: Typecast

["Public.Procedures.StAstext_38ca.Parameters"]: Typecast

["Public.Procedures.StAstext_75a2.Parameters"]: Typecast

["Public.Procedures.LockrowE9aa.Parameters"]: Typecast

["Public.Procedures.Lockrow_02b4.Parameters"]: Typecast

["Public.Procedures.Lockrow_27e1.Parameters"]: Typecast

["Public.Procedures.Lockrow_9a8a.Parameters"]: Typecast

["Public.Procedures.Addauth.Parameters"]: Typecast

["Public.Procedures.Checkauth_27e1.Parameters"]: Typecast

["Public.Procedures.Checkauth_2ec2.Parameters"]: Typecast

["Public.Procedures.GeographyTypmodIn.Parameters"]: Typecast

["Public.Procedures.GeographyTypmodOut.Parameters"]: Typecast

["Public.Procedures.GeographyIn.Parameters"]: Typecast

["Public.Procedures.GeographyOut.Parameters"]: Typecast

["Public.Procedures.GeographyRecv.Parameters"]: Typecast

["Public.Procedures.GeographySend.Parameters"]: Typecast

["Public.Procedures.StAstextE728.Parameters"]: Typecast

["Public.Procedures.StGeographyfromtext.Parameters"]: Typecast

["Public.Procedures.StGeogfromtext.Parameters"]: Typecast

["Public.Procedures.StGeogfromwkb.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodDims.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodSrid.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodType.Parameters"]: Typecast

["Public.Procedures.Geography_0faa.Parameters"]: Typecast

["Public.Procedures.Geometry_38ca.Parameters"]: Typecast

["Public.Procedures.GeographyGistConsistent.Parameters"]: Typecast

["Public.Procedures.GeographyGistCompress.Parameters"]: Typecast

["Public.Procedures.GeographyGistPenalty.Parameters"]: Typecast

["Public.Procedures.GeographyGistPicksplit.Parameters"]: Typecast

["Public.Procedures.GeographyGistUnion.Parameters"]: Typecast

["Public.Procedures.GeographyGistSame.Parameters"]: Typecast

["Public.Procedures.GeographyGistDecompress.Parameters"]: Typecast

["Public.Procedures.GeographyOverlaps.Parameters"]: Typecast

["Public.Procedures.GeographyDistanceKnn.Parameters"]: Typecast

["Public.Procedures.GeographyGistDistance.Parameters"]: Typecast

["Public.Procedures.OverlapsGeog_5a37.Parameters"]: Typecast

["Public.Procedures.OverlapsGeogBd57.Parameters"]: Typecast

["Public.Procedures.OverlapsGeog_1597.Parameters"]: Typecast

["Public.Procedures.GeogBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.GeographyLt.Parameters"]: Typecast

["Public.Procedures.GeographyLe.Parameters"]: Typecast

["Public.Procedures.GeographyGt.Parameters"]: Typecast

["Public.Procedures.GeographyGe.Parameters"]: Typecast

["Public.Procedures.GeographyEq.Parameters"]: Typecast

["Public.Procedures.GeographyCmp.Parameters"]: Typecast

["Public.Procedures.StAssvg_8ddb.Parameters"]: Typecast

["Public.Procedures.StAssvgE728.Parameters"]: Typecast

["Public.Procedures.StProjectE61a.Parameters"]: Typecast

["Public.Procedures.StAzimuthA587.Parameters"]: Typecast

["Public.Procedures.StBuffer_49f7.Parameters"]: Typecast

["Public.Procedures.StAsgmlCe11.Parameters"]: Typecast

["Public.Procedures.StAsgml_98d7.Parameters"]: Typecast

["Public.Procedures.StAsgmlE728.Parameters"]: Typecast

["Public.Procedures.StAskml_48da.Parameters"]: Typecast

["Public.Procedures.StAskmlE728.Parameters"]: Typecast

["Public.Procedures.StAsgeojson_8ddb.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonE728.Parameters"]: Typecast

["Public.Procedures.StDistance_89b8.Parameters"]: Typecast

["Public.Procedures.StDistance_2ec2.Parameters"]: Typecast

["Public.Procedures.StAreaAc0a.Parameters"]: Typecast

["Public.Procedures.StAreaE728.Parameters"]: Typecast

["Public.Procedures.StLengthAc0a.Parameters"]: Typecast

["Public.Procedures.StLengthE728.Parameters"]: Typecast

["Public.Procedures.StProject_665e.Parameters"]: Typecast

["Public.Procedures.StPerimeterAc0a.Parameters"]: Typecast

["Public.Procedures.StSegmentize_772c.Parameters"]: Typecast

["Public.Procedures.StAsbinary_38ca.Parameters"]: Typecast

["Public.Procedures.StAsbinaryF815.Parameters"]: Typecast

["Public.Procedures.StAsewkt_38ca.Parameters"]: Typecast

["Public.Procedures.StAsewkt_75a2.Parameters"]: Typecast

["Public.Procedures.StAsewktE728.Parameters"]: Typecast

["Public.Procedures.Geometrytype_38ca.Parameters"]: Typecast

["Public.Procedures.StSummary_38ca.Parameters"]: Typecast

["Public.Procedures.StGeohash_75a2.Parameters"]: Typecast

["Public.Procedures.StSrid_38ca.Parameters"]: Typecast

["Public.Procedures.StSetsrid_75a2.Parameters"]: Typecast

["Public.Procedures.StCentroidAc0a.Parameters"]: Typecast

["Public.Procedures.StCentroidE728.Parameters"]: Typecast

["Public.Procedures.StCoversA587.Parameters"]: Typecast

["Public.Procedures.StDwithin_5395.Parameters"]: Typecast

["Public.Procedures.StCoveredbyA587.Parameters"]: Typecast

["Public.Procedures.StIntersectsA587.Parameters"]: Typecast

["Public.Procedures.StBuffer_772c.Parameters"]: Typecast

["Public.Procedures.StBuffer_2117.Parameters"]: Typecast

["Public.Procedures.StBuffer_3a01.Parameters"]: Typecast

["Public.Procedures.StBufferC349.Parameters"]: Typecast

["Public.Procedures.StBufferF7c6.Parameters"]: Typecast

["Public.Procedures.StIntersectionA587.Parameters"]: Typecast

["Public.Procedures.StIntersection_2ec2.Parameters"]: Typecast

["Public.Procedures.StCovers_2ec2.Parameters"]: Typecast

["Public.Procedures.StCoveredby_2ec2.Parameters"]: Typecast

["Public.Procedures.StDwithinEfc0.Parameters"]: Typecast

["Public.Procedures.StIntersects_2ec2.Parameters"]: Typecast

["Public.Procedures.StClosestpoint_89b8.Parameters"]: Typecast

["Public.Procedures.StClosestpoint_2ec2.Parameters"]: Typecast

["Public.Procedures.StShortestline_89b8.Parameters"]: Typecast

["Public.Procedures.StShortestline_2ec2.Parameters"]: Typecast

["Public.Procedures.StLinesubstring_665e.Parameters"]: Typecast

["Public.Procedures.StLinesubstringE586.Parameters"]: Typecast

["Public.Procedures.StLinelocatepoint_89b8.Parameters"]: Typecast

["Public.Procedures.StLinelocatepoint_2ec2.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoints_5d11.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointsC349.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointCee3.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointC349.Parameters"]: Typecast

["Public.Procedures.StDistancesphereEb6a.Parameters"]: Typecast

["Public.Procedures.StDistancesphereE059.Parameters"]: Typecast

["Public.Procedures.PostgisTypeName.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintSrid.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintDims.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintType.Parameters"]: Typecast

["Public.Procedures.St_3ddistance.Parameters"]: Typecast

["Public.Procedures.St_3dmaxdistance.Parameters"]: Typecast

["Public.Procedures.St_3dclosestpoint.Parameters"]: Typecast

["Public.Procedures.St_3dshortestline.Parameters"]: Typecast

["Public.Procedures.St_3dlongestline.Parameters"]: Typecast

["Public.Procedures.StCoorddim.Parameters"]: Typecast

["Public.Procedures.StCurvetoline.Parameters"]: Typecast

["Public.Procedures.StHasarc.Parameters"]: Typecast

["Public.Procedures.StLinetocurve.Parameters"]: Typecast

["Public.Procedures.StPoint_0aec.Parameters"]: Typecast

["Public.Procedures.StPoint_0b7f.Parameters"]: Typecast

["Public.Procedures.StPointz.Parameters"]: Typecast

["Public.Procedures.StPointm.Parameters"]: Typecast

["Public.Procedures.StPointzm.Parameters"]: Typecast

["Public.Procedures.StPolygon.Parameters"]: Typecast

["Public.Procedures.StWkbtosql.Parameters"]: Typecast

["Public.Procedures.StLocatebetween.Parameters"]: Typecast

["Public.Procedures.StLocatealong.Parameters"]: Typecast

["Public.Procedures.StLocatebetweenelevations.Parameters"]: Typecast

["Public.Procedures.StInterpolatepoint.Parameters"]: Typecast

["Public.Procedures.StHexagon.Parameters"]: Typecast

["Public.Procedures.StSquare.Parameters"]: Typecast

["Public.Procedures.StHexagongrid.Parameters"]: Typecast

["Public.Procedures.StSquaregrid.Parameters"]: Typecast

["Public.Procedures.Contains_2dD703.Parameters"]: Typecast

["Public.Procedures.IsContained_2dD703.Parameters"]: Typecast

["Public.Procedures.Overlaps_2dD703.Parameters"]: Typecast

["Public.Procedures.Overlaps_2d_1585.Parameters"]: Typecast

["Public.Procedures.Contains_2d_1585.Parameters"]: Typecast

["Public.Procedures.IsContained_2d_1585.Parameters"]: Typecast

["Public.Procedures.Contains_2d_3f94.Parameters"]: Typecast

["Public.Procedures.IsContained_2d_3f94.Parameters"]: Typecast

["Public.Procedures.Overlaps_2d_3f94.Parameters"]: Typecast

["Public.Procedures.OverlapsNd_44c4.Parameters"]: Typecast

["Public.Procedures.OverlapsNdBd57.Parameters"]: Typecast

["Public.Procedures.OverlapsNd_19dd.Parameters"]: Typecast

["Public.Procedures.Geom2dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.Geom3dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.Geom4dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.StSimplifypolygonhull.Parameters"]: Typecast

["Public.Procedures.StConcavehull.Parameters"]: Typecast

["Public.Procedures.StAsx3d.Parameters"]: Typecast

["Public.Procedures.StAngleEb6a.Parameters"]: Typecast

["Public.Procedures.St_3dlineinterpolatepoint.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfig_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChoose_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplit_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryOverlaps_3d.Parameters"]: Typecast

["Public.Procedures.GeometryContains_3d.Parameters"]: Typecast

["Public.Procedures.GeometryContained_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySame_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfig_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChoose_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplit_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompress_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfigNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChooseNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompressNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistConfigNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistChooseNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistInnerConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistLeafConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistCompressNd.Parameters"]: Typecast

["Public.Procedures.StLetters.Parameters"]: Typecast
[49561]: Typecast;
["PgToast.Types.PgToast_49556Index"]: Typecast
[50318]: Typecast;
["PgToast.Types.PgToast_50314Index"]: Typecast
[50324]: Typecast;
["PgToast.Types.PgToast_50320Index"]: Typecast
[2837]: Typecast;
["PgToast.Types.PgToast_1255Index"]: Typecast
[4172]: Typecast;
["PgToast.Types.PgToast_1247Index"]: Typecast
[2831]: Typecast;
["PgToast.Types.PgToast_2604Index"]: Typecast
[2833]: Typecast;
["PgToast.Types.PgToast_2606Index"]: Typecast
[4158]: Typecast;
["PgToast.Types.PgToast_2612Index"]: Typecast
[4160]: Typecast;
["PgToast.Types.PgToast_2600Index"]: Typecast
[2841]: Typecast;
["PgToast.Types.PgToast_2619Index"]: Typecast
[3440]: Typecast;
["PgToast.Types.PgToast_3381Index"]: Typecast
[3431]: Typecast;
["PgToast.Types.PgToast_3429Index"]: Typecast
[2839]: Typecast;
["PgToast.Types.PgToast_2618Index"]: Typecast
[2337]: Typecast;
["PgToast.Types.PgToast_2620Index"]: Typecast
[4146]: Typecast;
["PgToast.Types.PgToast_3466Index"]: Typecast
[2835]: Typecast;
["PgToast.Types.PgToast_2609Index"]: Typecast
[50330]: Typecast;
["PgToast.Types.PgToast_50326Index"]: Typecast
[4164]: Typecast;
["PgToast.Types.PgToast_2615Index"]: Typecast
[4178]: Typecast;
["PgToast.Types.PgToast_1262Index"]: Typecast
[2967]: Typecast;
["PgToast.Types.PgToast_2964Index"]: Typecast
[4186]: Typecast;
["PgToast.Types.PgToast_1213Index"]: Typecast
[4176]: Typecast;
["PgToast.Types.PgToast_1260Index"]: Typecast
[2847]: Typecast;
["PgToast.Types.PgToast_2396Index"]: Typecast
[4170]: Typecast;
["PgToast.Types.PgToast_3600Index"]: Typecast
[4148]: Typecast;
["PgToast.Types.PgToast_3079Index"]: Typecast
[4150]: Typecast;
["PgToast.Types.PgToast_2328Index"]: Typecast
[4152]: Typecast;
["PgToast.Types.PgToast_1417Index"]: Typecast
[4174]: Typecast;
["PgToast.Types.PgToast_1418Index"]: Typecast
[4154]: Typecast;
["PgToast.Types.PgToast_3118Index"]: Typecast
[4168]: Typecast;
["PgToast.Types.PgToast_3256Index"]: Typecast
[4182]: Typecast;
["PgToast.Types.PgToast_6000Index"]: Typecast
[4144]: Typecast;
["PgToast.Types.PgToast_826Index"]: Typecast
[4156]: Typecast;
["PgToast.Types.PgToast_3394Index"]: Typecast
[3599]: Typecast;
["PgToast.Types.PgToast_3596Index"]: Typecast
[4061]: Typecast;
["PgToast.Types.PgToast_3592Index"]: Typecast
[6176]: Typecast;
["PgToast.Types.PgToast_3456Index"]: Typecast
[6245]: Typecast;
["PgToast.Types.PgToast_6243Index"]: Typecast
[4166]: Typecast;
["PgToast.Types.PgToast_3350Index"]: Typecast
[6229]: Typecast;
["PgToast.Types.PgToast_6106Index"]: Typecast
[4184]: Typecast;
["PgToast.Types.PgToast_6100Index"]: Typecast
[50336]: Typecast;
["PgToast.Types.PgToast_50332Index"]: Typecast
[50342]: Typecast;
["PgToast.Types.PgToast_50338Index"]: Typecast
[13662]: Typecast;
["PgToast.Types.PgToast_13658Index"]: Typecast
[13667]: Typecast;
["PgToast.Types.PgToast_13663Index"]: Typecast
[13672]: Typecast;
["PgToast.Types.PgToast_13668Index"]: Typecast
[13677]: Typecast;
["PgToast.Types.PgToast_13673Index"]: Typecast
}

            interface HasDatabase {
              database: Database;
            }
          
export class Database extends PostgresDatabase implements HasDatabase { 
get database() { return this};

          /**
           * Connect to your database server via URL, and return 
           * a fully typed database you can use to access it.
           */
          static async connect(postgresUrl: string, props?: postgres.Options<never>) {
              return new Database(await initializeContext(postgresUrl, props));
          }
        
        

          public Public = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

          public Procedures = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

          public StForcepolygoncw = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcepolygoncw.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcepolygoncw( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcepolygoncw) );
              return responseBody;
           
}
}(this)

          public SpheroidIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.SpheroidIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Spheroid.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.spheroid_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Spheroid.parse(results?.[0].spheroid_in) );
              return responseBody;
           
}
}(this)

          public SpheroidOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.SpheroidOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.spheroid_out( ${ typed[49240](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].spheroid_out) );
              return responseBody;
           
}
}(this)

          public GeometryIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry_in) );
              return responseBody;
           
}
}(this)

          public GeometryOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_out( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geometry_out) );
              return responseBody;
           
}
}(this)

          public GeometryTypmodIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryTypmodIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_typmod_in( ${ typed[1263](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_typmod_in) );
              return responseBody;
           
}
}(this)

          public GeometryTypmodOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryTypmodOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_typmod_out( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geometry_typmod_out) );
              return responseBody;
           
}
}(this)

          public GeometryAnalyze = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryAnalyze.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_analyze( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_analyze) );
              return responseBody;
           
}
}(this)

          public GeometryRecv = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryRecv.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_recv( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry_recv) );
              return responseBody;
           
}
}(this)

          public GeometrySend = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySend.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_send( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].geometry_send) );
              return responseBody;
           
}
}(this)

          public Geometry_4946 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometry_4946.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Geometry_8997 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometry_8997.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[600](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Point = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Point.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Point.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.point( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Point.parse(results?.[0].point) );
              return responseBody;
           
}
}(this)

          public GeometryB0d8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryB0d8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[602](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Path = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Path.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Path.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.path( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Path.parse(results?.[0].path) );
              return responseBody;
           
}
}(this)

          public GeometryF1be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryF1be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[604](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Polygon = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Polygon.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Polygon.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.polygon( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Polygon.parse(results?.[0].polygon) );
              return responseBody;
           
}
}(this)

          public StX = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StX.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_x( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_x) );
              return responseBody;
           
}
}(this)

          public StY = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StY.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_y( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_y) );
              return responseBody;
           
}
}(this)

          public StZ = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StZ.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_z( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_z) );
              return responseBody;
           
}
}(this)

          public StM = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StM.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_m( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_m) );
              return responseBody;
           
}
}(this)

          public Box3dIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box3dIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box3d_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d_in) );
              return responseBody;
           
}
}(this)

          public Box3dOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box3dOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box3d_out( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box3d_out) );
              return responseBody;
           
}
}(this)

          public Box2dIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2dIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2d_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d_in) );
              return responseBody;
           
}
}(this)

          public Box2dOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2dOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2d_out( ${ typed[49275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box2d_out) );
              return responseBody;
           
}
}(this)

          public Box2dfIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2dfIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2df.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2df_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2df.parse(results?.[0].box2df_in) );
              return responseBody;
           
}
}(this)

          public Box2dfOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2dfOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2df_out( ${ typed[49279](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box2df_out) );
              return responseBody;
           
}
}(this)

          public GidxIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GidxIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Gidx.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gidx_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Gidx.parse(results?.[0].gidx_in) );
              return responseBody;
           
}
}(this)

          public GidxOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GidxOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gidx_out( ${ typed[49283](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].gidx_out) );
              return responseBody;
           
}
}(this)

          public GeometryLt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryLt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_lt(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_lt) );
              return responseBody;
           
}
}(this)

          public GeometryLe = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryLe.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_le(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_le) );
              return responseBody;
           
}
}(this)

          public GeometryGt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gt(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gt) );
              return responseBody;
           
}
}(this)

          public GeometryGe = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGe.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_ge(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_ge) );
              return responseBody;
           
}
}(this)

          public GeometryEq = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryEq.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_eq(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_eq) );
              return responseBody;
           
}
}(this)

          public GeometryCmp = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryCmp.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_cmp(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_cmp) );
              return responseBody;
           
}
}(this)

          public GeometrySortsupport = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySortsupport.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_sortsupport( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_sortsupport) );
              return responseBody;
           
}
}(this)

          public GeometryHash = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryHash.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_hash( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_hash) );
              return responseBody;
           
}
}(this)

          public GeometryGistDistance_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistDistance_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_distance_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_gist_distance_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistConsistent_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistConsistent_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gist_consistent_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistCompress_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistCompress_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_compress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_compress_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistPenalty_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistPenalty_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_penalty_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_penalty_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistPicksplit_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistPicksplit_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_picksplit_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_picksplit_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistUnion_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistUnion_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_union_2d( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_union_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistSame_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistSame_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_same_2d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_same_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistDecompress_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistDecompress_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_decompress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_decompress_2d) );
              return responseBody;
           
}
}(this)

          public GeometryGistSortsupport_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistSortsupport_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_sortsupport_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_gist_sortsupport_2d) );
              return responseBody;
           
}
}(this)

          public StForcerhr = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcerhr.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcerhr( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcerhr) );
              return responseBody;
           
}
}(this)

          public PostgisNoop = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisNoop.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_noop( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_noop) );
              return responseBody;
           
}
}(this)

          public StForcepolygonccw = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcepolygonccw.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcepolygonccw( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcepolygonccw) );
              return responseBody;
           
}
}(this)

          public GserializedGistSel_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GserializedGistSel_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gserialized_gist_sel_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_sel_2d) );
              return responseBody;
           
}
}(this)

          public GserializedGistSelNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GserializedGistSelNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gserialized_gist_sel_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_sel_nd) );
              return responseBody;
           
}
}(this)

          public GserializedGistJoinsel_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GserializedGistJoinsel_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gserialized_gist_joinsel_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[21](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_joinsel_2d) );
              return responseBody;
           
}
}(this)

          public GserializedGistJoinselNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GserializedGistJoinselNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gserialized_gist_joinsel_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[21](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_joinsel_nd) );
              return responseBody;
           
}
}(this)

          public GeometryOverlaps = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverlaps.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overlaps(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps) );
              return responseBody;
           
}
}(this)

          public GeometrySame = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySame.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_same(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same) );
              return responseBody;
           
}
}(this)

          public GeometryDistanceCentroid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryDistanceCentroid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_distance_centroid(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_centroid) );
              return responseBody;
           
}
}(this)

          public GeometryDistanceBox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryDistanceBox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_distance_box(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_box) );
              return responseBody;
           
}
}(this)

          public GeometryContains = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryContains.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_contains(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains) );
              return responseBody;
           
}
}(this)

          public GeometryWithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryWithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_within(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_within) );
              return responseBody;
           
}
}(this)

          public GeometryLeft = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryLeft.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_left(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_left) );
              return responseBody;
           
}
}(this)

          public GeometryOverleft = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverleft.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overleft(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overleft) );
              return responseBody;
           
}
}(this)

          public GeometryBelow = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryBelow.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_below(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_below) );
              return responseBody;
           
}
}(this)

          public GeometryOverbelow = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverbelow.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overbelow(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overbelow) );
              return responseBody;
           
}
}(this)

          public GeometryOverright = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverright.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overright(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overright) );
              return responseBody;
           
}
}(this)

          public GeometryRight = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryRight.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_right(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_right) );
              return responseBody;
           
}
}(this)

          public GeometryOverabove = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverabove.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overabove(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overabove) );
              return responseBody;
           
}
}(this)

          public GeometryAbove = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryAbove.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_above(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_above) );
              return responseBody;
           
}
}(this)

          public GeometryGistConsistentNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistConsistentNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gist_consistent_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistCompressNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistCompressNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_compress_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistPenaltyNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistPenaltyNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_penalty_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_penalty_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistPicksplitNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistPicksplitNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_picksplit_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistUnionNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistUnionNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_union_nd( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_union_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistSameNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistSameNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_same_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_same_nd) );
              return responseBody;
           
}
}(this)

          public GeometryGistDecompressNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistDecompressNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_decompress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_decompress_nd) );
              return responseBody;
           
}
}(this)

          public GeometryOverlapsNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverlapsNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overlaps_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps_nd) );
              return responseBody;
           
}
}(this)

          public GeometryContainsNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryContainsNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_contains_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains_nd) );
              return responseBody;
           
}
}(this)

          public GeometryWithinNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryWithinNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_within_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_within_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySameNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySameNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_same_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same_nd) );
              return responseBody;
           
}
}(this)

          public GeometryDistanceCentroidNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryDistanceCentroidNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_distance_centroid_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_centroid_nd) );
              return responseBody;
           
}
}(this)

          public GeometryDistanceCpa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryDistanceCpa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_distance_cpa( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_cpa) );
              return responseBody;
           
}
}(this)

          public GeometryGistDistanceNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryGistDistanceNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_gist_distance_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_gist_distance_nd) );
              return responseBody;
           
}
}(this)

          public StShiftlongitude = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StShiftlongitude.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_shiftlongitude( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shiftlongitude) );
              return responseBody;
           
}
}(this)

          public StWrapx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StWrapx.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_wrapx(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },wrap => ${ typed[701](undefinedIsNull(parameters.wrap)) },move => ${ typed[701](undefinedIsNull(parameters.move)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wrapx) );
              return responseBody;
           
}
}(this)

          public StXmin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StXmin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_xmin( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_xmin) );
              return responseBody;
           
}
}(this)

          public StYmin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StYmin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ymin( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_ymin) );
              return responseBody;
           
}
}(this)

          public StZmin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StZmin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_zmin( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_zmin) );
              return responseBody;
           
}
}(this)

          public StXmax = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StXmax.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_xmax( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_xmax) );
              return responseBody;
           
}
}(this)

          public StYmax = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StYmax.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ymax( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_ymax) );
              return responseBody;
           
}
}(this)

          public StZmax = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StZmax.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_zmax( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_zmax) );
              return responseBody;
           
}
}(this)

          public StExpand_3044 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpand_3044.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand( ${ typed[49275](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public StExpand_3ea7 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpand_3ea7.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand(box => ${ typed[49275](undefinedIsNull(parameters.box)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public PostgisGetbbox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisGetbbox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_getbbox( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].postgis_getbbox) );
              return responseBody;
           
}
}(this)

          public StMakebox2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakebox2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makebox2d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_makebox2d) );
              return responseBody;
           
}
}(this)

          public StEstimatedextentD2f5 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEstimatedextentD2f5.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[16](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}(this)

          public StEstimatedextent_27e1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEstimatedextent_27e1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}(this)

          public StEstimatedextent_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEstimatedextent_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}(this)

          public StFindextent_27e1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFindextent_27e1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_findextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_findextent) );
              return responseBody;
           
}
}(this)

          public StFindextent_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFindextent_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_findextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_findextent) );
              return responseBody;
           
}
}(this)

          public PostgisAddbbox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisAddbbox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_addbbox( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_addbbox) );
              return responseBody;
           
}
}(this)

          public PostgisDropbbox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisDropbbox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_dropbbox( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_dropbbox) );
              return responseBody;
           
}
}(this)

          public PostgisHasbbox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisHasbbox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_hasbbox( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].postgis_hasbbox) );
              return responseBody;
           
}
}(this)

          public StQuantizecoordinates = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StQuantizecoordinates.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_quantizecoordinates(g => ${ typed[49244](undefinedIsNull(parameters.g)) },prec_x => ${ typed[23](undefinedIsNull(parameters.precX)) },prec_y => ${ typed[23](undefinedIsNull(parameters.precY)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_quantizecoordinates) );
              return responseBody;
           
}
}(this)

          public StMemsize = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMemsize.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_memsize( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_memsize) );
              return responseBody;
           
}
}(this)

          public StSummary_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSummary_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_summary( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_summary) );
              return responseBody;
           
}
}(this)

          public StNpoints = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNpoints.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_npoints( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_npoints) );
              return responseBody;
           
}
}(this)

          public StNrings = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNrings.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_nrings( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_nrings) );
              return responseBody;
           
}
}(this)

          public St_3dlength = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dlength.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dlength( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dlength) );
              return responseBody;
           
}
}(this)

          public StLength2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLength2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_length2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length2d) );
              return responseBody;
           
}
}(this)

          public StLength_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLength_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_length( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}(this)

          public StLengthspheroid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLengthspheroid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lengthspheroid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49240](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_lengthspheroid) );
              return responseBody;
           
}
}(this)

          public StLength2dspheroid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLength2dspheroid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_length2dspheroid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49240](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length2dspheroid) );
              return responseBody;
           
}
}(this)

          public St_3dperimeter = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dperimeter.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dperimeter( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dperimeter) );
              return responseBody;
           
}
}(this)

          public StPerimeter2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPerimeter2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_perimeter2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter2d) );
              return responseBody;
           
}
}(this)

          public StPerimeter_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPerimeter_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_perimeter( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter) );
              return responseBody;
           
}
}(this)

          public StArea2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StArea2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_area2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area2d) );
              return responseBody;
           
}
}(this)

          public StArea_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StArea_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_area( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}(this)

          public StIspolygoncw = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIspolygoncw.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ispolygoncw( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_ispolygoncw) );
              return responseBody;
           
}
}(this)

          public StIspolygonccw = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIspolygonccw.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ispolygonccw( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_ispolygonccw) );
              return responseBody;
           
}
}(this)

          public StDistancespheroid_0cb2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistancespheroid_0cb2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distancespheroid(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[49240](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancespheroid) );
              return responseBody;
           
}
}(this)

          public StDistancespheroidEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistancespheroidEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distancespheroid(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancespheroid) );
              return responseBody;
           
}
}(this)

          public StDistanceEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistanceEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}(this)

          public StPointinsidecircle = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointinsidecircle.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointinsidecircle( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_pointinsidecircle) );
              return responseBody;
           
}
}(this)

          public StAzimuthEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAzimuthEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_azimuth(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_azimuth) );
              return responseBody;
           
}
}(this)

          public StProject_2077 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StProject_2077.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_project(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },azimuth => ${ typed[701](undefinedIsNull(parameters.azimuth)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_project) );
              return responseBody;
           
}
}(this)

          public StProjectE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StProjectE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_project(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_project) );
              return responseBody;
           
}
}(this)

          public StAngleA4a1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAngleA4a1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_angle(pt1 => ${ typed[49244](undefinedIsNull(parameters.pt1)) },pt2 => ${ typed[49244](undefinedIsNull(parameters.pt2)) },pt3 => ${ typed[49244](undefinedIsNull(parameters.pt3)) },pt4 => ${ typed[49244](undefinedIsNull(parameters.pt4)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_angle) );
              return responseBody;
           
}
}(this)

          public StLineextend = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineextend.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineextend(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },distance_forward => ${ typed[701](undefinedIsNull(parameters.distanceForward)) },distance_backward => ${ typed[701](undefinedIsNull(parameters.distanceBackward)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineextend) );
              return responseBody;
           
}
}(this)

          public StForce2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForce2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_force2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force2d) );
              return responseBody;
           
}
}(this)

          public StForce3dz = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForce3dz.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_force3dz(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3dz) );
              return responseBody;
           
}
}(this)

          public StForce3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForce3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_force3d(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3d) );
              return responseBody;
           
}
}(this)

          public StForce3dm = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForce3dm.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_force3dm(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },mvalue => ${ typed[701](undefinedIsNull(parameters.mvalue)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3dm) );
              return responseBody;
           
}
}(this)

          public StForce4d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForce4d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_force4d(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) },mvalue => ${ typed[701](undefinedIsNull(parameters.mvalue)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force4d) );
              return responseBody;
           
}
}(this)

          public StForcecollection = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcecollection.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcecollection( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcecollection) );
              return responseBody;
           
}
}(this)

          public StCollectionextractEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCollectionextractEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_collectionextract( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionextract) );
              return responseBody;
           
}
}(this)

          public StCollectionextract_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCollectionextract_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_collectionextract( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionextract) );
              return responseBody;
           
}
}(this)

          public StCollectionhomogenize = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCollectionhomogenize.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_collectionhomogenize( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionhomogenize) );
              return responseBody;
           
}
}(this)

          public StMulti = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMulti.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multi( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multi) );
              return responseBody;
           
}
}(this)

          public StForcecurve = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcecurve.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcecurve( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcecurve) );
              return responseBody;
           
}
}(this)

          public StForcesfs_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcesfs_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcesfs( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcesfs) );
              return responseBody;
           
}
}(this)

          public StForcesfsF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StForcesfsF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_forcesfs(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) },version => ${ typed[25](undefinedIsNull(parameters.version)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcesfs) );
              return responseBody;
           
}
}(this)

          public StExpand_95d4 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpand_95d4.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand( ${ typed[49271](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public StExpandF49e = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpandF49e.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand(box => ${ typed[49271](undefinedIsNull(parameters.box)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) },dz => ${ typed[701](undefinedIsNull(parameters.dz)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public StExpandDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpandDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public StExpandBf72 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExpandBf72.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_expand(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) },dz => ${ typed[701](undefinedIsNull(parameters.dz)) },dm => ${ typed[701](undefinedIsNull(parameters.dm)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}(this)

          public StEnvelope = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEnvelope.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_envelope( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_envelope) );
              return responseBody;
           
}
}(this)

          public StBoundingdiagonal = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBoundingdiagonal.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_boundingdiagonal(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },fits => ${ typed[16](undefinedIsNull(parameters.fits)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_boundingdiagonal) );
              return responseBody;
           
}
}(this)

          public StReverse = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StReverse.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_reverse( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_reverse) );
              return responseBody;
           
}
}(this)

          public StScroll = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StScroll.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_scroll( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scroll) );
              return responseBody;
           
}
}(this)

          public PostgisGeosNoop = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisGeosNoop.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_geos_noop( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_geos_noop) );
              return responseBody;
           
}
}(this)

          public StNormalize = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNormalize.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_normalize(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_normalize) );
              return responseBody;
           
}
}(this)

          public StZmflag = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StZmflag.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_zmflag( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_zmflag) );
              return responseBody;
           
}
}(this)

          public StNdims = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNdims.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ndims( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_ndims) );
              return responseBody;
           
}
}(this)

          public StAsewkt_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewkt_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkt( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}(this)

          public StAsewktEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewktEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkt( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}(this)

          public StAstwkb_8607 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstwkb_8607.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astwkb(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },prec => ${ typed[23](undefinedIsNull(parameters.prec)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) },with_sizes => ${ typed[16](undefinedIsNull(parameters.withSizes)) },with_boxes => ${ typed[16](undefinedIsNull(parameters.withBoxes)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_astwkb) );
              return responseBody;
           
}
}(this)

          public StAstwkb_1445 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstwkb_1445.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astwkb(geom => ${ typed[49252](undefinedIsNull(parameters.geom)) },ids => ${ typed[1016](undefinedIsNull(parameters.ids)) },prec => ${ typed[23](undefinedIsNull(parameters.prec)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) },with_sizes => ${ typed[16](undefinedIsNull(parameters.withSizes)) },with_boxes => ${ typed[16](undefinedIsNull(parameters.withBoxes)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_astwkb) );
              return responseBody;
           
}
}(this)

          public StAsewkb_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewkb_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkb( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asewkb) );
              return responseBody;
           
}
}(this)

          public StAshexewkb_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAshexewkb_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ashexewkb( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_ashexewkb) );
              return responseBody;
           
}
}(this)

          public StAshexewkbF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAshexewkbF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_ashexewkb( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_ashexewkb) );
              return responseBody;
           
}
}(this)

          public StAsewkbF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewkbF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkb( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asewkb) );
              return responseBody;
           
}
}(this)

          public StAslatlontext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAslatlontext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_aslatlontext(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },tmpl => ${ typed[25](undefinedIsNull(parameters.tmpl)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_aslatlontext) );
              return responseBody;
           
}
}(this)

          public Geomfromewkb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geomfromewkb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geomfromewkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geomfromewkb) );
              return responseBody;
           
}
}(this)

          public StGeomfromewkb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromewkb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromewkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromewkb) );
              return responseBody;
           
}
}(this)

          public StGeomfromtwkb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromtwkb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromtwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtwkb) );
              return responseBody;
           
}
}(this)

          public Geomfromewkt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geomfromewkt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geomfromewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geomfromewkt) );
              return responseBody;
           
}
}(this)

          public StGeomfromewkt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromewkt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromewkt) );
              return responseBody;
           
}
}(this)

          public PostgisCacheBbox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Trigger.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_cache_bbox()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Trigger.parse(results?.[0].postgis_cache_bbox) );
              return responseBody;
           
}
}(this)

          public StMakepoint_0aec = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepoint_0aec.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}(this)

          public StMakepoint_81ec = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepoint_81ec.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}(this)

          public StMakepoint_570b = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepoint_570b.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}(this)

          public StMakepointm = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepointm.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepointm( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepointm) );
              return responseBody;
           
}
}(this)

          public St_3dmakebox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dmakebox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dmakebox(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_3dmakebox) );
              return responseBody;
           
}
}(this)

          public StMakelineF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakelineF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makeline( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeline) );
              return responseBody;
           
}
}(this)

          public StLinefrommultipoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefrommultipoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefrommultipoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefrommultipoint) );
              return responseBody;
           
}
}(this)

          public StMakelineEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakelineEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makeline(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeline) );
              return responseBody;
           
}
}(this)

          public StAddpointEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAddpointEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_addpoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addpoint) );
              return responseBody;
           
}
}(this)

          public StScale_2077 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StScale_2077.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_scale( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}(this)

          public StAddpointCc0f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAddpointCc0f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_addpoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addpoint) );
              return responseBody;
           
}
}(this)

          public StRemovepoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRemovepoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_removepoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_removepoint) );
              return responseBody;
           
}
}(this)

          public StSetpoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSetpoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_setpoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[49244](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_setpoint) );
              return responseBody;
           
}
}(this)

          public StMakeenvelope = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakeenvelope.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makeenvelope( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[23](undefinedIsNull(parameters.argument_4)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeenvelope) );
              return responseBody;
           
}
}(this)

          public StTileenvelope = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTileenvelope.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_tileenvelope(zoom => ${ typed[23](undefinedIsNull(parameters.zoom)) },x => ${ typed[23](undefinedIsNull(parameters.x)) },y => ${ typed[23](undefinedIsNull(parameters.y)) },bounds => ${ typed[49244](undefinedIsNull(parameters.bounds)) },margin => ${ typed[701](undefinedIsNull(parameters.margin)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_tileenvelope) );
              return responseBody;
           
}
}(this)

          public StMakepolygon_0543 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepolygon_0543.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepolygon( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49252](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepolygon) );
              return responseBody;
           
}
}(this)

          public StMakepolygon_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakepolygon_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makepolygon( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepolygon) );
              return responseBody;
           
}
}(this)

          public StBuildarea = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuildarea.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buildarea( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buildarea) );
              return responseBody;
           
}
}(this)

          public StPolygonizeF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygonizeF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygonize( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonize) );
              return responseBody;
           
}
}(this)

          public StClusterintersectingF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClusterintersectingF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_clusterintersecting( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].st_clusterintersecting) );
              return responseBody;
           
}
}(this)

          public StClusterwithin_2892 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClusterwithin_2892.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_clusterwithin( ${ typed[49252](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].st_clusterwithin) );
              return responseBody;
           
}
}(this)

          public StLinemerge_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinemerge_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linemerge( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linemerge) );
              return responseBody;
           
}
}(this)

          public StLinemergeCad2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinemergeCad2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linemerge( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[16](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linemerge) );
              return responseBody;
           
}
}(this)

          public StAffineA659 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAffineA659.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_affine( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) }, ${ typed[701](undefinedIsNull(parameters.argument_5)) }, ${ typed[701](undefinedIsNull(parameters.argument_6)) }, ${ typed[701](undefinedIsNull(parameters.argument_7)) }, ${ typed[701](undefinedIsNull(parameters.argument_8)) }, ${ typed[701](undefinedIsNull(parameters.argument_9)) }, ${ typed[701](undefinedIsNull(parameters.argument_10)) }, ${ typed[701](undefinedIsNull(parameters.argument_11)) }, ${ typed[701](undefinedIsNull(parameters.argument_12)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_affine) );
              return responseBody;
           
}
}(this)

          public StAffine_0997 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAffine_0997.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_affine( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) }, ${ typed[701](undefinedIsNull(parameters.argument_5)) }, ${ typed[701](undefinedIsNull(parameters.argument_6)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_affine) );
              return responseBody;
           
}
}(this)

          public StRotateDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotateDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotate( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}(this)

          public StRotate_6aac = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotate_6aac.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotate( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}(this)

          public StRotate_8af1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotate_8af1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotate( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[49244](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}(this)

          public StRotatez = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotatez.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotatez( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatez) );
              return responseBody;
           
}
}(this)

          public StRotatex = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotatex.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotatex( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatex) );
              return responseBody;
           
}
}(this)

          public StRotatey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRotatey.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_rotatey( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatey) );
              return responseBody;
           
}
}(this)

          public StTranslate_6aac = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTranslate_6aac.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_translate( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_translate) );
              return responseBody;
           
}
}(this)

          public StTranslate_2077 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTranslate_2077.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_translate( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_translate) );
              return responseBody;
           
}
}(this)

          public StScaleEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StScaleEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_scale( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}(this)

          public StScale_8af1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StScale_8af1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_scale(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[49244](undefinedIsNull(parameters.argument_1)) },origin => ${ typed[49244](undefinedIsNull(parameters.origin)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}(this)

          public StScale_6aac = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StScale_6aac.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_scale( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}(this)

          public StTransscale = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransscale.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transscale( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transscale) );
              return responseBody;
           
}
}(this)

          public StDump = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDump.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dump( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dump)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}(this)

          public StDumprings = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDumprings.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dumprings( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumprings)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}(this)

          public StDumppoints = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDumppoints.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dumppoints( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumppoints)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}(this)

          public StDumpsegments = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDumpsegments.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dumpsegments( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumpsegments)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}(this)

          public PopulateGeometryColumns_23fc = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PopulateGeometryColumns_23fc.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.populate_geometry_columns(use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].populate_geometry_columns) );
              return responseBody;
           
}
}(this)

          public PopulateGeometryColumns_4174 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PopulateGeometryColumns_4174.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.populate_geometry_columns(tbl_oid => ${ typed[26](undefinedIsNull(parameters.tblOid)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].populate_geometry_columns) );
              return responseBody;
           
}
}(this)

          public Addgeometrycolumn_8fbb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Addgeometrycolumn_8fbb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.addgeometrycolumn(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid_in => ${ typed[23](undefinedIsNull(parameters.newSridIn)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public Addgeometrycolumn_4617 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Addgeometrycolumn_4617.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.addgeometrycolumn(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid => ${ typed[23](undefinedIsNull(parameters.newSrid)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public Addgeometrycolumn_093c = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Addgeometrycolumn_093c.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.addgeometrycolumn(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid => ${ typed[23](undefinedIsNull(parameters.newSrid)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public Dropgeometrycolumn_0412 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Dropgeometrycolumn_0412.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrycolumn(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public Dropgeometrycolumn_2253 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Dropgeometrycolumn_2253.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrycolumn(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public DropgeometrycolumnF11a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.DropgeometrycolumnF11a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrycolumn(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}(this)

          public Dropgeometrytable_2253 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Dropgeometrytable_2253.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrytable(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}(this)

          public StSegmentizeDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSegmentizeDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_segmentize( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_segmentize) );
              return responseBody;
           
}
}(this)

          public DropgeometrytableF11a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.DropgeometrytableF11a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrytable(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}(this)

          public DropgeometrytableBfde = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.DropgeometrytableBfde.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.dropgeometrytable(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}(this)

          public UpdategeometrysridB2ee = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.UpdategeometrysridB2ee.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.updategeometrysrid(catalogn_name => ${ typed[1043](undefinedIsNull(parameters.catalognName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid_in => ${ typed[23](undefinedIsNull(parameters.newSridIn)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}(this)

          public Updategeometrysrid_7b58 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Updategeometrysrid_7b58.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.updategeometrysrid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[1043](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}(this)

          public Updategeometrysrid_11c8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Updategeometrysrid_11c8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.updategeometrysrid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}(this)

          public FindSrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.FindSrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.find_srid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[1043](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].find_srid) );
              return responseBody;
           
}
}(this)

          public GetProj4FromSrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GetProj4FromSrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.get_proj4_from_srid( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].get_proj4_from_srid) );
              return responseBody;
           
}
}(this)

          public StSetsridEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSetsridEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_setsrid(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_setsrid) );
              return responseBody;
           
}
}(this)

          public StSrid_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSrid_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_srid(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_srid) );
              return responseBody;
           
}
}(this)

          public PostgisTransformGeometry = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTransformGeometry.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_transform_geometry(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },argument_1 => ${ typed[25](undefinedIsNull(parameters.argument_1)) },argument_2 => ${ typed[25](undefinedIsNull(parameters.argument_2)) },argument_3 => ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_transform_geometry) );
              return responseBody;
           
}
}(this)

          public PostgisSrsCodes = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisSrsCodes.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_srs_codes(auth_name => ${ typed[25](undefinedIsNull(parameters.authName)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_codes)).filter<PgCatalog.Types.Text>((r):r is PgCatalog.Types.Text => r !== null) );
              return responseBody;
           
}
}(this)

          public PostgisSrs = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisSrs.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49586].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrs;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_srs(auth_name => ${ typed[25](undefinedIsNull(parameters.authName)) },auth_srid => ${ typed[25](undefinedIsNull(parameters.authSrid)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs)).filter<Public.Types.PostgisSrs>((r):r is Public.Types.PostgisSrs => r !== null) );
              return responseBody;
           
}
}(this)

          public PostgisSrsAll = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49587].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrsAll;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_srs_all()`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_all)).filter<Public.Types.PostgisSrsAll>((r):r is Public.Types.PostgisSrsAll => r !== null) );
              return responseBody;
           
}
}(this)

          public PostgisSrsSearch = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisSrsSearch.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49588].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrsSearch;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_srs_search(bounds => ${ typed[49244](undefinedIsNull(parameters.bounds)) },authname => ${ typed[25](undefinedIsNull(parameters.authname)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_search)).filter<Public.Types.PostgisSrsSearch>((r):r is Public.Types.PostgisSrsSearch => r !== null) );
              return responseBody;
           
}
}(this)

          public StTransformEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransformEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transform( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}(this)

          public StTransformF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransformF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transform(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },to_proj => ${ typed[25](undefinedIsNull(parameters.toProj)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}(this)

          public StTransformEfe6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransformEfe6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transform(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },from_proj => ${ typed[25](undefinedIsNull(parameters.fromProj)) },to_proj => ${ typed[25](undefinedIsNull(parameters.toProj)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}(this)

          public StTransform_3ad9 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransform_3ad9.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transform(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },from_proj => ${ typed[25](undefinedIsNull(parameters.fromProj)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}(this)

          public PostgisTransformPipelineGeometry = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTransformPipelineGeometry.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_transform_pipeline_geometry(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },forward => ${ typed[16](undefinedIsNull(parameters.forward)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_transform_pipeline_geometry) );
              return responseBody;
           
}
}(this)

          public StTransformpipeline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTransformpipeline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_transformpipeline(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transformpipeline) );
              return responseBody;
           
}
}(this)

          public StInversetransformpipeline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StInversetransformpipeline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_inversetransformpipeline(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_inversetransformpipeline) );
              return responseBody;
           
}
}(this)

          public PostgisVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_version) );
              return responseBody;
           
}
}(this)

          public PostgisLiblwgeomVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_liblwgeom_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_liblwgeom_version) );
              return responseBody;
           
}
}(this)

          public PostgisProjVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_proj_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_proj_version) );
              return responseBody;
           
}
}(this)

          public PostgisWagyuVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_wagyu_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_wagyu_version) );
              return responseBody;
           
}
}(this)

          public PostgisScriptsInstalled = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_scripts_installed()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_installed) );
              return responseBody;
           
}
}(this)

          public PostgisLibVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_lib_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_version) );
              return responseBody;
           
}
}(this)

          public PostgisScriptsReleased = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_scripts_released()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_released) );
              return responseBody;
           
}
}(this)

          public PostgisGeosVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_geos_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_geos_version) );
              return responseBody;
           
}
}(this)

          public PostgisGeosCompiledVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_geos_compiled_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_geos_compiled_version) );
              return responseBody;
           
}
}(this)

          public PostgisLibRevision = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_lib_revision()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_revision) );
              return responseBody;
           
}
}(this)

          public PostgisSvnVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_svn_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_svn_version) );
              return responseBody;
           
}
}(this)

          public PostgisLibxmlVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_libxml_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libxml_version) );
              return responseBody;
           
}
}(this)

          public PostgisScriptsBuildDate = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_scripts_build_date()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_build_date) );
              return responseBody;
           
}
}(this)

          public PostgisLibBuildDate = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_lib_build_date()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_build_date) );
              return responseBody;
           
}
}(this)

          public PostgisExtensionsUpgrade = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisExtensionsUpgrade.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_extensions_upgrade(target_version => ${ typed[25](undefinedIsNull(parameters.targetVersion)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_extensions_upgrade) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepointDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepointDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepoints_1c13 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepoints_1c13.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoints(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },repeat => ${ typed[16](undefinedIsNull(parameters.repeat)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}(this)

          public StLinesubstring_2077 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinesubstring_2077.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linesubstring( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}(this)

          public StLinelocatepointEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinelocatepointEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linelocatepoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}(this)

          public StAddmeasure = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAddmeasure.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_addmeasure( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addmeasure) );
              return responseBody;
           
}
}(this)

          public StClosestpointofapproach = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClosestpointofapproach.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_closestpointofapproach( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_closestpointofapproach) );
              return responseBody;
           
}
}(this)

          public PostgisFullVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_full_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_full_version) );
              return responseBody;
           
}
}(this)

          public Box2d_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2d_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d) );
              return responseBody;
           
}
}(this)

          public Box3d_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box3d_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box3d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d) );
              return responseBody;
           
}
}(this)

          public Box_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box) );
              return responseBody;
           
}
}(this)

          public Box2d_8784 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box2d_8784.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box2d( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d) );
              return responseBody;
           
}
}(this)

          public Box3dF5fa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box3dF5fa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box3d( ${ typed[49275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d) );
              return responseBody;
           
}
}(this)

          public Box_8784 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box_8784.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box) );
              return responseBody;
           
}
}(this)

          public Text = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Text.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.text( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].text) );
              return responseBody;
           
}
}(this)

          public Box3dtobox = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Box3dtobox.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.box3dtobox( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box3dtobox) );
              return responseBody;
           
}
}(this)

          public GeometryF5fa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryF5fa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[49275](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Geometry_8784 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometry_8784.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[49271](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public GeometryE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Geometry_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometry_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public Bytea_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Bytea_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.bytea( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].bytea) );
              return responseBody;
           
}
}(this)

          public StSimplifyDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSimplifyDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_simplify( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplify) );
              return responseBody;
           
}
}(this)

          public StSimplify_1c13 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSimplify_1c13.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_simplify( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplify) );
              return responseBody;
           
}
}(this)

          public StSimplifyvw = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSimplifyvw.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_simplifyvw( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifyvw) );
              return responseBody;
           
}
}(this)

          public StSeteffectivearea = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSeteffectivearea.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_seteffectivearea( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_seteffectivearea) );
              return responseBody;
           
}
}(this)

          public StFilterbym = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFilterbym.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_filterbym( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[16](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_filterbym) );
              return responseBody;
           
}
}(this)

          public StChaikinsmoothing = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StChaikinsmoothing.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_chaikinsmoothing( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_chaikinsmoothing) );
              return responseBody;
           
}
}(this)

          public StSnaptogridBf72 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSnaptogridBf72.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_snaptogrid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}(this)

          public StSnaptogrid_2077 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSnaptogrid_2077.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_snaptogrid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}(this)

          public StSnaptogridDeb6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSnaptogridDeb6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_snaptogrid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}(this)

          public StSnaptogrid_7713 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSnaptogrid_7713.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_snaptogrid(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) },argument_3 => ${ typed[701](undefinedIsNull(parameters.argument_3)) },argument_4 => ${ typed[701](undefinedIsNull(parameters.argument_4)) },argument_5 => ${ typed[701](undefinedIsNull(parameters.argument_5)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}(this)

          public StDistancecpa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistancecpa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distancecpa( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancecpa) );
              return responseBody;
           
}
}(this)

          public StCpawithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCpawithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_cpawithin( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_cpawithin) );
              return responseBody;
           
}
}(this)

          public StIsvalidtrajectory = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvalidtrajectory.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvalidtrajectory( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalidtrajectory) );
              return responseBody;
           
}
}(this)

          public StIntersectionE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersectionE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersection(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}(this)

          public StBufferDcba = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBufferDcba.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) },options => ${ typed[25](undefinedIsNull(parameters.options)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StBuffer_3222 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuffer_3222.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) },quadsegs => ${ typed[23](undefinedIsNull(parameters.quadsegs)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StMinimumboundingradius = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMinimumboundingradius.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49662].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StMinimumboundingradius;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_minimumboundingradius(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_minimumboundingradius)).filter<Public.Types.StMinimumboundingradius>((r):r is Public.Types.StMinimumboundingradius => r !== null) );
              return responseBody;
           
}
}(this)

          public StMinimumboundingcircle = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMinimumboundingcircle.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_minimumboundingcircle(inputgeom => ${ typed[49244](undefinedIsNull(parameters.inputgeom)) },segs_per_quarter => ${ typed[23](undefinedIsNull(parameters.segsPerQuarter)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_minimumboundingcircle) );
              return responseBody;
           
}
}(this)

          public StOrientedenvelope = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StOrientedenvelope.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_orientedenvelope( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_orientedenvelope) );
              return responseBody;
           
}
}(this)

          public StOffsetcurve = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StOffsetcurve.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_offsetcurve(line => ${ typed[49244](undefinedIsNull(parameters.line)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },params => ${ typed[25](undefinedIsNull(parameters.params)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_offsetcurve) );
              return responseBody;
           
}
}(this)

          public StGeneratepointsEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeneratepointsEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_generatepoints(area => ${ typed[49244](undefinedIsNull(parameters.area)) },npoints => ${ typed[23](undefinedIsNull(parameters.npoints)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_generatepoints) );
              return responseBody;
           
}
}(this)

          public StGeneratepointsA8be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeneratepointsA8be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_generatepoints(area => ${ typed[49244](undefinedIsNull(parameters.area)) },npoints => ${ typed[23](undefinedIsNull(parameters.npoints)) },seed => ${ typed[23](undefinedIsNull(parameters.seed)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_generatepoints) );
              return responseBody;
           
}
}(this)

          public StConvexhull = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StConvexhull.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_convexhull( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_convexhull) );
              return responseBody;
           
}
}(this)

          public StSimplifypreservetopology = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSimplifypreservetopology.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_simplifypreservetopology( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifypreservetopology) );
              return responseBody;
           
}
}(this)

          public StIsvalidreason_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvalidreason_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvalidreason( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_isvalidreason) );
              return responseBody;
           
}
}(this)

          public StIsvaliddetail = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvaliddetail.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.ValidDetail.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvaliddetail(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`
  const results = response;

              const responseBody = ( Public.Types.ValidDetail.parse(results?.[0].st_isvaliddetail) );
              return responseBody;
           
}
}(this)

          public StIsvalidreasonEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvalidreasonEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvalidreason( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_isvalidreason) );
              return responseBody;
           
}
}(this)

          public StIsvalidEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvalidEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvalid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalid) );
              return responseBody;
           
}
}(this)

          public StHausdorffdistanceEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StHausdorffdistanceEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_hausdorffdistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_hausdorffdistance) );
              return responseBody;
           
}
}(this)

          public StHausdorffdistanceE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StHausdorffdistanceE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_hausdorffdistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_hausdorffdistance) );
              return responseBody;
           
}
}(this)

          public StFrechetdistance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFrechetdistance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_frechetdistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_frechetdistance) );
              return responseBody;
           
}
}(this)

          public StMaximuminscribedcircle = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMaximuminscribedcircle.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49680].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StMaximuminscribedcircle;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_maximuminscribedcircle(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_maximuminscribedcircle)).filter<Public.Types.StMaximuminscribedcircle>((r):r is Public.Types.StMaximuminscribedcircle => r !== null) );
              return responseBody;
           
}
}(this)

          public StLargestemptycircle = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLargestemptycircle.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[49681].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StLargestemptycircle;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_largestemptycircle(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },boundary => ${ typed[49244](undefinedIsNull(parameters.boundary)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_largestemptycircle)).filter<Public.Types.StLargestemptycircle>((r):r is Public.Types.StLargestemptycircle => r !== null) );
              return responseBody;
           
}
}(this)

          public StDifference = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDifference.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_difference(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_difference) );
              return responseBody;
           
}
}(this)

          public StBoundary = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBoundary.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_boundary( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_boundary) );
              return responseBody;
           
}
}(this)

          public StPoints = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPoints.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_points( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_points) );
              return responseBody;
           
}
}(this)

          public StSymdifference = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSymdifference.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_symdifference(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_symdifference) );
              return responseBody;
           
}
}(this)

          public StSymmetricdifference = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSymmetricdifference.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_symmetricdifference(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_symmetricdifference) );
              return responseBody;
           
}
}(this)

          public StUnionEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StUnionEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_union(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}(this)

          public StUnionE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StUnionE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_union(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}(this)

          public StUnaryunion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StUnaryunion.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_unaryunion(argument_0 => ${ typed[49244](undefinedIsNull(parameters.argument_0)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_unaryunion) );
              return responseBody;
           
}
}(this)

          public StRemoverepeatedpoints = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRemoverepeatedpoints.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_removerepeatedpoints(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_removerepeatedpoints) );
              return responseBody;
           
}
}(this)

          public StClipbybox2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClipbybox2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_clipbybox2d(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },box => ${ typed[49275](undefinedIsNull(parameters.box)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_clipbybox2d) );
              return responseBody;
           
}
}(this)

          public StSubdivide = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSubdivide.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_subdivide(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxvertices => ${ typed[23](undefinedIsNull(parameters.maxvertices)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_subdivide)).filter<Public.Types.Geometry>((r):r is Public.Types.Geometry => r !== null) );
              return responseBody;
           
}
}(this)

          public StReduceprecision = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StReduceprecision.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_reduceprecision(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_reduceprecision) );
              return responseBody;
           
}
}(this)

          public StMakevalid_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakevalid_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makevalid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makevalid) );
              return responseBody;
           
}
}(this)

          public StMakevalidF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMakevalidF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_makevalid(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },params => ${ typed[25](undefinedIsNull(parameters.params)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makevalid) );
              return responseBody;
           
}
}(this)

          public StCleangeometry = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCleangeometry.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_cleangeometry( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_cleangeometry) );
              return responseBody;
           
}
}(this)

          public StSplit = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSplit.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_split(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_split) );
              return responseBody;
           
}
}(this)

          public StSharedpaths = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSharedpaths.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_sharedpaths(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_sharedpaths) );
              return responseBody;
           
}
}(this)

          public StSnap = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSnap.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_snap(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snap) );
              return responseBody;
           
}
}(this)

          public StRelatematch = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRelatematch.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_relatematch( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_relatematch) );
              return responseBody;
           
}
}(this)

          public StNode = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNode.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_node(g => ${ typed[49244](undefinedIsNull(parameters.g)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_node) );
              return responseBody;
           
}
}(this)

          public StDelaunaytriangles = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDelaunaytriangles.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_delaunaytriangles(g1 => ${ typed[49244](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_delaunaytriangles) );
              return responseBody;
           
}
}(this)

          public StTriangulatepolygon = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTriangulatepolygon.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_triangulatepolygon(g1 => ${ typed[49244](undefinedIsNull(parameters.g1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_triangulatepolygon) );
              return responseBody;
           
}
}(this)

          public StVoronoipolygons = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StVoronoipolygons.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_voronoipolygons(g1 => ${ typed[49244](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },extend_to => ${ typed[49244](undefinedIsNull(parameters.extendTo)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_voronoipolygons) );
              return responseBody;
           
}
}(this)

          public StVoronoilines = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StVoronoilines.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_voronoilines(g1 => ${ typed[49244](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },extend_to => ${ typed[49244](undefinedIsNull(parameters.extendTo)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_voronoilines) );
              return responseBody;
           
}
}(this)

          public StCombinebbox_2c84 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCombinebbox_2c84.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_combinebbox( ${ typed[49271](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}(this)

          public StCombinebboxEe61 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCombinebboxEe61.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_combinebbox( ${ typed[49271](undefinedIsNull(parameters.argument_0)) }, ${ typed[49271](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}(this)

          public StCombinebbox_7c5a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCombinebbox_7c5a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_combinebbox( ${ typed[49275](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}(this)

          public StCollectEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCollectEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_collect(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collect) );
              return responseBody;
           
}
}(this)

          public StCollectF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCollectF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_collect( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collect) );
              return responseBody;
           
}
}(this)

          public PgisGeometryAccumTransfnE941 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryAccumTransfnE941.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryAccumTransfnDd3f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryAccumTransfn_0a1f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryCollectFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryCollectFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_collect_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_collect_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryPolygonizeFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_polygonize_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_polygonize_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryClusterintersectingFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_clusterintersecting_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].pgis_geometry_clusterintersecting_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryClusterwithinFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_clusterwithin_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].pgis_geometry_clusterwithin_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryMakelineFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryMakelineFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_makeline_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_makeline_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryCoverageunionFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_coverageunion_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_coverageunion_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelTransfnE941 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_transfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelTransfnDd3f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_transfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelCombinefn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_combinefn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_combinefn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelSerialfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_serialfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_geometry_union_parallel_serialfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelDeserialfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_deserialfn( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_deserialfn) );
              return responseBody;
           
}
}(this)

          public PgisGeometryUnionParallelFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_geometry_union_parallel_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_union_parallel_finalfn) );
              return responseBody;
           
}
}(this)

          public StUnionF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StUnionF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_union( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}(this)

          public StCoverageunionF393 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoverageunionF393.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_coverageunion( ${ typed[49252](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_coverageunion) );
              return responseBody;
           
}
}(this)

          public StRelateEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRelateEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_relate(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}(this)

          public StRelateCc0f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRelateCc0f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_relate(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}(this)

          public StRelate_6458 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StRelate_6458.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_relate(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}(this)

          public StDisjoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDisjoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_disjoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_disjoint) );
              return responseBody;
           
}
}(this)

          public PostgisIndexSupportfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisIndexSupportfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_index_supportfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].postgis_index_supportfn) );
              return responseBody;
           
}
}(this)

          public StLinecrossingdirection = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinecrossingdirection.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linecrossingdirection(line1 => ${ typed[49244](undefinedIsNull(parameters.line1)) },line2 => ${ typed[49244](undefinedIsNull(parameters.line2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_linecrossingdirection) );
              return responseBody;
           
}
}(this)

          public StDwithinE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDwithinE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dwithin(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}(this)

          public StTouches = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StTouches.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_touches(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_touches) );
              return responseBody;
           
}
}(this)

          public StIntersectsEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersectsEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersects(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}(this)

          public StCrosses = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCrosses.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_crosses(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_crosses) );
              return responseBody;
           
}
}(this)

          public StContains = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StContains.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_contains(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_contains) );
              return responseBody;
           
}
}(this)

          public StContainsproperly = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StContainsproperly.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_containsproperly(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_containsproperly) );
              return responseBody;
           
}
}(this)

          public StWithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StWithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_within(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_within) );
              return responseBody;
           
}
}(this)

          public StCoversEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoversEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_covers(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}(this)

          public StCoveredbyEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoveredbyEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_coveredby(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}(this)

          public StOverlaps = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StOverlaps.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_overlaps(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_overlaps) );
              return responseBody;
           
}
}(this)

          public StDfullywithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDfullywithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dfullywithin(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dfullywithin) );
              return responseBody;
           
}
}(this)

          public St_3ddwithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3ddwithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3ddwithin(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3ddwithin) );
              return responseBody;
           
}
}(this)

          public St_3ddfullywithin = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3ddfullywithin.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3ddfullywithin(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3ddfullywithin) );
              return responseBody;
           
}
}(this)

          public St_3dintersects = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dintersects.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dintersects(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3dintersects) );
              return responseBody;
           
}
}(this)

          public StOrderingequals = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StOrderingequals.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_orderingequals(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_orderingequals) );
              return responseBody;
           
}
}(this)

          public StEquals = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEquals.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_equals(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_equals) );
              return responseBody;
           
}
}(this)

          public StIsvalid_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsvalid_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isvalid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalid) );
              return responseBody;
           
}
}(this)

          public StMinimumclearance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMinimumclearance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_minimumclearance( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_minimumclearance) );
              return responseBody;
           
}
}(this)

          public StMinimumclearanceline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMinimumclearanceline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_minimumclearanceline( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_minimumclearanceline) );
              return responseBody;
           
}
}(this)

          public StCentroid_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCentroid_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_centroid( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}(this)

          public StGeometricmedian = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeometricmedian.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geometricmedian(g => ${ typed[49244](undefinedIsNull(parameters.g)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },max_iter => ${ typed[23](undefinedIsNull(parameters.maxIter)) },fail_if_not_converged => ${ typed[16](undefinedIsNull(parameters.failIfNotConverged)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometricmedian) );
              return responseBody;
           
}
}(this)

          public StIsring = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsring.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isring( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isring) );
              return responseBody;
           
}
}(this)

          public StPointonsurface = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointonsurface.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointonsurface( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointonsurface) );
              return responseBody;
           
}
}(this)

          public StIssimple = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIssimple.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_issimple( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_issimple) );
              return responseBody;
           
}
}(this)

          public StIscollection = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIscollection.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_iscollection( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_iscollection) );
              return responseBody;
           
}
}(this)

          public Equals = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Equals.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.equals(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].equals) );
              return responseBody;
           
}
}(this)

          public StGeomfromgml_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgml_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgml) );
              return responseBody;
           
}
}(this)

          public StGeomfromgmlE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgmlE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgml) );
              return responseBody;
           
}
}(this)

          public StGmltosqlE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGmltosqlE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_gmltosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_gmltosql) );
              return responseBody;
           
}
}(this)

          public StGmltosql_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGmltosql_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_gmltosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_gmltosql) );
              return responseBody;
           
}
}(this)

          public StGeomfromkml = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromkml.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromkml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromkml) );
              return responseBody;
           
}
}(this)

          public StGeomfrommarc21 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfrommarc21.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfrommarc21(marc21xml => ${ typed[25](undefinedIsNull(parameters.marc21xml)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfrommarc21) );
              return responseBody;
           
}
}(this)

          public StAsmarc21 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsmarc21.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asmarc21(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },format => ${ typed[25](undefinedIsNull(parameters.format)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asmarc21) );
              return responseBody;
           
}
}(this)

          public StGeomfromgeojsonE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgeojsonE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgeojson( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}(this)

          public StGeomfromgeojson_608f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgeojson_608f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgeojson( ${ typed[114](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}(this)

          public StGeomfromgeojson_3c9d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgeojson_3c9d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgeojson( ${ typed[3802](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}(this)

          public PostgisLibjsonVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_libjson_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libjson_version) );
              return responseBody;
           
}
}(this)

          public StLinefromencodedpolyline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefromencodedpolyline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefromencodedpolyline(txtin => ${ typed[25](undefinedIsNull(parameters.txtin)) },nprecision => ${ typed[23](undefinedIsNull(parameters.nprecision)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromencodedpolyline) );
              return responseBody;
           
}
}(this)

          public StAsencodedpolyline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsencodedpolyline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asencodedpolyline(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },nprecision => ${ typed[23](undefinedIsNull(parameters.nprecision)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asencodedpolyline) );
              return responseBody;
           
}
}(this)

          public StAssvgA8be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAssvgA8be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_assvg(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },rel => ${ typed[23](undefinedIsNull(parameters.rel)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}(this)

          public StAsgmlA8be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgmlA8be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgml(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}(this)

          public StAsgml_2621 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgml_2621.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgml(version => ${ typed[23](undefinedIsNull(parameters.version)) },geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}(this)

          public StAskmlE3da = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAskmlE3da.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_askml(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}(this)

          public StAsgeojsonA8be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgeojsonA8be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgeojson(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}(this)

          public StAsgeojsonF2c6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgeojsonF2c6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgeojson(r => ${ typed[2249](undefinedIsNull(parameters.r)) },geom_column => ${ typed[25](undefinedIsNull(parameters.geomColumn)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },pretty_bool => ${ typed[16](undefinedIsNull(parameters.prettyBool)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}(this)

          public Json = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Json.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Json.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.json( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Json.parse(results?.[0].json) );
              return responseBody;
           
}
}(this)

          public Jsonb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Jsonb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Jsonb.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.jsonb( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Jsonb.parse(results?.[0].jsonb) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtTransfn_647f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtTransfn_647f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtTransfn_27f4 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtTransfn_27f4.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtTransfnF57f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtTransfnF57f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtTransfn_92c1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtTransfn_92c1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) }, ${ typed[25](undefinedIsNull(parameters.argument_4)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtTransfnF5be = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtTransfnF5be.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) }, ${ typed[25](undefinedIsNull(parameters.argument_4)) }, ${ typed[25](undefinedIsNull(parameters.argument_5)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asmvt_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtCombinefn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtCombinefn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_combinefn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_combinefn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtSerialfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtSerialfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_serialfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asmvt_serialfn) );
              return responseBody;
           
}
}(this)

          public PgisAsmvtDeserialfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsmvtDeserialfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asmvt_deserialfn( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_deserialfn) );
              return responseBody;
           
}
}(this)

          public StAsmvtgeom = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsmvtgeom.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asmvtgeom(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },bounds => ${ typed[49275](undefinedIsNull(parameters.bounds)) },extent => ${ typed[23](undefinedIsNull(parameters.extent)) },buffer => ${ typed[23](undefinedIsNull(parameters.buffer)) },clip_geom => ${ typed[16](undefinedIsNull(parameters.clipGeom)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_asmvtgeom) );
              return responseBody;
           
}
}(this)

          public PostgisLibprotobufVersion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_libprotobuf_version()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libprotobuf_version) );
              return responseBody;
           
}
}(this)

          public PgisAsgeobufTransfn_647f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsgeobufTransfn_647f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asgeobuf_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsgeobufTransfn_27f4 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asgeobuf_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsgeobufFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsgeobufFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asgeobuf_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asgeobuf_finalfn) );
              return responseBody;
           
}
}(this)

          public PgisAsflatgeobufTransfn_647f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsflatgeobufTransfn_9633 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsflatgeobufTransfn_521f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}(this)

          public PgisAsflatgeobufFinalfn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PgisAsflatgeobufFinalfn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.pgis_asflatgeobuf_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asflatgeobuf_finalfn) );
              return responseBody;
           
}
}(this)

          public StFromflatgeobuftotable = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFromflatgeobuftotable.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_fromflatgeobuftotable( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[17](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].st_fromflatgeobuftotable) );
              return responseBody;
           
}
}(this)

          public StFromflatgeobuf = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFromflatgeobuf.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Anyelement.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_fromflatgeobuf( ${ typed[2283](undefinedIsNull(parameters.argument_0)) }, ${ typed[17](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_fromflatgeobuf)).filter<PgCatalog.Types.Anyelement>((r):r is PgCatalog.Types.Anyelement => r !== null) );
              return responseBody;
           
}
}(this)

          public StGeohashEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeohashEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geohash(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxchars => ${ typed[23](undefinedIsNull(parameters.maxchars)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geohash) );
              return responseBody;
           
}
}(this)

          public StBox2dfromgeohash = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBox2dfromgeohash.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_box2dfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_box2dfromgeohash) );
              return responseBody;
           
}
}(this)

          public StPointfromgeohash = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointfromgeohash.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromgeohash) );
              return responseBody;
           
}
}(this)

          public StGeomfromgeohash = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromgeohash.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeohash) );
              return responseBody;
           
}
}(this)

          public StNumpoints = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNumpoints.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_numpoints( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numpoints) );
              return responseBody;
           
}
}(this)

          public StNumgeometries = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNumgeometries.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_numgeometries( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numgeometries) );
              return responseBody;
           
}
}(this)

          public StGeometryn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeometryn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geometryn( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryn) );
              return responseBody;
           
}
}(this)

          public StDimension = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDimension.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dimension( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_dimension) );
              return responseBody;
           
}
}(this)

          public StExteriorring = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StExteriorring.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_exteriorring( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_exteriorring) );
              return responseBody;
           
}
}(this)

          public StNuminteriorrings = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNuminteriorrings.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_numinteriorrings( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numinteriorrings) );
              return responseBody;
           
}
}(this)

          public StNuminteriorring = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNuminteriorring.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_numinteriorring( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numinteriorring) );
              return responseBody;
           
}
}(this)

          public StInteriorringn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StInteriorringn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_interiorringn( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_interiorringn) );
              return responseBody;
           
}
}(this)

          public Geometrytype_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometrytype_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometrytype( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].geometrytype) );
              return responseBody;
           
}
}(this)

          public StGeometrytype = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeometrytype.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geometrytype( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geometrytype) );
              return responseBody;
           
}
}(this)

          public StPointn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointn( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointn) );
              return responseBody;
           
}
}(this)

          public StNumpatches = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StNumpatches.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_numpatches( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numpatches) );
              return responseBody;
           
}
}(this)

          public StPatchn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPatchn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_patchn( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_patchn) );
              return responseBody;
           
}
}(this)

          public StStartpoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StStartpoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_startpoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_startpoint) );
              return responseBody;
           
}
}(this)

          public StEndpoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StEndpoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_endpoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_endpoint) );
              return responseBody;
           
}
}(this)

          public StIsclosed = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsclosed.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isclosed( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isclosed) );
              return responseBody;
           
}
}(this)

          public StIsempty = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIsempty.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_isempty( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isempty) );
              return responseBody;
           
}
}(this)

          public StAsbinaryF1e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsbinaryF1e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asbinary( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}(this)

          public StAsbinary_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsbinary_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asbinary( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}(this)

          public StAstext_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstext_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astext( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}(this)

          public StAstextEd82 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstextEd82.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astext( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}(this)

          public StGeometryfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeometryfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geometryfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryfromtext) );
              return responseBody;
           
}
}(this)

          public StGeometryfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeometryfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geometryfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryfromtext) );
              return responseBody;
           
}
}(this)

          public StGeomfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtext) );
              return responseBody;
           
}
}(this)

          public StGeomfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtext) );
              return responseBody;
           
}
}(this)

          public StWkttosql = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StWkttosql.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_wkttosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wkttosql) );
              return responseBody;
           
}
}(this)

          public StPointfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromtext) );
              return responseBody;
           
}
}(this)

          public StPointfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromtext) );
              return responseBody;
           
}
}(this)

          public StLinefromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromtext) );
              return responseBody;
           
}
}(this)

          public StLinefromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromtext) );
              return responseBody;
           
}
}(this)

          public StPolyfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolyfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromtext) );
              return responseBody;
           
}
}(this)

          public StPolyfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolyfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromtext) );
              return responseBody;
           
}
}(this)

          public StPolygonfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygonfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromtext) );
              return responseBody;
           
}
}(this)

          public StPolygonfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygonfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromtext) );
              return responseBody;
           
}
}(this)

          public StMlinefromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMlinefromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mlinefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromtext) );
              return responseBody;
           
}
}(this)

          public StMlinefromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMlinefromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mlinefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromtext) );
              return responseBody;
           
}
}(this)

          public StMultilinestringfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultilinestringfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multilinestringfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinestringfromtext) );
              return responseBody;
           
}
}(this)

          public StMultilinestringfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultilinestringfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multilinestringfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinestringfromtext) );
              return responseBody;
           
}
}(this)

          public StMpointfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpointfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromtext) );
              return responseBody;
           
}
}(this)

          public StMpointfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpointfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromtext) );
              return responseBody;
           
}
}(this)

          public StMultipointfromtext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipointfromtext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromtext) );
              return responseBody;
           
}
}(this)

          public StMpolyfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpolyfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromtext) );
              return responseBody;
           
}
}(this)

          public StMpolyfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpolyfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromtext) );
              return responseBody;
           
}
}(this)

          public StMultipolygonfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipolygonfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipolygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolygonfromtext) );
              return responseBody;
           
}
}(this)

          public StMultipolygonfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipolygonfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipolygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolygonfromtext) );
              return responseBody;
           
}
}(this)

          public StGeomcollfromtext_27e2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomcollfromtext_27e2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomcollfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromtext) );
              return responseBody;
           
}
}(this)

          public StGeomcollfromtextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomcollfromtextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomcollfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromtext) );
              return responseBody;
           
}
}(this)

          public StGeomfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromwkb) );
              return responseBody;
           
}
}(this)

          public StGeomfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromwkb) );
              return responseBody;
           
}
}(this)

          public StPointfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromwkb) );
              return responseBody;
           
}
}(this)

          public StPointfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromwkb) );
              return responseBody;
           
}
}(this)

          public StLinefromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromwkb) );
              return responseBody;
           
}
}(this)

          public StLinefromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinefromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromwkb) );
              return responseBody;
           
}
}(this)

          public StLinestringfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinestringfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linestringfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linestringfromwkb) );
              return responseBody;
           
}
}(this)

          public StLinestringfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinestringfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linestringfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linestringfromwkb) );
              return responseBody;
           
}
}(this)

          public StPolyfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolyfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromwkb) );
              return responseBody;
           
}
}(this)

          public StPolyfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolyfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromwkb) );
              return responseBody;
           
}
}(this)

          public StPolygonfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygonfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygonfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromwkb) );
              return responseBody;
           
}
}(this)

          public StPolygonfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygonfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygonfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromwkb) );
              return responseBody;
           
}
}(this)

          public StMpointfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpointfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromwkb) );
              return responseBody;
           
}
}(this)

          public StMpointfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpointfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromwkb) );
              return responseBody;
           
}
}(this)

          public StMultipointfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipointfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromwkb) );
              return responseBody;
           
}
}(this)

          public GeographyAnalyze = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyAnalyze.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_analyze( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_analyze) );
              return responseBody;
           
}
}(this)

          public StMultipointfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipointfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromwkb) );
              return responseBody;
           
}
}(this)

          public StMultilinefromwkb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultilinefromwkb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multilinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinefromwkb) );
              return responseBody;
           
}
}(this)

          public StMlinefromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMlinefromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mlinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromwkb) );
              return responseBody;
           
}
}(this)

          public StMlinefromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMlinefromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mlinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromwkb) );
              return responseBody;
           
}
}(this)

          public StMpolyfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpolyfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromwkb) );
              return responseBody;
           
}
}(this)

          public StMpolyfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMpolyfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_mpolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromwkb) );
              return responseBody;
           
}
}(this)

          public StMultipolyfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipolyfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolyfromwkb) );
              return responseBody;
           
}
}(this)

          public StMultipolyfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMultipolyfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_multipolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolyfromwkb) );
              return responseBody;
           
}
}(this)

          public StGeomcollfromwkbD8af = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomcollfromwkbD8af.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomcollfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromwkb) );
              return responseBody;
           
}
}(this)

          public StGeomcollfromwkb_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeomcollfromwkb_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geomcollfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromwkb) );
              return responseBody;
           
}
}(this)

          public StMaxdistance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StMaxdistance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_maxdistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_maxdistance) );
              return responseBody;
           
}
}(this)

          public StClosestpointEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClosestpointEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_closestpoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}(this)

          public StShortestlineEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StShortestlineEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_shortestline(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}(this)

          public StLongestline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLongestline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_longestline(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_longestline) );
              return responseBody;
           
}
}(this)

          public StSwapordinates = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSwapordinates.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_swapordinates(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },ords => ${ typed[2275](undefinedIsNull(parameters.ords)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_swapordinates) );
              return responseBody;
           
}
}(this)

          public StFlipcoordinates = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StFlipcoordinates.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_flipcoordinates( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_flipcoordinates) );
              return responseBody;
           
}
}(this)

          public StBdpolyfromtext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBdpolyfromtext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_bdpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_bdpolyfromtext) );
              return responseBody;
           
}
}(this)

          public StBdmpolyfromtext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBdmpolyfromtext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_bdmpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_bdmpolyfromtext) );
              return responseBody;
           
}
}(this)

          public Unlockrows = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Unlockrows.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.unlockrows( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].unlockrows) );
              return responseBody;
           
}
}(this)

          public Geography_675a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geography_675a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}(this)

          public Geography_2d19 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geography_2d19.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}(this)

          public Bytea_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Bytea_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.bytea( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].bytea) );
              return responseBody;
           
}
}(this)

          public StAstext_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstext_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astext( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}(this)

          public StAstext_75a2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstext_75a2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astext( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}(this)

          public LockrowE9aa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.LockrowE9aa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) }, ${ typed[1114](undefinedIsNull(parameters.argument_4)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}(this)

          public Lockrow_02b4 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Lockrow_02b4.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}(this)

          public Lockrow_27e1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Lockrow_27e1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}(this)

          public Lockrow_9a8a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Lockrow_9a8a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[1114](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}(this)

          public Addauth = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Addauth.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.addauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].addauth) );
              return responseBody;
           
}
}(this)

          public Checkauth_27e1 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Checkauth_27e1.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.checkauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].checkauth) );
              return responseBody;
           
}
}(this)

          public Checkauth_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Checkauth_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.checkauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].checkauth) );
              return responseBody;
           
}
}(this)

          public Checkauthtrigger = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Trigger.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.checkauthtrigger()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Trigger.parse(results?.[0].checkauthtrigger) );
              return responseBody;
           
}
}(this)

          public Gettransactionid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Xid.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.gettransactionid()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Xid.parse(results?.[0].gettransactionid) );
              return responseBody;
           
}
}(this)

          public Enablelongtransactions = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.enablelongtransactions()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].enablelongtransactions) );
              return responseBody;
           
}
}(this)

          public Longtransactionsenabled = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.longtransactionsenabled()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].longtransactionsenabled) );
              return responseBody;
           
}
}(this)

          public Disablelongtransactions = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call() {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.disablelongtransactions()`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].disablelongtransactions) );
              return responseBody;
           
}
}(this)

          public GeographyTypmodIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyTypmodIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_typmod_in( ${ typed[1263](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geography_typmod_in) );
              return responseBody;
           
}
}(this)

          public GeographyTypmodOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyTypmodOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_typmod_out( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geography_typmod_out) );
              return responseBody;
           
}
}(this)

          public GeographyIn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyIn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography_in) );
              return responseBody;
           
}
}(this)

          public GeographyOut = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyOut.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_out( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geography_out) );
              return responseBody;
           
}
}(this)

          public GeographyRecv = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyRecv.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_recv( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography_recv) );
              return responseBody;
           
}
}(this)

          public GeographySend = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySend.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_send( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].geography_send) );
              return responseBody;
           
}
}(this)

          public StAstextE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAstextE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_astext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}(this)

          public StGeographyfromtext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeographyfromtext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geographyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geographyfromtext) );
              return responseBody;
           
}
}(this)

          public StGeogfromtext = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeogfromtext.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geogfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geogfromtext) );
              return responseBody;
           
}
}(this)

          public StGeogfromwkb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeogfromwkb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geogfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geogfromwkb) );
              return responseBody;
           
}
}(this)

          public PostgisTypmodDims = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTypmodDims.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_typmod_dims( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_typmod_dims) );
              return responseBody;
           
}
}(this)

          public PostgisTypmodSrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTypmodSrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_typmod_srid( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_typmod_srid) );
              return responseBody;
           
}
}(this)

          public PostgisTypmodType = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTypmodType.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_typmod_type( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_typmod_type) );
              return responseBody;
           
}
}(this)

          public Geography_0faa = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geography_0faa.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography( ${ typed[49244](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}(this)

          public Geometry_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometry_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}(this)

          public GeographyGistConsistent = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistConsistent.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_consistent( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_gist_consistent) );
              return responseBody;
           
}
}(this)

          public GeographyGistCompress = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistCompress.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_compress( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_compress) );
              return responseBody;
           
}
}(this)

          public GeographyGistPenalty = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistPenalty.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_penalty( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_penalty) );
              return responseBody;
           
}
}(this)

          public GeographyGistPicksplit = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistPicksplit.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_picksplit( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_picksplit) );
              return responseBody;
           
}
}(this)

          public GeographyGistUnion = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistUnion.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_union( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_union) );
              return responseBody;
           
}
}(this)

          public GeographyGistSame = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistSame.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_same( ${ typed[49275](undefinedIsNull(parameters.argument_0)) }, ${ typed[49275](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_same) );
              return responseBody;
           
}
}(this)

          public GeographyGistDecompress = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistDecompress.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_decompress( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_decompress) );
              return responseBody;
           
}
}(this)

          public GeographyOverlaps = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyOverlaps.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_overlaps( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_overlaps) );
              return responseBody;
           
}
}(this)

          public GeographyDistanceKnn = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyDistanceKnn.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_distance_knn( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geography_distance_knn) );
              return responseBody;
           
}
}(this)

          public GeographyGistDistance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGistDistance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gist_distance( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geography_gist_distance) );
              return responseBody;
           
}
}(this)

          public OverlapsGeog_5a37 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsGeog_5a37.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_geog( ${ typed[49283](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}(this)

          public OverlapsGeogBd57 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsGeogBd57.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_geog( ${ typed[49283](undefinedIsNull(parameters.argument_0)) }, ${ typed[49283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}(this)

          public OverlapsGeog_1597 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsGeog_1597.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_geog( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}(this)

          public GeogBrinInclusionAddValue = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeogBrinInclusionAddValue.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geog_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geog_brin_inclusion_add_value) );
              return responseBody;
           
}
}(this)

          public GeographyLt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyLt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_lt( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_lt) );
              return responseBody;
           
}
}(this)

          public GeographyLe = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyLe.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_le( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_le) );
              return responseBody;
           
}
}(this)

          public GeographyGt = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGt.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_gt( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_gt) );
              return responseBody;
           
}
}(this)

          public GeographyGe = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyGe.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_ge( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_ge) );
              return responseBody;
           
}
}(this)

          public GeographyEq = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyEq.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_eq( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_eq) );
              return responseBody;
           
}
}(this)

          public GeographyCmp = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographyCmp.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_cmp( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geography_cmp) );
              return responseBody;
           
}
}(this)

          public StAssvg_8ddb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAssvg_8ddb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_assvg(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },rel => ${ typed[23](undefinedIsNull(parameters.rel)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}(this)

          public StAssvgE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAssvgE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_assvg( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}(this)

          public StProjectE61a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StProjectE61a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_project(geog_from => ${ typed[49950](undefinedIsNull(parameters.geogFrom)) },geog_to => ${ typed[49950](undefinedIsNull(parameters.geogTo)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_project) );
              return responseBody;
           
}
}(this)

          public StAzimuthA587 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAzimuthA587.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_azimuth(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_azimuth) );
              return responseBody;
           
}
}(this)

          public StBuffer_49f7 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuffer_49f7.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StAsgmlCe11 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgmlCe11.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgml(version => ${ typed[23](undefinedIsNull(parameters.version)) },geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}(this)

          public StAsgml_98d7 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgml_98d7.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgml(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}(this)

          public StAsgmlE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgmlE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}(this)

          public StAskml_48da = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAskml_48da.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_askml(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}(this)

          public StAskmlE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAskmlE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_askml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}(this)

          public StAsgeojson_8ddb = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgeojson_8ddb.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgeojson(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}(this)

          public StAsgeojsonE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsgeojsonE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asgeojson( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}(this)

          public StDistance_89b8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistance_89b8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distance(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}(this)

          public StDistance_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistance_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distance( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}(this)

          public StAreaAc0a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAreaAc0a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_area(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}(this)

          public StAreaE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAreaE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_area( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}(this)

          public StLengthAc0a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLengthAc0a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_length(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}(this)

          public StLengthE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLengthE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_length( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}(this)

          public StProject_665e = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StProject_665e.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_project(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },azimuth => ${ typed[701](undefinedIsNull(parameters.azimuth)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_project) );
              return responseBody;
           
}
}(this)

          public StPerimeterAc0a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPerimeterAc0a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_perimeter(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter) );
              return responseBody;
           
}
}(this)

          public StSegmentize_772c = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSegmentize_772c.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_segmentize(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },max_segment_length => ${ typed[701](undefinedIsNull(parameters.maxSegmentLength)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_segmentize) );
              return responseBody;
           
}
}(this)

          public StAsbinary_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsbinary_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asbinary( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}(this)

          public StAsbinaryF815 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsbinaryF815.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asbinary( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}(this)

          public StAsewkt_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewkt_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkt( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}(this)

          public StAsewkt_75a2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewkt_75a2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkt( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}(this)

          public StAsewktE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsewktE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}(this)

          public Geometrytype_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geometrytype_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometrytype( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].geometrytype) );
              return responseBody;
           
}
}(this)

          public StSummary_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSummary_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_summary( ${ typed[49950](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_summary) );
              return responseBody;
           
}
}(this)

          public StGeohash_75a2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StGeohash_75a2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_geohash(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },maxchars => ${ typed[23](undefinedIsNull(parameters.maxchars)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geohash) );
              return responseBody;
           
}
}(this)

          public StSrid_38ca = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSrid_38ca.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_srid(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_srid) );
              return responseBody;
           
}
}(this)

          public StSetsrid_75a2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSetsrid_75a2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_setsrid(geog => ${ typed[49950](undefinedIsNull(parameters.geog)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_setsrid) );
              return responseBody;
           
}
}(this)

          public StCentroidAc0a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCentroidAc0a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_centroid(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}(this)

          public StCentroidE728 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCentroidE728.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_centroid( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}(this)

          public StCoversA587 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoversA587.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_covers(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}(this)

          public StDwithin_5395 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDwithin_5395.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dwithin(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}(this)

          public StCoveredbyA587 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoveredbyA587.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_coveredby(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}(this)

          public StIntersectsA587 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersectsA587.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersects(geog1 => ${ typed[49950](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[49950](undefinedIsNull(parameters.geog2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}(this)

          public StBuffer_772c = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuffer_772c.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StBuffer_2117 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuffer_2117.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StBuffer_3a01 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBuffer_3a01.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StBufferC349 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBufferC349.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StBufferF7c6 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StBufferF7c6.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}(this)

          public StIntersectionA587 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersectionA587.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersection( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[49950](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}(this)

          public StIntersection_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersection_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersection( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}(this)

          public StCovers_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCovers_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_covers( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}(this)

          public StCoveredby_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoveredby_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_coveredby( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}(this)

          public StDwithinEfc0 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDwithinEfc0.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_dwithin( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}(this)

          public StIntersects_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StIntersects_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_intersects( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}(this)

          public StClosestpoint_89b8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClosestpoint_89b8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_closestpoint(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[49950](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}(this)

          public StClosestpoint_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StClosestpoint_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_closestpoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}(this)

          public StShortestline_89b8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StShortestline_89b8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_shortestline(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[49950](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}(this)

          public StShortestline_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StShortestline_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_shortestline( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}(this)

          public StLinesubstring_665e = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinesubstring_665e.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linesubstring( ${ typed[49950](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}(this)

          public StLinesubstringE586 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinesubstringE586.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linesubstring( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}(this)

          public StLinelocatepoint_89b8 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinelocatepoint_89b8.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linelocatepoint(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[49950](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}(this)

          public StLinelocatepoint_2ec2 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinelocatepoint_2ec2.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linelocatepoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepoints_5d11 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepoints_5d11.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoints(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) },repeat => ${ typed[16](undefinedIsNull(parameters.repeat)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepointsC349 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepointsC349.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoints( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepointCee3 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepointCee3.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoint(argument_0 => ${ typed[49950](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}(this)

          public StLineinterpolatepointC349 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLineinterpolatepointC349.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_lineinterpolatepoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}(this)

          public StDistancesphereEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistancesphereEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distancesphere(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancesphere) );
              return responseBody;
           
}
}(this)

          public StDistancesphereE059 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StDistancesphereE059.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_distancesphere(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancesphere) );
              return responseBody;
           
}
}(this)

          public PostgisTypeName = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisTypeName.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Varchar.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_type_name(geomname => ${ typed[1043](undefinedIsNull(parameters.geomname)) },coord_dimension => ${ typed[23](undefinedIsNull(parameters.coordDimension)) },use_new_name => ${ typed[16](undefinedIsNull(parameters.useNewName)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Varchar.parse(results?.[0].postgis_type_name) );
              return responseBody;
           
}
}(this)

          public PostgisConstraintSrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisConstraintSrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_constraint_srid(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_constraint_srid) );
              return responseBody;
           
}
}(this)

          public PostgisConstraintDims = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisConstraintDims.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_constraint_dims(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_constraint_dims) );
              return responseBody;
           
}
}(this)

          public PostgisConstraintType = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.PostgisConstraintType.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Varchar.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.postgis_constraint_type(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Varchar.parse(results?.[0].postgis_constraint_type) );
              return responseBody;
           
}
}(this)

          public St_3ddistance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3ddistance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3ddistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3ddistance) );
              return responseBody;
           
}
}(this)

          public St_3dmaxdistance = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dmaxdistance.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dmaxdistance(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dmaxdistance) );
              return responseBody;
           
}
}(this)

          public St_3dclosestpoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dclosestpoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dclosestpoint(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dclosestpoint) );
              return responseBody;
           
}
}(this)

          public St_3dshortestline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dshortestline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dshortestline(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dshortestline) );
              return responseBody;
           
}
}(this)

          public St_3dlongestline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dlongestline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dlongestline(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dlongestline) );
              return responseBody;
           
}
}(this)

          public StCoorddim = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCoorddim.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_coorddim(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_coorddim) );
              return responseBody;
           
}
}(this)

          public StCurvetoline = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StCurvetoline.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_curvetoline(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },tol => ${ typed[701](undefinedIsNull(parameters.tol)) },toltype => ${ typed[23](undefinedIsNull(parameters.toltype)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_curvetoline) );
              return responseBody;
           
}
}(this)

          public StHasarc = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StHasarc.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_hasarc(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_hasarc) );
              return responseBody;
           
}
}(this)

          public StLinetocurve = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLinetocurve.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_linetocurve(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linetocurve) );
              return responseBody;
           
}
}(this)

          public StPoint_0aec = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPoint_0aec.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_point( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_point) );
              return responseBody;
           
}
}(this)

          public StPoint_0b7f = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPoint_0b7f.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_point(argument_0 => ${ typed[701](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_point) );
              return responseBody;
           
}
}(this)

          public StPointz = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointz.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointz(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },zcoordinate => ${ typed[701](undefinedIsNull(parameters.zcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointz) );
              return responseBody;
           
}
}(this)

          public StPointm = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointm.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointm(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },mcoordinate => ${ typed[701](undefinedIsNull(parameters.mcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointm) );
              return responseBody;
           
}
}(this)

          public StPointzm = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPointzm.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_pointzm(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },zcoordinate => ${ typed[701](undefinedIsNull(parameters.zcoordinate)) },mcoordinate => ${ typed[701](undefinedIsNull(parameters.mcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointzm) );
              return responseBody;
           
}
}(this)

          public StPolygon = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StPolygon.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_polygon( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygon) );
              return responseBody;
           
}
}(this)

          public StWkbtosql = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StWkbtosql.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_wkbtosql(wkb => ${ typed[17](undefinedIsNull(parameters.wkb)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wkbtosql) );
              return responseBody;
           
}
}(this)

          public StLocatebetween = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLocatebetween.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_locatebetween(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) },frommeasure => ${ typed[701](undefinedIsNull(parameters.frommeasure)) },tomeasure => ${ typed[701](undefinedIsNull(parameters.tomeasure)) },leftrightoffset => ${ typed[701](undefinedIsNull(parameters.leftrightoffset)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatebetween) );
              return responseBody;
           
}
}(this)

          public StLocatealong = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLocatealong.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_locatealong(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) },measure => ${ typed[701](undefinedIsNull(parameters.measure)) },leftrightoffset => ${ typed[701](undefinedIsNull(parameters.leftrightoffset)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatealong) );
              return responseBody;
           
}
}(this)

          public StLocatebetweenelevations = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLocatebetweenelevations.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_locatebetweenelevations(geometry => ${ typed[49244](undefinedIsNull(parameters.geometry)) },fromelevation => ${ typed[701](undefinedIsNull(parameters.fromelevation)) },toelevation => ${ typed[701](undefinedIsNull(parameters.toelevation)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatebetweenelevations) );
              return responseBody;
           
}
}(this)

          public StInterpolatepoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StInterpolatepoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_interpolatepoint(line => ${ typed[49244](undefinedIsNull(parameters.line)) },point => ${ typed[49244](undefinedIsNull(parameters.point)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_interpolatepoint) );
              return responseBody;
           
}
}(this)

          public StHexagon = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StHexagon.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_hexagon(size => ${ typed[701](undefinedIsNull(parameters.size)) },cell_i => ${ typed[23](undefinedIsNull(parameters.cellI)) },cell_j => ${ typed[23](undefinedIsNull(parameters.cellJ)) },origin => ${ typed[49244](undefinedIsNull(parameters.origin)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_hexagon) );
              return responseBody;
           
}
}(this)

          public StSquare = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSquare.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_square(size => ${ typed[701](undefinedIsNull(parameters.size)) },cell_i => ${ typed[23](undefinedIsNull(parameters.cellI)) },cell_j => ${ typed[23](undefinedIsNull(parameters.cellJ)) },origin => ${ typed[49244](undefinedIsNull(parameters.origin)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_square) );
              return responseBody;
           
}
}(this)

          public StHexagongrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StHexagongrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[50151].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StHexagongrid;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_hexagongrid(size => ${ typed[701](undefinedIsNull(parameters.size)) },bounds => ${ typed[49244](undefinedIsNull(parameters.bounds)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_hexagongrid)).filter<Public.Types.StHexagongrid>((r):r is Public.Types.StHexagongrid => r !== null) );
              return responseBody;
           
}
}(this)

          public StSquaregrid = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSquaregrid.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[50152].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StSquaregrid;
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_squaregrid(size => ${ typed[701](undefinedIsNull(parameters.size)) },bounds => ${ typed[49244](undefinedIsNull(parameters.bounds)) })`
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_squaregrid)).filter<Public.Types.StSquaregrid>((r):r is Public.Types.StSquaregrid => r !== null) );
              return responseBody;
           
}
}(this)

          public Contains_2dD703 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Contains_2dD703.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.contains_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}(this)

          public IsContained_2dD703 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.IsContained_2dD703.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.is_contained_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}(this)

          public Overlaps_2dD703 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Overlaps_2dD703.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}(this)

          public Overlaps_2d_1585 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Overlaps_2d_1585.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}(this)

          public Contains_2d_1585 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Contains_2d_1585.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.contains_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}(this)

          public IsContained_2d_1585 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.IsContained_2d_1585.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.is_contained_2d( ${ typed[49279](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}(this)

          public Contains_2d_3f94 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Contains_2d_3f94.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.contains_2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}(this)

          public IsContained_2d_3f94 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.IsContained_2d_3f94.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.is_contained_2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}(this)

          public Overlaps_2d_3f94 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Overlaps_2d_3f94.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_2d( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49279](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}(this)

          public OverlapsNd_44c4 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsNd_44c4.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_nd( ${ typed[49283](undefinedIsNull(parameters.argument_0)) }, ${ typed[49244](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}(this)

          public OverlapsNdBd57 = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsNdBd57.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_nd( ${ typed[49283](undefinedIsNull(parameters.argument_0)) }, ${ typed[49283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}(this)

          public OverlapsNd_19dd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.OverlapsNd_19dd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.overlaps_nd( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[49283](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}(this)

          public Geom2dBrinInclusionAddValue = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geom2dBrinInclusionAddValue.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geom2d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom2d_brin_inclusion_add_value) );
              return responseBody;
           
}
}(this)

          public Geom3dBrinInclusionAddValue = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geom3dBrinInclusionAddValue.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geom3d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom3d_brin_inclusion_add_value) );
              return responseBody;
           
}
}(this)

          public Geom4dBrinInclusionAddValue = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.Geom4dBrinInclusionAddValue.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geom4d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom4d_brin_inclusion_add_value) );
              return responseBody;
           
}
}(this)

          public StSimplifypolygonhull = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StSimplifypolygonhull.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_simplifypolygonhull(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },vertex_fraction => ${ typed[701](undefinedIsNull(parameters.vertexFraction)) },is_outer => ${ typed[16](undefinedIsNull(parameters.isOuter)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifypolygonhull) );
              return responseBody;
           
}
}(this)

          public StConcavehull = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StConcavehull.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_concavehull(param_geom => ${ typed[49244](undefinedIsNull(parameters.paramGeom)) },param_pctconvex => ${ typed[701](undefinedIsNull(parameters.paramPctconvex)) },param_allow_holes => ${ typed[16](undefinedIsNull(parameters.paramAllowHoles)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_concavehull) );
              return responseBody;
           
}
}(this)

          public StAsx3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAsx3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_asx3d(geom => ${ typed[49244](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asx3d) );
              return responseBody;
           
}
}(this)

          public StAngleEb6a = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StAngleEb6a.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_angle(line1 => ${ typed[49244](undefinedIsNull(parameters.line1)) },line2 => ${ typed[49244](undefinedIsNull(parameters.line2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_angle) );
              return responseBody;
           
}
}(this)

          public St_3dlineinterpolatepoint = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.St_3dlineinterpolatepoint.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_3dlineinterpolatepoint( ${ typed[49244](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dlineinterpolatepoint) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistConfig_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistConfig_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_config_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_2d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistChoose_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistChoose_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_choose_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_2d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistPicksplit_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistPicksplit_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_picksplit_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_2d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistInnerConsistent_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_inner_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_2d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistLeafConsistent_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_leaf_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_2d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistCompress_2d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistCompress_2d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_compress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_2d) );
              return responseBody;
           
}
}(this)

          public GeometryOverlaps_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryOverlaps_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_overlaps_3d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps_3d) );
              return responseBody;
           
}
}(this)

          public GeometryContains_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryContains_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_contains_3d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains_3d) );
              return responseBody;
           
}
}(this)

          public GeometryContained_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometryContained_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_contained_3d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contained_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySame_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySame_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_same_3d(geom1 => ${ typed[49244](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[49244](undefinedIsNull(parameters.geom2)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistConfig_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistConfig_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_config_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistChoose_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistChoose_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_choose_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistPicksplit_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistPicksplit_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_picksplit_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistInnerConsistent_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_inner_consistent_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistLeafConsistent_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_leaf_consistent_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistCompress_3d = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistCompress_3d.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_compress_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_3d) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistConfigNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistConfigNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_config_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistChooseNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistChooseNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_choose_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistPicksplitNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistPicksplitNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistInnerConsistentNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_inner_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistLeafConsistentNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_leaf_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_nd) );
              return responseBody;
           
}
}(this)

          public GeometrySpgistCompressNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeometrySpgistCompressNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geometry_spgist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistConfigNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistConfigNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_config_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_config_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistChooseNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistChooseNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_choose_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_choose_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistPicksplitNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistPicksplitNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_picksplit_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistInnerConsistentNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistInnerConsistentNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_inner_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_inner_consistent_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistLeafConsistentNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistLeafConsistentNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_leaf_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_spgist_leaf_consistent_nd) );
              return responseBody;
           
}
}(this)

          public GeographySpgistCompressNd = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.GeographySpgistCompressNd.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.geography_spgist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_spgist_compress_nd) );
              return responseBody;
           
}
}(this)

          public StLetters = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async call(parameters : Public.Procedures.StLetters.Parameters) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const sql = this.database.context.sql;
  const typed = sql.typed as unknown as PostgresTypecasts;
  const response = await sql`SELECT public.st_letters(letters => ${ typed[25](undefinedIsNull(parameters.letters)) },font => ${ typed[114](undefinedIsNull(parameters.font)) })`
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_letters) );
              return responseBody;
           
}
}(this)
}(this)

          public Tables = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

          public SpatialRefSys = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.SpatialRefSys.Values): Promise<Public.Types.SpatialRefSys>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    INSERT INTO
      public.spatial_ref_sys (srid,auth_name,auth_srid,srtext,proj4text)
    VALUES (${ values.srid === undefined ? sql`DEFAULT` : typed[23](values.srid) },${ values.authName === undefined ? sql`DEFAULT` : typed[1043](values.authName) },${ values.authSrid === undefined ? sql`DEFAULT` : typed[23](values.authSrid) },${ values.srtext === undefined ? sql`DEFAULT` : typed[1043](values.srtext) },${ values.proj4text === undefined ? sql`DEFAULT` : typed[1043](values.proj4text) })
    ON CONFLICT (srid) DO UPDATE
    SET
      auth_name = EXCLUDED.auth_name,auth_srid = EXCLUDED.auth_srid,srtext = EXCLUDED.srtext,proj4text = EXCLUDED.proj4text
    RETURNING
      srid,auth_name,auth_srid,srtext,proj4text
    `
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
async all(options?: Public.Tables.SpatialRefSys.Options) : Promise<Public.Types.SpatialRefSys[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      srid,auth_name,auth_srid,srtext,proj4text 
    FROM
      public.spatial_ref_sys 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))
}

          public SpatialRefSysPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.SpatialRefSysPkey, options?: Public.Tables.SpatialRefSys.Options) : Promise<Public.Types.SpatialRefSys>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      srid,auth_name,auth_srid,srtext,proj4text 
    FROM
      public.spatial_ref_sys 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}

async update(parameters: Public.Types.SpatialRefSysPkey, values: Partial<Public.Tables.SpatialRefSys.Values>) : Promise<Public.Types.SpatialRefSys>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.spatial_ref_sys 
    SET
      srid = ${ values.srid === undefined ? sql`srid` : typed[23](values.srid) } , auth_name = ${ values.authName === undefined ? sql`auth_name` : typed[1043](values.authName) } , auth_srid = ${ values.authSrid === undefined ? sql`auth_srid` : typed[23](values.authSrid) } , srtext = ${ values.srtext === undefined ? sql`srtext` : typed[1043](values.srtext) } , proj4text = ${ values.proj4text === undefined ? sql`proj4text` : typed[1043](values.proj4text) } 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    RETURNING srid,auth_name,auth_srid,srtext,proj4text`
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
async delete(parameters: Public.Types.SpatialRefSysPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.spatial_ref_sys 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    RETURNING srid,auth_name,auth_srid,srtext,proj4text`
 return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.SpatialRefSysPkey };
}(this)

          public NycCensusBlocks = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.NycCensusBlocks.Values): Promise<Public.Types.NycCensusBlocks>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      

      if (!Public.Tables.NycCensusBlocks.includesPrimaryKey(values)) {
      
const response = await sql`
      --
      INSERT INTO
        public.nyc_census_blocks (blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom)
      VALUES (${ values.blkid === undefined ? sql`DEFAULT` : typed[1043](values.blkid) },${ values.popnTotal === undefined ? sql`DEFAULT` : typed[701](values.popnTotal) },${ values.popnWhite === undefined ? sql`DEFAULT` : typed[701](values.popnWhite) },${ values.popnBlack === undefined ? sql`DEFAULT` : typed[701](values.popnBlack) },${ values.popnNativ === undefined ? sql`DEFAULT` : typed[701](values.popnNativ) },${ values.popnAsian === undefined ? sql`DEFAULT` : typed[701](values.popnAsian) },${ values.popnOther === undefined ? sql`DEFAULT` : typed[701](values.popnOther) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
      RETURNING
        gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await sql`
    INSERT INTO
      public.nyc_census_blocks (gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.blkid === undefined ? sql`DEFAULT` : typed[1043](values.blkid) },${ values.popnTotal === undefined ? sql`DEFAULT` : typed[701](values.popnTotal) },${ values.popnWhite === undefined ? sql`DEFAULT` : typed[701](values.popnWhite) },${ values.popnBlack === undefined ? sql`DEFAULT` : typed[701](values.popnBlack) },${ values.popnNativ === undefined ? sql`DEFAULT` : typed[701](values.popnNativ) },${ values.popnAsian === undefined ? sql`DEFAULT` : typed[701](values.popnAsian) },${ values.popnOther === undefined ? sql`DEFAULT` : typed[701](values.popnOther) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      blkid = EXCLUDED.blkid,popn_total = EXCLUDED.popn_total,popn_white = EXCLUDED.popn_white,popn_black = EXCLUDED.popn_black,popn_nativ = EXCLUDED.popn_nativ,popn_asian = EXCLUDED.popn_asian,popn_other = EXCLUDED.popn_other,boroname = EXCLUDED.boroname,geom = EXCLUDED.geom
    RETURNING
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}

          public NycCensusBlocksPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycCensusBlocksPkey, options?: Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}

async update(parameters: Public.Types.NycCensusBlocksPkey, values: Partial<Public.Tables.NycCensusBlocks.Values>) : Promise<Public.Types.NycCensusBlocks>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_census_blocks 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , blkid = ${ values.blkid === undefined ? sql`blkid` : typed[1043](values.blkid) } , popn_total = ${ values.popnTotal === undefined ? sql`popn_total` : typed[701](values.popnTotal) } , popn_white = ${ values.popnWhite === undefined ? sql`popn_white` : typed[701](values.popnWhite) } , popn_black = ${ values.popnBlack === undefined ? sql`popn_black` : typed[701](values.popnBlack) } , popn_nativ = ${ values.popnNativ === undefined ? sql`popn_nativ` : typed[701](values.popnNativ) } , popn_asian = ${ values.popnAsian === undefined ? sql`popn_asian` : typed[701](values.popnAsian) } , popn_other = ${ values.popnOther === undefined ? sql`popn_other` : typed[701](values.popnOther) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
async delete(parameters: Public.Types.NycCensusBlocksPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_census_blocks 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.NycCensusBlocksPkey };

          public NycCensusBlocksGeomIdx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycCensusBlocksGeomIdx, options?: Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks[]>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}

async update(parameters: Public.Types.NycCensusBlocksGeomIdx, values: Partial<Public.Tables.NycCensusBlocks.Values>) : Promise<Public.Types.NycCensusBlocks[]>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_census_blocks 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , blkid = ${ values.blkid === undefined ? sql`blkid` : typed[1043](values.blkid) } , popn_total = ${ values.popnTotal === undefined ? sql`popn_total` : typed[701](values.popnTotal) } , popn_white = ${ values.popnWhite === undefined ? sql`popn_white` : typed[701](values.popnWhite) } , popn_black = ${ values.popnBlack === undefined ? sql`popn_black` : typed[701](values.popnBlack) } , popn_nativ = ${ values.popnNativ === undefined ? sql`popn_nativ` : typed[701](values.popnNativ) } , popn_asian = ${ values.popnAsian === undefined ? sql`popn_asian` : typed[701](values.popnAsian) } , popn_other = ${ values.popnOther === undefined ? sql`popn_other` : typed[701](values.popnOther) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}
async delete(parameters: Public.Types.NycCensusBlocksGeomIdx) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_census_blocks 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}
}(this)

}(this)

          public NycHomicides = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.NycHomicides.Values): Promise<Public.Types.NycHomicides>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      

      if (!Public.Tables.NycHomicides.includesPrimaryKey(values)) {
      
const response = await sql`
      --
      INSERT INTO
        public.nyc_homicides (incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom)
      VALUES (${ values.incidentD === undefined ? sql`DEFAULT` : typed[1082](values.incidentD) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.numVictim === undefined ? sql`DEFAULT` : typed[1043](values.numVictim) },${ values.primaryMo === undefined ? sql`DEFAULT` : typed[1043](values.primaryMo) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.weapon === undefined ? sql`DEFAULT` : typed[1043](values.weapon) },${ values.lightDark === undefined ? sql`DEFAULT` : typed[1043](values.lightDark) },${ values.year === undefined ? sql`DEFAULT` : typed[701](values.year) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
      RETURNING
        gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await sql`
    INSERT INTO
      public.nyc_homicides (gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.incidentD === undefined ? sql`DEFAULT` : typed[1082](values.incidentD) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.numVictim === undefined ? sql`DEFAULT` : typed[1043](values.numVictim) },${ values.primaryMo === undefined ? sql`DEFAULT` : typed[1043](values.primaryMo) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.weapon === undefined ? sql`DEFAULT` : typed[1043](values.weapon) },${ values.lightDark === undefined ? sql`DEFAULT` : typed[1043](values.lightDark) },${ values.year === undefined ? sql`DEFAULT` : typed[701](values.year) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      incident_d = EXCLUDED.incident_d,boroname = EXCLUDED.boroname,num_victim = EXCLUDED.num_victim,primary_mo = EXCLUDED.primary_mo,id = EXCLUDED.id,weapon = EXCLUDED.weapon,light_dark = EXCLUDED.light_dark,year = EXCLUDED.year,geom = EXCLUDED.geom
    RETURNING
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}

          public NycHomicidesPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycHomicidesPkey, options?: Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}

async update(parameters: Public.Types.NycHomicidesPkey, values: Partial<Public.Tables.NycHomicides.Values>) : Promise<Public.Types.NycHomicides>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_homicides 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , incident_d = ${ values.incidentD === undefined ? sql`incident_d` : typed[1082](values.incidentD) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , num_victim = ${ values.numVictim === undefined ? sql`num_victim` : typed[1043](values.numVictim) } , primary_mo = ${ values.primaryMo === undefined ? sql`primary_mo` : typed[1043](values.primaryMo) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , weapon = ${ values.weapon === undefined ? sql`weapon` : typed[1043](values.weapon) } , light_dark = ${ values.lightDark === undefined ? sql`light_dark` : typed[1043](values.lightDark) } , year = ${ values.year === undefined ? sql`year` : typed[701](values.year) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
async delete(parameters: Public.Types.NycHomicidesPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_homicides 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.NycHomicidesPkey };

          public NycHomicidesGeomIdx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycHomicidesGeomIdx, options?: Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides[]>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}

async update(parameters: Public.Types.NycHomicidesGeomIdx, values: Partial<Public.Tables.NycHomicides.Values>) : Promise<Public.Types.NycHomicides[]>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_homicides 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , incident_d = ${ values.incidentD === undefined ? sql`incident_d` : typed[1082](values.incidentD) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , num_victim = ${ values.numVictim === undefined ? sql`num_victim` : typed[1043](values.numVictim) } , primary_mo = ${ values.primaryMo === undefined ? sql`primary_mo` : typed[1043](values.primaryMo) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , weapon = ${ values.weapon === undefined ? sql`weapon` : typed[1043](values.weapon) } , light_dark = ${ values.lightDark === undefined ? sql`light_dark` : typed[1043](values.lightDark) } , year = ${ values.year === undefined ? sql`year` : typed[701](values.year) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}
async delete(parameters: Public.Types.NycHomicidesGeomIdx) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_homicides 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}
}(this)

}(this)

          public NycNeighborhoods = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.NycNeighborhoods.Values): Promise<Public.Types.NycNeighborhoods>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      

      if (!Public.Tables.NycNeighborhoods.includesPrimaryKey(values)) {
      
const response = await sql`
      --
      INSERT INTO
        public.nyc_neighborhoods (boroname,name,geom)
      VALUES (${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
      RETURNING
        gid,boroname,name,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await sql`
    INSERT INTO
      public.nyc_neighborhoods (gid,boroname,name,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      boroname = EXCLUDED.boroname,name = EXCLUDED.name,geom = EXCLUDED.geom
    RETURNING
      gid,boroname,name,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}

          public NycNeighborhoodsPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycNeighborhoodsPkey, options?: Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}

async update(parameters: Public.Types.NycNeighborhoodsPkey, values: Partial<Public.Tables.NycNeighborhoods.Values>) : Promise<Public.Types.NycNeighborhoods>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_neighborhoods 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,boroname,name,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
async delete(parameters: Public.Types.NycNeighborhoodsPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_neighborhoods 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,boroname,name,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.NycNeighborhoodsPkey };

          public NycNeighborhoodsGeomIdx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycNeighborhoodsGeomIdx, options?: Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods[]>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}

async update(parameters: Public.Types.NycNeighborhoodsGeomIdx, values: Partial<Public.Tables.NycNeighborhoods.Values>) : Promise<Public.Types.NycNeighborhoods[]>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_neighborhoods 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,boroname,name,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}
async delete(parameters: Public.Types.NycNeighborhoodsGeomIdx) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_neighborhoods 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,boroname,name,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}
}(this)

}(this)

          public NycStreets = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.NycStreets.Values): Promise<Public.Types.NycStreets>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      

      if (!Public.Tables.NycStreets.includesPrimaryKey(values)) {
      
const response = await sql`
      --
      INSERT INTO
        public.nyc_streets (id,name,oneway,type,geom)
      VALUES (${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.oneway === undefined ? sql`DEFAULT` : typed[1043](values.oneway) },${ values.type === undefined ? sql`DEFAULT` : typed[1043](values.type) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
      RETURNING
        gid,id,name,oneway,type,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await sql`
    INSERT INTO
      public.nyc_streets (gid,id,name,oneway,type,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.oneway === undefined ? sql`DEFAULT` : typed[1043](values.oneway) },${ values.type === undefined ? sql`DEFAULT` : typed[1043](values.type) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      id = EXCLUDED.id,name = EXCLUDED.name,oneway = EXCLUDED.oneway,type = EXCLUDED.type,geom = EXCLUDED.geom
    RETURNING
      gid,id,name,oneway,type,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}

          public NycStreetsPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycStreetsPkey, options?: Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}

async update(parameters: Public.Types.NycStreetsPkey, values: Partial<Public.Tables.NycStreets.Values>) : Promise<Public.Types.NycStreets>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_streets 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , oneway = ${ values.oneway === undefined ? sql`oneway` : typed[1043](values.oneway) } , type = ${ values.type === undefined ? sql`type` : typed[1043](values.type) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,id,name,oneway,type,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
async delete(parameters: Public.Types.NycStreetsPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_streets 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,id,name,oneway,type,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.NycStreetsPkey };

          public NycStreetsGeomIdx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycStreetsGeomIdx, options?: Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets[]>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}

async update(parameters: Public.Types.NycStreetsGeomIdx, values: Partial<Public.Tables.NycStreets.Values>) : Promise<Public.Types.NycStreets[]>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_streets 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , oneway = ${ values.oneway === undefined ? sql`oneway` : typed[1043](values.oneway) } , type = ${ values.type === undefined ? sql`type` : typed[1043](values.type) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,id,name,oneway,type,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}
async delete(parameters: Public.Types.NycStreetsGeomIdx) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_streets 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,id,name,oneway,type,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}
}(this)

}(this)

          public NycSubwayStations = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Public.Tables.NycSubwayStations.Values): Promise<Public.Types.NycSubwayStations>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      

      if (!Public.Tables.NycSubwayStations.includesPrimaryKey(values)) {
      
const response = await sql`
      --
      INSERT INTO
        public.nyc_subway_stations (objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom)
      VALUES (${ values.objectid === undefined ? sql`DEFAULT` : typed[1700](values.objectid) },${ values.id === undefined ? sql`DEFAULT` : typed[1700](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.altName === undefined ? sql`DEFAULT` : typed[1043](values.altName) },${ values.crossSt === undefined ? sql`DEFAULT` : typed[1043](values.crossSt) },${ values.longName === undefined ? sql`DEFAULT` : typed[1043](values.longName) },${ values.label === undefined ? sql`DEFAULT` : typed[1043](values.label) },${ values.borough === undefined ? sql`DEFAULT` : typed[1043](values.borough) },${ values.nghbhd === undefined ? sql`DEFAULT` : typed[1043](values.nghbhd) },${ values.routes === undefined ? sql`DEFAULT` : typed[1043](values.routes) },${ values.transfers === undefined ? sql`DEFAULT` : typed[1043](values.transfers) },${ values.color === undefined ? sql`DEFAULT` : typed[1043](values.color) },${ values.express === undefined ? sql`DEFAULT` : typed[1043](values.express) },${ values.closed === undefined ? sql`DEFAULT` : typed[1043](values.closed) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
      RETURNING
        gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await sql`
    INSERT INTO
      public.nyc_subway_stations (gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.objectid === undefined ? sql`DEFAULT` : typed[1700](values.objectid) },${ values.id === undefined ? sql`DEFAULT` : typed[1700](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.altName === undefined ? sql`DEFAULT` : typed[1043](values.altName) },${ values.crossSt === undefined ? sql`DEFAULT` : typed[1043](values.crossSt) },${ values.longName === undefined ? sql`DEFAULT` : typed[1043](values.longName) },${ values.label === undefined ? sql`DEFAULT` : typed[1043](values.label) },${ values.borough === undefined ? sql`DEFAULT` : typed[1043](values.borough) },${ values.nghbhd === undefined ? sql`DEFAULT` : typed[1043](values.nghbhd) },${ values.routes === undefined ? sql`DEFAULT` : typed[1043](values.routes) },${ values.transfers === undefined ? sql`DEFAULT` : typed[1043](values.transfers) },${ values.color === undefined ? sql`DEFAULT` : typed[1043](values.color) },${ values.express === undefined ? sql`DEFAULT` : typed[1043](values.express) },${ values.closed === undefined ? sql`DEFAULT` : typed[1043](values.closed) },${ values.geom === undefined ? sql`DEFAULT` : typed[49244](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      objectid = EXCLUDED.objectid,id = EXCLUDED.id,name = EXCLUDED.name,alt_name = EXCLUDED.alt_name,cross_st = EXCLUDED.cross_st,long_name = EXCLUDED.long_name,label = EXCLUDED.label,borough = EXCLUDED.borough,nghbhd = EXCLUDED.nghbhd,routes = EXCLUDED.routes,transfers = EXCLUDED.transfers,color = EXCLUDED.color,express = EXCLUDED.express,closed = EXCLUDED.closed,geom = EXCLUDED.geom
    RETURNING
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations[]>{

      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}

          public NycSubwayStationsPkey = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycSubwayStationsPkey, options?: Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}

async update(parameters: Public.Types.NycSubwayStationsPkey, values: Partial<Public.Tables.NycSubwayStations.Values>) : Promise<Public.Types.NycSubwayStations>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_subway_stations 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , objectid = ${ values.objectid === undefined ? sql`objectid` : typed[1700](values.objectid) } , id = ${ values.id === undefined ? sql`id` : typed[1700](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , alt_name = ${ values.altName === undefined ? sql`alt_name` : typed[1043](values.altName) } , cross_st = ${ values.crossSt === undefined ? sql`cross_st` : typed[1043](values.crossSt) } , long_name = ${ values.longName === undefined ? sql`long_name` : typed[1043](values.longName) } , label = ${ values.label === undefined ? sql`label` : typed[1043](values.label) } , borough = ${ values.borough === undefined ? sql`borough` : typed[1043](values.borough) } , nghbhd = ${ values.nghbhd === undefined ? sql`nghbhd` : typed[1043](values.nghbhd) } , routes = ${ values.routes === undefined ? sql`routes` : typed[1043](values.routes) } , transfers = ${ values.transfers === undefined ? sql`transfers` : typed[1043](values.transfers) } , color = ${ values.color === undefined ? sql`color` : typed[1043](values.color) } , express = ${ values.express === undefined ? sql`express` : typed[1043](values.express) } , closed = ${ values.closed === undefined ? sql`closed` : typed[1043](values.closed) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
async delete(parameters: Public.Types.NycSubwayStationsPkey) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_subway_stations 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
}(this)
public get ByPrimaryKey(){ return this.NycSubwayStationsPkey };

          public NycSubwayStationsGeomIdx = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
async read(parameters: Public.Types.NycSubwayStationsGeomIdx, options?: Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations[]>{

      console.assert(parameters);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await sql`
    -- 
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}

async update(parameters: Public.Types.NycSubwayStationsGeomIdx, values: Partial<Public.Tables.NycSubwayStations.Values>) : Promise<Public.Types.NycSubwayStations[]>{

      console.assert(parameters);
      console.assert(values);
      const sql = this.database.context.sql;
      const typed = sql.typed as unknown as PostgresTypecasts;
      
const response = await sql`
    --
    UPDATE 
      public.nyc_subway_stations 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , objectid = ${ values.objectid === undefined ? sql`objectid` : typed[1700](values.objectid) } , id = ${ values.id === undefined ? sql`id` : typed[1700](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , alt_name = ${ values.altName === undefined ? sql`alt_name` : typed[1043](values.altName) } , cross_st = ${ values.crossSt === undefined ? sql`cross_st` : typed[1043](values.crossSt) } , long_name = ${ values.longName === undefined ? sql`long_name` : typed[1043](values.longName) } , label = ${ values.label === undefined ? sql`label` : typed[1043](values.label) } , borough = ${ values.borough === undefined ? sql`borough` : typed[1043](values.borough) } , nghbhd = ${ values.nghbhd === undefined ? sql`nghbhd` : typed[1043](values.nghbhd) } , routes = ${ values.routes === undefined ? sql`routes` : typed[1043](values.routes) } , transfers = ${ values.transfers === undefined ? sql`transfers` : typed[1043](values.transfers) } , color = ${ values.color === undefined ? sql`color` : typed[1043](values.color) } , express = ${ values.express === undefined ? sql`express` : typed[1043](values.express) } , closed = ${ values.closed === undefined ? sql`closed` : typed[1043](values.closed) } , geom = ${ values.geom === undefined ? sql`geom` : typed[49244](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}
async delete(parameters: Public.Types.NycSubwayStationsGeomIdx) {
 console.assert(parameters);
 const sql = this.database.context.sql;
 const typed = sql.typed as unknown as PostgresTypecasts;
 const response = await sql`
    --
    DELETE FROM 
      public.nyc_subway_stations 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[49244](parameters.geom) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`
 return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}
}(this)

}(this)
}(this)
}(this)

          public PgToast = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

          public Procedures = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
}(this)

          public Tables = new class implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
}(this)
}(this)
}

          // begin - operation dispatch map
          import { EmbraceSQLRequest, OperationDispatchMethod } from "@embracesql/shared";
          export class OperationDispatcher {
            private dispatchMap: Record<string, OperationDispatchMethod>;
            constructor(private database: Database){
              this.dispatchMap = {

          
"Public.Procedures.StForcepolygoncw.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcepolygoncw.call(request.parameters as Public.Procedures.StForcepolygoncw.Parameters),
"Public.Procedures.SpheroidIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.SpheroidIn.call(request.parameters as Public.Procedures.SpheroidIn.Parameters),
"Public.Procedures.SpheroidOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.SpheroidOut.call(request.parameters as Public.Procedures.SpheroidOut.Parameters),
"Public.Procedures.GeometryIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryIn.call(request.parameters as Public.Procedures.GeometryIn.Parameters),
"Public.Procedures.GeometryOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOut.call(request.parameters as Public.Procedures.GeometryOut.Parameters),
"Public.Procedures.GeometryTypmodIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryTypmodIn.call(request.parameters as Public.Procedures.GeometryTypmodIn.Parameters),
"Public.Procedures.GeometryTypmodOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryTypmodOut.call(request.parameters as Public.Procedures.GeometryTypmodOut.Parameters),
"Public.Procedures.GeometryAnalyze.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryAnalyze.call(request.parameters as Public.Procedures.GeometryAnalyze.Parameters),
"Public.Procedures.GeometryRecv.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryRecv.call(request.parameters as Public.Procedures.GeometryRecv.Parameters),
"Public.Procedures.GeometrySend.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySend.call(request.parameters as Public.Procedures.GeometrySend.Parameters),
"Public.Procedures.Geometry_4946.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometry_4946.call(request.parameters as Public.Procedures.Geometry_4946.Parameters),
"Public.Procedures.Geometry_8997.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometry_8997.call(request.parameters as Public.Procedures.Geometry_8997.Parameters),
"Public.Procedures.Point.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Point.call(request.parameters as Public.Procedures.Point.Parameters),
"Public.Procedures.GeometryB0d8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryB0d8.call(request.parameters as Public.Procedures.GeometryB0d8.Parameters),
"Public.Procedures.Path.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Path.call(request.parameters as Public.Procedures.Path.Parameters),
"Public.Procedures.GeometryF1be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryF1be.call(request.parameters as Public.Procedures.GeometryF1be.Parameters),
"Public.Procedures.Polygon.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Polygon.call(request.parameters as Public.Procedures.Polygon.Parameters),
"Public.Procedures.StX.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StX.call(request.parameters as Public.Procedures.StX.Parameters),
"Public.Procedures.StY.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StY.call(request.parameters as Public.Procedures.StY.Parameters),
"Public.Procedures.StZ.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StZ.call(request.parameters as Public.Procedures.StZ.Parameters),
"Public.Procedures.StM.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StM.call(request.parameters as Public.Procedures.StM.Parameters),
"Public.Procedures.Box3dIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box3dIn.call(request.parameters as Public.Procedures.Box3dIn.Parameters),
"Public.Procedures.Box3dOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box3dOut.call(request.parameters as Public.Procedures.Box3dOut.Parameters),
"Public.Procedures.Box2dIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2dIn.call(request.parameters as Public.Procedures.Box2dIn.Parameters),
"Public.Procedures.Box2dOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2dOut.call(request.parameters as Public.Procedures.Box2dOut.Parameters),
"Public.Procedures.Box2dfIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2dfIn.call(request.parameters as Public.Procedures.Box2dfIn.Parameters),
"Public.Procedures.Box2dfOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2dfOut.call(request.parameters as Public.Procedures.Box2dfOut.Parameters),
"Public.Procedures.GidxIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GidxIn.call(request.parameters as Public.Procedures.GidxIn.Parameters),
"Public.Procedures.GidxOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GidxOut.call(request.parameters as Public.Procedures.GidxOut.Parameters),
"Public.Procedures.GeometryLt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryLt.call(request.parameters as Public.Procedures.GeometryLt.Parameters),
"Public.Procedures.GeometryLe.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryLe.call(request.parameters as Public.Procedures.GeometryLe.Parameters),
"Public.Procedures.GeometryGt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGt.call(request.parameters as Public.Procedures.GeometryGt.Parameters),
"Public.Procedures.GeometryGe.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGe.call(request.parameters as Public.Procedures.GeometryGe.Parameters),
"Public.Procedures.GeometryEq.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryEq.call(request.parameters as Public.Procedures.GeometryEq.Parameters),
"Public.Procedures.GeometryCmp.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryCmp.call(request.parameters as Public.Procedures.GeometryCmp.Parameters),
"Public.Procedures.GeometrySortsupport.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySortsupport.call(request.parameters as Public.Procedures.GeometrySortsupport.Parameters),
"Public.Procedures.GeometryHash.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryHash.call(request.parameters as Public.Procedures.GeometryHash.Parameters),
"Public.Procedures.GeometryGistDistance_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistDistance_2d.call(request.parameters as Public.Procedures.GeometryGistDistance_2d.Parameters),
"Public.Procedures.GeometryGistConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistConsistent_2d.call(request.parameters as Public.Procedures.GeometryGistConsistent_2d.Parameters),
"Public.Procedures.GeometryGistCompress_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistCompress_2d.call(request.parameters as Public.Procedures.GeometryGistCompress_2d.Parameters),
"Public.Procedures.GeometryGistPenalty_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistPenalty_2d.call(request.parameters as Public.Procedures.GeometryGistPenalty_2d.Parameters),
"Public.Procedures.GeometryGistPicksplit_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistPicksplit_2d.call(request.parameters as Public.Procedures.GeometryGistPicksplit_2d.Parameters),
"Public.Procedures.GeometryGistUnion_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistUnion_2d.call(request.parameters as Public.Procedures.GeometryGistUnion_2d.Parameters),
"Public.Procedures.GeometryGistSame_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistSame_2d.call(request.parameters as Public.Procedures.GeometryGistSame_2d.Parameters),
"Public.Procedures.GeometryGistDecompress_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistDecompress_2d.call(request.parameters as Public.Procedures.GeometryGistDecompress_2d.Parameters),
"Public.Procedures.GeometryGistSortsupport_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistSortsupport_2d.call(request.parameters as Public.Procedures.GeometryGistSortsupport_2d.Parameters),
"Public.Procedures.StForcerhr.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcerhr.call(request.parameters as Public.Procedures.StForcerhr.Parameters),
"Public.Procedures.PostgisNoop.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisNoop.call(request.parameters as Public.Procedures.PostgisNoop.Parameters),
"Public.Procedures.StForcepolygonccw.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcepolygonccw.call(request.parameters as Public.Procedures.StForcepolygonccw.Parameters),
"Public.Procedures.GserializedGistSel_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GserializedGistSel_2d.call(request.parameters as Public.Procedures.GserializedGistSel_2d.Parameters),
"Public.Procedures.GserializedGistSelNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GserializedGistSelNd.call(request.parameters as Public.Procedures.GserializedGistSelNd.Parameters),
"Public.Procedures.GserializedGistJoinsel_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GserializedGistJoinsel_2d.call(request.parameters as Public.Procedures.GserializedGistJoinsel_2d.Parameters),
"Public.Procedures.GserializedGistJoinselNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GserializedGistJoinselNd.call(request.parameters as Public.Procedures.GserializedGistJoinselNd.Parameters),
"Public.Procedures.GeometryOverlaps.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverlaps.call(request.parameters as Public.Procedures.GeometryOverlaps.Parameters),
"Public.Procedures.GeometrySame.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySame.call(request.parameters as Public.Procedures.GeometrySame.Parameters),
"Public.Procedures.GeometryDistanceCentroid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryDistanceCentroid.call(request.parameters as Public.Procedures.GeometryDistanceCentroid.Parameters),
"Public.Procedures.GeometryDistanceBox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryDistanceBox.call(request.parameters as Public.Procedures.GeometryDistanceBox.Parameters),
"Public.Procedures.GeometryContains.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryContains.call(request.parameters as Public.Procedures.GeometryContains.Parameters),
"Public.Procedures.GeometryWithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryWithin.call(request.parameters as Public.Procedures.GeometryWithin.Parameters),
"Public.Procedures.GeometryLeft.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryLeft.call(request.parameters as Public.Procedures.GeometryLeft.Parameters),
"Public.Procedures.GeometryOverleft.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverleft.call(request.parameters as Public.Procedures.GeometryOverleft.Parameters),
"Public.Procedures.GeometryBelow.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryBelow.call(request.parameters as Public.Procedures.GeometryBelow.Parameters),
"Public.Procedures.GeometryOverbelow.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverbelow.call(request.parameters as Public.Procedures.GeometryOverbelow.Parameters),
"Public.Procedures.GeometryOverright.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverright.call(request.parameters as Public.Procedures.GeometryOverright.Parameters),
"Public.Procedures.GeometryRight.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryRight.call(request.parameters as Public.Procedures.GeometryRight.Parameters),
"Public.Procedures.GeometryOverabove.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverabove.call(request.parameters as Public.Procedures.GeometryOverabove.Parameters),
"Public.Procedures.GeometryAbove.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryAbove.call(request.parameters as Public.Procedures.GeometryAbove.Parameters),
"Public.Procedures.GeometryGistConsistentNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistConsistentNd.call(request.parameters as Public.Procedures.GeometryGistConsistentNd.Parameters),
"Public.Procedures.GeometryGistCompressNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistCompressNd.call(request.parameters as Public.Procedures.GeometryGistCompressNd.Parameters),
"Public.Procedures.GeometryGistPenaltyNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistPenaltyNd.call(request.parameters as Public.Procedures.GeometryGistPenaltyNd.Parameters),
"Public.Procedures.GeometryGistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistPicksplitNd.call(request.parameters as Public.Procedures.GeometryGistPicksplitNd.Parameters),
"Public.Procedures.GeometryGistUnionNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistUnionNd.call(request.parameters as Public.Procedures.GeometryGistUnionNd.Parameters),
"Public.Procedures.GeometryGistSameNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistSameNd.call(request.parameters as Public.Procedures.GeometryGistSameNd.Parameters),
"Public.Procedures.GeometryGistDecompressNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistDecompressNd.call(request.parameters as Public.Procedures.GeometryGistDecompressNd.Parameters),
"Public.Procedures.GeometryOverlapsNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverlapsNd.call(request.parameters as Public.Procedures.GeometryOverlapsNd.Parameters),
"Public.Procedures.GeometryContainsNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryContainsNd.call(request.parameters as Public.Procedures.GeometryContainsNd.Parameters),
"Public.Procedures.GeometryWithinNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryWithinNd.call(request.parameters as Public.Procedures.GeometryWithinNd.Parameters),
"Public.Procedures.GeometrySameNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySameNd.call(request.parameters as Public.Procedures.GeometrySameNd.Parameters),
"Public.Procedures.GeometryDistanceCentroidNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryDistanceCentroidNd.call(request.parameters as Public.Procedures.GeometryDistanceCentroidNd.Parameters),
"Public.Procedures.GeometryDistanceCpa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryDistanceCpa.call(request.parameters as Public.Procedures.GeometryDistanceCpa.Parameters),
"Public.Procedures.GeometryGistDistanceNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryGistDistanceNd.call(request.parameters as Public.Procedures.GeometryGistDistanceNd.Parameters),
"Public.Procedures.StShiftlongitude.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StShiftlongitude.call(request.parameters as Public.Procedures.StShiftlongitude.Parameters),
"Public.Procedures.StWrapx.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StWrapx.call(request.parameters as Public.Procedures.StWrapx.Parameters),
"Public.Procedures.StXmin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StXmin.call(request.parameters as Public.Procedures.StXmin.Parameters),
"Public.Procedures.StYmin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StYmin.call(request.parameters as Public.Procedures.StYmin.Parameters),
"Public.Procedures.StZmin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StZmin.call(request.parameters as Public.Procedures.StZmin.Parameters),
"Public.Procedures.StXmax.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StXmax.call(request.parameters as Public.Procedures.StXmax.Parameters),
"Public.Procedures.StYmax.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StYmax.call(request.parameters as Public.Procedures.StYmax.Parameters),
"Public.Procedures.StZmax.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StZmax.call(request.parameters as Public.Procedures.StZmax.Parameters),
"Public.Procedures.StExpand_3044.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpand_3044.call(request.parameters as Public.Procedures.StExpand_3044.Parameters),
"Public.Procedures.StExpand_3ea7.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpand_3ea7.call(request.parameters as Public.Procedures.StExpand_3ea7.Parameters),
"Public.Procedures.PostgisGetbbox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisGetbbox.call(request.parameters as Public.Procedures.PostgisGetbbox.Parameters),
"Public.Procedures.StMakebox2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakebox2d.call(request.parameters as Public.Procedures.StMakebox2d.Parameters),
"Public.Procedures.StEstimatedextentD2f5.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEstimatedextentD2f5.call(request.parameters as Public.Procedures.StEstimatedextentD2f5.Parameters),
"Public.Procedures.StEstimatedextent_27e1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEstimatedextent_27e1.call(request.parameters as Public.Procedures.StEstimatedextent_27e1.Parameters),
"Public.Procedures.StEstimatedextent_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEstimatedextent_2ec2.call(request.parameters as Public.Procedures.StEstimatedextent_2ec2.Parameters),
"Public.Procedures.StFindextent_27e1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFindextent_27e1.call(request.parameters as Public.Procedures.StFindextent_27e1.Parameters),
"Public.Procedures.StFindextent_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFindextent_2ec2.call(request.parameters as Public.Procedures.StFindextent_2ec2.Parameters),
"Public.Procedures.PostgisAddbbox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisAddbbox.call(request.parameters as Public.Procedures.PostgisAddbbox.Parameters),
"Public.Procedures.PostgisDropbbox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisDropbbox.call(request.parameters as Public.Procedures.PostgisDropbbox.Parameters),
"Public.Procedures.PostgisHasbbox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisHasbbox.call(request.parameters as Public.Procedures.PostgisHasbbox.Parameters),
"Public.Procedures.StQuantizecoordinates.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StQuantizecoordinates.call(request.parameters as Public.Procedures.StQuantizecoordinates.Parameters),
"Public.Procedures.StMemsize.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMemsize.call(request.parameters as Public.Procedures.StMemsize.Parameters),
"Public.Procedures.StSummary_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSummary_0faa.call(request.parameters as Public.Procedures.StSummary_0faa.Parameters),
"Public.Procedures.StNpoints.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNpoints.call(request.parameters as Public.Procedures.StNpoints.Parameters),
"Public.Procedures.StNrings.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNrings.call(request.parameters as Public.Procedures.StNrings.Parameters),
"Public.Procedures.St_3dlength.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dlength.call(request.parameters as Public.Procedures.St_3dlength.Parameters),
"Public.Procedures.StLength2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLength2d.call(request.parameters as Public.Procedures.StLength2d.Parameters),
"Public.Procedures.StLength_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLength_0faa.call(request.parameters as Public.Procedures.StLength_0faa.Parameters),
"Public.Procedures.StLengthspheroid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLengthspheroid.call(request.parameters as Public.Procedures.StLengthspheroid.Parameters),
"Public.Procedures.StLength2dspheroid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLength2dspheroid.call(request.parameters as Public.Procedures.StLength2dspheroid.Parameters),
"Public.Procedures.St_3dperimeter.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dperimeter.call(request.parameters as Public.Procedures.St_3dperimeter.Parameters),
"Public.Procedures.StPerimeter2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPerimeter2d.call(request.parameters as Public.Procedures.StPerimeter2d.Parameters),
"Public.Procedures.StPerimeter_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPerimeter_0faa.call(request.parameters as Public.Procedures.StPerimeter_0faa.Parameters),
"Public.Procedures.StArea2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StArea2d.call(request.parameters as Public.Procedures.StArea2d.Parameters),
"Public.Procedures.StArea_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StArea_0faa.call(request.parameters as Public.Procedures.StArea_0faa.Parameters),
"Public.Procedures.StIspolygoncw.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIspolygoncw.call(request.parameters as Public.Procedures.StIspolygoncw.Parameters),
"Public.Procedures.StIspolygonccw.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIspolygonccw.call(request.parameters as Public.Procedures.StIspolygonccw.Parameters),
"Public.Procedures.StDistancespheroid_0cb2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistancespheroid_0cb2.call(request.parameters as Public.Procedures.StDistancespheroid_0cb2.Parameters),
"Public.Procedures.StDistancespheroidEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistancespheroidEb6a.call(request.parameters as Public.Procedures.StDistancespheroidEb6a.Parameters),
"Public.Procedures.StDistanceEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistanceEb6a.call(request.parameters as Public.Procedures.StDistanceEb6a.Parameters),
"Public.Procedures.StPointinsidecircle.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointinsidecircle.call(request.parameters as Public.Procedures.StPointinsidecircle.Parameters),
"Public.Procedures.StAzimuthEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAzimuthEb6a.call(request.parameters as Public.Procedures.StAzimuthEb6a.Parameters),
"Public.Procedures.StProject_2077.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StProject_2077.call(request.parameters as Public.Procedures.StProject_2077.Parameters),
"Public.Procedures.StProjectE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StProjectE059.call(request.parameters as Public.Procedures.StProjectE059.Parameters),
"Public.Procedures.StAngleA4a1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAngleA4a1.call(request.parameters as Public.Procedures.StAngleA4a1.Parameters),
"Public.Procedures.StLineextend.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineextend.call(request.parameters as Public.Procedures.StLineextend.Parameters),
"Public.Procedures.StForce2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForce2d.call(request.parameters as Public.Procedures.StForce2d.Parameters),
"Public.Procedures.StForce3dz.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForce3dz.call(request.parameters as Public.Procedures.StForce3dz.Parameters),
"Public.Procedures.StForce3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForce3d.call(request.parameters as Public.Procedures.StForce3d.Parameters),
"Public.Procedures.StForce3dm.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForce3dm.call(request.parameters as Public.Procedures.StForce3dm.Parameters),
"Public.Procedures.StForce4d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForce4d.call(request.parameters as Public.Procedures.StForce4d.Parameters),
"Public.Procedures.StForcecollection.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcecollection.call(request.parameters as Public.Procedures.StForcecollection.Parameters),
"Public.Procedures.StCollectionextractEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCollectionextractEd82.call(request.parameters as Public.Procedures.StCollectionextractEd82.Parameters),
"Public.Procedures.StCollectionextract_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCollectionextract_0faa.call(request.parameters as Public.Procedures.StCollectionextract_0faa.Parameters),
"Public.Procedures.StCollectionhomogenize.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCollectionhomogenize.call(request.parameters as Public.Procedures.StCollectionhomogenize.Parameters),
"Public.Procedures.StMulti.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMulti.call(request.parameters as Public.Procedures.StMulti.Parameters),
"Public.Procedures.StForcecurve.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcecurve.call(request.parameters as Public.Procedures.StForcecurve.Parameters),
"Public.Procedures.StForcesfs_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcesfs_0faa.call(request.parameters as Public.Procedures.StForcesfs_0faa.Parameters),
"Public.Procedures.StForcesfsF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StForcesfsF1e2.call(request.parameters as Public.Procedures.StForcesfsF1e2.Parameters),
"Public.Procedures.StExpand_95d4.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpand_95d4.call(request.parameters as Public.Procedures.StExpand_95d4.Parameters),
"Public.Procedures.StExpandF49e.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpandF49e.call(request.parameters as Public.Procedures.StExpandF49e.Parameters),
"Public.Procedures.StExpandDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpandDeb6.call(request.parameters as Public.Procedures.StExpandDeb6.Parameters),
"Public.Procedures.StExpandBf72.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExpandBf72.call(request.parameters as Public.Procedures.StExpandBf72.Parameters),
"Public.Procedures.StEnvelope.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEnvelope.call(request.parameters as Public.Procedures.StEnvelope.Parameters),
"Public.Procedures.StBoundingdiagonal.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBoundingdiagonal.call(request.parameters as Public.Procedures.StBoundingdiagonal.Parameters),
"Public.Procedures.StReverse.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StReverse.call(request.parameters as Public.Procedures.StReverse.Parameters),
"Public.Procedures.StScroll.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StScroll.call(request.parameters as Public.Procedures.StScroll.Parameters),
"Public.Procedures.PostgisGeosNoop.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisGeosNoop.call(request.parameters as Public.Procedures.PostgisGeosNoop.Parameters),
"Public.Procedures.StNormalize.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNormalize.call(request.parameters as Public.Procedures.StNormalize.Parameters),
"Public.Procedures.StZmflag.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StZmflag.call(request.parameters as Public.Procedures.StZmflag.Parameters),
"Public.Procedures.StNdims.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNdims.call(request.parameters as Public.Procedures.StNdims.Parameters),
"Public.Procedures.StAsewkt_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewkt_0faa.call(request.parameters as Public.Procedures.StAsewkt_0faa.Parameters),
"Public.Procedures.StAsewktEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewktEd82.call(request.parameters as Public.Procedures.StAsewktEd82.Parameters),
"Public.Procedures.StAstwkb_8607.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstwkb_8607.call(request.parameters as Public.Procedures.StAstwkb_8607.Parameters),
"Public.Procedures.StAstwkb_1445.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstwkb_1445.call(request.parameters as Public.Procedures.StAstwkb_1445.Parameters),
"Public.Procedures.StAsewkb_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewkb_0faa.call(request.parameters as Public.Procedures.StAsewkb_0faa.Parameters),
"Public.Procedures.StAshexewkb_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAshexewkb_0faa.call(request.parameters as Public.Procedures.StAshexewkb_0faa.Parameters),
"Public.Procedures.StAshexewkbF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAshexewkbF1e2.call(request.parameters as Public.Procedures.StAshexewkbF1e2.Parameters),
"Public.Procedures.StAsewkbF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewkbF1e2.call(request.parameters as Public.Procedures.StAsewkbF1e2.Parameters),
"Public.Procedures.StAslatlontext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAslatlontext.call(request.parameters as Public.Procedures.StAslatlontext.Parameters),
"Public.Procedures.Geomfromewkb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geomfromewkb.call(request.parameters as Public.Procedures.Geomfromewkb.Parameters),
"Public.Procedures.StGeomfromewkb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromewkb.call(request.parameters as Public.Procedures.StGeomfromewkb.Parameters),
"Public.Procedures.StGeomfromtwkb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromtwkb.call(request.parameters as Public.Procedures.StGeomfromtwkb.Parameters),
"Public.Procedures.Geomfromewkt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geomfromewkt.call(request.parameters as Public.Procedures.Geomfromewkt.Parameters),
"Public.Procedures.StGeomfromewkt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromewkt.call(request.parameters as Public.Procedures.StGeomfromewkt.Parameters),
"Public.Procedures.PostgisCacheBbox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisCacheBbox.call(),
"Public.Procedures.StMakepoint_0aec.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepoint_0aec.call(request.parameters as Public.Procedures.StMakepoint_0aec.Parameters),
"Public.Procedures.StMakepoint_81ec.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepoint_81ec.call(request.parameters as Public.Procedures.StMakepoint_81ec.Parameters),
"Public.Procedures.StMakepoint_570b.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepoint_570b.call(request.parameters as Public.Procedures.StMakepoint_570b.Parameters),
"Public.Procedures.StMakepointm.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepointm.call(request.parameters as Public.Procedures.StMakepointm.Parameters),
"Public.Procedures.St_3dmakebox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dmakebox.call(request.parameters as Public.Procedures.St_3dmakebox.Parameters),
"Public.Procedures.StMakelineF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakelineF393.call(request.parameters as Public.Procedures.StMakelineF393.Parameters),
"Public.Procedures.StLinefrommultipoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefrommultipoint.call(request.parameters as Public.Procedures.StLinefrommultipoint.Parameters),
"Public.Procedures.StMakelineEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakelineEb6a.call(request.parameters as Public.Procedures.StMakelineEb6a.Parameters),
"Public.Procedures.StAddpointEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAddpointEb6a.call(request.parameters as Public.Procedures.StAddpointEb6a.Parameters),
"Public.Procedures.StScale_2077.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StScale_2077.call(request.parameters as Public.Procedures.StScale_2077.Parameters),
"Public.Procedures.StAddpointCc0f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAddpointCc0f.call(request.parameters as Public.Procedures.StAddpointCc0f.Parameters),
"Public.Procedures.StRemovepoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRemovepoint.call(request.parameters as Public.Procedures.StRemovepoint.Parameters),
"Public.Procedures.StSetpoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSetpoint.call(request.parameters as Public.Procedures.StSetpoint.Parameters),
"Public.Procedures.StMakeenvelope.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakeenvelope.call(request.parameters as Public.Procedures.StMakeenvelope.Parameters),
"Public.Procedures.StTileenvelope.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTileenvelope.call(request.parameters as Public.Procedures.StTileenvelope.Parameters),
"Public.Procedures.StMakepolygon_0543.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepolygon_0543.call(request.parameters as Public.Procedures.StMakepolygon_0543.Parameters),
"Public.Procedures.StMakepolygon_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakepolygon_0faa.call(request.parameters as Public.Procedures.StMakepolygon_0faa.Parameters),
"Public.Procedures.StBuildarea.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuildarea.call(request.parameters as Public.Procedures.StBuildarea.Parameters),
"Public.Procedures.StPolygonizeF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygonizeF393.call(request.parameters as Public.Procedures.StPolygonizeF393.Parameters),
"Public.Procedures.StClusterintersectingF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClusterintersectingF393.call(request.parameters as Public.Procedures.StClusterintersectingF393.Parameters),
"Public.Procedures.StClusterwithin_2892.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClusterwithin_2892.call(request.parameters as Public.Procedures.StClusterwithin_2892.Parameters),
"Public.Procedures.StLinemerge_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinemerge_0faa.call(request.parameters as Public.Procedures.StLinemerge_0faa.Parameters),
"Public.Procedures.StLinemergeCad2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinemergeCad2.call(request.parameters as Public.Procedures.StLinemergeCad2.Parameters),
"Public.Procedures.StAffineA659.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAffineA659.call(request.parameters as Public.Procedures.StAffineA659.Parameters),
"Public.Procedures.StAffine_0997.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAffine_0997.call(request.parameters as Public.Procedures.StAffine_0997.Parameters),
"Public.Procedures.StRotateDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotateDeb6.call(request.parameters as Public.Procedures.StRotateDeb6.Parameters),
"Public.Procedures.StRotate_6aac.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotate_6aac.call(request.parameters as Public.Procedures.StRotate_6aac.Parameters),
"Public.Procedures.StRotate_8af1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotate_8af1.call(request.parameters as Public.Procedures.StRotate_8af1.Parameters),
"Public.Procedures.StRotatez.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotatez.call(request.parameters as Public.Procedures.StRotatez.Parameters),
"Public.Procedures.StRotatex.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotatex.call(request.parameters as Public.Procedures.StRotatex.Parameters),
"Public.Procedures.StRotatey.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRotatey.call(request.parameters as Public.Procedures.StRotatey.Parameters),
"Public.Procedures.StTranslate_6aac.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTranslate_6aac.call(request.parameters as Public.Procedures.StTranslate_6aac.Parameters),
"Public.Procedures.StTranslate_2077.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTranslate_2077.call(request.parameters as Public.Procedures.StTranslate_2077.Parameters),
"Public.Procedures.StScaleEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StScaleEb6a.call(request.parameters as Public.Procedures.StScaleEb6a.Parameters),
"Public.Procedures.StScale_8af1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StScale_8af1.call(request.parameters as Public.Procedures.StScale_8af1.Parameters),
"Public.Procedures.StScale_6aac.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StScale_6aac.call(request.parameters as Public.Procedures.StScale_6aac.Parameters),
"Public.Procedures.StTransscale.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransscale.call(request.parameters as Public.Procedures.StTransscale.Parameters),
"Public.Procedures.StDump.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDump.call(request.parameters as Public.Procedures.StDump.Parameters),
"Public.Procedures.StDumprings.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDumprings.call(request.parameters as Public.Procedures.StDumprings.Parameters),
"Public.Procedures.StDumppoints.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDumppoints.call(request.parameters as Public.Procedures.StDumppoints.Parameters),
"Public.Procedures.StDumpsegments.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDumpsegments.call(request.parameters as Public.Procedures.StDumpsegments.Parameters),
"Public.Procedures.PopulateGeometryColumns_23fc.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PopulateGeometryColumns_23fc.call(request.parameters as Public.Procedures.PopulateGeometryColumns_23fc.Parameters),
"Public.Procedures.PopulateGeometryColumns_4174.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PopulateGeometryColumns_4174.call(request.parameters as Public.Procedures.PopulateGeometryColumns_4174.Parameters),
"Public.Procedures.Addgeometrycolumn_8fbb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Addgeometrycolumn_8fbb.call(request.parameters as Public.Procedures.Addgeometrycolumn_8fbb.Parameters),
"Public.Procedures.Addgeometrycolumn_4617.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Addgeometrycolumn_4617.call(request.parameters as Public.Procedures.Addgeometrycolumn_4617.Parameters),
"Public.Procedures.Addgeometrycolumn_093c.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Addgeometrycolumn_093c.call(request.parameters as Public.Procedures.Addgeometrycolumn_093c.Parameters),
"Public.Procedures.Dropgeometrycolumn_0412.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Dropgeometrycolumn_0412.call(request.parameters as Public.Procedures.Dropgeometrycolumn_0412.Parameters),
"Public.Procedures.Dropgeometrycolumn_2253.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Dropgeometrycolumn_2253.call(request.parameters as Public.Procedures.Dropgeometrycolumn_2253.Parameters),
"Public.Procedures.DropgeometrycolumnF11a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.DropgeometrycolumnF11a.call(request.parameters as Public.Procedures.DropgeometrycolumnF11a.Parameters),
"Public.Procedures.Dropgeometrytable_2253.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Dropgeometrytable_2253.call(request.parameters as Public.Procedures.Dropgeometrytable_2253.Parameters),
"Public.Procedures.StSegmentizeDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSegmentizeDeb6.call(request.parameters as Public.Procedures.StSegmentizeDeb6.Parameters),
"Public.Procedures.DropgeometrytableF11a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.DropgeometrytableF11a.call(request.parameters as Public.Procedures.DropgeometrytableF11a.Parameters),
"Public.Procedures.DropgeometrytableBfde.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.DropgeometrytableBfde.call(request.parameters as Public.Procedures.DropgeometrytableBfde.Parameters),
"Public.Procedures.UpdategeometrysridB2ee.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.UpdategeometrysridB2ee.call(request.parameters as Public.Procedures.UpdategeometrysridB2ee.Parameters),
"Public.Procedures.Updategeometrysrid_7b58.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Updategeometrysrid_7b58.call(request.parameters as Public.Procedures.Updategeometrysrid_7b58.Parameters),
"Public.Procedures.Updategeometrysrid_11c8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Updategeometrysrid_11c8.call(request.parameters as Public.Procedures.Updategeometrysrid_11c8.Parameters),
"Public.Procedures.FindSrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.FindSrid.call(request.parameters as Public.Procedures.FindSrid.Parameters),
"Public.Procedures.GetProj4FromSrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GetProj4FromSrid.call(request.parameters as Public.Procedures.GetProj4FromSrid.Parameters),
"Public.Procedures.StSetsridEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSetsridEd82.call(request.parameters as Public.Procedures.StSetsridEd82.Parameters),
"Public.Procedures.StSrid_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSrid_0faa.call(request.parameters as Public.Procedures.StSrid_0faa.Parameters),
"Public.Procedures.PostgisTransformGeometry.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTransformGeometry.call(request.parameters as Public.Procedures.PostgisTransformGeometry.Parameters),
"Public.Procedures.PostgisSrsCodes.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisSrsCodes.call(request.parameters as Public.Procedures.PostgisSrsCodes.Parameters),
"Public.Procedures.PostgisSrs.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisSrs.call(request.parameters as Public.Procedures.PostgisSrs.Parameters),
"Public.Procedures.PostgisSrsAll.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisSrsAll.call(),
"Public.Procedures.PostgisSrsSearch.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisSrsSearch.call(request.parameters as Public.Procedures.PostgisSrsSearch.Parameters),
"Public.Procedures.StTransformEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransformEd82.call(request.parameters as Public.Procedures.StTransformEd82.Parameters),
"Public.Procedures.StTransformF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransformF1e2.call(request.parameters as Public.Procedures.StTransformF1e2.Parameters),
"Public.Procedures.StTransformEfe6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransformEfe6.call(request.parameters as Public.Procedures.StTransformEfe6.Parameters),
"Public.Procedures.StTransform_3ad9.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransform_3ad9.call(request.parameters as Public.Procedures.StTransform_3ad9.Parameters),
"Public.Procedures.PostgisTransformPipelineGeometry.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTransformPipelineGeometry.call(request.parameters as Public.Procedures.PostgisTransformPipelineGeometry.Parameters),
"Public.Procedures.StTransformpipeline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTransformpipeline.call(request.parameters as Public.Procedures.StTransformpipeline.Parameters),
"Public.Procedures.StInversetransformpipeline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StInversetransformpipeline.call(request.parameters as Public.Procedures.StInversetransformpipeline.Parameters),
"Public.Procedures.PostgisVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisVersion.call(),
"Public.Procedures.PostgisLiblwgeomVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLiblwgeomVersion.call(),
"Public.Procedures.PostgisProjVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisProjVersion.call(),
"Public.Procedures.PostgisWagyuVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisWagyuVersion.call(),
"Public.Procedures.PostgisScriptsInstalled.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisScriptsInstalled.call(),
"Public.Procedures.PostgisLibVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibVersion.call(),
"Public.Procedures.PostgisScriptsReleased.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisScriptsReleased.call(),
"Public.Procedures.PostgisGeosVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisGeosVersion.call(),
"Public.Procedures.PostgisGeosCompiledVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisGeosCompiledVersion.call(),
"Public.Procedures.PostgisLibRevision.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibRevision.call(),
"Public.Procedures.PostgisSvnVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisSvnVersion.call(),
"Public.Procedures.PostgisLibxmlVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibxmlVersion.call(),
"Public.Procedures.PostgisScriptsBuildDate.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisScriptsBuildDate.call(),
"Public.Procedures.PostgisLibBuildDate.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibBuildDate.call(),
"Public.Procedures.PostgisExtensionsUpgrade.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisExtensionsUpgrade.call(request.parameters as Public.Procedures.PostgisExtensionsUpgrade.Parameters),
"Public.Procedures.StLineinterpolatepointDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepointDeb6.call(request.parameters as Public.Procedures.StLineinterpolatepointDeb6.Parameters),
"Public.Procedures.StLineinterpolatepoints_1c13.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepoints_1c13.call(request.parameters as Public.Procedures.StLineinterpolatepoints_1c13.Parameters),
"Public.Procedures.StLinesubstring_2077.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinesubstring_2077.call(request.parameters as Public.Procedures.StLinesubstring_2077.Parameters),
"Public.Procedures.StLinelocatepointEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinelocatepointEb6a.call(request.parameters as Public.Procedures.StLinelocatepointEb6a.Parameters),
"Public.Procedures.StAddmeasure.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAddmeasure.call(request.parameters as Public.Procedures.StAddmeasure.Parameters),
"Public.Procedures.StClosestpointofapproach.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClosestpointofapproach.call(request.parameters as Public.Procedures.StClosestpointofapproach.Parameters),
"Public.Procedures.PostgisFullVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisFullVersion.call(),
"Public.Procedures.Box2d_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2d_0faa.call(request.parameters as Public.Procedures.Box2d_0faa.Parameters),
"Public.Procedures.Box3d_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box3d_0faa.call(request.parameters as Public.Procedures.Box3d_0faa.Parameters),
"Public.Procedures.Box_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box_0faa.call(request.parameters as Public.Procedures.Box_0faa.Parameters),
"Public.Procedures.Box2d_8784.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box2d_8784.call(request.parameters as Public.Procedures.Box2d_8784.Parameters),
"Public.Procedures.Box3dF5fa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box3dF5fa.call(request.parameters as Public.Procedures.Box3dF5fa.Parameters),
"Public.Procedures.Box_8784.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box_8784.call(request.parameters as Public.Procedures.Box_8784.Parameters),
"Public.Procedures.Text.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Text.call(request.parameters as Public.Procedures.Text.Parameters),
"Public.Procedures.Box3dtobox.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Box3dtobox.call(request.parameters as Public.Procedures.Box3dtobox.Parameters),
"Public.Procedures.GeometryF5fa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryF5fa.call(request.parameters as Public.Procedures.GeometryF5fa.Parameters),
"Public.Procedures.Geometry_8784.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometry_8784.call(request.parameters as Public.Procedures.Geometry_8784.Parameters),
"Public.Procedures.GeometryE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryE728.call(request.parameters as Public.Procedures.GeometryE728.Parameters),
"Public.Procedures.Geometry_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometry_2d19.call(request.parameters as Public.Procedures.Geometry_2d19.Parameters),
"Public.Procedures.Bytea_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Bytea_0faa.call(request.parameters as Public.Procedures.Bytea_0faa.Parameters),
"Public.Procedures.StSimplifyDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSimplifyDeb6.call(request.parameters as Public.Procedures.StSimplifyDeb6.Parameters),
"Public.Procedures.StSimplify_1c13.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSimplify_1c13.call(request.parameters as Public.Procedures.StSimplify_1c13.Parameters),
"Public.Procedures.StSimplifyvw.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSimplifyvw.call(request.parameters as Public.Procedures.StSimplifyvw.Parameters),
"Public.Procedures.StSeteffectivearea.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSeteffectivearea.call(request.parameters as Public.Procedures.StSeteffectivearea.Parameters),
"Public.Procedures.StFilterbym.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFilterbym.call(request.parameters as Public.Procedures.StFilterbym.Parameters),
"Public.Procedures.StChaikinsmoothing.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StChaikinsmoothing.call(request.parameters as Public.Procedures.StChaikinsmoothing.Parameters),
"Public.Procedures.StSnaptogridBf72.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSnaptogridBf72.call(request.parameters as Public.Procedures.StSnaptogridBf72.Parameters),
"Public.Procedures.StSnaptogrid_2077.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSnaptogrid_2077.call(request.parameters as Public.Procedures.StSnaptogrid_2077.Parameters),
"Public.Procedures.StSnaptogridDeb6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSnaptogridDeb6.call(request.parameters as Public.Procedures.StSnaptogridDeb6.Parameters),
"Public.Procedures.StSnaptogrid_7713.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSnaptogrid_7713.call(request.parameters as Public.Procedures.StSnaptogrid_7713.Parameters),
"Public.Procedures.StDistancecpa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistancecpa.call(request.parameters as Public.Procedures.StDistancecpa.Parameters),
"Public.Procedures.StCpawithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCpawithin.call(request.parameters as Public.Procedures.StCpawithin.Parameters),
"Public.Procedures.StIsvalidtrajectory.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvalidtrajectory.call(request.parameters as Public.Procedures.StIsvalidtrajectory.Parameters),
"Public.Procedures.StIntersectionE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersectionE059.call(request.parameters as Public.Procedures.StIntersectionE059.Parameters),
"Public.Procedures.StBufferDcba.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBufferDcba.call(request.parameters as Public.Procedures.StBufferDcba.Parameters),
"Public.Procedures.StBuffer_3222.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuffer_3222.call(request.parameters as Public.Procedures.StBuffer_3222.Parameters),
"Public.Procedures.StMinimumboundingradius.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMinimumboundingradius.call(request.parameters as Public.Procedures.StMinimumboundingradius.Parameters),
"Public.Procedures.StMinimumboundingcircle.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMinimumboundingcircle.call(request.parameters as Public.Procedures.StMinimumboundingcircle.Parameters),
"Public.Procedures.StOrientedenvelope.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StOrientedenvelope.call(request.parameters as Public.Procedures.StOrientedenvelope.Parameters),
"Public.Procedures.StOffsetcurve.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StOffsetcurve.call(request.parameters as Public.Procedures.StOffsetcurve.Parameters),
"Public.Procedures.StGeneratepointsEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeneratepointsEd82.call(request.parameters as Public.Procedures.StGeneratepointsEd82.Parameters),
"Public.Procedures.StGeneratepointsA8be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeneratepointsA8be.call(request.parameters as Public.Procedures.StGeneratepointsA8be.Parameters),
"Public.Procedures.StConvexhull.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StConvexhull.call(request.parameters as Public.Procedures.StConvexhull.Parameters),
"Public.Procedures.StSimplifypreservetopology.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSimplifypreservetopology.call(request.parameters as Public.Procedures.StSimplifypreservetopology.Parameters),
"Public.Procedures.StIsvalidreason_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvalidreason_0faa.call(request.parameters as Public.Procedures.StIsvalidreason_0faa.Parameters),
"Public.Procedures.StIsvaliddetail.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvaliddetail.call(request.parameters as Public.Procedures.StIsvaliddetail.Parameters),
"Public.Procedures.StIsvalidreasonEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvalidreasonEd82.call(request.parameters as Public.Procedures.StIsvalidreasonEd82.Parameters),
"Public.Procedures.StIsvalidEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvalidEd82.call(request.parameters as Public.Procedures.StIsvalidEd82.Parameters),
"Public.Procedures.StHausdorffdistanceEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StHausdorffdistanceEb6a.call(request.parameters as Public.Procedures.StHausdorffdistanceEb6a.Parameters),
"Public.Procedures.StHausdorffdistanceE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StHausdorffdistanceE059.call(request.parameters as Public.Procedures.StHausdorffdistanceE059.Parameters),
"Public.Procedures.StFrechetdistance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFrechetdistance.call(request.parameters as Public.Procedures.StFrechetdistance.Parameters),
"Public.Procedures.StMaximuminscribedcircle.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMaximuminscribedcircle.call(request.parameters as Public.Procedures.StMaximuminscribedcircle.Parameters),
"Public.Procedures.StLargestemptycircle.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLargestemptycircle.call(request.parameters as Public.Procedures.StLargestemptycircle.Parameters),
"Public.Procedures.StDifference.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDifference.call(request.parameters as Public.Procedures.StDifference.Parameters),
"Public.Procedures.StBoundary.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBoundary.call(request.parameters as Public.Procedures.StBoundary.Parameters),
"Public.Procedures.StPoints.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPoints.call(request.parameters as Public.Procedures.StPoints.Parameters),
"Public.Procedures.StSymdifference.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSymdifference.call(request.parameters as Public.Procedures.StSymdifference.Parameters),
"Public.Procedures.StSymmetricdifference.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSymmetricdifference.call(request.parameters as Public.Procedures.StSymmetricdifference.Parameters),
"Public.Procedures.StUnionEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StUnionEb6a.call(request.parameters as Public.Procedures.StUnionEb6a.Parameters),
"Public.Procedures.StUnionE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StUnionE059.call(request.parameters as Public.Procedures.StUnionE059.Parameters),
"Public.Procedures.StUnaryunion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StUnaryunion.call(request.parameters as Public.Procedures.StUnaryunion.Parameters),
"Public.Procedures.StRemoverepeatedpoints.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRemoverepeatedpoints.call(request.parameters as Public.Procedures.StRemoverepeatedpoints.Parameters),
"Public.Procedures.StClipbybox2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClipbybox2d.call(request.parameters as Public.Procedures.StClipbybox2d.Parameters),
"Public.Procedures.StSubdivide.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSubdivide.call(request.parameters as Public.Procedures.StSubdivide.Parameters),
"Public.Procedures.StReduceprecision.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StReduceprecision.call(request.parameters as Public.Procedures.StReduceprecision.Parameters),
"Public.Procedures.StMakevalid_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakevalid_0faa.call(request.parameters as Public.Procedures.StMakevalid_0faa.Parameters),
"Public.Procedures.StMakevalidF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMakevalidF1e2.call(request.parameters as Public.Procedures.StMakevalidF1e2.Parameters),
"Public.Procedures.StCleangeometry.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCleangeometry.call(request.parameters as Public.Procedures.StCleangeometry.Parameters),
"Public.Procedures.StSplit.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSplit.call(request.parameters as Public.Procedures.StSplit.Parameters),
"Public.Procedures.StSharedpaths.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSharedpaths.call(request.parameters as Public.Procedures.StSharedpaths.Parameters),
"Public.Procedures.StSnap.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSnap.call(request.parameters as Public.Procedures.StSnap.Parameters),
"Public.Procedures.StRelatematch.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRelatematch.call(request.parameters as Public.Procedures.StRelatematch.Parameters),
"Public.Procedures.StNode.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNode.call(request.parameters as Public.Procedures.StNode.Parameters),
"Public.Procedures.StDelaunaytriangles.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDelaunaytriangles.call(request.parameters as Public.Procedures.StDelaunaytriangles.Parameters),
"Public.Procedures.StTriangulatepolygon.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTriangulatepolygon.call(request.parameters as Public.Procedures.StTriangulatepolygon.Parameters),
"Public.Procedures.StVoronoipolygons.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StVoronoipolygons.call(request.parameters as Public.Procedures.StVoronoipolygons.Parameters),
"Public.Procedures.StVoronoilines.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StVoronoilines.call(request.parameters as Public.Procedures.StVoronoilines.Parameters),
"Public.Procedures.StCombinebbox_2c84.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCombinebbox_2c84.call(request.parameters as Public.Procedures.StCombinebbox_2c84.Parameters),
"Public.Procedures.StCombinebboxEe61.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCombinebboxEe61.call(request.parameters as Public.Procedures.StCombinebboxEe61.Parameters),
"Public.Procedures.StCombinebbox_7c5a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCombinebbox_7c5a.call(request.parameters as Public.Procedures.StCombinebbox_7c5a.Parameters),
"Public.Procedures.StCollectEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCollectEb6a.call(request.parameters as Public.Procedures.StCollectEb6a.Parameters),
"Public.Procedures.StCollectF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCollectF393.call(request.parameters as Public.Procedures.StCollectF393.Parameters),
"Public.Procedures.PgisGeometryAccumTransfnE941.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryAccumTransfnE941.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfnE941.Parameters),
"Public.Procedures.PgisGeometryAccumTransfnDd3f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryAccumTransfnDd3f.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfnDd3f.Parameters),
"Public.Procedures.PgisGeometryAccumTransfn_0a1f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryAccumTransfn_0a1f.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfn_0a1f.Parameters),
"Public.Procedures.PgisGeometryCollectFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryCollectFinalfn.call(request.parameters as Public.Procedures.PgisGeometryCollectFinalfn.Parameters),
"Public.Procedures.PgisGeometryPolygonizeFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryPolygonizeFinalfn.call(request.parameters as Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters),
"Public.Procedures.PgisGeometryClusterintersectingFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryClusterintersectingFinalfn.call(request.parameters as Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters),
"Public.Procedures.PgisGeometryClusterwithinFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryClusterwithinFinalfn.call(request.parameters as Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters),
"Public.Procedures.PgisGeometryMakelineFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryMakelineFinalfn.call(request.parameters as Public.Procedures.PgisGeometryMakelineFinalfn.Parameters),
"Public.Procedures.PgisGeometryCoverageunionFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryCoverageunionFinalfn.call(request.parameters as Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters),
"Public.Procedures.PgisGeometryUnionParallelTransfnE941.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelTransfnE941.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelTransfnE941.Parameters),
"Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelTransfnDd3f.Parameters),
"Public.Procedures.PgisGeometryUnionParallelCombinefn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelCombinefn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters),
"Public.Procedures.PgisGeometryUnionParallelSerialfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelSerialfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters),
"Public.Procedures.PgisGeometryUnionParallelDeserialfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelDeserialfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters),
"Public.Procedures.PgisGeometryUnionParallelFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisGeometryUnionParallelFinalfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters),
"Public.Procedures.StUnionF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StUnionF393.call(request.parameters as Public.Procedures.StUnionF393.Parameters),
"Public.Procedures.StCoverageunionF393.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoverageunionF393.call(request.parameters as Public.Procedures.StCoverageunionF393.Parameters),
"Public.Procedures.StRelateEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRelateEb6a.call(request.parameters as Public.Procedures.StRelateEb6a.Parameters),
"Public.Procedures.StRelateCc0f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRelateCc0f.call(request.parameters as Public.Procedures.StRelateCc0f.Parameters),
"Public.Procedures.StRelate_6458.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StRelate_6458.call(request.parameters as Public.Procedures.StRelate_6458.Parameters),
"Public.Procedures.StDisjoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDisjoint.call(request.parameters as Public.Procedures.StDisjoint.Parameters),
"Public.Procedures.PostgisIndexSupportfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisIndexSupportfn.call(request.parameters as Public.Procedures.PostgisIndexSupportfn.Parameters),
"Public.Procedures.StLinecrossingdirection.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinecrossingdirection.call(request.parameters as Public.Procedures.StLinecrossingdirection.Parameters),
"Public.Procedures.StDwithinE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDwithinE059.call(request.parameters as Public.Procedures.StDwithinE059.Parameters),
"Public.Procedures.StTouches.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StTouches.call(request.parameters as Public.Procedures.StTouches.Parameters),
"Public.Procedures.StIntersectsEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersectsEb6a.call(request.parameters as Public.Procedures.StIntersectsEb6a.Parameters),
"Public.Procedures.StCrosses.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCrosses.call(request.parameters as Public.Procedures.StCrosses.Parameters),
"Public.Procedures.StContains.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StContains.call(request.parameters as Public.Procedures.StContains.Parameters),
"Public.Procedures.StContainsproperly.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StContainsproperly.call(request.parameters as Public.Procedures.StContainsproperly.Parameters),
"Public.Procedures.StWithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StWithin.call(request.parameters as Public.Procedures.StWithin.Parameters),
"Public.Procedures.StCoversEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoversEb6a.call(request.parameters as Public.Procedures.StCoversEb6a.Parameters),
"Public.Procedures.StCoveredbyEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoveredbyEb6a.call(request.parameters as Public.Procedures.StCoveredbyEb6a.Parameters),
"Public.Procedures.StOverlaps.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StOverlaps.call(request.parameters as Public.Procedures.StOverlaps.Parameters),
"Public.Procedures.StDfullywithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDfullywithin.call(request.parameters as Public.Procedures.StDfullywithin.Parameters),
"Public.Procedures.St_3ddwithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3ddwithin.call(request.parameters as Public.Procedures.St_3ddwithin.Parameters),
"Public.Procedures.St_3ddfullywithin.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3ddfullywithin.call(request.parameters as Public.Procedures.St_3ddfullywithin.Parameters),
"Public.Procedures.St_3dintersects.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dintersects.call(request.parameters as Public.Procedures.St_3dintersects.Parameters),
"Public.Procedures.StOrderingequals.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StOrderingequals.call(request.parameters as Public.Procedures.StOrderingequals.Parameters),
"Public.Procedures.StEquals.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEquals.call(request.parameters as Public.Procedures.StEquals.Parameters),
"Public.Procedures.StIsvalid_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsvalid_0faa.call(request.parameters as Public.Procedures.StIsvalid_0faa.Parameters),
"Public.Procedures.StMinimumclearance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMinimumclearance.call(request.parameters as Public.Procedures.StMinimumclearance.Parameters),
"Public.Procedures.StMinimumclearanceline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMinimumclearanceline.call(request.parameters as Public.Procedures.StMinimumclearanceline.Parameters),
"Public.Procedures.StCentroid_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCentroid_0faa.call(request.parameters as Public.Procedures.StCentroid_0faa.Parameters),
"Public.Procedures.StGeometricmedian.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeometricmedian.call(request.parameters as Public.Procedures.StGeometricmedian.Parameters),
"Public.Procedures.StIsring.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsring.call(request.parameters as Public.Procedures.StIsring.Parameters),
"Public.Procedures.StPointonsurface.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointonsurface.call(request.parameters as Public.Procedures.StPointonsurface.Parameters),
"Public.Procedures.StIssimple.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIssimple.call(request.parameters as Public.Procedures.StIssimple.Parameters),
"Public.Procedures.StIscollection.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIscollection.call(request.parameters as Public.Procedures.StIscollection.Parameters),
"Public.Procedures.Equals.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Equals.call(request.parameters as Public.Procedures.Equals.Parameters),
"Public.Procedures.StGeomfromgml_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgml_27e2.call(request.parameters as Public.Procedures.StGeomfromgml_27e2.Parameters),
"Public.Procedures.StGeomfromgmlE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgmlE728.call(request.parameters as Public.Procedures.StGeomfromgmlE728.Parameters),
"Public.Procedures.StGmltosqlE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGmltosqlE728.call(request.parameters as Public.Procedures.StGmltosqlE728.Parameters),
"Public.Procedures.StGmltosql_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGmltosql_27e2.call(request.parameters as Public.Procedures.StGmltosql_27e2.Parameters),
"Public.Procedures.StGeomfromkml.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromkml.call(request.parameters as Public.Procedures.StGeomfromkml.Parameters),
"Public.Procedures.StGeomfrommarc21.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfrommarc21.call(request.parameters as Public.Procedures.StGeomfrommarc21.Parameters),
"Public.Procedures.StAsmarc21.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsmarc21.call(request.parameters as Public.Procedures.StAsmarc21.Parameters),
"Public.Procedures.StGeomfromgeojsonE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgeojsonE728.call(request.parameters as Public.Procedures.StGeomfromgeojsonE728.Parameters),
"Public.Procedures.StGeomfromgeojson_608f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgeojson_608f.call(request.parameters as Public.Procedures.StGeomfromgeojson_608f.Parameters),
"Public.Procedures.StGeomfromgeojson_3c9d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgeojson_3c9d.call(request.parameters as Public.Procedures.StGeomfromgeojson_3c9d.Parameters),
"Public.Procedures.PostgisLibjsonVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibjsonVersion.call(),
"Public.Procedures.StLinefromencodedpolyline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefromencodedpolyline.call(request.parameters as Public.Procedures.StLinefromencodedpolyline.Parameters),
"Public.Procedures.StAsencodedpolyline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsencodedpolyline.call(request.parameters as Public.Procedures.StAsencodedpolyline.Parameters),
"Public.Procedures.StAssvgA8be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAssvgA8be.call(request.parameters as Public.Procedures.StAssvgA8be.Parameters),
"Public.Procedures.StAsgmlA8be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgmlA8be.call(request.parameters as Public.Procedures.StAsgmlA8be.Parameters),
"Public.Procedures.StAsgml_2621.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgml_2621.call(request.parameters as Public.Procedures.StAsgml_2621.Parameters),
"Public.Procedures.StAskmlE3da.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAskmlE3da.call(request.parameters as Public.Procedures.StAskmlE3da.Parameters),
"Public.Procedures.StAsgeojsonA8be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgeojsonA8be.call(request.parameters as Public.Procedures.StAsgeojsonA8be.Parameters),
"Public.Procedures.StAsgeojsonF2c6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgeojsonF2c6.call(request.parameters as Public.Procedures.StAsgeojsonF2c6.Parameters),
"Public.Procedures.Json.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Json.call(request.parameters as Public.Procedures.Json.Parameters),
"Public.Procedures.Jsonb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Jsonb.call(request.parameters as Public.Procedures.Jsonb.Parameters),
"Public.Procedures.PgisAsmvtTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtTransfn_647f.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_647f.Parameters),
"Public.Procedures.PgisAsmvtTransfn_27f4.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtTransfn_27f4.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_27f4.Parameters),
"Public.Procedures.PgisAsmvtTransfnF57f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtTransfnF57f.call(request.parameters as Public.Procedures.PgisAsmvtTransfnF57f.Parameters),
"Public.Procedures.PgisAsmvtTransfn_92c1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtTransfn_92c1.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_92c1.Parameters),
"Public.Procedures.PgisAsmvtTransfnF5be.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtTransfnF5be.call(request.parameters as Public.Procedures.PgisAsmvtTransfnF5be.Parameters),
"Public.Procedures.PgisAsmvtFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtFinalfn.call(request.parameters as Public.Procedures.PgisAsmvtFinalfn.Parameters),
"Public.Procedures.PgisAsmvtCombinefn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtCombinefn.call(request.parameters as Public.Procedures.PgisAsmvtCombinefn.Parameters),
"Public.Procedures.PgisAsmvtSerialfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtSerialfn.call(request.parameters as Public.Procedures.PgisAsmvtSerialfn.Parameters),
"Public.Procedures.PgisAsmvtDeserialfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsmvtDeserialfn.call(request.parameters as Public.Procedures.PgisAsmvtDeserialfn.Parameters),
"Public.Procedures.StAsmvtgeom.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsmvtgeom.call(request.parameters as Public.Procedures.StAsmvtgeom.Parameters),
"Public.Procedures.PostgisLibprotobufVersion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisLibprotobufVersion.call(),
"Public.Procedures.PgisAsgeobufTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsgeobufTransfn_647f.call(request.parameters as Public.Procedures.PgisAsgeobufTransfn_647f.Parameters),
"Public.Procedures.PgisAsgeobufTransfn_27f4.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsgeobufTransfn_27f4.call(request.parameters as Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters),
"Public.Procedures.PgisAsgeobufFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsgeobufFinalfn.call(request.parameters as Public.Procedures.PgisAsgeobufFinalfn.Parameters),
"Public.Procedures.PgisAsflatgeobufTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsflatgeobufTransfn_647f.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters),
"Public.Procedures.PgisAsflatgeobufTransfn_9633.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsflatgeobufTransfn_9633.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters),
"Public.Procedures.PgisAsflatgeobufTransfn_521f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsflatgeobufTransfn_521f.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters),
"Public.Procedures.PgisAsflatgeobufFinalfn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PgisAsflatgeobufFinalfn.call(request.parameters as Public.Procedures.PgisAsflatgeobufFinalfn.Parameters),
"Public.Procedures.StFromflatgeobuftotable.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFromflatgeobuftotable.call(request.parameters as Public.Procedures.StFromflatgeobuftotable.Parameters),
"Public.Procedures.StFromflatgeobuf.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFromflatgeobuf.call(request.parameters as Public.Procedures.StFromflatgeobuf.Parameters),
"Public.Procedures.StGeohashEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeohashEd82.call(request.parameters as Public.Procedures.StGeohashEd82.Parameters),
"Public.Procedures.StBox2dfromgeohash.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBox2dfromgeohash.call(request.parameters as Public.Procedures.StBox2dfromgeohash.Parameters),
"Public.Procedures.StPointfromgeohash.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointfromgeohash.call(request.parameters as Public.Procedures.StPointfromgeohash.Parameters),
"Public.Procedures.StGeomfromgeohash.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromgeohash.call(request.parameters as Public.Procedures.StGeomfromgeohash.Parameters),
"Public.Procedures.StNumpoints.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNumpoints.call(request.parameters as Public.Procedures.StNumpoints.Parameters),
"Public.Procedures.StNumgeometries.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNumgeometries.call(request.parameters as Public.Procedures.StNumgeometries.Parameters),
"Public.Procedures.StGeometryn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeometryn.call(request.parameters as Public.Procedures.StGeometryn.Parameters),
"Public.Procedures.StDimension.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDimension.call(request.parameters as Public.Procedures.StDimension.Parameters),
"Public.Procedures.StExteriorring.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StExteriorring.call(request.parameters as Public.Procedures.StExteriorring.Parameters),
"Public.Procedures.StNuminteriorrings.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNuminteriorrings.call(request.parameters as Public.Procedures.StNuminteriorrings.Parameters),
"Public.Procedures.StNuminteriorring.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNuminteriorring.call(request.parameters as Public.Procedures.StNuminteriorring.Parameters),
"Public.Procedures.StInteriorringn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StInteriorringn.call(request.parameters as Public.Procedures.StInteriorringn.Parameters),
"Public.Procedures.Geometrytype_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometrytype_0faa.call(request.parameters as Public.Procedures.Geometrytype_0faa.Parameters),
"Public.Procedures.StGeometrytype.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeometrytype.call(request.parameters as Public.Procedures.StGeometrytype.Parameters),
"Public.Procedures.StPointn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointn.call(request.parameters as Public.Procedures.StPointn.Parameters),
"Public.Procedures.StNumpatches.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StNumpatches.call(request.parameters as Public.Procedures.StNumpatches.Parameters),
"Public.Procedures.StPatchn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPatchn.call(request.parameters as Public.Procedures.StPatchn.Parameters),
"Public.Procedures.StStartpoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StStartpoint.call(request.parameters as Public.Procedures.StStartpoint.Parameters),
"Public.Procedures.StEndpoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StEndpoint.call(request.parameters as Public.Procedures.StEndpoint.Parameters),
"Public.Procedures.StIsclosed.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsclosed.call(request.parameters as Public.Procedures.StIsclosed.Parameters),
"Public.Procedures.StIsempty.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIsempty.call(request.parameters as Public.Procedures.StIsempty.Parameters),
"Public.Procedures.StAsbinaryF1e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsbinaryF1e2.call(request.parameters as Public.Procedures.StAsbinaryF1e2.Parameters),
"Public.Procedures.StAsbinary_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsbinary_0faa.call(request.parameters as Public.Procedures.StAsbinary_0faa.Parameters),
"Public.Procedures.StAstext_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstext_0faa.call(request.parameters as Public.Procedures.StAstext_0faa.Parameters),
"Public.Procedures.StAstextEd82.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstextEd82.call(request.parameters as Public.Procedures.StAstextEd82.Parameters),
"Public.Procedures.StGeometryfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeometryfromtextE728.call(request.parameters as Public.Procedures.StGeometryfromtextE728.Parameters),
"Public.Procedures.StGeometryfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeometryfromtext_27e2.call(request.parameters as Public.Procedures.StGeometryfromtext_27e2.Parameters),
"Public.Procedures.StGeomfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromtextE728.call(request.parameters as Public.Procedures.StGeomfromtextE728.Parameters),
"Public.Procedures.StGeomfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromtext_27e2.call(request.parameters as Public.Procedures.StGeomfromtext_27e2.Parameters),
"Public.Procedures.StWkttosql.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StWkttosql.call(request.parameters as Public.Procedures.StWkttosql.Parameters),
"Public.Procedures.StPointfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointfromtextE728.call(request.parameters as Public.Procedures.StPointfromtextE728.Parameters),
"Public.Procedures.StPointfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointfromtext_27e2.call(request.parameters as Public.Procedures.StPointfromtext_27e2.Parameters),
"Public.Procedures.StLinefromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefromtextE728.call(request.parameters as Public.Procedures.StLinefromtextE728.Parameters),
"Public.Procedures.StLinefromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefromtext_27e2.call(request.parameters as Public.Procedures.StLinefromtext_27e2.Parameters),
"Public.Procedures.StPolyfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolyfromtextE728.call(request.parameters as Public.Procedures.StPolyfromtextE728.Parameters),
"Public.Procedures.StPolyfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolyfromtext_27e2.call(request.parameters as Public.Procedures.StPolyfromtext_27e2.Parameters),
"Public.Procedures.StPolygonfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygonfromtext_27e2.call(request.parameters as Public.Procedures.StPolygonfromtext_27e2.Parameters),
"Public.Procedures.StPolygonfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygonfromtextE728.call(request.parameters as Public.Procedures.StPolygonfromtextE728.Parameters),
"Public.Procedures.StMlinefromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMlinefromtext_27e2.call(request.parameters as Public.Procedures.StMlinefromtext_27e2.Parameters),
"Public.Procedures.StMlinefromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMlinefromtextE728.call(request.parameters as Public.Procedures.StMlinefromtextE728.Parameters),
"Public.Procedures.StMultilinestringfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultilinestringfromtextE728.call(request.parameters as Public.Procedures.StMultilinestringfromtextE728.Parameters),
"Public.Procedures.StMultilinestringfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultilinestringfromtext_27e2.call(request.parameters as Public.Procedures.StMultilinestringfromtext_27e2.Parameters),
"Public.Procedures.StMpointfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpointfromtext_27e2.call(request.parameters as Public.Procedures.StMpointfromtext_27e2.Parameters),
"Public.Procedures.StMpointfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpointfromtextE728.call(request.parameters as Public.Procedures.StMpointfromtextE728.Parameters),
"Public.Procedures.StMultipointfromtext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipointfromtext.call(request.parameters as Public.Procedures.StMultipointfromtext.Parameters),
"Public.Procedures.StMpolyfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpolyfromtext_27e2.call(request.parameters as Public.Procedures.StMpolyfromtext_27e2.Parameters),
"Public.Procedures.StMpolyfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpolyfromtextE728.call(request.parameters as Public.Procedures.StMpolyfromtextE728.Parameters),
"Public.Procedures.StMultipolygonfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipolygonfromtext_27e2.call(request.parameters as Public.Procedures.StMultipolygonfromtext_27e2.Parameters),
"Public.Procedures.StMultipolygonfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipolygonfromtextE728.call(request.parameters as Public.Procedures.StMultipolygonfromtextE728.Parameters),
"Public.Procedures.StGeomcollfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomcollfromtext_27e2.call(request.parameters as Public.Procedures.StGeomcollfromtext_27e2.Parameters),
"Public.Procedures.StGeomcollfromtextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomcollfromtextE728.call(request.parameters as Public.Procedures.StGeomcollfromtextE728.Parameters),
"Public.Procedures.StGeomfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromwkb_2d19.call(request.parameters as Public.Procedures.StGeomfromwkb_2d19.Parameters),
"Public.Procedures.StGeomfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomfromwkbD8af.call(request.parameters as Public.Procedures.StGeomfromwkbD8af.Parameters),
"Public.Procedures.StPointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointfromwkbD8af.call(request.parameters as Public.Procedures.StPointfromwkbD8af.Parameters),
"Public.Procedures.StPointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointfromwkb_2d19.call(request.parameters as Public.Procedures.StPointfromwkb_2d19.Parameters),
"Public.Procedures.StLinefromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefromwkbD8af.call(request.parameters as Public.Procedures.StLinefromwkbD8af.Parameters),
"Public.Procedures.StLinefromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinefromwkb_2d19.call(request.parameters as Public.Procedures.StLinefromwkb_2d19.Parameters),
"Public.Procedures.StLinestringfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinestringfromwkbD8af.call(request.parameters as Public.Procedures.StLinestringfromwkbD8af.Parameters),
"Public.Procedures.StLinestringfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinestringfromwkb_2d19.call(request.parameters as Public.Procedures.StLinestringfromwkb_2d19.Parameters),
"Public.Procedures.StPolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolyfromwkbD8af.call(request.parameters as Public.Procedures.StPolyfromwkbD8af.Parameters),
"Public.Procedures.StPolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolyfromwkb_2d19.call(request.parameters as Public.Procedures.StPolyfromwkb_2d19.Parameters),
"Public.Procedures.StPolygonfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygonfromwkbD8af.call(request.parameters as Public.Procedures.StPolygonfromwkbD8af.Parameters),
"Public.Procedures.StPolygonfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygonfromwkb_2d19.call(request.parameters as Public.Procedures.StPolygonfromwkb_2d19.Parameters),
"Public.Procedures.StMpointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpointfromwkbD8af.call(request.parameters as Public.Procedures.StMpointfromwkbD8af.Parameters),
"Public.Procedures.StMpointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpointfromwkb_2d19.call(request.parameters as Public.Procedures.StMpointfromwkb_2d19.Parameters),
"Public.Procedures.StMultipointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipointfromwkbD8af.call(request.parameters as Public.Procedures.StMultipointfromwkbD8af.Parameters),
"Public.Procedures.GeographyAnalyze.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyAnalyze.call(request.parameters as Public.Procedures.GeographyAnalyze.Parameters),
"Public.Procedures.StMultipointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipointfromwkb_2d19.call(request.parameters as Public.Procedures.StMultipointfromwkb_2d19.Parameters),
"Public.Procedures.StMultilinefromwkb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultilinefromwkb.call(request.parameters as Public.Procedures.StMultilinefromwkb.Parameters),
"Public.Procedures.StMlinefromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMlinefromwkbD8af.call(request.parameters as Public.Procedures.StMlinefromwkbD8af.Parameters),
"Public.Procedures.StMlinefromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMlinefromwkb_2d19.call(request.parameters as Public.Procedures.StMlinefromwkb_2d19.Parameters),
"Public.Procedures.StMpolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpolyfromwkbD8af.call(request.parameters as Public.Procedures.StMpolyfromwkbD8af.Parameters),
"Public.Procedures.StMpolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMpolyfromwkb_2d19.call(request.parameters as Public.Procedures.StMpolyfromwkb_2d19.Parameters),
"Public.Procedures.StMultipolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipolyfromwkbD8af.call(request.parameters as Public.Procedures.StMultipolyfromwkbD8af.Parameters),
"Public.Procedures.StMultipolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMultipolyfromwkb_2d19.call(request.parameters as Public.Procedures.StMultipolyfromwkb_2d19.Parameters),
"Public.Procedures.StGeomcollfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomcollfromwkbD8af.call(request.parameters as Public.Procedures.StGeomcollfromwkbD8af.Parameters),
"Public.Procedures.StGeomcollfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeomcollfromwkb_2d19.call(request.parameters as Public.Procedures.StGeomcollfromwkb_2d19.Parameters),
"Public.Procedures.StMaxdistance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StMaxdistance.call(request.parameters as Public.Procedures.StMaxdistance.Parameters),
"Public.Procedures.StClosestpointEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClosestpointEb6a.call(request.parameters as Public.Procedures.StClosestpointEb6a.Parameters),
"Public.Procedures.StShortestlineEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StShortestlineEb6a.call(request.parameters as Public.Procedures.StShortestlineEb6a.Parameters),
"Public.Procedures.StLongestline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLongestline.call(request.parameters as Public.Procedures.StLongestline.Parameters),
"Public.Procedures.StSwapordinates.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSwapordinates.call(request.parameters as Public.Procedures.StSwapordinates.Parameters),
"Public.Procedures.StFlipcoordinates.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StFlipcoordinates.call(request.parameters as Public.Procedures.StFlipcoordinates.Parameters),
"Public.Procedures.StBdpolyfromtext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBdpolyfromtext.call(request.parameters as Public.Procedures.StBdpolyfromtext.Parameters),
"Public.Procedures.StBdmpolyfromtext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBdmpolyfromtext.call(request.parameters as Public.Procedures.StBdmpolyfromtext.Parameters),
"Public.Procedures.Unlockrows.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Unlockrows.call(request.parameters as Public.Procedures.Unlockrows.Parameters),
"Public.Procedures.Geography_675a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geography_675a.call(request.parameters as Public.Procedures.Geography_675a.Parameters),
"Public.Procedures.Geography_2d19.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geography_2d19.call(request.parameters as Public.Procedures.Geography_2d19.Parameters),
"Public.Procedures.Bytea_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Bytea_38ca.call(request.parameters as Public.Procedures.Bytea_38ca.Parameters),
"Public.Procedures.StAstext_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstext_38ca.call(request.parameters as Public.Procedures.StAstext_38ca.Parameters),
"Public.Procedures.StAstext_75a2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstext_75a2.call(request.parameters as Public.Procedures.StAstext_75a2.Parameters),
"Public.Procedures.LockrowE9aa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.LockrowE9aa.call(request.parameters as Public.Procedures.LockrowE9aa.Parameters),
"Public.Procedures.Lockrow_02b4.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Lockrow_02b4.call(request.parameters as Public.Procedures.Lockrow_02b4.Parameters),
"Public.Procedures.Lockrow_27e1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Lockrow_27e1.call(request.parameters as Public.Procedures.Lockrow_27e1.Parameters),
"Public.Procedures.Lockrow_9a8a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Lockrow_9a8a.call(request.parameters as Public.Procedures.Lockrow_9a8a.Parameters),
"Public.Procedures.Addauth.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Addauth.call(request.parameters as Public.Procedures.Addauth.Parameters),
"Public.Procedures.Checkauth_27e1.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Checkauth_27e1.call(request.parameters as Public.Procedures.Checkauth_27e1.Parameters),
"Public.Procedures.Checkauth_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Checkauth_2ec2.call(request.parameters as Public.Procedures.Checkauth_2ec2.Parameters),
"Public.Procedures.Checkauthtrigger.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Checkauthtrigger.call(),
"Public.Procedures.Gettransactionid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Gettransactionid.call(),
"Public.Procedures.Enablelongtransactions.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Enablelongtransactions.call(),
"Public.Procedures.Longtransactionsenabled.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Longtransactionsenabled.call(),
"Public.Procedures.Disablelongtransactions.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Disablelongtransactions.call(),
"Public.Procedures.GeographyTypmodIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyTypmodIn.call(request.parameters as Public.Procedures.GeographyTypmodIn.Parameters),
"Public.Procedures.GeographyTypmodOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyTypmodOut.call(request.parameters as Public.Procedures.GeographyTypmodOut.Parameters),
"Public.Procedures.GeographyIn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyIn.call(request.parameters as Public.Procedures.GeographyIn.Parameters),
"Public.Procedures.GeographyOut.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyOut.call(request.parameters as Public.Procedures.GeographyOut.Parameters),
"Public.Procedures.GeographyRecv.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyRecv.call(request.parameters as Public.Procedures.GeographyRecv.Parameters),
"Public.Procedures.GeographySend.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySend.call(request.parameters as Public.Procedures.GeographySend.Parameters),
"Public.Procedures.StAstextE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAstextE728.call(request.parameters as Public.Procedures.StAstextE728.Parameters),
"Public.Procedures.StGeographyfromtext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeographyfromtext.call(request.parameters as Public.Procedures.StGeographyfromtext.Parameters),
"Public.Procedures.StGeogfromtext.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeogfromtext.call(request.parameters as Public.Procedures.StGeogfromtext.Parameters),
"Public.Procedures.StGeogfromwkb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeogfromwkb.call(request.parameters as Public.Procedures.StGeogfromwkb.Parameters),
"Public.Procedures.PostgisTypmodDims.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTypmodDims.call(request.parameters as Public.Procedures.PostgisTypmodDims.Parameters),
"Public.Procedures.PostgisTypmodSrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTypmodSrid.call(request.parameters as Public.Procedures.PostgisTypmodSrid.Parameters),
"Public.Procedures.PostgisTypmodType.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTypmodType.call(request.parameters as Public.Procedures.PostgisTypmodType.Parameters),
"Public.Procedures.Geography_0faa.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geography_0faa.call(request.parameters as Public.Procedures.Geography_0faa.Parameters),
"Public.Procedures.Geometry_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometry_38ca.call(request.parameters as Public.Procedures.Geometry_38ca.Parameters),
"Public.Procedures.GeographyGistConsistent.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistConsistent.call(request.parameters as Public.Procedures.GeographyGistConsistent.Parameters),
"Public.Procedures.GeographyGistCompress.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistCompress.call(request.parameters as Public.Procedures.GeographyGistCompress.Parameters),
"Public.Procedures.GeographyGistPenalty.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistPenalty.call(request.parameters as Public.Procedures.GeographyGistPenalty.Parameters),
"Public.Procedures.GeographyGistPicksplit.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistPicksplit.call(request.parameters as Public.Procedures.GeographyGistPicksplit.Parameters),
"Public.Procedures.GeographyGistUnion.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistUnion.call(request.parameters as Public.Procedures.GeographyGistUnion.Parameters),
"Public.Procedures.GeographyGistSame.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistSame.call(request.parameters as Public.Procedures.GeographyGistSame.Parameters),
"Public.Procedures.GeographyGistDecompress.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistDecompress.call(request.parameters as Public.Procedures.GeographyGistDecompress.Parameters),
"Public.Procedures.GeographyOverlaps.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyOverlaps.call(request.parameters as Public.Procedures.GeographyOverlaps.Parameters),
"Public.Procedures.GeographyDistanceKnn.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyDistanceKnn.call(request.parameters as Public.Procedures.GeographyDistanceKnn.Parameters),
"Public.Procedures.GeographyGistDistance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGistDistance.call(request.parameters as Public.Procedures.GeographyGistDistance.Parameters),
"Public.Procedures.OverlapsGeog_5a37.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsGeog_5a37.call(request.parameters as Public.Procedures.OverlapsGeog_5a37.Parameters),
"Public.Procedures.OverlapsGeogBd57.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsGeogBd57.call(request.parameters as Public.Procedures.OverlapsGeogBd57.Parameters),
"Public.Procedures.OverlapsGeog_1597.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsGeog_1597.call(request.parameters as Public.Procedures.OverlapsGeog_1597.Parameters),
"Public.Procedures.GeogBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeogBrinInclusionAddValue.call(request.parameters as Public.Procedures.GeogBrinInclusionAddValue.Parameters),
"Public.Procedures.GeographyLt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyLt.call(request.parameters as Public.Procedures.GeographyLt.Parameters),
"Public.Procedures.GeographyLe.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyLe.call(request.parameters as Public.Procedures.GeographyLe.Parameters),
"Public.Procedures.GeographyGt.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGt.call(request.parameters as Public.Procedures.GeographyGt.Parameters),
"Public.Procedures.GeographyGe.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyGe.call(request.parameters as Public.Procedures.GeographyGe.Parameters),
"Public.Procedures.GeographyEq.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyEq.call(request.parameters as Public.Procedures.GeographyEq.Parameters),
"Public.Procedures.GeographyCmp.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographyCmp.call(request.parameters as Public.Procedures.GeographyCmp.Parameters),
"Public.Procedures.StAssvg_8ddb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAssvg_8ddb.call(request.parameters as Public.Procedures.StAssvg_8ddb.Parameters),
"Public.Procedures.StAssvgE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAssvgE728.call(request.parameters as Public.Procedures.StAssvgE728.Parameters),
"Public.Procedures.StProjectE61a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StProjectE61a.call(request.parameters as Public.Procedures.StProjectE61a.Parameters),
"Public.Procedures.StAzimuthA587.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAzimuthA587.call(request.parameters as Public.Procedures.StAzimuthA587.Parameters),
"Public.Procedures.StBuffer_49f7.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuffer_49f7.call(request.parameters as Public.Procedures.StBuffer_49f7.Parameters),
"Public.Procedures.StAsgmlCe11.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgmlCe11.call(request.parameters as Public.Procedures.StAsgmlCe11.Parameters),
"Public.Procedures.StAsgml_98d7.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgml_98d7.call(request.parameters as Public.Procedures.StAsgml_98d7.Parameters),
"Public.Procedures.StAsgmlE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgmlE728.call(request.parameters as Public.Procedures.StAsgmlE728.Parameters),
"Public.Procedures.StAskml_48da.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAskml_48da.call(request.parameters as Public.Procedures.StAskml_48da.Parameters),
"Public.Procedures.StAskmlE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAskmlE728.call(request.parameters as Public.Procedures.StAskmlE728.Parameters),
"Public.Procedures.StAsgeojson_8ddb.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgeojson_8ddb.call(request.parameters as Public.Procedures.StAsgeojson_8ddb.Parameters),
"Public.Procedures.StAsgeojsonE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsgeojsonE728.call(request.parameters as Public.Procedures.StAsgeojsonE728.Parameters),
"Public.Procedures.StDistance_89b8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistance_89b8.call(request.parameters as Public.Procedures.StDistance_89b8.Parameters),
"Public.Procedures.StDistance_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistance_2ec2.call(request.parameters as Public.Procedures.StDistance_2ec2.Parameters),
"Public.Procedures.StAreaAc0a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAreaAc0a.call(request.parameters as Public.Procedures.StAreaAc0a.Parameters),
"Public.Procedures.StAreaE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAreaE728.call(request.parameters as Public.Procedures.StAreaE728.Parameters),
"Public.Procedures.StLengthAc0a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLengthAc0a.call(request.parameters as Public.Procedures.StLengthAc0a.Parameters),
"Public.Procedures.StLengthE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLengthE728.call(request.parameters as Public.Procedures.StLengthE728.Parameters),
"Public.Procedures.StProject_665e.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StProject_665e.call(request.parameters as Public.Procedures.StProject_665e.Parameters),
"Public.Procedures.StPerimeterAc0a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPerimeterAc0a.call(request.parameters as Public.Procedures.StPerimeterAc0a.Parameters),
"Public.Procedures.StSegmentize_772c.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSegmentize_772c.call(request.parameters as Public.Procedures.StSegmentize_772c.Parameters),
"Public.Procedures.StAsbinary_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsbinary_38ca.call(request.parameters as Public.Procedures.StAsbinary_38ca.Parameters),
"Public.Procedures.StAsbinaryF815.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsbinaryF815.call(request.parameters as Public.Procedures.StAsbinaryF815.Parameters),
"Public.Procedures.StAsewkt_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewkt_38ca.call(request.parameters as Public.Procedures.StAsewkt_38ca.Parameters),
"Public.Procedures.StAsewkt_75a2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewkt_75a2.call(request.parameters as Public.Procedures.StAsewkt_75a2.Parameters),
"Public.Procedures.StAsewktE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsewktE728.call(request.parameters as Public.Procedures.StAsewktE728.Parameters),
"Public.Procedures.Geometrytype_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geometrytype_38ca.call(request.parameters as Public.Procedures.Geometrytype_38ca.Parameters),
"Public.Procedures.StSummary_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSummary_38ca.call(request.parameters as Public.Procedures.StSummary_38ca.Parameters),
"Public.Procedures.StGeohash_75a2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StGeohash_75a2.call(request.parameters as Public.Procedures.StGeohash_75a2.Parameters),
"Public.Procedures.StSrid_38ca.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSrid_38ca.call(request.parameters as Public.Procedures.StSrid_38ca.Parameters),
"Public.Procedures.StSetsrid_75a2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSetsrid_75a2.call(request.parameters as Public.Procedures.StSetsrid_75a2.Parameters),
"Public.Procedures.StCentroidAc0a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCentroidAc0a.call(request.parameters as Public.Procedures.StCentroidAc0a.Parameters),
"Public.Procedures.StCentroidE728.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCentroidE728.call(request.parameters as Public.Procedures.StCentroidE728.Parameters),
"Public.Procedures.StCoversA587.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoversA587.call(request.parameters as Public.Procedures.StCoversA587.Parameters),
"Public.Procedures.StDwithin_5395.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDwithin_5395.call(request.parameters as Public.Procedures.StDwithin_5395.Parameters),
"Public.Procedures.StCoveredbyA587.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoveredbyA587.call(request.parameters as Public.Procedures.StCoveredbyA587.Parameters),
"Public.Procedures.StIntersectsA587.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersectsA587.call(request.parameters as Public.Procedures.StIntersectsA587.Parameters),
"Public.Procedures.StBuffer_772c.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuffer_772c.call(request.parameters as Public.Procedures.StBuffer_772c.Parameters),
"Public.Procedures.StBuffer_2117.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuffer_2117.call(request.parameters as Public.Procedures.StBuffer_2117.Parameters),
"Public.Procedures.StBuffer_3a01.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBuffer_3a01.call(request.parameters as Public.Procedures.StBuffer_3a01.Parameters),
"Public.Procedures.StBufferC349.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBufferC349.call(request.parameters as Public.Procedures.StBufferC349.Parameters),
"Public.Procedures.StBufferF7c6.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StBufferF7c6.call(request.parameters as Public.Procedures.StBufferF7c6.Parameters),
"Public.Procedures.StIntersectionA587.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersectionA587.call(request.parameters as Public.Procedures.StIntersectionA587.Parameters),
"Public.Procedures.StIntersection_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersection_2ec2.call(request.parameters as Public.Procedures.StIntersection_2ec2.Parameters),
"Public.Procedures.StCovers_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCovers_2ec2.call(request.parameters as Public.Procedures.StCovers_2ec2.Parameters),
"Public.Procedures.StCoveredby_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoveredby_2ec2.call(request.parameters as Public.Procedures.StCoveredby_2ec2.Parameters),
"Public.Procedures.StDwithinEfc0.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDwithinEfc0.call(request.parameters as Public.Procedures.StDwithinEfc0.Parameters),
"Public.Procedures.StIntersects_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StIntersects_2ec2.call(request.parameters as Public.Procedures.StIntersects_2ec2.Parameters),
"Public.Procedures.StClosestpoint_89b8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClosestpoint_89b8.call(request.parameters as Public.Procedures.StClosestpoint_89b8.Parameters),
"Public.Procedures.StClosestpoint_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StClosestpoint_2ec2.call(request.parameters as Public.Procedures.StClosestpoint_2ec2.Parameters),
"Public.Procedures.StShortestline_89b8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StShortestline_89b8.call(request.parameters as Public.Procedures.StShortestline_89b8.Parameters),
"Public.Procedures.StShortestline_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StShortestline_2ec2.call(request.parameters as Public.Procedures.StShortestline_2ec2.Parameters),
"Public.Procedures.StLinesubstring_665e.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinesubstring_665e.call(request.parameters as Public.Procedures.StLinesubstring_665e.Parameters),
"Public.Procedures.StLinesubstringE586.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinesubstringE586.call(request.parameters as Public.Procedures.StLinesubstringE586.Parameters),
"Public.Procedures.StLinelocatepoint_89b8.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinelocatepoint_89b8.call(request.parameters as Public.Procedures.StLinelocatepoint_89b8.Parameters),
"Public.Procedures.StLinelocatepoint_2ec2.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinelocatepoint_2ec2.call(request.parameters as Public.Procedures.StLinelocatepoint_2ec2.Parameters),
"Public.Procedures.StLineinterpolatepoints_5d11.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepoints_5d11.call(request.parameters as Public.Procedures.StLineinterpolatepoints_5d11.Parameters),
"Public.Procedures.StLineinterpolatepointsC349.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepointsC349.call(request.parameters as Public.Procedures.StLineinterpolatepointsC349.Parameters),
"Public.Procedures.StLineinterpolatepointCee3.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepointCee3.call(request.parameters as Public.Procedures.StLineinterpolatepointCee3.Parameters),
"Public.Procedures.StLineinterpolatepointC349.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLineinterpolatepointC349.call(request.parameters as Public.Procedures.StLineinterpolatepointC349.Parameters),
"Public.Procedures.StDistancesphereEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistancesphereEb6a.call(request.parameters as Public.Procedures.StDistancesphereEb6a.Parameters),
"Public.Procedures.StDistancesphereE059.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StDistancesphereE059.call(request.parameters as Public.Procedures.StDistancesphereE059.Parameters),
"Public.Procedures.PostgisTypeName.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisTypeName.call(request.parameters as Public.Procedures.PostgisTypeName.Parameters),
"Public.Procedures.PostgisConstraintSrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisConstraintSrid.call(request.parameters as Public.Procedures.PostgisConstraintSrid.Parameters),
"Public.Procedures.PostgisConstraintDims.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisConstraintDims.call(request.parameters as Public.Procedures.PostgisConstraintDims.Parameters),
"Public.Procedures.PostgisConstraintType.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.PostgisConstraintType.call(request.parameters as Public.Procedures.PostgisConstraintType.Parameters),
"Public.Procedures.St_3ddistance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3ddistance.call(request.parameters as Public.Procedures.St_3ddistance.Parameters),
"Public.Procedures.St_3dmaxdistance.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dmaxdistance.call(request.parameters as Public.Procedures.St_3dmaxdistance.Parameters),
"Public.Procedures.St_3dclosestpoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dclosestpoint.call(request.parameters as Public.Procedures.St_3dclosestpoint.Parameters),
"Public.Procedures.St_3dshortestline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dshortestline.call(request.parameters as Public.Procedures.St_3dshortestline.Parameters),
"Public.Procedures.St_3dlongestline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dlongestline.call(request.parameters as Public.Procedures.St_3dlongestline.Parameters),
"Public.Procedures.StCoorddim.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCoorddim.call(request.parameters as Public.Procedures.StCoorddim.Parameters),
"Public.Procedures.StCurvetoline.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StCurvetoline.call(request.parameters as Public.Procedures.StCurvetoline.Parameters),
"Public.Procedures.StHasarc.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StHasarc.call(request.parameters as Public.Procedures.StHasarc.Parameters),
"Public.Procedures.StLinetocurve.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLinetocurve.call(request.parameters as Public.Procedures.StLinetocurve.Parameters),
"Public.Procedures.StPoint_0aec.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPoint_0aec.call(request.parameters as Public.Procedures.StPoint_0aec.Parameters),
"Public.Procedures.StPoint_0b7f.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPoint_0b7f.call(request.parameters as Public.Procedures.StPoint_0b7f.Parameters),
"Public.Procedures.StPointz.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointz.call(request.parameters as Public.Procedures.StPointz.Parameters),
"Public.Procedures.StPointm.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointm.call(request.parameters as Public.Procedures.StPointm.Parameters),
"Public.Procedures.StPointzm.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPointzm.call(request.parameters as Public.Procedures.StPointzm.Parameters),
"Public.Procedures.StPolygon.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StPolygon.call(request.parameters as Public.Procedures.StPolygon.Parameters),
"Public.Procedures.StWkbtosql.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StWkbtosql.call(request.parameters as Public.Procedures.StWkbtosql.Parameters),
"Public.Procedures.StLocatebetween.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLocatebetween.call(request.parameters as Public.Procedures.StLocatebetween.Parameters),
"Public.Procedures.StLocatealong.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLocatealong.call(request.parameters as Public.Procedures.StLocatealong.Parameters),
"Public.Procedures.StLocatebetweenelevations.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLocatebetweenelevations.call(request.parameters as Public.Procedures.StLocatebetweenelevations.Parameters),
"Public.Procedures.StInterpolatepoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StInterpolatepoint.call(request.parameters as Public.Procedures.StInterpolatepoint.Parameters),
"Public.Procedures.StHexagon.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StHexagon.call(request.parameters as Public.Procedures.StHexagon.Parameters),
"Public.Procedures.StSquare.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSquare.call(request.parameters as Public.Procedures.StSquare.Parameters),
"Public.Procedures.StHexagongrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StHexagongrid.call(request.parameters as Public.Procedures.StHexagongrid.Parameters),
"Public.Procedures.StSquaregrid.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSquaregrid.call(request.parameters as Public.Procedures.StSquaregrid.Parameters),
"Public.Procedures.Contains_2dD703.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Contains_2dD703.call(request.parameters as Public.Procedures.Contains_2dD703.Parameters),
"Public.Procedures.IsContained_2dD703.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.IsContained_2dD703.call(request.parameters as Public.Procedures.IsContained_2dD703.Parameters),
"Public.Procedures.Overlaps_2dD703.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Overlaps_2dD703.call(request.parameters as Public.Procedures.Overlaps_2dD703.Parameters),
"Public.Procedures.Overlaps_2d_1585.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Overlaps_2d_1585.call(request.parameters as Public.Procedures.Overlaps_2d_1585.Parameters),
"Public.Procedures.Contains_2d_1585.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Contains_2d_1585.call(request.parameters as Public.Procedures.Contains_2d_1585.Parameters),
"Public.Procedures.IsContained_2d_1585.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.IsContained_2d_1585.call(request.parameters as Public.Procedures.IsContained_2d_1585.Parameters),
"Public.Procedures.Contains_2d_3f94.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Contains_2d_3f94.call(request.parameters as Public.Procedures.Contains_2d_3f94.Parameters),
"Public.Procedures.IsContained_2d_3f94.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.IsContained_2d_3f94.call(request.parameters as Public.Procedures.IsContained_2d_3f94.Parameters),
"Public.Procedures.Overlaps_2d_3f94.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Overlaps_2d_3f94.call(request.parameters as Public.Procedures.Overlaps_2d_3f94.Parameters),
"Public.Procedures.OverlapsNd_44c4.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsNd_44c4.call(request.parameters as Public.Procedures.OverlapsNd_44c4.Parameters),
"Public.Procedures.OverlapsNdBd57.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsNdBd57.call(request.parameters as Public.Procedures.OverlapsNdBd57.Parameters),
"Public.Procedures.OverlapsNd_19dd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.OverlapsNd_19dd.call(request.parameters as Public.Procedures.OverlapsNd_19dd.Parameters),
"Public.Procedures.Geom2dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geom2dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom2dBrinInclusionAddValue.Parameters),
"Public.Procedures.Geom3dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geom3dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom3dBrinInclusionAddValue.Parameters),
"Public.Procedures.Geom4dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.Geom4dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom4dBrinInclusionAddValue.Parameters),
"Public.Procedures.StSimplifypolygonhull.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StSimplifypolygonhull.call(request.parameters as Public.Procedures.StSimplifypolygonhull.Parameters),
"Public.Procedures.StConcavehull.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StConcavehull.call(request.parameters as Public.Procedures.StConcavehull.Parameters),
"Public.Procedures.StAsx3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAsx3d.call(request.parameters as Public.Procedures.StAsx3d.Parameters),
"Public.Procedures.StAngleEb6a.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StAngleEb6a.call(request.parameters as Public.Procedures.StAngleEb6a.Parameters),
"Public.Procedures.St_3dlineinterpolatepoint.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.St_3dlineinterpolatepoint.call(request.parameters as Public.Procedures.St_3dlineinterpolatepoint.Parameters),
"Public.Procedures.GeometrySpgistConfig_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistConfig_2d.call(request.parameters as Public.Procedures.GeometrySpgistConfig_2d.Parameters),
"Public.Procedures.GeometrySpgistChoose_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistChoose_2d.call(request.parameters as Public.Procedures.GeometrySpgistChoose_2d.Parameters),
"Public.Procedures.GeometrySpgistPicksplit_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistPicksplit_2d.call(request.parameters as Public.Procedures.GeometrySpgistPicksplit_2d.Parameters),
"Public.Procedures.GeometrySpgistInnerConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistInnerConsistent_2d.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters),
"Public.Procedures.GeometrySpgistLeafConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistLeafConsistent_2d.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters),
"Public.Procedures.GeometrySpgistCompress_2d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistCompress_2d.call(request.parameters as Public.Procedures.GeometrySpgistCompress_2d.Parameters),
"Public.Procedures.GeometryOverlaps_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryOverlaps_3d.call(request.parameters as Public.Procedures.GeometryOverlaps_3d.Parameters),
"Public.Procedures.GeometryContains_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryContains_3d.call(request.parameters as Public.Procedures.GeometryContains_3d.Parameters),
"Public.Procedures.GeometryContained_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometryContained_3d.call(request.parameters as Public.Procedures.GeometryContained_3d.Parameters),
"Public.Procedures.GeometrySame_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySame_3d.call(request.parameters as Public.Procedures.GeometrySame_3d.Parameters),
"Public.Procedures.GeometrySpgistConfig_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistConfig_3d.call(request.parameters as Public.Procedures.GeometrySpgistConfig_3d.Parameters),
"Public.Procedures.GeometrySpgistChoose_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistChoose_3d.call(request.parameters as Public.Procedures.GeometrySpgistChoose_3d.Parameters),
"Public.Procedures.GeometrySpgistPicksplit_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistPicksplit_3d.call(request.parameters as Public.Procedures.GeometrySpgistPicksplit_3d.Parameters),
"Public.Procedures.GeometrySpgistInnerConsistent_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistInnerConsistent_3d.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters),
"Public.Procedures.GeometrySpgistLeafConsistent_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistLeafConsistent_3d.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters),
"Public.Procedures.GeometrySpgistCompress_3d.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistCompress_3d.call(request.parameters as Public.Procedures.GeometrySpgistCompress_3d.Parameters),
"Public.Procedures.GeometrySpgistConfigNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistConfigNd.call(request.parameters as Public.Procedures.GeometrySpgistConfigNd.Parameters),
"Public.Procedures.GeometrySpgistChooseNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistChooseNd.call(request.parameters as Public.Procedures.GeometrySpgistChooseNd.Parameters),
"Public.Procedures.GeometrySpgistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistPicksplitNd.call(request.parameters as Public.Procedures.GeometrySpgistPicksplitNd.Parameters),
"Public.Procedures.GeometrySpgistInnerConsistentNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistInnerConsistentNd.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters),
"Public.Procedures.GeometrySpgistLeafConsistentNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistLeafConsistentNd.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters),
"Public.Procedures.GeometrySpgistCompressNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeometrySpgistCompressNd.call(request.parameters as Public.Procedures.GeometrySpgistCompressNd.Parameters),
"Public.Procedures.GeographySpgistConfigNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistConfigNd.call(request.parameters as Public.Procedures.GeographySpgistConfigNd.Parameters),
"Public.Procedures.GeographySpgistChooseNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistChooseNd.call(request.parameters as Public.Procedures.GeographySpgistChooseNd.Parameters),
"Public.Procedures.GeographySpgistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistPicksplitNd.call(request.parameters as Public.Procedures.GeographySpgistPicksplitNd.Parameters),
"Public.Procedures.GeographySpgistInnerConsistentNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistInnerConsistentNd.call(request.parameters as Public.Procedures.GeographySpgistInnerConsistentNd.Parameters),
"Public.Procedures.GeographySpgistLeafConsistentNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistLeafConsistentNd.call(request.parameters as Public.Procedures.GeographySpgistLeafConsistentNd.Parameters),
"Public.Procedures.GeographySpgistCompressNd.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.GeographySpgistCompressNd.call(request.parameters as Public.Procedures.GeographySpgistCompressNd.Parameters),
"Public.Procedures.StLetters.call": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Procedures.StLetters.call(request.parameters as Public.Procedures.StLetters.Parameters),
"Public.Tables.SpatialRefSys.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.SpatialRefSys.create(request.values as Public.Tables.SpatialRefSys.Values),

             "Public.Tables.SpatialRefSys.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.SpatialRefSys.all(request.options as Public.Tables.SpatialRefSys.Options),
            
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.read(request.parameters as Public.Types.SpatialRefSysPkey,request.options as Public.Tables.SpatialRefSys.Options),
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.update(request.parameters as Public.Types.SpatialRefSysPkey,request.values as Partial<Public.Tables.SpatialRefSys.Values>),
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.delete(request.parameters as Public.Types.SpatialRefSysPkey),
"Public.Tables.NycCensusBlocks.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.create(request.values as Public.Tables.NycCensusBlocks.Values),

             "Public.Tables.NycCensusBlocks.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.NycCensusBlocks.all(request.options as Public.Tables.NycCensusBlocks.Options),
            
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.read(request.parameters as Public.Types.NycCensusBlocksPkey,request.options as Public.Tables.NycCensusBlocks.Options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.update(request.parameters as Public.Types.NycCensusBlocksPkey,request.values as Partial<Public.Tables.NycCensusBlocks.Values>),
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.delete(request.parameters as Public.Types.NycCensusBlocksPkey),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.read(request.parameters as Public.Types.NycCensusBlocksGeomIdx,request.options as Public.Tables.NycCensusBlocks.Options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.update(request.parameters as Public.Types.NycCensusBlocksGeomIdx,request.values as Partial<Public.Tables.NycCensusBlocks.Values>),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.delete(request.parameters as Public.Types.NycCensusBlocksGeomIdx),
"Public.Tables.NycHomicides.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.create(request.values as Public.Tables.NycHomicides.Values),

             "Public.Tables.NycHomicides.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.NycHomicides.all(request.options as Public.Tables.NycHomicides.Options),
            
"Public.Tables.NycHomicides.NycHomicidesPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.read(request.parameters as Public.Types.NycHomicidesPkey,request.options as Public.Tables.NycHomicides.Options),
"Public.Tables.NycHomicides.NycHomicidesPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.update(request.parameters as Public.Types.NycHomicidesPkey,request.values as Partial<Public.Tables.NycHomicides.Values>),
"Public.Tables.NycHomicides.NycHomicidesPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.delete(request.parameters as Public.Types.NycHomicidesPkey),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.read(request.parameters as Public.Types.NycHomicidesGeomIdx,request.options as Public.Tables.NycHomicides.Options),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.update(request.parameters as Public.Types.NycHomicidesGeomIdx,request.values as Partial<Public.Tables.NycHomicides.Values>),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.delete(request.parameters as Public.Types.NycHomicidesGeomIdx),
"Public.Tables.NycNeighborhoods.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.create(request.values as Public.Tables.NycNeighborhoods.Values),

             "Public.Tables.NycNeighborhoods.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.NycNeighborhoods.all(request.options as Public.Tables.NycNeighborhoods.Options),
            
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.read(request.parameters as Public.Types.NycNeighborhoodsPkey,request.options as Public.Tables.NycNeighborhoods.Options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.update(request.parameters as Public.Types.NycNeighborhoodsPkey,request.values as Partial<Public.Tables.NycNeighborhoods.Values>),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.delete(request.parameters as Public.Types.NycNeighborhoodsPkey),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.read(request.parameters as Public.Types.NycNeighborhoodsGeomIdx,request.options as Public.Tables.NycNeighborhoods.Options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.update(request.parameters as Public.Types.NycNeighborhoodsGeomIdx,request.values as Partial<Public.Tables.NycNeighborhoods.Values>),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.delete(request.parameters as Public.Types.NycNeighborhoodsGeomIdx),
"Public.Tables.NycStreets.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.create(request.values as Public.Tables.NycStreets.Values),

             "Public.Tables.NycStreets.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.NycStreets.all(request.options as Public.Tables.NycStreets.Options),
            
"Public.Tables.NycStreets.NycStreetsPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsPkey.read(request.parameters as Public.Types.NycStreetsPkey,request.options as Public.Tables.NycStreets.Options),
"Public.Tables.NycStreets.NycStreetsPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsPkey.update(request.parameters as Public.Types.NycStreetsPkey,request.values as Partial<Public.Tables.NycStreets.Values>),
"Public.Tables.NycStreets.NycStreetsPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsPkey.delete(request.parameters as Public.Types.NycStreetsPkey),
"Public.Tables.NycStreets.NycStreetsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.read(request.parameters as Public.Types.NycStreetsGeomIdx,request.options as Public.Tables.NycStreets.Options),
"Public.Tables.NycStreets.NycStreetsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.update(request.parameters as Public.Types.NycStreetsGeomIdx,request.values as Partial<Public.Tables.NycStreets.Values>),
"Public.Tables.NycStreets.NycStreetsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.delete(request.parameters as Public.Types.NycStreetsGeomIdx),
"Public.Tables.NycSubwayStations.create": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.create(request.values as Public.Tables.NycSubwayStations.Values),

             "Public.Tables.NycSubwayStations.all": async (request: EmbraceSQLRequest<object, object, object>) =>
              database.Public.Tables.NycSubwayStations.all(request.options as Public.Tables.NycSubwayStations.Options),
            
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.read(request.parameters as Public.Types.NycSubwayStationsPkey,request.options as Public.Tables.NycSubwayStations.Options),
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.update(request.parameters as Public.Types.NycSubwayStationsPkey,request.values as Partial<Public.Tables.NycSubwayStations.Values>),
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.delete(request.parameters as Public.Types.NycSubwayStationsPkey),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.read(request.parameters as Public.Types.NycSubwayStationsGeomIdx,request.options as Public.Tables.NycSubwayStations.Options),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.update(request.parameters as Public.Types.NycSubwayStationsGeomIdx,request.values as Partial<Public.Tables.NycSubwayStations.Values>),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, object>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.delete(request.parameters as Public.Types.NycSubwayStationsGeomIdx),
}
}

            async dispatch(request: EmbraceSQLRequest<object, object, object>) {
              if (!this.dispatchMap[request.operation]) {
                throw new Error(`${request.operation} not available`);
              }
              return this.dispatchMap[request.operation](request);
            }
            
}