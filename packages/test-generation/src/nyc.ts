
        // ⚠️ generated - do not modify ⚠️

        /**
         * These types are node/browser isomorphic and are used by all other
         * EmbraceSQL generated code.
         */
        /* eslint-disable @typescript-eslint/no-explicit-any */
        /* eslint-disable @typescript-eslint/no-empty-interface */
        /* eslint-disable @typescript-eslint/no-namespace */
        /* eslint-disable @typescript-eslint/no-unused-vars */
        /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
        /* eslint-disable @typescript-eslint/no-redundant-type-constituents */
        /* @typescript-eslint/no-redundant-type-constituents */
        import {UUID, JsDate, JSONValue, JSONObject, Empty, Nullable, NullableMembers, undefinedIsNull, nullIsUndefined, NEVER, EmbraceSQLOptions} from "@embracesql/shared";
        import type { PartiallyOptional, PossiblyEmpty, ReadOptions, Sort, InvokeQueryOptions as GenericInvokeQueryOptions } from "@embracesql/shared";
        import { Geometry } from "@embracesql/shared";
        import { DatabaseMetadata, Schema, Table, Column, Index, Procedure } from "@embracesql/shared";
    

            import { Context, initializeContext, PostgresDatabase } from "@embracesql/postgres";
            import postgres from "postgres";
          

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        type ArgumentToPostgres = any;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        type ArgumentFromPostgres = any;
        type Typecast = (x: ArgumentToPostgres) => ArgumentFromPostgres;
        export interface PostgresTypecasts { 
      
[16]: Typecast;
["PgCatalog.Types.Bool"]: Typecast
[17]: Typecast;
["PgCatalog.Types.Bytea"]: Typecast
[18]: Typecast;
["PgCatalog.Types.Char"]: Typecast
[19]: Typecast;
["PgCatalog.Types.Name"]: Typecast
[20]: Typecast;
["PgCatalog.Types.Int8"]: Typecast
[21]: Typecast;
["PgCatalog.Types.Int2"]: Typecast
[22]: Typecast;
["PgCatalog.Types.Int2vector"]: Typecast
[23]: Typecast;
["PgCatalog.Types.Int4"]: Typecast
[24]: Typecast;
["PgCatalog.Types.Regproc"]: Typecast
[25]: Typecast;
["PgCatalog.Types.Text"]: Typecast
[26]: Typecast;
["PgCatalog.Types.Oid"]: Typecast
[27]: Typecast;
["PgCatalog.Types.Tid"]: Typecast
[28]: Typecast;
["PgCatalog.Types.Xid"]: Typecast
[29]: Typecast;
["PgCatalog.Types.Cid"]: Typecast
[30]: Typecast;
["PgCatalog.Types.Oidvector"]: Typecast
[71]: Typecast;
["PgCatalog.Types.PgType"]: Typecast
[75]: Typecast;
["PgCatalog.Types.PgAttribute"]: Typecast
[81]: Typecast;
["PgCatalog.Types.PgProc"]: Typecast
[83]: Typecast;
["PgCatalog.Types.PgClass"]: Typecast
[114]: Typecast;
["PgCatalog.Types.Json"]: Typecast
[142]: Typecast;
["PgCatalog.Types.Xml"]: Typecast
[194]: Typecast;
["PgCatalog.Types.PgNodeTree"]: Typecast
[3361]: Typecast;
["PgCatalog.Types.PgNdistinct"]: Typecast
[3402]: Typecast;
["PgCatalog.Types.PgDependencies"]: Typecast
[5017]: Typecast;
["PgCatalog.Types.PgMcvList"]: Typecast
[32]: Typecast;
["PgCatalog.Types.PgDdlCommand"]: Typecast
[5069]: Typecast;
["PgCatalog.Types.Xid8"]: Typecast
[600]: Typecast;
["PgCatalog.Types.Point"]: Typecast
[601]: Typecast;
["PgCatalog.Types.Lseg"]: Typecast
[602]: Typecast;
["PgCatalog.Types.Path"]: Typecast
[603]: Typecast;
["PgCatalog.Types.Box"]: Typecast
[604]: Typecast;
["PgCatalog.Types.Polygon"]: Typecast
[628]: Typecast;
["PgCatalog.Types.Line"]: Typecast
[700]: Typecast;
["PgCatalog.Types.Float4"]: Typecast
[701]: Typecast;
["PgCatalog.Types.Float8"]: Typecast
[705]: Typecast;
["PgCatalog.Types.Unknown"]: Typecast
[718]: Typecast;
["PgCatalog.Types.Circle"]: Typecast
[790]: Typecast;
["PgCatalog.Types.Money"]: Typecast
[829]: Typecast;
["PgCatalog.Types.Macaddr"]: Typecast
[869]: Typecast;
["PgCatalog.Types.Inet"]: Typecast
[650]: Typecast;
["PgCatalog.Types.Cidr"]: Typecast
[774]: Typecast;
["PgCatalog.Types.Macaddr8"]: Typecast
[1033]: Typecast;
["PgCatalog.Types.Aclitem"]: Typecast
[1042]: Typecast;
["PgCatalog.Types.Bpchar"]: Typecast
[1043]: Typecast;
["PgCatalog.Types.Varchar"]: Typecast
[1082]: Typecast;
["PgCatalog.Types.Date"]: Typecast
[1083]: Typecast;
["PgCatalog.Types.Time"]: Typecast
[1114]: Typecast;
["PgCatalog.Types.Timestamp"]: Typecast
[1184]: Typecast;
["PgCatalog.Types.Timestamptz"]: Typecast
[1186]: Typecast;
["PgCatalog.Types.Interval"]: Typecast
[1266]: Typecast;
["PgCatalog.Types.Timetz"]: Typecast
[1560]: Typecast;
["PgCatalog.Types.Bit"]: Typecast
[1562]: Typecast;
["PgCatalog.Types.Varbit"]: Typecast
[1700]: Typecast;
["PgCatalog.Types.Numeric"]: Typecast
[1790]: Typecast;
["PgCatalog.Types.Refcursor"]: Typecast
[2202]: Typecast;
["PgCatalog.Types.Regprocedure"]: Typecast
[2203]: Typecast;
["PgCatalog.Types.Regoper"]: Typecast
[2204]: Typecast;
["PgCatalog.Types.Regoperator"]: Typecast
[2205]: Typecast;
["PgCatalog.Types.Regclass"]: Typecast
[4191]: Typecast;
["PgCatalog.Types.Regcollation"]: Typecast
[2206]: Typecast;
["PgCatalog.Types.Regtype"]: Typecast
[4096]: Typecast;
["PgCatalog.Types.Regrole"]: Typecast
[4089]: Typecast;
["PgCatalog.Types.Regnamespace"]: Typecast
[2950]: Typecast;
["PgCatalog.Types.Uuid"]: Typecast
[3220]: Typecast;
["PgCatalog.Types.PgLsn"]: Typecast
[3614]: Typecast;
["PgCatalog.Types.Tsvector"]: Typecast
[3642]: Typecast;
["PgCatalog.Types.Gtsvector"]: Typecast
[3615]: Typecast;
["PgCatalog.Types.Tsquery"]: Typecast
[3734]: Typecast;
["PgCatalog.Types.Regconfig"]: Typecast
[3769]: Typecast;
["PgCatalog.Types.Regdictionary"]: Typecast
[3802]: Typecast;
["PgCatalog.Types.Jsonb"]: Typecast
[4072]: Typecast;
["PgCatalog.Types.Jsonpath"]: Typecast
[2970]: Typecast;
["PgCatalog.Types.TxidSnapshot"]: Typecast
[5038]: Typecast;
["PgCatalog.Types.PgSnapshot"]: Typecast
[3904]: Typecast;
["PgCatalog.Types.Int4range"]: Typecast
[3906]: Typecast;
["PgCatalog.Types.Numrange"]: Typecast
[3908]: Typecast;
["PgCatalog.Types.Tsrange"]: Typecast
[3910]: Typecast;
["PgCatalog.Types.Tstzrange"]: Typecast
[3912]: Typecast;
["PgCatalog.Types.Daterange"]: Typecast
[3926]: Typecast;
["PgCatalog.Types.Int8range"]: Typecast
[4451]: Typecast;
["PgCatalog.Types.Int4multirange"]: Typecast
[4532]: Typecast;
["PgCatalog.Types.Nummultirange"]: Typecast
[4533]: Typecast;
["PgCatalog.Types.Tsmultirange"]: Typecast
[4534]: Typecast;
["PgCatalog.Types.Tstzmultirange"]: Typecast
[4535]: Typecast;
["PgCatalog.Types.Datemultirange"]: Typecast
[4536]: Typecast;
["PgCatalog.Types.Int8multirange"]: Typecast
[2249]: Typecast;
["PgCatalog.Types.Record"]: Typecast
[2287]: Typecast;
["PgCatalog.Types.RecordArray"]: Typecast
[2275]: Typecast;
["PgCatalog.Types.Cstring"]: Typecast
[2276]: Typecast;
["PgCatalog.Types.Any"]: Typecast
[2277]: Typecast;
["PgCatalog.Types.Anyarray"]: Typecast
[2278]: Typecast;
["PgCatalog.Types.Void"]: Typecast
[2279]: Typecast;
["PgCatalog.Types.Trigger"]: Typecast
[3838]: Typecast;
["PgCatalog.Types.EventTrigger"]: Typecast
[2280]: Typecast;
["PgCatalog.Types.LanguageHandler"]: Typecast
[2281]: Typecast;
["PgCatalog.Types.Internal"]: Typecast
[2283]: Typecast;
["PgCatalog.Types.Anyelement"]: Typecast
[2776]: Typecast;
["PgCatalog.Types.Anynonarray"]: Typecast
[3500]: Typecast;
["PgCatalog.Types.Anyenum"]: Typecast
[3115]: Typecast;
["PgCatalog.Types.FdwHandler"]: Typecast
[325]: Typecast;
["PgCatalog.Types.IndexAmHandler"]: Typecast
[3310]: Typecast;
["PgCatalog.Types.TsmHandler"]: Typecast
[269]: Typecast;
["PgCatalog.Types.TableAmHandler"]: Typecast
[3831]: Typecast;
["PgCatalog.Types.Anyrange"]: Typecast
[5077]: Typecast;
["PgCatalog.Types.Anycompatible"]: Typecast
[5078]: Typecast;
["PgCatalog.Types.Anycompatiblearray"]: Typecast
[5079]: Typecast;
["PgCatalog.Types.Anycompatiblenonarray"]: Typecast
[5080]: Typecast;
["PgCatalog.Types.Anycompatiblerange"]: Typecast
[4537]: Typecast;
["PgCatalog.Types.Anymultirange"]: Typecast
[4538]: Typecast;
["PgCatalog.Types.Anycompatiblemultirange"]: Typecast
[4600]: Typecast;
["PgCatalog.Types.PgBrinBloomSummary"]: Typecast
[4601]: Typecast;
["PgCatalog.Types.PgBrinMinmaxMultiSummary"]: Typecast
[1000]: Typecast;
["PgCatalog.Types.BoolArray"]: Typecast
[1001]: Typecast;
["PgCatalog.Types.ByteaArray"]: Typecast
[1002]: Typecast;
["PgCatalog.Types.CharArray"]: Typecast
[1003]: Typecast;
["PgCatalog.Types.NameArray"]: Typecast
[1016]: Typecast;
["PgCatalog.Types.Int8Array"]: Typecast
[1005]: Typecast;
["PgCatalog.Types.Int2Array"]: Typecast
[1006]: Typecast;
["PgCatalog.Types.Int2vectorArray"]: Typecast
[1007]: Typecast;
["PgCatalog.Types.Int4Array"]: Typecast
[1008]: Typecast;
["PgCatalog.Types.RegprocArray"]: Typecast
[1009]: Typecast;
["PgCatalog.Types.TextArray"]: Typecast
[1028]: Typecast;
["PgCatalog.Types.OidArray"]: Typecast
[1010]: Typecast;
["PgCatalog.Types.TidArray"]: Typecast
[1011]: Typecast;
["PgCatalog.Types.XidArray"]: Typecast
[1012]: Typecast;
["PgCatalog.Types.CidArray"]: Typecast
[1013]: Typecast;
["PgCatalog.Types.OidvectorArray"]: Typecast
[210]: Typecast;
["PgCatalog.Types.PgTypeArray"]: Typecast
[270]: Typecast;
["PgCatalog.Types.PgAttributeArray"]: Typecast
[272]: Typecast;
["PgCatalog.Types.PgProcArray"]: Typecast
[273]: Typecast;
["PgCatalog.Types.PgClassArray"]: Typecast
[199]: Typecast;
["PgCatalog.Types.JsonArray"]: Typecast
[143]: Typecast;
["PgCatalog.Types.XmlArray"]: Typecast
[271]: Typecast;
["PgCatalog.Types.Xid8Array"]: Typecast
[1017]: Typecast;
["PgCatalog.Types.PointArray"]: Typecast
[1018]: Typecast;
["PgCatalog.Types.LsegArray"]: Typecast
[1019]: Typecast;
["PgCatalog.Types.PathArray"]: Typecast
[1020]: Typecast;
["PgCatalog.Types.BoxArray"]: Typecast
[1027]: Typecast;
["PgCatalog.Types.PolygonArray"]: Typecast
[629]: Typecast;
["PgCatalog.Types.LineArray"]: Typecast
[1021]: Typecast;
["PgCatalog.Types.Float4Array"]: Typecast
[1022]: Typecast;
["PgCatalog.Types.Float8Array"]: Typecast
[719]: Typecast;
["PgCatalog.Types.CircleArray"]: Typecast
[791]: Typecast;
["PgCatalog.Types.MoneyArray"]: Typecast
[1040]: Typecast;
["PgCatalog.Types.MacaddrArray"]: Typecast
[1041]: Typecast;
["PgCatalog.Types.InetArray"]: Typecast
[651]: Typecast;
["PgCatalog.Types.CidrArray"]: Typecast
[775]: Typecast;
["PgCatalog.Types.Macaddr8Array"]: Typecast
[1034]: Typecast;
["PgCatalog.Types.AclitemArray"]: Typecast
[1014]: Typecast;
["PgCatalog.Types.BpcharArray"]: Typecast
[1015]: Typecast;
["PgCatalog.Types.VarcharArray"]: Typecast
[1182]: Typecast;
["PgCatalog.Types.DateArray"]: Typecast
[1183]: Typecast;
["PgCatalog.Types.TimeArray"]: Typecast
[1115]: Typecast;
["PgCatalog.Types.TimestampArray"]: Typecast
[1185]: Typecast;
["PgCatalog.Types.TimestamptzArray"]: Typecast
[1187]: Typecast;
["PgCatalog.Types.IntervalArray"]: Typecast
[1270]: Typecast;
["PgCatalog.Types.TimetzArray"]: Typecast
[1561]: Typecast;
["PgCatalog.Types.BitArray"]: Typecast
[1563]: Typecast;
["PgCatalog.Types.VarbitArray"]: Typecast
[1231]: Typecast;
["PgCatalog.Types.NumericArray"]: Typecast
[2201]: Typecast;
["PgCatalog.Types.RefcursorArray"]: Typecast
[2207]: Typecast;
["PgCatalog.Types.RegprocedureArray"]: Typecast
[2208]: Typecast;
["PgCatalog.Types.RegoperArray"]: Typecast
[2209]: Typecast;
["PgCatalog.Types.RegoperatorArray"]: Typecast
[2210]: Typecast;
["PgCatalog.Types.RegclassArray"]: Typecast
[4192]: Typecast;
["PgCatalog.Types.RegcollationArray"]: Typecast
[2211]: Typecast;
["PgCatalog.Types.RegtypeArray"]: Typecast
[4097]: Typecast;
["PgCatalog.Types.RegroleArray"]: Typecast
[4090]: Typecast;
["PgCatalog.Types.RegnamespaceArray"]: Typecast
[2951]: Typecast;
["PgCatalog.Types.UuidArray"]: Typecast
[3221]: Typecast;
["PgCatalog.Types.PgLsnArray"]: Typecast
[3643]: Typecast;
["PgCatalog.Types.TsvectorArray"]: Typecast
[3644]: Typecast;
["PgCatalog.Types.GtsvectorArray"]: Typecast
[3645]: Typecast;
["PgCatalog.Types.TsqueryArray"]: Typecast
[3735]: Typecast;
["PgCatalog.Types.RegconfigArray"]: Typecast
[3770]: Typecast;
["PgCatalog.Types.RegdictionaryArray"]: Typecast
[3807]: Typecast;
["PgCatalog.Types.JsonbArray"]: Typecast
[4073]: Typecast;
["PgCatalog.Types.JsonpathArray"]: Typecast
[2949]: Typecast;
["PgCatalog.Types.TxidSnapshotArray"]: Typecast
[5039]: Typecast;
["PgCatalog.Types.PgSnapshotArray"]: Typecast
[3905]: Typecast;
["PgCatalog.Types.Int4rangeArray"]: Typecast
[3907]: Typecast;
["PgCatalog.Types.NumrangeArray"]: Typecast
[3909]: Typecast;
["PgCatalog.Types.TsrangeArray"]: Typecast
[3911]: Typecast;
["PgCatalog.Types.TstzrangeArray"]: Typecast
[3913]: Typecast;
["PgCatalog.Types.DaterangeArray"]: Typecast
[3927]: Typecast;
["PgCatalog.Types.Int8rangeArray"]: Typecast
[6150]: Typecast;
["PgCatalog.Types.Int4multirangeArray"]: Typecast
[6151]: Typecast;
["PgCatalog.Types.NummultirangeArray"]: Typecast
[6152]: Typecast;
["PgCatalog.Types.TsmultirangeArray"]: Typecast
[6153]: Typecast;
["PgCatalog.Types.TstzmultirangeArray"]: Typecast
[6155]: Typecast;
["PgCatalog.Types.DatemultirangeArray"]: Typecast
[6157]: Typecast;
["PgCatalog.Types.Int8multirangeArray"]: Typecast
[1263]: Typecast;
["PgCatalog.Types.CstringArray"]: Typecast
[10001]: Typecast;
["PgCatalog.Types.PgAttrdef"]: Typecast
[10000]: Typecast;
["PgCatalog.Types.PgAttrdefArray"]: Typecast
[10003]: Typecast;
["PgCatalog.Types.PgConstraint"]: Typecast
[10002]: Typecast;
["PgCatalog.Types.PgConstraintArray"]: Typecast
[10005]: Typecast;
["PgCatalog.Types.PgInherits"]: Typecast
[10004]: Typecast;
["PgCatalog.Types.PgInheritsArray"]: Typecast
[10007]: Typecast;
["PgCatalog.Types.PgIndex"]: Typecast
[10006]: Typecast;
["PgCatalog.Types.PgIndexArray"]: Typecast
[10009]: Typecast;
["PgCatalog.Types.PgOperator"]: Typecast
[10008]: Typecast;
["PgCatalog.Types.PgOperatorArray"]: Typecast
[10011]: Typecast;
["PgCatalog.Types.PgOpfamily"]: Typecast
[10010]: Typecast;
["PgCatalog.Types.PgOpfamilyArray"]: Typecast
[10013]: Typecast;
["PgCatalog.Types.PgOpclass"]: Typecast
[10012]: Typecast;
["PgCatalog.Types.PgOpclassArray"]: Typecast
[10015]: Typecast;
["PgCatalog.Types.PgAm"]: Typecast
[10014]: Typecast;
["PgCatalog.Types.PgAmArray"]: Typecast
[10017]: Typecast;
["PgCatalog.Types.PgAmop"]: Typecast
[10016]: Typecast;
["PgCatalog.Types.PgAmopArray"]: Typecast
[10019]: Typecast;
["PgCatalog.Types.PgAmproc"]: Typecast
[10018]: Typecast;
["PgCatalog.Types.PgAmprocArray"]: Typecast
[10021]: Typecast;
["PgCatalog.Types.PgLanguage"]: Typecast
[10020]: Typecast;
["PgCatalog.Types.PgLanguageArray"]: Typecast
[10023]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadata"]: Typecast
[10022]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadataArray"]: Typecast
[10025]: Typecast;
["PgCatalog.Types.PgLargeobject"]: Typecast
[10024]: Typecast;
["PgCatalog.Types.PgLargeobjectArray"]: Typecast
[10027]: Typecast;
["PgCatalog.Types.PgAggregate"]: Typecast
[10026]: Typecast;
["PgCatalog.Types.PgAggregateArray"]: Typecast
[10029]: Typecast;
["PgCatalog.Types.PgStatistic"]: Typecast
[10028]: Typecast;
["PgCatalog.Types.PgStatisticArray"]: Typecast
[10031]: Typecast;
["PgCatalog.Types.PgStatisticExt"]: Typecast
[10030]: Typecast;
["PgCatalog.Types.PgStatisticExtArray"]: Typecast
[10033]: Typecast;
["PgCatalog.Types.PgStatisticExtData"]: Typecast
[10032]: Typecast;
["PgCatalog.Types.PgStatisticExtDataArray"]: Typecast
[10035]: Typecast;
["PgCatalog.Types.PgRewrite"]: Typecast
[10034]: Typecast;
["PgCatalog.Types.PgRewriteArray"]: Typecast
[10037]: Typecast;
["PgCatalog.Types.PgTrigger"]: Typecast
[10036]: Typecast;
["PgCatalog.Types.PgTriggerArray"]: Typecast
[10039]: Typecast;
["PgCatalog.Types.PgEventTrigger"]: Typecast
[10038]: Typecast;
["PgCatalog.Types.PgEventTriggerArray"]: Typecast
[10041]: Typecast;
["PgCatalog.Types.PgDescription"]: Typecast
[10040]: Typecast;
["PgCatalog.Types.PgDescriptionArray"]: Typecast
[10043]: Typecast;
["PgCatalog.Types.PgCast"]: Typecast
[10042]: Typecast;
["PgCatalog.Types.PgCastArray"]: Typecast
[10045]: Typecast;
["PgCatalog.Types.PgEnum"]: Typecast
[10044]: Typecast;
["PgCatalog.Types.PgEnumArray"]: Typecast
[10047]: Typecast;
["PgCatalog.Types.PgNamespace"]: Typecast
[10046]: Typecast;
["PgCatalog.Types.PgNamespaceArray"]: Typecast
[10049]: Typecast;
["PgCatalog.Types.PgConversion"]: Typecast
[10048]: Typecast;
["PgCatalog.Types.PgConversionArray"]: Typecast
[10051]: Typecast;
["PgCatalog.Types.PgDepend"]: Typecast
[10050]: Typecast;
["PgCatalog.Types.PgDependArray"]: Typecast
[1248]: Typecast;
["PgCatalog.Types.PgDatabase"]: Typecast
[10052]: Typecast;
["PgCatalog.Types.PgDatabaseArray"]: Typecast
[10054]: Typecast;
["PgCatalog.Types.PgDbRoleSetting"]: Typecast
[10053]: Typecast;
["PgCatalog.Types.PgDbRoleSettingArray"]: Typecast
[10056]: Typecast;
["PgCatalog.Types.PgTablespace"]: Typecast
[10055]: Typecast;
["PgCatalog.Types.PgTablespaceArray"]: Typecast
[2842]: Typecast;
["PgCatalog.Types.PgAuthid"]: Typecast
[10057]: Typecast;
["PgCatalog.Types.PgAuthidArray"]: Typecast
[2843]: Typecast;
["PgCatalog.Types.PgAuthMembers"]: Typecast
[10058]: Typecast;
["PgCatalog.Types.PgAuthMembersArray"]: Typecast
[10060]: Typecast;
["PgCatalog.Types.PgShdepend"]: Typecast
[10059]: Typecast;
["PgCatalog.Types.PgShdependArray"]: Typecast
[10062]: Typecast;
["PgCatalog.Types.PgShdescription"]: Typecast
[10061]: Typecast;
["PgCatalog.Types.PgShdescriptionArray"]: Typecast
[10064]: Typecast;
["PgCatalog.Types.PgTsConfig"]: Typecast
[10063]: Typecast;
["PgCatalog.Types.PgTsConfigArray"]: Typecast
[10066]: Typecast;
["PgCatalog.Types.PgTsConfigMap"]: Typecast
[10065]: Typecast;
["PgCatalog.Types.PgTsConfigMapArray"]: Typecast
[10068]: Typecast;
["PgCatalog.Types.PgTsDict"]: Typecast
[10067]: Typecast;
["PgCatalog.Types.PgTsDictArray"]: Typecast
[10070]: Typecast;
["PgCatalog.Types.PgTsParser"]: Typecast
[10069]: Typecast;
["PgCatalog.Types.PgTsParserArray"]: Typecast
[10072]: Typecast;
["PgCatalog.Types.PgTsTemplate"]: Typecast
[10071]: Typecast;
["PgCatalog.Types.PgTsTemplateArray"]: Typecast
[10074]: Typecast;
["PgCatalog.Types.PgExtension"]: Typecast
[10073]: Typecast;
["PgCatalog.Types.PgExtensionArray"]: Typecast
[10076]: Typecast;
["PgCatalog.Types.PgForeignDataWrapper"]: Typecast
[10075]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperArray"]: Typecast
[10078]: Typecast;
["PgCatalog.Types.PgForeignServer"]: Typecast
[10077]: Typecast;
["PgCatalog.Types.PgForeignServerArray"]: Typecast
[10080]: Typecast;
["PgCatalog.Types.PgUserMapping"]: Typecast
[10079]: Typecast;
["PgCatalog.Types.PgUserMappingArray"]: Typecast
[10082]: Typecast;
["PgCatalog.Types.PgForeignTable"]: Typecast
[10081]: Typecast;
["PgCatalog.Types.PgForeignTableArray"]: Typecast
[10084]: Typecast;
["PgCatalog.Types.PgPolicy"]: Typecast
[10083]: Typecast;
["PgCatalog.Types.PgPolicyArray"]: Typecast
[10086]: Typecast;
["PgCatalog.Types.PgReplicationOrigin"]: Typecast
[10085]: Typecast;
["PgCatalog.Types.PgReplicationOriginArray"]: Typecast
[10088]: Typecast;
["PgCatalog.Types.PgDefaultAcl"]: Typecast
[10087]: Typecast;
["PgCatalog.Types.PgDefaultAclArray"]: Typecast
[10090]: Typecast;
["PgCatalog.Types.PgInitPrivs"]: Typecast
[10089]: Typecast;
["PgCatalog.Types.PgInitPrivsArray"]: Typecast
[10092]: Typecast;
["PgCatalog.Types.PgSeclabel"]: Typecast
[10091]: Typecast;
["PgCatalog.Types.PgSeclabelArray"]: Typecast
[4066]: Typecast;
["PgCatalog.Types.PgShseclabel"]: Typecast
[10093]: Typecast;
["PgCatalog.Types.PgShseclabelArray"]: Typecast
[10095]: Typecast;
["PgCatalog.Types.PgCollation"]: Typecast
[10094]: Typecast;
["PgCatalog.Types.PgCollationArray"]: Typecast
[10097]: Typecast;
["PgCatalog.Types.PgParameterAcl"]: Typecast
[10096]: Typecast;
["PgCatalog.Types.PgParameterAclArray"]: Typecast
[10099]: Typecast;
["PgCatalog.Types.PgPartitionedTable"]: Typecast
[10098]: Typecast;
["PgCatalog.Types.PgPartitionedTableArray"]: Typecast
[10101]: Typecast;
["PgCatalog.Types.PgRange"]: Typecast
[10100]: Typecast;
["PgCatalog.Types.PgRangeArray"]: Typecast
[10103]: Typecast;
["PgCatalog.Types.PgTransform"]: Typecast
[10102]: Typecast;
["PgCatalog.Types.PgTransformArray"]: Typecast
[10105]: Typecast;
["PgCatalog.Types.PgSequence"]: Typecast
[10104]: Typecast;
["PgCatalog.Types.PgSequenceArray"]: Typecast
[10107]: Typecast;
["PgCatalog.Types.PgPublication"]: Typecast
[10106]: Typecast;
["PgCatalog.Types.PgPublicationArray"]: Typecast
[10109]: Typecast;
["PgCatalog.Types.PgPublicationNamespace"]: Typecast
[10108]: Typecast;
["PgCatalog.Types.PgPublicationNamespaceArray"]: Typecast
[10111]: Typecast;
["PgCatalog.Types.PgPublicationRel"]: Typecast
[10110]: Typecast;
["PgCatalog.Types.PgPublicationRelArray"]: Typecast
[6101]: Typecast;
["PgCatalog.Types.PgSubscription"]: Typecast
[10112]: Typecast;
["PgCatalog.Types.PgSubscriptionArray"]: Typecast
[10114]: Typecast;
["PgCatalog.Types.PgSubscriptionRel"]: Typecast
[10113]: Typecast;
["PgCatalog.Types.PgSubscriptionRelArray"]: Typecast
[12002]: Typecast;
["PgCatalog.Types.PgRoles"]: Typecast
[12001]: Typecast;
["PgCatalog.Types.PgRolesArray"]: Typecast
[12007]: Typecast;
["PgCatalog.Types.PgShadow"]: Typecast
[12006]: Typecast;
["PgCatalog.Types.PgShadowArray"]: Typecast
[12012]: Typecast;
["PgCatalog.Types.PgGroup"]: Typecast
[12011]: Typecast;
["PgCatalog.Types.PgGroupArray"]: Typecast
[12016]: Typecast;
["PgCatalog.Types.PgUser"]: Typecast
[12015]: Typecast;
["PgCatalog.Types.PgUserArray"]: Typecast
[12020]: Typecast;
["PgCatalog.Types.PgPolicies"]: Typecast
[12019]: Typecast;
["PgCatalog.Types.PgPoliciesArray"]: Typecast
[12025]: Typecast;
["PgCatalog.Types.PgRules"]: Typecast
[12024]: Typecast;
["PgCatalog.Types.PgRulesArray"]: Typecast
[12030]: Typecast;
["PgCatalog.Types.PgViews"]: Typecast
[12029]: Typecast;
["PgCatalog.Types.PgViewsArray"]: Typecast
[12035]: Typecast;
["PgCatalog.Types.PgTables"]: Typecast
[12034]: Typecast;
["PgCatalog.Types.PgTablesArray"]: Typecast
[12040]: Typecast;
["PgCatalog.Types.PgMatviews"]: Typecast
[12039]: Typecast;
["PgCatalog.Types.PgMatviewsArray"]: Typecast
[12045]: Typecast;
["PgCatalog.Types.PgIndexes"]: Typecast
[12044]: Typecast;
["PgCatalog.Types.PgIndexesArray"]: Typecast
[12050]: Typecast;
["PgCatalog.Types.PgSequences"]: Typecast
[12049]: Typecast;
["PgCatalog.Types.PgSequencesArray"]: Typecast
[12055]: Typecast;
["PgCatalog.Types.PgStats"]: Typecast
[12054]: Typecast;
["PgCatalog.Types.PgStatsArray"]: Typecast
[12060]: Typecast;
["PgCatalog.Types.PgStatsExt"]: Typecast
[12059]: Typecast;
["PgCatalog.Types.PgStatsExtArray"]: Typecast
[12065]: Typecast;
["PgCatalog.Types.PgStatsExtExprs"]: Typecast
[12064]: Typecast;
["PgCatalog.Types.PgStatsExtExprsArray"]: Typecast
[12070]: Typecast;
["PgCatalog.Types.PgPublicationTables"]: Typecast
[12069]: Typecast;
["PgCatalog.Types.PgPublicationTablesArray"]: Typecast
[12075]: Typecast;
["PgCatalog.Types.PgLocks"]: Typecast
[12074]: Typecast;
["PgCatalog.Types.PgLocksArray"]: Typecast
[12079]: Typecast;
["PgCatalog.Types.PgCursors"]: Typecast
[12078]: Typecast;
["PgCatalog.Types.PgCursorsArray"]: Typecast
[12083]: Typecast;
["PgCatalog.Types.PgAvailableExtensions"]: Typecast
[12082]: Typecast;
["PgCatalog.Types.PgAvailableExtensionsArray"]: Typecast
[12087]: Typecast;
["PgCatalog.Types.PgAvailableExtensionVersions"]: Typecast
[12086]: Typecast;
["PgCatalog.Types.PgAvailableExtensionVersionsArray"]: Typecast
[12092]: Typecast;
["PgCatalog.Types.PgPreparedXacts"]: Typecast
[12091]: Typecast;
["PgCatalog.Types.PgPreparedXactsArray"]: Typecast
[12097]: Typecast;
["PgCatalog.Types.PgPreparedStatements"]: Typecast
[12096]: Typecast;
["PgCatalog.Types.PgPreparedStatementsArray"]: Typecast
[12101]: Typecast;
["PgCatalog.Types.PgSeclabels"]: Typecast
[12100]: Typecast;
["PgCatalog.Types.PgSeclabelsArray"]: Typecast
[12106]: Typecast;
["PgCatalog.Types.PgSettings"]: Typecast
[12105]: Typecast;
["PgCatalog.Types.PgSettingsArray"]: Typecast
[12112]: Typecast;
["PgCatalog.Types.PgFileSettings"]: Typecast
[12111]: Typecast;
["PgCatalog.Types.PgFileSettingsArray"]: Typecast
[12116]: Typecast;
["PgCatalog.Types.PgHbaFileRules"]: Typecast
[12115]: Typecast;
["PgCatalog.Types.PgHbaFileRulesArray"]: Typecast
[12120]: Typecast;
["PgCatalog.Types.PgIdentFileMappings"]: Typecast
[12119]: Typecast;
["PgCatalog.Types.PgIdentFileMappingsArray"]: Typecast
[12124]: Typecast;
["PgCatalog.Types.PgTimezoneAbbrevs"]: Typecast
[12123]: Typecast;
["PgCatalog.Types.PgTimezoneAbbrevsArray"]: Typecast
[12128]: Typecast;
["PgCatalog.Types.PgTimezoneNames"]: Typecast
[12127]: Typecast;
["PgCatalog.Types.PgTimezoneNamesArray"]: Typecast
[12132]: Typecast;
["PgCatalog.Types.PgConfig"]: Typecast
[12131]: Typecast;
["PgCatalog.Types.PgConfigArray"]: Typecast
[12136]: Typecast;
["PgCatalog.Types.PgShmemAllocations"]: Typecast
[12135]: Typecast;
["PgCatalog.Types.PgShmemAllocationsArray"]: Typecast
[12140]: Typecast;
["PgCatalog.Types.PgBackendMemoryContexts"]: Typecast
[12139]: Typecast;
["PgCatalog.Types.PgBackendMemoryContextsArray"]: Typecast
[12144]: Typecast;
["PgCatalog.Types.PgStatAllTables"]: Typecast
[12143]: Typecast;
["PgCatalog.Types.PgStatAllTablesArray"]: Typecast
[12149]: Typecast;
["PgCatalog.Types.PgStatXactAllTables"]: Typecast
[12148]: Typecast;
["PgCatalog.Types.PgStatXactAllTablesArray"]: Typecast
[12154]: Typecast;
["PgCatalog.Types.PgStatSysTables"]: Typecast
[12153]: Typecast;
["PgCatalog.Types.PgStatSysTablesArray"]: Typecast
[12159]: Typecast;
["PgCatalog.Types.PgStatXactSysTables"]: Typecast
[12158]: Typecast;
["PgCatalog.Types.PgStatXactSysTablesArray"]: Typecast
[12163]: Typecast;
["PgCatalog.Types.PgStatUserTables"]: Typecast
[12162]: Typecast;
["PgCatalog.Types.PgStatUserTablesArray"]: Typecast
[12168]: Typecast;
["PgCatalog.Types.PgStatXactUserTables"]: Typecast
[12167]: Typecast;
["PgCatalog.Types.PgStatXactUserTablesArray"]: Typecast
[12172]: Typecast;
["PgCatalog.Types.PgStatioAllTables"]: Typecast
[12171]: Typecast;
["PgCatalog.Types.PgStatioAllTablesArray"]: Typecast
[12177]: Typecast;
["PgCatalog.Types.PgStatioSysTables"]: Typecast
[12176]: Typecast;
["PgCatalog.Types.PgStatioSysTablesArray"]: Typecast
[12181]: Typecast;
["PgCatalog.Types.PgStatioUserTables"]: Typecast
[12180]: Typecast;
["PgCatalog.Types.PgStatioUserTablesArray"]: Typecast
[12185]: Typecast;
["PgCatalog.Types.PgStatAllIndexes"]: Typecast
[12184]: Typecast;
["PgCatalog.Types.PgStatAllIndexesArray"]: Typecast
[12190]: Typecast;
["PgCatalog.Types.PgStatSysIndexes"]: Typecast
[12189]: Typecast;
["PgCatalog.Types.PgStatSysIndexesArray"]: Typecast
[12194]: Typecast;
["PgCatalog.Types.PgStatUserIndexes"]: Typecast
[12193]: Typecast;
["PgCatalog.Types.PgStatUserIndexesArray"]: Typecast
[12198]: Typecast;
["PgCatalog.Types.PgStatioAllIndexes"]: Typecast
[12197]: Typecast;
["PgCatalog.Types.PgStatioAllIndexesArray"]: Typecast
[12203]: Typecast;
["PgCatalog.Types.PgStatioSysIndexes"]: Typecast
[12202]: Typecast;
["PgCatalog.Types.PgStatioSysIndexesArray"]: Typecast
[12207]: Typecast;
["PgCatalog.Types.PgStatioUserIndexes"]: Typecast
[12206]: Typecast;
["PgCatalog.Types.PgStatioUserIndexesArray"]: Typecast
[12211]: Typecast;
["PgCatalog.Types.PgStatioAllSequences"]: Typecast
[12210]: Typecast;
["PgCatalog.Types.PgStatioAllSequencesArray"]: Typecast
[12216]: Typecast;
["PgCatalog.Types.PgStatioSysSequences"]: Typecast
[12215]: Typecast;
["PgCatalog.Types.PgStatioSysSequencesArray"]: Typecast
[12220]: Typecast;
["PgCatalog.Types.PgStatioUserSequences"]: Typecast
[12219]: Typecast;
["PgCatalog.Types.PgStatioUserSequencesArray"]: Typecast
[12224]: Typecast;
["PgCatalog.Types.PgStatActivity"]: Typecast
[12223]: Typecast;
["PgCatalog.Types.PgStatActivityArray"]: Typecast
[12229]: Typecast;
["PgCatalog.Types.PgStatReplication"]: Typecast
[12228]: Typecast;
["PgCatalog.Types.PgStatReplicationArray"]: Typecast
[12234]: Typecast;
["PgCatalog.Types.PgStatSlru"]: Typecast
[12233]: Typecast;
["PgCatalog.Types.PgStatSlruArray"]: Typecast
[12238]: Typecast;
["PgCatalog.Types.PgStatWalReceiver"]: Typecast
[12237]: Typecast;
["PgCatalog.Types.PgStatWalReceiverArray"]: Typecast
[12242]: Typecast;
["PgCatalog.Types.PgStatRecoveryPrefetch"]: Typecast
[12241]: Typecast;
["PgCatalog.Types.PgStatRecoveryPrefetchArray"]: Typecast
[12246]: Typecast;
["PgCatalog.Types.PgStatSubscription"]: Typecast
[12245]: Typecast;
["PgCatalog.Types.PgStatSubscriptionArray"]: Typecast
[12251]: Typecast;
["PgCatalog.Types.PgStatSsl"]: Typecast
[12250]: Typecast;
["PgCatalog.Types.PgStatSslArray"]: Typecast
[12255]: Typecast;
["PgCatalog.Types.PgStatGssapi"]: Typecast
[12254]: Typecast;
["PgCatalog.Types.PgStatGssapiArray"]: Typecast
[12259]: Typecast;
["PgCatalog.Types.PgReplicationSlots"]: Typecast
[12258]: Typecast;
["PgCatalog.Types.PgReplicationSlotsArray"]: Typecast
[12264]: Typecast;
["PgCatalog.Types.PgStatReplicationSlots"]: Typecast
[12263]: Typecast;
["PgCatalog.Types.PgStatReplicationSlotsArray"]: Typecast
[12268]: Typecast;
["PgCatalog.Types.PgStatDatabase"]: Typecast
[12267]: Typecast;
["PgCatalog.Types.PgStatDatabaseArray"]: Typecast
[12273]: Typecast;
["PgCatalog.Types.PgStatDatabaseConflicts"]: Typecast
[12272]: Typecast;
["PgCatalog.Types.PgStatDatabaseConflictsArray"]: Typecast
[12277]: Typecast;
["PgCatalog.Types.PgStatUserFunctions"]: Typecast
[12276]: Typecast;
["PgCatalog.Types.PgStatUserFunctionsArray"]: Typecast
[12282]: Typecast;
["PgCatalog.Types.PgStatXactUserFunctions"]: Typecast
[12281]: Typecast;
["PgCatalog.Types.PgStatXactUserFunctionsArray"]: Typecast
[12287]: Typecast;
["PgCatalog.Types.PgStatArchiver"]: Typecast
[12286]: Typecast;
["PgCatalog.Types.PgStatArchiverArray"]: Typecast
[12291]: Typecast;
["PgCatalog.Types.PgStatBgwriter"]: Typecast
[12290]: Typecast;
["PgCatalog.Types.PgStatBgwriterArray"]: Typecast
[12295]: Typecast;
["PgCatalog.Types.PgStatIo"]: Typecast
[12294]: Typecast;
["PgCatalog.Types.PgStatIoArray"]: Typecast
[12299]: Typecast;
["PgCatalog.Types.PgStatWal"]: Typecast
[12298]: Typecast;
["PgCatalog.Types.PgStatWalArray"]: Typecast
[12303]: Typecast;
["PgCatalog.Types.PgStatProgressAnalyze"]: Typecast
[12302]: Typecast;
["PgCatalog.Types.PgStatProgressAnalyzeArray"]: Typecast
[12308]: Typecast;
["PgCatalog.Types.PgStatProgressVacuum"]: Typecast
[12307]: Typecast;
["PgCatalog.Types.PgStatProgressVacuumArray"]: Typecast
[12313]: Typecast;
["PgCatalog.Types.PgStatProgressCluster"]: Typecast
[12312]: Typecast;
["PgCatalog.Types.PgStatProgressClusterArray"]: Typecast
[12318]: Typecast;
["PgCatalog.Types.PgStatProgressCreateIndex"]: Typecast
[12317]: Typecast;
["PgCatalog.Types.PgStatProgressCreateIndexArray"]: Typecast
[12323]: Typecast;
["PgCatalog.Types.PgStatProgressBasebackup"]: Typecast
[12322]: Typecast;
["PgCatalog.Types.PgStatProgressBasebackupArray"]: Typecast
[12328]: Typecast;
["PgCatalog.Types.PgStatProgressCopy"]: Typecast
[12327]: Typecast;
["PgCatalog.Types.PgStatProgressCopyArray"]: Typecast
[12333]: Typecast;
["PgCatalog.Types.PgUserMappings"]: Typecast
[12332]: Typecast;
["PgCatalog.Types.PgUserMappingsArray"]: Typecast
[12338]: Typecast;
["PgCatalog.Types.PgReplicationOriginStatus"]: Typecast
[12337]: Typecast;
["PgCatalog.Types.PgReplicationOriginStatusArray"]: Typecast
[12342]: Typecast;
["PgCatalog.Types.PgStatSubscriptionStats"]: Typecast
[12341]: Typecast;
["PgCatalog.Types.PgStatSubscriptionStatsArray"]: Typecast
[2690]: Typecast;
["PgCatalog.Types.PgProcOidIndex"]: Typecast
[2691]: Typecast;
["PgCatalog.Types.PgProcPronameArgsNspIndex"]: Typecast
[2703]: Typecast;
["PgCatalog.Types.PgTypeOidIndex"]: Typecast
[2704]: Typecast;
["PgCatalog.Types.PgTypeTypnameNspIndex"]: Typecast
[2658]: Typecast;
["PgCatalog.Types.PgAttributeRelidAttnamIndex"]: Typecast
[2659]: Typecast;
["PgCatalog.Types.PgAttributeRelidAttnumIndex"]: Typecast
[2662]: Typecast;
["PgCatalog.Types.PgClassOidIndex"]: Typecast
[2663]: Typecast;
["PgCatalog.Types.PgClassRelnameNspIndex"]: Typecast
[3455]: Typecast;
["PgCatalog.Types.PgClassTblspcRelfilenodeIndex"]: Typecast
[2656]: Typecast;
["PgCatalog.Types.PgAttrdefAdrelidAdnumIndex"]: Typecast
[2657]: Typecast;
["PgCatalog.Types.PgAttrdefOidIndex"]: Typecast
[2664]: Typecast;
["PgCatalog.Types.PgConstraintConnameNspIndex"]: Typecast
[2665]: Typecast;
["PgCatalog.Types.PgConstraintConrelidContypidConnameIndex"]: Typecast
[2666]: Typecast;
["PgCatalog.Types.PgConstraintContypidIndex"]: Typecast
[2667]: Typecast;
["PgCatalog.Types.PgConstraintOidIndex"]: Typecast
[2579]: Typecast;
["PgCatalog.Types.PgConstraintConparentidIndex"]: Typecast
[2680]: Typecast;
["PgCatalog.Types.PgInheritsRelidSeqnoIndex"]: Typecast
[2187]: Typecast;
["PgCatalog.Types.PgInheritsParentIndex"]: Typecast
[2678]: Typecast;
["PgCatalog.Types.PgIndexIndrelidIndex"]: Typecast
[2679]: Typecast;
["PgCatalog.Types.PgIndexIndexrelidIndex"]: Typecast
[2688]: Typecast;
["PgCatalog.Types.PgOperatorOidIndex"]: Typecast
[2689]: Typecast;
["PgCatalog.Types.PgOperatorOprnameLRNIndex"]: Typecast
[2754]: Typecast;
["PgCatalog.Types.PgOpfamilyAmNameNspIndex"]: Typecast
[2755]: Typecast;
["PgCatalog.Types.PgOpfamilyOidIndex"]: Typecast
[2686]: Typecast;
["PgCatalog.Types.PgOpclassAmNameNspIndex"]: Typecast
[2687]: Typecast;
["PgCatalog.Types.PgOpclassOidIndex"]: Typecast
[2651]: Typecast;
["PgCatalog.Types.PgAmNameIndex"]: Typecast
[2652]: Typecast;
["PgCatalog.Types.PgAmOidIndex"]: Typecast
[2653]: Typecast;
["PgCatalog.Types.PgAmopFamStratIndex"]: Typecast
[2654]: Typecast;
["PgCatalog.Types.PgAmopOprFamIndex"]: Typecast
[2756]: Typecast;
["PgCatalog.Types.PgAmopOidIndex"]: Typecast
[2655]: Typecast;
["PgCatalog.Types.PgAmprocFamProcIndex"]: Typecast
[2757]: Typecast;
["PgCatalog.Types.PgAmprocOidIndex"]: Typecast
[2681]: Typecast;
["PgCatalog.Types.PgLanguageNameIndex"]: Typecast
[2682]: Typecast;
["PgCatalog.Types.PgLanguageOidIndex"]: Typecast
[2996]: Typecast;
["PgCatalog.Types.PgLargeobjectMetadataOidIndex"]: Typecast
[2683]: Typecast;
["PgCatalog.Types.PgLargeobjectLoidPnIndex"]: Typecast
[2650]: Typecast;
["PgCatalog.Types.PgAggregateFnoidIndex"]: Typecast
[2696]: Typecast;
["PgCatalog.Types.PgStatisticRelidAttInhIndex"]: Typecast
[3380]: Typecast;
["PgCatalog.Types.PgStatisticExtOidIndex"]: Typecast
[3997]: Typecast;
["PgCatalog.Types.PgStatisticExtNameIndex"]: Typecast
[3379]: Typecast;
["PgCatalog.Types.PgStatisticExtRelidIndex"]: Typecast
[3433]: Typecast;
["PgCatalog.Types.PgStatisticExtDataStxoidInhIndex"]: Typecast
[2692]: Typecast;
["PgCatalog.Types.PgRewriteOidIndex"]: Typecast
[2693]: Typecast;
["PgCatalog.Types.PgRewriteRelRulenameIndex"]: Typecast
[2699]: Typecast;
["PgCatalog.Types.PgTriggerTgconstraintIndex"]: Typecast
[2701]: Typecast;
["PgCatalog.Types.PgTriggerTgrelidTgnameIndex"]: Typecast
[2702]: Typecast;
["PgCatalog.Types.PgTriggerOidIndex"]: Typecast
[3467]: Typecast;
["PgCatalog.Types.PgEventTriggerEvtnameIndex"]: Typecast
[3468]: Typecast;
["PgCatalog.Types.PgEventTriggerOidIndex"]: Typecast
[2675]: Typecast;
["PgCatalog.Types.PgDescriptionOCOIndex"]: Typecast
[2660]: Typecast;
["PgCatalog.Types.PgCastOidIndex"]: Typecast
[2661]: Typecast;
["PgCatalog.Types.PgCastSourceTargetIndex"]: Typecast
[3502]: Typecast;
["PgCatalog.Types.PgEnumOidIndex"]: Typecast
[3503]: Typecast;
["PgCatalog.Types.PgEnumTypidLabelIndex"]: Typecast
[3534]: Typecast;
["PgCatalog.Types.PgEnumTypidSortorderIndex"]: Typecast
[2684]: Typecast;
["PgCatalog.Types.PgNamespaceNspnameIndex"]: Typecast
[2685]: Typecast;
["PgCatalog.Types.PgNamespaceOidIndex"]: Typecast
[2668]: Typecast;
["PgCatalog.Types.PgConversionDefaultIndex"]: Typecast
[2669]: Typecast;
["PgCatalog.Types.PgConversionNameNspIndex"]: Typecast
[2670]: Typecast;
["PgCatalog.Types.PgConversionOidIndex"]: Typecast
[2673]: Typecast;
["PgCatalog.Types.PgDependDependerIndex"]: Typecast
[2674]: Typecast;
["PgCatalog.Types.PgDependReferenceIndex"]: Typecast
[2671]: Typecast;
["PgCatalog.Types.PgDatabaseDatnameIndex"]: Typecast
[2672]: Typecast;
["PgCatalog.Types.PgDatabaseOidIndex"]: Typecast
[2965]: Typecast;
["PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex"]: Typecast
[2697]: Typecast;
["PgCatalog.Types.PgTablespaceOidIndex"]: Typecast
[2698]: Typecast;
["PgCatalog.Types.PgTablespaceSpcnameIndex"]: Typecast
[2676]: Typecast;
["PgCatalog.Types.PgAuthidRolnameIndex"]: Typecast
[2677]: Typecast;
["PgCatalog.Types.PgAuthidOidIndex"]: Typecast
[6303]: Typecast;
["PgCatalog.Types.PgAuthMembersOidIndex"]: Typecast
[2694]: Typecast;
["PgCatalog.Types.PgAuthMembersRoleMemberIndex"]: Typecast
[2695]: Typecast;
["PgCatalog.Types.PgAuthMembersMemberRoleIndex"]: Typecast
[6302]: Typecast;
["PgCatalog.Types.PgAuthMembersGrantorIndex"]: Typecast
[1232]: Typecast;
["PgCatalog.Types.PgShdependDependerIndex"]: Typecast
[1233]: Typecast;
["PgCatalog.Types.PgShdependReferenceIndex"]: Typecast
[2397]: Typecast;
["PgCatalog.Types.PgShdescriptionOCIndex"]: Typecast
[3608]: Typecast;
["PgCatalog.Types.PgTsConfigCfgnameIndex"]: Typecast
[3712]: Typecast;
["PgCatalog.Types.PgTsConfigOidIndex"]: Typecast
[3609]: Typecast;
["PgCatalog.Types.PgTsConfigMapIndex"]: Typecast
[3604]: Typecast;
["PgCatalog.Types.PgTsDictDictnameIndex"]: Typecast
[3605]: Typecast;
["PgCatalog.Types.PgTsDictOidIndex"]: Typecast
[3606]: Typecast;
["PgCatalog.Types.PgTsParserPrsnameIndex"]: Typecast
[3607]: Typecast;
["PgCatalog.Types.PgTsParserOidIndex"]: Typecast
[3766]: Typecast;
["PgCatalog.Types.PgTsTemplateTmplnameIndex"]: Typecast
[3767]: Typecast;
["PgCatalog.Types.PgTsTemplateOidIndex"]: Typecast
[3080]: Typecast;
["PgCatalog.Types.PgExtensionOidIndex"]: Typecast
[3081]: Typecast;
["PgCatalog.Types.PgExtensionNameIndex"]: Typecast
[112]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperOidIndex"]: Typecast
[548]: Typecast;
["PgCatalog.Types.PgForeignDataWrapperNameIndex"]: Typecast
[113]: Typecast;
["PgCatalog.Types.PgForeignServerOidIndex"]: Typecast
[549]: Typecast;
["PgCatalog.Types.PgForeignServerNameIndex"]: Typecast
[174]: Typecast;
["PgCatalog.Types.PgUserMappingOidIndex"]: Typecast
[175]: Typecast;
["PgCatalog.Types.PgUserMappingUserServerIndex"]: Typecast
[3119]: Typecast;
["PgCatalog.Types.PgForeignTableRelidIndex"]: Typecast
[3257]: Typecast;
["PgCatalog.Types.PgPolicyOidIndex"]: Typecast
[3258]: Typecast;
["PgCatalog.Types.PgPolicyPolrelidPolnameIndex"]: Typecast
[6001]: Typecast;
["PgCatalog.Types.PgReplicationOriginRoiidentIndex"]: Typecast
[6002]: Typecast;
["PgCatalog.Types.PgReplicationOriginRonameIndex"]: Typecast
[827]: Typecast;
["PgCatalog.Types.PgDefaultAclRoleNspObjIndex"]: Typecast
[828]: Typecast;
["PgCatalog.Types.PgDefaultAclOidIndex"]: Typecast
[3395]: Typecast;
["PgCatalog.Types.PgInitPrivsOCOIndex"]: Typecast
[3597]: Typecast;
["PgCatalog.Types.PgSeclabelObjectIndex"]: Typecast
[3593]: Typecast;
["PgCatalog.Types.PgShseclabelObjectIndex"]: Typecast
[3164]: Typecast;
["PgCatalog.Types.PgCollationNameEncNspIndex"]: Typecast
[3085]: Typecast;
["PgCatalog.Types.PgCollationOidIndex"]: Typecast
[6246]: Typecast;
["PgCatalog.Types.PgParameterAclParnameIndex"]: Typecast
[6247]: Typecast;
["PgCatalog.Types.PgParameterAclOidIndex"]: Typecast
[3351]: Typecast;
["PgCatalog.Types.PgPartitionedTablePartrelidIndex"]: Typecast
[3542]: Typecast;
["PgCatalog.Types.PgRangeRngtypidIndex"]: Typecast
[2228]: Typecast;
["PgCatalog.Types.PgRangeRngmultitypidIndex"]: Typecast
[3574]: Typecast;
["PgCatalog.Types.PgTransformOidIndex"]: Typecast
[3575]: Typecast;
["PgCatalog.Types.PgTransformTypeLangIndex"]: Typecast
[5002]: Typecast;
["PgCatalog.Types.PgSequenceSeqrelidIndex"]: Typecast
[6110]: Typecast;
["PgCatalog.Types.PgPublicationOidIndex"]: Typecast
[6111]: Typecast;
["PgCatalog.Types.PgPublicationPubnameIndex"]: Typecast
[6238]: Typecast;
["PgCatalog.Types.PgPublicationNamespaceOidIndex"]: Typecast
[6239]: Typecast;
["PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex"]: Typecast
[6112]: Typecast;
["PgCatalog.Types.PgPublicationRelOidIndex"]: Typecast
[6113]: Typecast;
["PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex"]: Typecast
[6116]: Typecast;
["PgCatalog.Types.PgPublicationRelPrpubidIndex"]: Typecast
[6114]: Typecast;
["PgCatalog.Types.PgSubscriptionOidIndex"]: Typecast
[6115]: Typecast;
["PgCatalog.Types.PgSubscriptionSubnameIndex"]: Typecast
[6117]: Typecast;
["PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex"]: Typecast
[13488]: Typecast;
["InformationSchema.Types.CardinalNumber"]: Typecast
[13487]: Typecast;
["InformationSchema.Types.CardinalNumberArray"]: Typecast
[13491]: Typecast;
["InformationSchema.Types.CharacterData"]: Typecast
[13490]: Typecast;
["InformationSchema.Types.CharacterDataArray"]: Typecast
[13493]: Typecast;
["InformationSchema.Types.SqlIdentifier"]: Typecast
[13492]: Typecast;
["InformationSchema.Types.SqlIdentifierArray"]: Typecast
[13496]: Typecast;
["InformationSchema.Types.InformationSchemaCatalogName"]: Typecast
[13495]: Typecast;
["InformationSchema.Types.InformationSchemaCatalogNameArray"]: Typecast
[13499]: Typecast;
["InformationSchema.Types.TimeStamp"]: Typecast
[13498]: Typecast;
["InformationSchema.Types.TimeStampArray"]: Typecast
[13501]: Typecast;
["InformationSchema.Types.YesOrNo"]: Typecast
[13500]: Typecast;
["InformationSchema.Types.YesOrNoArray"]: Typecast
[13505]: Typecast;
["InformationSchema.Types.ApplicableRoles"]: Typecast
[13504]: Typecast;
["InformationSchema.Types.ApplicableRolesArray"]: Typecast
[13510]: Typecast;
["InformationSchema.Types.AdministrableRoleAuthorizations"]: Typecast
[13509]: Typecast;
["InformationSchema.Types.AdministrableRoleAuthorizationsArray"]: Typecast
[13514]: Typecast;
["InformationSchema.Types.Attributes"]: Typecast
[13513]: Typecast;
["InformationSchema.Types.AttributesArray"]: Typecast
[13519]: Typecast;
["InformationSchema.Types.CharacterSets"]: Typecast
[13518]: Typecast;
["InformationSchema.Types.CharacterSetsArray"]: Typecast
[13524]: Typecast;
["InformationSchema.Types.CheckConstraintRoutineUsage"]: Typecast
[13523]: Typecast;
["InformationSchema.Types.CheckConstraintRoutineUsageArray"]: Typecast
[13529]: Typecast;
["InformationSchema.Types.CheckConstraints"]: Typecast
[13528]: Typecast;
["InformationSchema.Types.CheckConstraintsArray"]: Typecast
[13534]: Typecast;
["InformationSchema.Types.Collations"]: Typecast
[13533]: Typecast;
["InformationSchema.Types.CollationsArray"]: Typecast
[13539]: Typecast;
["InformationSchema.Types.CollationCharacterSetApplicability"]: Typecast
[13538]: Typecast;
["InformationSchema.Types.CollationCharacterSetApplicabilityArray"]: Typecast
[13544]: Typecast;
["InformationSchema.Types.ColumnColumnUsage"]: Typecast
[13543]: Typecast;
["InformationSchema.Types.ColumnColumnUsageArray"]: Typecast
[13549]: Typecast;
["InformationSchema.Types.ColumnDomainUsage"]: Typecast
[13548]: Typecast;
["InformationSchema.Types.ColumnDomainUsageArray"]: Typecast
[13554]: Typecast;
["InformationSchema.Types.ColumnPrivileges"]: Typecast
[13553]: Typecast;
["InformationSchema.Types.ColumnPrivilegesArray"]: Typecast
[13559]: Typecast;
["InformationSchema.Types.ColumnUdtUsage"]: Typecast
[13558]: Typecast;
["InformationSchema.Types.ColumnUdtUsageArray"]: Typecast
[13564]: Typecast;
["InformationSchema.Types.Columns"]: Typecast
[13563]: Typecast;
["InformationSchema.Types.ColumnsArray"]: Typecast
[13569]: Typecast;
["InformationSchema.Types.ConstraintColumnUsage"]: Typecast
[13568]: Typecast;
["InformationSchema.Types.ConstraintColumnUsageArray"]: Typecast
[13574]: Typecast;
["InformationSchema.Types.ConstraintTableUsage"]: Typecast
[13573]: Typecast;
["InformationSchema.Types.ConstraintTableUsageArray"]: Typecast
[13579]: Typecast;
["InformationSchema.Types.DomainConstraints"]: Typecast
[13578]: Typecast;
["InformationSchema.Types.DomainConstraintsArray"]: Typecast
[13584]: Typecast;
["InformationSchema.Types.DomainUdtUsage"]: Typecast
[13583]: Typecast;
["InformationSchema.Types.DomainUdtUsageArray"]: Typecast
[13589]: Typecast;
["InformationSchema.Types.Domains"]: Typecast
[13588]: Typecast;
["InformationSchema.Types.DomainsArray"]: Typecast
[13594]: Typecast;
["InformationSchema.Types.EnabledRoles"]: Typecast
[13593]: Typecast;
["InformationSchema.Types.EnabledRolesArray"]: Typecast
[13598]: Typecast;
["InformationSchema.Types.KeyColumnUsage"]: Typecast
[13597]: Typecast;
["InformationSchema.Types.KeyColumnUsageArray"]: Typecast
[13603]: Typecast;
["InformationSchema.Types.Parameters"]: Typecast
[13602]: Typecast;
["InformationSchema.Types.ParametersArray"]: Typecast
[13608]: Typecast;
["InformationSchema.Types.ReferentialConstraints"]: Typecast
[13607]: Typecast;
["InformationSchema.Types.ReferentialConstraintsArray"]: Typecast
[13613]: Typecast;
["InformationSchema.Types.RoleColumnGrants"]: Typecast
[13612]: Typecast;
["InformationSchema.Types.RoleColumnGrantsArray"]: Typecast
[13617]: Typecast;
["InformationSchema.Types.RoutineColumnUsage"]: Typecast
[13616]: Typecast;
["InformationSchema.Types.RoutineColumnUsageArray"]: Typecast
[13622]: Typecast;
["InformationSchema.Types.RoutinePrivileges"]: Typecast
[13621]: Typecast;
["InformationSchema.Types.RoutinePrivilegesArray"]: Typecast
[13627]: Typecast;
["InformationSchema.Types.RoleRoutineGrants"]: Typecast
[13626]: Typecast;
["InformationSchema.Types.RoleRoutineGrantsArray"]: Typecast
[13631]: Typecast;
["InformationSchema.Types.RoutineRoutineUsage"]: Typecast
[13630]: Typecast;
["InformationSchema.Types.RoutineRoutineUsageArray"]: Typecast
[13636]: Typecast;
["InformationSchema.Types.RoutineSequenceUsage"]: Typecast
[13635]: Typecast;
["InformationSchema.Types.RoutineSequenceUsageArray"]: Typecast
[13641]: Typecast;
["InformationSchema.Types.RoutineTableUsage"]: Typecast
[13640]: Typecast;
["InformationSchema.Types.RoutineTableUsageArray"]: Typecast
[13646]: Typecast;
["InformationSchema.Types.Routines"]: Typecast
[13645]: Typecast;
["InformationSchema.Types.RoutinesArray"]: Typecast
[13651]: Typecast;
["InformationSchema.Types.Schemata"]: Typecast
[13650]: Typecast;
["InformationSchema.Types.SchemataArray"]: Typecast
[13655]: Typecast;
["InformationSchema.Types.Sequences"]: Typecast
[13654]: Typecast;
["InformationSchema.Types.SequencesArray"]: Typecast
[13660]: Typecast;
["InformationSchema.Types.SqlFeatures"]: Typecast
[13659]: Typecast;
["InformationSchema.Types.SqlFeaturesArray"]: Typecast
[13665]: Typecast;
["InformationSchema.Types.SqlImplementationInfo"]: Typecast
[13664]: Typecast;
["InformationSchema.Types.SqlImplementationInfoArray"]: Typecast
[13670]: Typecast;
["InformationSchema.Types.SqlParts"]: Typecast
[13669]: Typecast;
["InformationSchema.Types.SqlPartsArray"]: Typecast
[13675]: Typecast;
["InformationSchema.Types.SqlSizing"]: Typecast
[13674]: Typecast;
["InformationSchema.Types.SqlSizingArray"]: Typecast
[13680]: Typecast;
["InformationSchema.Types.TableConstraints"]: Typecast
[13679]: Typecast;
["InformationSchema.Types.TableConstraintsArray"]: Typecast
[13685]: Typecast;
["InformationSchema.Types.TablePrivileges"]: Typecast
[13684]: Typecast;
["InformationSchema.Types.TablePrivilegesArray"]: Typecast
[13690]: Typecast;
["InformationSchema.Types.RoleTableGrants"]: Typecast
[13689]: Typecast;
["InformationSchema.Types.RoleTableGrantsArray"]: Typecast
[13694]: Typecast;
["InformationSchema.Types.Tables"]: Typecast
[13693]: Typecast;
["InformationSchema.Types.TablesArray"]: Typecast
[13699]: Typecast;
["InformationSchema.Types.Transforms"]: Typecast
[13698]: Typecast;
["InformationSchema.Types.TransformsArray"]: Typecast
[13704]: Typecast;
["InformationSchema.Types.TriggeredUpdateColumns"]: Typecast
[13703]: Typecast;
["InformationSchema.Types.TriggeredUpdateColumnsArray"]: Typecast
[13709]: Typecast;
["InformationSchema.Types.Triggers"]: Typecast
[13708]: Typecast;
["InformationSchema.Types.TriggersArray"]: Typecast
[13714]: Typecast;
["InformationSchema.Types.UdtPrivileges"]: Typecast
[13713]: Typecast;
["InformationSchema.Types.UdtPrivilegesArray"]: Typecast
[13719]: Typecast;
["InformationSchema.Types.RoleUdtGrants"]: Typecast
[13718]: Typecast;
["InformationSchema.Types.RoleUdtGrantsArray"]: Typecast
[13723]: Typecast;
["InformationSchema.Types.UsagePrivileges"]: Typecast
[13722]: Typecast;
["InformationSchema.Types.UsagePrivilegesArray"]: Typecast
[13728]: Typecast;
["InformationSchema.Types.RoleUsageGrants"]: Typecast
[13727]: Typecast;
["InformationSchema.Types.RoleUsageGrantsArray"]: Typecast
[13732]: Typecast;
["InformationSchema.Types.UserDefinedTypes"]: Typecast
[13731]: Typecast;
["InformationSchema.Types.UserDefinedTypesArray"]: Typecast
[13737]: Typecast;
["InformationSchema.Types.ViewColumnUsage"]: Typecast
[13736]: Typecast;
["InformationSchema.Types.ViewColumnUsageArray"]: Typecast
[13742]: Typecast;
["InformationSchema.Types.ViewRoutineUsage"]: Typecast
[13741]: Typecast;
["InformationSchema.Types.ViewRoutineUsageArray"]: Typecast
[13747]: Typecast;
["InformationSchema.Types.ViewTableUsage"]: Typecast
[13746]: Typecast;
["InformationSchema.Types.ViewTableUsageArray"]: Typecast
[13752]: Typecast;
["InformationSchema.Types.Views"]: Typecast
[13751]: Typecast;
["InformationSchema.Types.ViewsArray"]: Typecast
[13757]: Typecast;
["InformationSchema.Types.DataTypePrivileges"]: Typecast
[13756]: Typecast;
["InformationSchema.Types.DataTypePrivilegesArray"]: Typecast
[13762]: Typecast;
["InformationSchema.Types.ElementTypes"]: Typecast
[13761]: Typecast;
["InformationSchema.Types.ElementTypesArray"]: Typecast
[13767]: Typecast;
["InformationSchema.Types.PgForeignTableColumns"]: Typecast
[13772]: Typecast;
["InformationSchema.Types.ColumnOptions"]: Typecast
[13771]: Typecast;
["InformationSchema.Types.ColumnOptionsArray"]: Typecast
[13776]: Typecast;
["InformationSchema.Types.PgForeignDataWrappers"]: Typecast
[13780]: Typecast;
["InformationSchema.Types.ForeignDataWrapperOptions"]: Typecast
[13779]: Typecast;
["InformationSchema.Types.ForeignDataWrapperOptionsArray"]: Typecast
[13784]: Typecast;
["InformationSchema.Types.ForeignDataWrappers"]: Typecast
[13783]: Typecast;
["InformationSchema.Types.ForeignDataWrappersArray"]: Typecast
[13788]: Typecast;
["InformationSchema.Types.PgForeignServers"]: Typecast
[13793]: Typecast;
["InformationSchema.Types.ForeignServerOptions"]: Typecast
[13792]: Typecast;
["InformationSchema.Types.ForeignServerOptionsArray"]: Typecast
[13797]: Typecast;
["InformationSchema.Types.ForeignServers"]: Typecast
[13796]: Typecast;
["InformationSchema.Types.ForeignServersArray"]: Typecast
[13801]: Typecast;
["InformationSchema.Types.PgForeignTables"]: Typecast
[13806]: Typecast;
["InformationSchema.Types.ForeignTableOptions"]: Typecast
[13805]: Typecast;
["InformationSchema.Types.ForeignTableOptionsArray"]: Typecast
[13810]: Typecast;
["InformationSchema.Types.ForeignTables"]: Typecast
[13809]: Typecast;
["InformationSchema.Types.ForeignTablesArray"]: Typecast
[13814]: Typecast;
["InformationSchema.Types.PgUserMappings"]: Typecast
[13819]: Typecast;
["InformationSchema.Types.UserMappingOptions"]: Typecast
[13818]: Typecast;
["InformationSchema.Types.UserMappingOptionsArray"]: Typecast
[13824]: Typecast;
["InformationSchema.Types.UserMappings"]: Typecast
[13823]: Typecast;
["InformationSchema.Types.UserMappingsArray"]: Typecast
[47254]: Typecast;
["Public.Types.Spheroid"]: Typecast
[47257]: Typecast;
["Public.Types.SpheroidArray"]: Typecast
[47258]: Typecast;
["Public.Types.Geometry"]: Typecast
[47266]: Typecast;
["Public.Types.GeometryArray"]: Typecast
[47285]: Typecast;
["Public.Types.Box3d"]: Typecast
[47288]: Typecast;
["Public.Types.Box3dArray"]: Typecast
[47289]: Typecast;
["Public.Types.Box2d"]: Typecast
[47292]: Typecast;
["Public.Types.Box2dArray"]: Typecast
[47293]: Typecast;
["Public.Types.Box2df"]: Typecast
[47296]: Typecast;
["Public.Types.Box2dfArray"]: Typecast
[47297]: Typecast;
["Public.Types.Gidx"]: Typecast
[47300]: Typecast;
["Public.Types.GidxArray"]: Typecast
[47565]: Typecast;
["Public.Types.GeometryDump"]: Typecast
[47564]: Typecast;
["Public.Types.GeometryDumpArray"]: Typecast
[47572]: Typecast;
["Public.Types.SpatialRefSys"]: Typecast
[47571]: Typecast;
["Public.Types.SpatialRefSysArray"]: Typecast
[47687]: Typecast;
["Public.Types.ValidDetail"]: Typecast
[47686]: Typecast;
["Public.Types.ValidDetailArray"]: Typecast
[47964]: Typecast;
["Public.Types.Geography"]: Typecast
[47970]: Typecast;
["Public.Types.GeographyArray"]: Typecast
[47988]: Typecast;
["Public.Types.GeographyColumns"]: Typecast
[47987]: Typecast;
["Public.Types.GeographyColumnsArray"]: Typecast
[48137]: Typecast;
["Public.Types.GeometryColumns"]: Typecast
[48136]: Typecast;
["Public.Types.GeometryColumnsArray"]: Typecast
[48330]: Typecast;
["Public.Types.NycCensusBlocks"]: Typecast
[48329]: Typecast;
["Public.Types.NycCensusBlocksArray"]: Typecast
[48336]: Typecast;
["Public.Types.NycHomicides"]: Typecast
[48335]: Typecast;
["Public.Types.NycHomicidesArray"]: Typecast
[48342]: Typecast;
["Public.Types.NycNeighborhoods"]: Typecast
[48341]: Typecast;
["Public.Types.NycNeighborhoodsArray"]: Typecast
[48348]: Typecast;
["Public.Types.NycStreets"]: Typecast
[48347]: Typecast;
["Public.Types.NycStreetsArray"]: Typecast
[48354]: Typecast;
["Public.Types.NycSubwayStations"]: Typecast
[48353]: Typecast;
["Public.Types.NycSubwayStationsArray"]: Typecast
[47576]: Typecast;
["Public.Types.SpatialRefSysPkey"]: Typecast
[48410]: Typecast;
["Public.Types.NycCensusBlocksPkey"]: Typecast
[48412]: Typecast;
["Public.Types.NycHomicidesPkey"]: Typecast
[48414]: Typecast;
["Public.Types.NycNeighborhoodsPkey"]: Typecast
[48416]: Typecast;
["Public.Types.NycStreetsPkey"]: Typecast
[48418]: Typecast;
["Public.Types.NycSubwayStationsPkey"]: Typecast
[48420]: Typecast;
["Public.Types.NycCensusBlocksGeomIdx"]: Typecast
[48421]: Typecast;
["Public.Types.NycHomicidesGeomIdx"]: Typecast
[48422]: Typecast;
["Public.Types.NycNeighborhoodsGeomIdx"]: Typecast
[48423]: Typecast;
["Public.Types.NycStreetsGeomIdx"]: Typecast
[48424]: Typecast;
["Public.Types.NycSubwayStationsGeomIdx"]: Typecast
[47600]: Typecast;
["Public.Types.PostgisSrs"]: Typecast
[47601]: Typecast;
["Public.Types.PostgisSrsAll"]: Typecast
[47602]: Typecast;
["Public.Types.PostgisSrsSearch"]: Typecast
[47676]: Typecast;
["Public.Types.StMinimumboundingradius"]: Typecast
[47694]: Typecast;
["Public.Types.StMaximuminscribedcircle"]: Typecast
[47695]: Typecast;
["Public.Types.StLargestemptycircle"]: Typecast
[48165]: Typecast;
["Public.Types.StHexagongrid"]: Typecast
[48166]: Typecast;
["Public.Types.StSquaregrid"]: Typecast

["Public.Procedures.StForcepolygoncw.Parameters"]: Typecast

["Public.Procedures.SpheroidIn.Parameters"]: Typecast

["Public.Procedures.SpheroidOut.Parameters"]: Typecast

["Public.Procedures.GeometryIn.Parameters"]: Typecast

["Public.Procedures.GeometryOut.Parameters"]: Typecast

["Public.Procedures.GeometryTypmodIn.Parameters"]: Typecast

["Public.Procedures.GeometryTypmodOut.Parameters"]: Typecast

["Public.Procedures.GeometryAnalyze.Parameters"]: Typecast

["Public.Procedures.GeometryRecv.Parameters"]: Typecast

["Public.Procedures.GeometrySend.Parameters"]: Typecast

["Public.Procedures.Geometry_6564.Parameters"]: Typecast

["Public.Procedures.Geometry_8997.Parameters"]: Typecast

["Public.Procedures.Point.Parameters"]: Typecast

["Public.Procedures.GeometryB0d8.Parameters"]: Typecast

["Public.Procedures.Path.Parameters"]: Typecast

["Public.Procedures.GeometryF1be.Parameters"]: Typecast

["Public.Procedures.Polygon.Parameters"]: Typecast

["Public.Procedures.StX.Parameters"]: Typecast

["Public.Procedures.StY.Parameters"]: Typecast

["Public.Procedures.StZ.Parameters"]: Typecast

["Public.Procedures.StM.Parameters"]: Typecast

["Public.Procedures.Box3dIn.Parameters"]: Typecast

["Public.Procedures.Box3dOut.Parameters"]: Typecast

["Public.Procedures.Box2dIn.Parameters"]: Typecast

["Public.Procedures.Box2dOut.Parameters"]: Typecast

["Public.Procedures.Box2dfIn.Parameters"]: Typecast

["Public.Procedures.Box2dfOut.Parameters"]: Typecast

["Public.Procedures.GidxIn.Parameters"]: Typecast

["Public.Procedures.GidxOut.Parameters"]: Typecast

["Public.Procedures.GeometryLt.Parameters"]: Typecast

["Public.Procedures.GeometryLe.Parameters"]: Typecast

["Public.Procedures.GeometryGt.Parameters"]: Typecast

["Public.Procedures.GeometryGe.Parameters"]: Typecast

["Public.Procedures.GeometryEq.Parameters"]: Typecast

["Public.Procedures.GeometryCmp.Parameters"]: Typecast

["Public.Procedures.GeometrySortsupport.Parameters"]: Typecast

["Public.Procedures.GeometryHash.Parameters"]: Typecast

["Public.Procedures.GeometryGistDistance_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistCompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistPenalty_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistPicksplit_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistUnion_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistSame_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistDecompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryGistSortsupport_2d.Parameters"]: Typecast

["Public.Procedures.StForcerhr.Parameters"]: Typecast

["Public.Procedures.PostgisNoop.Parameters"]: Typecast

["Public.Procedures.StForcepolygonccw.Parameters"]: Typecast

["Public.Procedures.GserializedGistSel_2d.Parameters"]: Typecast

["Public.Procedures.GserializedGistSelNd.Parameters"]: Typecast

["Public.Procedures.GserializedGistJoinsel_2d.Parameters"]: Typecast

["Public.Procedures.GserializedGistJoinselNd.Parameters"]: Typecast

["Public.Procedures.GeometryOverlaps.Parameters"]: Typecast

["Public.Procedures.GeometrySame.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCentroid.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceBox.Parameters"]: Typecast

["Public.Procedures.GeometryContains.Parameters"]: Typecast

["Public.Procedures.GeometryWithin.Parameters"]: Typecast

["Public.Procedures.GeometryLeft.Parameters"]: Typecast

["Public.Procedures.GeometryOverleft.Parameters"]: Typecast

["Public.Procedures.GeometryBelow.Parameters"]: Typecast

["Public.Procedures.GeometryOverbelow.Parameters"]: Typecast

["Public.Procedures.GeometryOverright.Parameters"]: Typecast

["Public.Procedures.GeometryRight.Parameters"]: Typecast

["Public.Procedures.GeometryOverabove.Parameters"]: Typecast

["Public.Procedures.GeometryAbove.Parameters"]: Typecast

["Public.Procedures.GeometryGistConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistCompressNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistPenaltyNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistUnionNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistSameNd.Parameters"]: Typecast

["Public.Procedures.GeometryGistDecompressNd.Parameters"]: Typecast

["Public.Procedures.GeometryOverlapsNd.Parameters"]: Typecast

["Public.Procedures.GeometryContainsNd.Parameters"]: Typecast

["Public.Procedures.GeometryWithinNd.Parameters"]: Typecast

["Public.Procedures.GeometrySameNd.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCentroidNd.Parameters"]: Typecast

["Public.Procedures.GeometryDistanceCpa.Parameters"]: Typecast

["Public.Procedures.GeometryGistDistanceNd.Parameters"]: Typecast

["Public.Procedures.StShiftlongitude.Parameters"]: Typecast

["Public.Procedures.StWrapx.Parameters"]: Typecast

["Public.Procedures.StXmin.Parameters"]: Typecast

["Public.Procedures.StYmin.Parameters"]: Typecast

["Public.Procedures.StZmin.Parameters"]: Typecast

["Public.Procedures.StXmax.Parameters"]: Typecast

["Public.Procedures.StYmax.Parameters"]: Typecast

["Public.Procedures.StZmax.Parameters"]: Typecast

["Public.Procedures.StExpand_269a.Parameters"]: Typecast

["Public.Procedures.StExpand_96e3.Parameters"]: Typecast

["Public.Procedures.PostgisGetbbox.Parameters"]: Typecast

["Public.Procedures.StMakebox2d.Parameters"]: Typecast

["Public.Procedures.StEstimatedextentD2f5.Parameters"]: Typecast

["Public.Procedures.StEstimatedextent_27e1.Parameters"]: Typecast

["Public.Procedures.StEstimatedextent_2ec2.Parameters"]: Typecast

["Public.Procedures.StFindextent_27e1.Parameters"]: Typecast

["Public.Procedures.StFindextent_2ec2.Parameters"]: Typecast

["Public.Procedures.PostgisAddbbox.Parameters"]: Typecast

["Public.Procedures.PostgisDropbbox.Parameters"]: Typecast

["Public.Procedures.PostgisHasbbox.Parameters"]: Typecast

["Public.Procedures.StQuantizecoordinates.Parameters"]: Typecast

["Public.Procedures.StMemsize.Parameters"]: Typecast

["Public.Procedures.StSummary_0cdb.Parameters"]: Typecast

["Public.Procedures.StNpoints.Parameters"]: Typecast

["Public.Procedures.StNrings.Parameters"]: Typecast

["Public.Procedures.St_3dlength.Parameters"]: Typecast

["Public.Procedures.StLength2d.Parameters"]: Typecast

["Public.Procedures.StLength_0cdb.Parameters"]: Typecast

["Public.Procedures.StLengthspheroid.Parameters"]: Typecast

["Public.Procedures.StLength2dspheroid.Parameters"]: Typecast

["Public.Procedures.St_3dperimeter.Parameters"]: Typecast

["Public.Procedures.StPerimeter2d.Parameters"]: Typecast

["Public.Procedures.StPerimeter_0cdb.Parameters"]: Typecast

["Public.Procedures.StArea2d.Parameters"]: Typecast

["Public.Procedures.StArea_0cdb.Parameters"]: Typecast

["Public.Procedures.StIspolygoncw.Parameters"]: Typecast

["Public.Procedures.StIspolygonccw.Parameters"]: Typecast

["Public.Procedures.StDistancespheroidCd56.Parameters"]: Typecast

["Public.Procedures.StDistancespheroid_3651.Parameters"]: Typecast

["Public.Procedures.StDistance_3651.Parameters"]: Typecast

["Public.Procedures.StPointinsidecircle.Parameters"]: Typecast

["Public.Procedures.StAzimuth_3651.Parameters"]: Typecast

["Public.Procedures.StProjectD5eb.Parameters"]: Typecast

["Public.Procedures.StProject_6961.Parameters"]: Typecast

["Public.Procedures.StAngleE1dd.Parameters"]: Typecast

["Public.Procedures.StLineextend.Parameters"]: Typecast

["Public.Procedures.StForce2d.Parameters"]: Typecast

["Public.Procedures.StForce3dz.Parameters"]: Typecast

["Public.Procedures.StForce3d.Parameters"]: Typecast

["Public.Procedures.StForce3dm.Parameters"]: Typecast

["Public.Procedures.StForce4d.Parameters"]: Typecast

["Public.Procedures.StForcecollection.Parameters"]: Typecast

["Public.Procedures.StCollectionextract_6cbe.Parameters"]: Typecast

["Public.Procedures.StCollectionextract_0cdb.Parameters"]: Typecast

["Public.Procedures.StCollectionhomogenize.Parameters"]: Typecast

["Public.Procedures.StMulti.Parameters"]: Typecast

["Public.Procedures.StForcecurve.Parameters"]: Typecast

["Public.Procedures.StForcesfs_0cdb.Parameters"]: Typecast

["Public.Procedures.StForcesfs_88bc.Parameters"]: Typecast

["Public.Procedures.StExpand_2074.Parameters"]: Typecast

["Public.Procedures.StExpand_704e.Parameters"]: Typecast

["Public.Procedures.StExpand_7163.Parameters"]: Typecast

["Public.Procedures.StExpand_5500.Parameters"]: Typecast

["Public.Procedures.StEnvelope.Parameters"]: Typecast

["Public.Procedures.StBoundingdiagonal.Parameters"]: Typecast

["Public.Procedures.StReverse.Parameters"]: Typecast

["Public.Procedures.StScroll.Parameters"]: Typecast

["Public.Procedures.PostgisGeosNoop.Parameters"]: Typecast

["Public.Procedures.StNormalize.Parameters"]: Typecast

["Public.Procedures.StZmflag.Parameters"]: Typecast

["Public.Procedures.StNdims.Parameters"]: Typecast

["Public.Procedures.StAsewkt_0cdb.Parameters"]: Typecast

["Public.Procedures.StAsewkt_6cbe.Parameters"]: Typecast

["Public.Procedures.StAstwkb_652e.Parameters"]: Typecast

["Public.Procedures.StAstwkbF3fd.Parameters"]: Typecast

["Public.Procedures.StAsewkb_0cdb.Parameters"]: Typecast

["Public.Procedures.StAshexewkb_0cdb.Parameters"]: Typecast

["Public.Procedures.StAshexewkb_88bc.Parameters"]: Typecast

["Public.Procedures.StAsewkb_88bc.Parameters"]: Typecast

["Public.Procedures.StAslatlontext.Parameters"]: Typecast

["Public.Procedures.Geomfromewkb.Parameters"]: Typecast

["Public.Procedures.StGeomfromewkb.Parameters"]: Typecast

["Public.Procedures.StGeomfromtwkb.Parameters"]: Typecast

["Public.Procedures.Geomfromewkt.Parameters"]: Typecast

["Public.Procedures.StGeomfromewkt.Parameters"]: Typecast

["Public.Procedures.StMakepoint_0aec.Parameters"]: Typecast

["Public.Procedures.StMakepoint_81ec.Parameters"]: Typecast

["Public.Procedures.StMakepoint_570b.Parameters"]: Typecast

["Public.Procedures.StMakepointm.Parameters"]: Typecast

["Public.Procedures.St_3dmakebox.Parameters"]: Typecast

["Public.Procedures.StMakelineA4b6.Parameters"]: Typecast

["Public.Procedures.StLinefrommultipoint.Parameters"]: Typecast

["Public.Procedures.StMakeline_3651.Parameters"]: Typecast

["Public.Procedures.StAddpoint_3651.Parameters"]: Typecast

["Public.Procedures.StScaleD5eb.Parameters"]: Typecast

["Public.Procedures.StAddpointAa17.Parameters"]: Typecast

["Public.Procedures.StRemovepoint.Parameters"]: Typecast

["Public.Procedures.StSetpoint.Parameters"]: Typecast

["Public.Procedures.StMakeenvelope.Parameters"]: Typecast

["Public.Procedures.StTileenvelope.Parameters"]: Typecast

["Public.Procedures.StMakepolygonE2e3.Parameters"]: Typecast

["Public.Procedures.StMakepolygon_0cdb.Parameters"]: Typecast

["Public.Procedures.StBuildarea.Parameters"]: Typecast

["Public.Procedures.StPolygonizeA4b6.Parameters"]: Typecast

["Public.Procedures.StClusterintersectingA4b6.Parameters"]: Typecast

["Public.Procedures.StClusterwithin_0e49.Parameters"]: Typecast

["Public.Procedures.StLinemerge_0cdb.Parameters"]: Typecast

["Public.Procedures.StLinemerge_4ba2.Parameters"]: Typecast

["Public.Procedures.StAffineE42d.Parameters"]: Typecast

["Public.Procedures.StAffine_1962.Parameters"]: Typecast

["Public.Procedures.StRotate_7163.Parameters"]: Typecast

["Public.Procedures.StRotate_8b9f.Parameters"]: Typecast

["Public.Procedures.StRotate_463e.Parameters"]: Typecast

["Public.Procedures.StRotatez.Parameters"]: Typecast

["Public.Procedures.StRotatex.Parameters"]: Typecast

["Public.Procedures.StRotatey.Parameters"]: Typecast

["Public.Procedures.StTranslate_8b9f.Parameters"]: Typecast

["Public.Procedures.StTranslateD5eb.Parameters"]: Typecast

["Public.Procedures.StScale_3651.Parameters"]: Typecast

["Public.Procedures.StScale_1bee.Parameters"]: Typecast

["Public.Procedures.StScale_8b9f.Parameters"]: Typecast

["Public.Procedures.StTransscale.Parameters"]: Typecast

["Public.Procedures.StDump.Parameters"]: Typecast

["Public.Procedures.StDumprings.Parameters"]: Typecast

["Public.Procedures.StDumppoints.Parameters"]: Typecast

["Public.Procedures.StDumpsegments.Parameters"]: Typecast

["Public.Procedures.PopulateGeometryColumns_23fc.Parameters"]: Typecast

["Public.Procedures.PopulateGeometryColumns_4174.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_8fbb.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_4617.Parameters"]: Typecast

["Public.Procedures.Addgeometrycolumn_093c.Parameters"]: Typecast

["Public.Procedures.Dropgeometrycolumn_0412.Parameters"]: Typecast

["Public.Procedures.Dropgeometrycolumn_2253.Parameters"]: Typecast

["Public.Procedures.DropgeometrycolumnF11a.Parameters"]: Typecast

["Public.Procedures.Dropgeometrytable_2253.Parameters"]: Typecast

["Public.Procedures.StSegmentize_7163.Parameters"]: Typecast

["Public.Procedures.DropgeometrytableF11a.Parameters"]: Typecast

["Public.Procedures.DropgeometrytableBfde.Parameters"]: Typecast

["Public.Procedures.UpdategeometrysridB2ee.Parameters"]: Typecast

["Public.Procedures.Updategeometrysrid_7b58.Parameters"]: Typecast

["Public.Procedures.Updategeometrysrid_11c8.Parameters"]: Typecast

["Public.Procedures.FindSrid.Parameters"]: Typecast

["Public.Procedures.GetProj4FromSrid.Parameters"]: Typecast

["Public.Procedures.StSetsrid_6cbe.Parameters"]: Typecast

["Public.Procedures.StSrid_0cdb.Parameters"]: Typecast

["Public.Procedures.PostgisTransformGeometry.Parameters"]: Typecast

["Public.Procedures.PostgisSrsCodes.Parameters"]: Typecast

["Public.Procedures.PostgisSrs.Parameters"]: Typecast

["Public.Procedures.PostgisSrsSearch.Parameters"]: Typecast

["Public.Procedures.StTransform_6cbe.Parameters"]: Typecast

["Public.Procedures.StTransform_88bc.Parameters"]: Typecast

["Public.Procedures.StTransform_655c.Parameters"]: Typecast

["Public.Procedures.StTransform_5016.Parameters"]: Typecast

["Public.Procedures.PostgisTransformPipelineGeometry.Parameters"]: Typecast

["Public.Procedures.StTransformpipeline.Parameters"]: Typecast

["Public.Procedures.StInversetransformpipeline.Parameters"]: Typecast

["Public.Procedures.PostgisExtensionsUpgrade.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoint_7163.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoints_8fda.Parameters"]: Typecast

["Public.Procedures.StLinesubstringD5eb.Parameters"]: Typecast

["Public.Procedures.StLinelocatepoint_3651.Parameters"]: Typecast

["Public.Procedures.StAddmeasure.Parameters"]: Typecast

["Public.Procedures.StClosestpointofapproach.Parameters"]: Typecast

["Public.Procedures.Box2d_0cdb.Parameters"]: Typecast

["Public.Procedures.Box3d_0cdb.Parameters"]: Typecast

["Public.Procedures.Box_0cdb.Parameters"]: Typecast

["Public.Procedures.Box2d_07e9.Parameters"]: Typecast

["Public.Procedures.Box3dE505.Parameters"]: Typecast

["Public.Procedures.Box_07e9.Parameters"]: Typecast

["Public.Procedures.Text.Parameters"]: Typecast

["Public.Procedures.Box3dtobox.Parameters"]: Typecast

["Public.Procedures.GeometryE505.Parameters"]: Typecast

["Public.Procedures.Geometry_07e9.Parameters"]: Typecast

["Public.Procedures.GeometryE728.Parameters"]: Typecast

["Public.Procedures.Geometry_2d19.Parameters"]: Typecast

["Public.Procedures.Bytea_0cdb.Parameters"]: Typecast

["Public.Procedures.StSimplify_7163.Parameters"]: Typecast

["Public.Procedures.StSimplify_8fda.Parameters"]: Typecast

["Public.Procedures.StSimplifyvw.Parameters"]: Typecast

["Public.Procedures.StSeteffectivearea.Parameters"]: Typecast

["Public.Procedures.StFilterbym.Parameters"]: Typecast

["Public.Procedures.StChaikinsmoothing.Parameters"]: Typecast

["Public.Procedures.StSnaptogrid_5500.Parameters"]: Typecast

["Public.Procedures.StSnaptogridD5eb.Parameters"]: Typecast

["Public.Procedures.StSnaptogrid_7163.Parameters"]: Typecast

["Public.Procedures.StSnaptogrid_7f2e.Parameters"]: Typecast

["Public.Procedures.StDistancecpa.Parameters"]: Typecast

["Public.Procedures.StCpawithin.Parameters"]: Typecast

["Public.Procedures.StIsvalidtrajectory.Parameters"]: Typecast

["Public.Procedures.StIntersection_6961.Parameters"]: Typecast

["Public.Procedures.StBufferBf44.Parameters"]: Typecast

["Public.Procedures.StBufferC33e.Parameters"]: Typecast

["Public.Procedures.StMinimumboundingradius.Parameters"]: Typecast

["Public.Procedures.StMinimumboundingcircle.Parameters"]: Typecast

["Public.Procedures.StOrientedenvelope.Parameters"]: Typecast

["Public.Procedures.StOffsetcurve.Parameters"]: Typecast

["Public.Procedures.StGeneratepoints_6cbe.Parameters"]: Typecast

["Public.Procedures.StGeneratepointsD341.Parameters"]: Typecast

["Public.Procedures.StConvexhull.Parameters"]: Typecast

["Public.Procedures.StSimplifypreservetopology.Parameters"]: Typecast

["Public.Procedures.StIsvalidreason_0cdb.Parameters"]: Typecast

["Public.Procedures.StIsvaliddetail.Parameters"]: Typecast

["Public.Procedures.StIsvalidreason_6cbe.Parameters"]: Typecast

["Public.Procedures.StIsvalid_6cbe.Parameters"]: Typecast

["Public.Procedures.StHausdorffdistance_3651.Parameters"]: Typecast

["Public.Procedures.StHausdorffdistance_6961.Parameters"]: Typecast

["Public.Procedures.StFrechetdistance.Parameters"]: Typecast

["Public.Procedures.StMaximuminscribedcircle.Parameters"]: Typecast

["Public.Procedures.StLargestemptycircle.Parameters"]: Typecast

["Public.Procedures.StDifference.Parameters"]: Typecast

["Public.Procedures.StBoundary.Parameters"]: Typecast

["Public.Procedures.StPoints.Parameters"]: Typecast

["Public.Procedures.StSymdifference.Parameters"]: Typecast

["Public.Procedures.StSymmetricdifference.Parameters"]: Typecast

["Public.Procedures.StUnion_3651.Parameters"]: Typecast

["Public.Procedures.StUnion_6961.Parameters"]: Typecast

["Public.Procedures.StUnaryunion.Parameters"]: Typecast

["Public.Procedures.StRemoverepeatedpoints.Parameters"]: Typecast

["Public.Procedures.StClipbybox2d.Parameters"]: Typecast

["Public.Procedures.StSubdivide.Parameters"]: Typecast

["Public.Procedures.StReduceprecision.Parameters"]: Typecast

["Public.Procedures.StMakevalid_0cdb.Parameters"]: Typecast

["Public.Procedures.StMakevalid_88bc.Parameters"]: Typecast

["Public.Procedures.StCleangeometry.Parameters"]: Typecast

["Public.Procedures.StSplit.Parameters"]: Typecast

["Public.Procedures.StSharedpaths.Parameters"]: Typecast

["Public.Procedures.StSnap.Parameters"]: Typecast

["Public.Procedures.StRelatematch.Parameters"]: Typecast

["Public.Procedures.StNode.Parameters"]: Typecast

["Public.Procedures.StDelaunaytriangles.Parameters"]: Typecast

["Public.Procedures.StTriangulatepolygon.Parameters"]: Typecast

["Public.Procedures.StVoronoipolygons.Parameters"]: Typecast

["Public.Procedures.StVoronoilines.Parameters"]: Typecast

["Public.Procedures.StCombinebbox_1ee2.Parameters"]: Typecast

["Public.Procedures.StCombinebbox_9d67.Parameters"]: Typecast

["Public.Procedures.StCombinebbox_1a7e.Parameters"]: Typecast

["Public.Procedures.StCollect_3651.Parameters"]: Typecast

["Public.Procedures.StCollectA4b6.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters"]: Typecast

["Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters"]: Typecast

["Public.Procedures.PgisGeometryCollectFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryMakelineFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters"]: Typecast

["Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters"]: Typecast

["Public.Procedures.StUnionA4b6.Parameters"]: Typecast

["Public.Procedures.StCoverageunionA4b6.Parameters"]: Typecast

["Public.Procedures.StRelate_3651.Parameters"]: Typecast

["Public.Procedures.StRelateAa17.Parameters"]: Typecast

["Public.Procedures.StRelateCaf9.Parameters"]: Typecast

["Public.Procedures.StDisjoint.Parameters"]: Typecast

["Public.Procedures.PostgisIndexSupportfn.Parameters"]: Typecast

["Public.Procedures.StLinecrossingdirection.Parameters"]: Typecast

["Public.Procedures.StDwithin_6961.Parameters"]: Typecast

["Public.Procedures.StTouches.Parameters"]: Typecast

["Public.Procedures.StIntersects_3651.Parameters"]: Typecast

["Public.Procedures.StCrosses.Parameters"]: Typecast

["Public.Procedures.StContains.Parameters"]: Typecast

["Public.Procedures.StContainsproperly.Parameters"]: Typecast

["Public.Procedures.StWithin.Parameters"]: Typecast

["Public.Procedures.StCovers_3651.Parameters"]: Typecast

["Public.Procedures.StCoveredby_3651.Parameters"]: Typecast

["Public.Procedures.StOverlaps.Parameters"]: Typecast

["Public.Procedures.StDfullywithin.Parameters"]: Typecast

["Public.Procedures.St_3ddwithin.Parameters"]: Typecast

["Public.Procedures.St_3ddfullywithin.Parameters"]: Typecast

["Public.Procedures.St_3dintersects.Parameters"]: Typecast

["Public.Procedures.StOrderingequals.Parameters"]: Typecast

["Public.Procedures.StEquals.Parameters"]: Typecast

["Public.Procedures.StIsvalid_0cdb.Parameters"]: Typecast

["Public.Procedures.StMinimumclearance.Parameters"]: Typecast

["Public.Procedures.StMinimumclearanceline.Parameters"]: Typecast

["Public.Procedures.StCentroid_0cdb.Parameters"]: Typecast

["Public.Procedures.StGeometricmedian.Parameters"]: Typecast

["Public.Procedures.StIsring.Parameters"]: Typecast

["Public.Procedures.StPointonsurface.Parameters"]: Typecast

["Public.Procedures.StIssimple.Parameters"]: Typecast

["Public.Procedures.StIscollection.Parameters"]: Typecast

["Public.Procedures.Equals.Parameters"]: Typecast

["Public.Procedures.StGeomfromgml_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromgmlE728.Parameters"]: Typecast

["Public.Procedures.StGmltosqlE728.Parameters"]: Typecast

["Public.Procedures.StGmltosql_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromkml.Parameters"]: Typecast

["Public.Procedures.StGeomfrommarc21.Parameters"]: Typecast

["Public.Procedures.StAsmarc21.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojsonE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojson_608f.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeojson_3c9d.Parameters"]: Typecast

["Public.Procedures.StLinefromencodedpolyline.Parameters"]: Typecast

["Public.Procedures.StAsencodedpolyline.Parameters"]: Typecast

["Public.Procedures.StAssvgD341.Parameters"]: Typecast

["Public.Procedures.StAsgmlD341.Parameters"]: Typecast

["Public.Procedures.StAsgml_32a0.Parameters"]: Typecast

["Public.Procedures.StAskmlCce7.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonD341.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonF2c6.Parameters"]: Typecast

["Public.Procedures.Json.Parameters"]: Typecast

["Public.Procedures.Jsonb.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_27f4.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfnF57f.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfn_92c1.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtTransfnF5be.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtCombinefn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtSerialfn.Parameters"]: Typecast

["Public.Procedures.PgisAsmvtDeserialfn.Parameters"]: Typecast

["Public.Procedures.StAsmvtgeom.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters"]: Typecast

["Public.Procedures.PgisAsgeobufFinalfn.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters"]: Typecast

["Public.Procedures.PgisAsflatgeobufFinalfn.Parameters"]: Typecast

["Public.Procedures.StFromflatgeobuftotable.Parameters"]: Typecast

["Public.Procedures.StFromflatgeobuf.Parameters"]: Typecast

["Public.Procedures.StGeohash_6cbe.Parameters"]: Typecast

["Public.Procedures.StBox2dfromgeohash.Parameters"]: Typecast

["Public.Procedures.StPointfromgeohash.Parameters"]: Typecast

["Public.Procedures.StGeomfromgeohash.Parameters"]: Typecast

["Public.Procedures.StNumpoints.Parameters"]: Typecast

["Public.Procedures.StNumgeometries.Parameters"]: Typecast

["Public.Procedures.StGeometryn.Parameters"]: Typecast

["Public.Procedures.StDimension.Parameters"]: Typecast

["Public.Procedures.StExteriorring.Parameters"]: Typecast

["Public.Procedures.StNuminteriorrings.Parameters"]: Typecast

["Public.Procedures.StNuminteriorring.Parameters"]: Typecast

["Public.Procedures.StInteriorringn.Parameters"]: Typecast

["Public.Procedures.Geometrytype_0cdb.Parameters"]: Typecast

["Public.Procedures.StGeometrytype.Parameters"]: Typecast

["Public.Procedures.StPointn.Parameters"]: Typecast

["Public.Procedures.StNumpatches.Parameters"]: Typecast

["Public.Procedures.StPatchn.Parameters"]: Typecast

["Public.Procedures.StStartpoint.Parameters"]: Typecast

["Public.Procedures.StEndpoint.Parameters"]: Typecast

["Public.Procedures.StIsclosed.Parameters"]: Typecast

["Public.Procedures.StIsempty.Parameters"]: Typecast

["Public.Procedures.StAsbinary_88bc.Parameters"]: Typecast

["Public.Procedures.StAsbinary_0cdb.Parameters"]: Typecast

["Public.Procedures.StAstext_0cdb.Parameters"]: Typecast

["Public.Procedures.StAstext_6cbe.Parameters"]: Typecast

["Public.Procedures.StGeometryfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeometryfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StWkttosql.Parameters"]: Typecast

["Public.Procedures.StPointfromtextE728.Parameters"]: Typecast

["Public.Procedures.StPointfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StLinefromtextE728.Parameters"]: Typecast

["Public.Procedures.StLinefromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolyfromtextE728.Parameters"]: Typecast

["Public.Procedures.StPolyfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolygonfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StPolygonfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMlinefromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMlinefromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultilinestringfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultilinestringfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpointfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpointfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultipointfromtext.Parameters"]: Typecast

["Public.Procedures.StMpolyfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMpolyfromtextE728.Parameters"]: Typecast

["Public.Procedures.StMultipolygonfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StMultipolygonfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromtext_27e2.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromtextE728.Parameters"]: Typecast

["Public.Procedures.StGeomfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StGeomfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StLinefromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StLinefromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StLinestringfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StLinestringfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StPolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StPolygonfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StPolygonfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMpointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMpointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultipointfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.GeographyAnalyze.Parameters"]: Typecast

["Public.Procedures.StMultipointfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultilinefromwkb.Parameters"]: Typecast

["Public.Procedures.StMlinefromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMlinefromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMpolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMpolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMultipolyfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StMultipolyfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromwkbD8af.Parameters"]: Typecast

["Public.Procedures.StGeomcollfromwkb_2d19.Parameters"]: Typecast

["Public.Procedures.StMaxdistance.Parameters"]: Typecast

["Public.Procedures.StClosestpoint_3651.Parameters"]: Typecast

["Public.Procedures.StShortestline_3651.Parameters"]: Typecast

["Public.Procedures.StLongestline.Parameters"]: Typecast

["Public.Procedures.StSwapordinates.Parameters"]: Typecast

["Public.Procedures.StFlipcoordinates.Parameters"]: Typecast

["Public.Procedures.StBdpolyfromtext.Parameters"]: Typecast

["Public.Procedures.StBdmpolyfromtext.Parameters"]: Typecast

["Public.Procedures.Unlockrows.Parameters"]: Typecast

["Public.Procedures.Geography_28e9.Parameters"]: Typecast

["Public.Procedures.Geography_2d19.Parameters"]: Typecast

["Public.Procedures.Bytea_7902.Parameters"]: Typecast

["Public.Procedures.StAstext_7902.Parameters"]: Typecast

["Public.Procedures.StAstext_3181.Parameters"]: Typecast

["Public.Procedures.LockrowE9aa.Parameters"]: Typecast

["Public.Procedures.Lockrow_02b4.Parameters"]: Typecast

["Public.Procedures.Lockrow_27e1.Parameters"]: Typecast

["Public.Procedures.Lockrow_9a8a.Parameters"]: Typecast

["Public.Procedures.Addauth.Parameters"]: Typecast

["Public.Procedures.Checkauth_27e1.Parameters"]: Typecast

["Public.Procedures.Checkauth_2ec2.Parameters"]: Typecast

["Public.Procedures.GeographyTypmodIn.Parameters"]: Typecast

["Public.Procedures.GeographyTypmodOut.Parameters"]: Typecast

["Public.Procedures.GeographyIn.Parameters"]: Typecast

["Public.Procedures.GeographyOut.Parameters"]: Typecast

["Public.Procedures.GeographyRecv.Parameters"]: Typecast

["Public.Procedures.GeographySend.Parameters"]: Typecast

["Public.Procedures.StAstextE728.Parameters"]: Typecast

["Public.Procedures.StGeographyfromtext.Parameters"]: Typecast

["Public.Procedures.StGeogfromtext.Parameters"]: Typecast

["Public.Procedures.StGeogfromwkb.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodDims.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodSrid.Parameters"]: Typecast

["Public.Procedures.PostgisTypmodType.Parameters"]: Typecast

["Public.Procedures.Geography_0cdb.Parameters"]: Typecast

["Public.Procedures.Geometry_7902.Parameters"]: Typecast

["Public.Procedures.GeographyGistConsistent.Parameters"]: Typecast

["Public.Procedures.GeographyGistCompress.Parameters"]: Typecast

["Public.Procedures.GeographyGistPenalty.Parameters"]: Typecast

["Public.Procedures.GeographyGistPicksplit.Parameters"]: Typecast

["Public.Procedures.GeographyGistUnion.Parameters"]: Typecast

["Public.Procedures.GeographyGistSame.Parameters"]: Typecast

["Public.Procedures.GeographyGistDecompress.Parameters"]: Typecast

["Public.Procedures.GeographyOverlaps.Parameters"]: Typecast

["Public.Procedures.GeographyDistanceKnn.Parameters"]: Typecast

["Public.Procedures.GeographyGistDistance.Parameters"]: Typecast

["Public.Procedures.OverlapsGeog_52a8.Parameters"]: Typecast

["Public.Procedures.OverlapsGeog_25ba.Parameters"]: Typecast

["Public.Procedures.OverlapsGeog_8fd3.Parameters"]: Typecast

["Public.Procedures.GeogBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.GeographyLt.Parameters"]: Typecast

["Public.Procedures.GeographyLe.Parameters"]: Typecast

["Public.Procedures.GeographyGt.Parameters"]: Typecast

["Public.Procedures.GeographyGe.Parameters"]: Typecast

["Public.Procedures.GeographyEq.Parameters"]: Typecast

["Public.Procedures.GeographyCmp.Parameters"]: Typecast

["Public.Procedures.StAssvg_6ec5.Parameters"]: Typecast

["Public.Procedures.StAssvgE728.Parameters"]: Typecast

["Public.Procedures.StProjectD4ec.Parameters"]: Typecast

["Public.Procedures.StAzimuthE452.Parameters"]: Typecast

["Public.Procedures.StBuffer_49f7.Parameters"]: Typecast

["Public.Procedures.StAsgmlE888.Parameters"]: Typecast

["Public.Procedures.StAsgml_2160.Parameters"]: Typecast

["Public.Procedures.StAsgmlE728.Parameters"]: Typecast

["Public.Procedures.StAskmlF40a.Parameters"]: Typecast

["Public.Procedures.StAskmlE728.Parameters"]: Typecast

["Public.Procedures.StAsgeojson_6ec5.Parameters"]: Typecast

["Public.Procedures.StAsgeojsonE728.Parameters"]: Typecast

["Public.Procedures.StDistance_8dcd.Parameters"]: Typecast

["Public.Procedures.StDistance_2ec2.Parameters"]: Typecast

["Public.Procedures.StAreaEcae.Parameters"]: Typecast

["Public.Procedures.StAreaE728.Parameters"]: Typecast

["Public.Procedures.StLengthEcae.Parameters"]: Typecast

["Public.Procedures.StLengthE728.Parameters"]: Typecast

["Public.Procedures.StProjectEd46.Parameters"]: Typecast

["Public.Procedures.StPerimeterEcae.Parameters"]: Typecast

["Public.Procedures.StSegmentizeCadf.Parameters"]: Typecast

["Public.Procedures.StAsbinary_7902.Parameters"]: Typecast

["Public.Procedures.StAsbinary_734d.Parameters"]: Typecast

["Public.Procedures.StAsewkt_7902.Parameters"]: Typecast

["Public.Procedures.StAsewkt_3181.Parameters"]: Typecast

["Public.Procedures.StAsewktE728.Parameters"]: Typecast

["Public.Procedures.Geometrytype_7902.Parameters"]: Typecast

["Public.Procedures.StSummary_7902.Parameters"]: Typecast

["Public.Procedures.StGeohash_3181.Parameters"]: Typecast

["Public.Procedures.StSrid_7902.Parameters"]: Typecast

["Public.Procedures.StSetsrid_3181.Parameters"]: Typecast

["Public.Procedures.StCentroidEcae.Parameters"]: Typecast

["Public.Procedures.StCentroidE728.Parameters"]: Typecast

["Public.Procedures.StCoversE452.Parameters"]: Typecast

["Public.Procedures.StDwithin_55df.Parameters"]: Typecast

["Public.Procedures.StCoveredbyE452.Parameters"]: Typecast

["Public.Procedures.StIntersectsE452.Parameters"]: Typecast

["Public.Procedures.StBufferCadf.Parameters"]: Typecast

["Public.Procedures.StBuffer_12e3.Parameters"]: Typecast

["Public.Procedures.StBuffer_3aaa.Parameters"]: Typecast

["Public.Procedures.StBufferC349.Parameters"]: Typecast

["Public.Procedures.StBufferF7c6.Parameters"]: Typecast

["Public.Procedures.StIntersectionE452.Parameters"]: Typecast

["Public.Procedures.StIntersection_2ec2.Parameters"]: Typecast

["Public.Procedures.StCovers_2ec2.Parameters"]: Typecast

["Public.Procedures.StCoveredby_2ec2.Parameters"]: Typecast

["Public.Procedures.StDwithinEfc0.Parameters"]: Typecast

["Public.Procedures.StIntersects_2ec2.Parameters"]: Typecast

["Public.Procedures.StClosestpoint_8dcd.Parameters"]: Typecast

["Public.Procedures.StClosestpoint_2ec2.Parameters"]: Typecast

["Public.Procedures.StShortestline_8dcd.Parameters"]: Typecast

["Public.Procedures.StShortestline_2ec2.Parameters"]: Typecast

["Public.Procedures.StLinesubstringEd46.Parameters"]: Typecast

["Public.Procedures.StLinesubstringE586.Parameters"]: Typecast

["Public.Procedures.StLinelocatepoint_8dcd.Parameters"]: Typecast

["Public.Procedures.StLinelocatepoint_2ec2.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoints_8796.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointsC349.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepoint_612b.Parameters"]: Typecast

["Public.Procedures.StLineinterpolatepointC349.Parameters"]: Typecast

["Public.Procedures.StDistancesphere_3651.Parameters"]: Typecast

["Public.Procedures.StDistancesphere_6961.Parameters"]: Typecast

["Public.Procedures.PostgisTypeName.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintSrid.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintDims.Parameters"]: Typecast

["Public.Procedures.PostgisConstraintType.Parameters"]: Typecast

["Public.Procedures.St_3ddistance.Parameters"]: Typecast

["Public.Procedures.St_3dmaxdistance.Parameters"]: Typecast

["Public.Procedures.St_3dclosestpoint.Parameters"]: Typecast

["Public.Procedures.St_3dshortestline.Parameters"]: Typecast

["Public.Procedures.St_3dlongestline.Parameters"]: Typecast

["Public.Procedures.StCoorddim.Parameters"]: Typecast

["Public.Procedures.StCurvetoline.Parameters"]: Typecast

["Public.Procedures.StHasarc.Parameters"]: Typecast

["Public.Procedures.StLinetocurve.Parameters"]: Typecast

["Public.Procedures.StPoint_0aec.Parameters"]: Typecast

["Public.Procedures.StPoint_0b7f.Parameters"]: Typecast

["Public.Procedures.StPointz.Parameters"]: Typecast

["Public.Procedures.StPointm.Parameters"]: Typecast

["Public.Procedures.StPointzm.Parameters"]: Typecast

["Public.Procedures.StPolygon.Parameters"]: Typecast

["Public.Procedures.StWkbtosql.Parameters"]: Typecast

["Public.Procedures.StLocatebetween.Parameters"]: Typecast

["Public.Procedures.StLocatealong.Parameters"]: Typecast

["Public.Procedures.StLocatebetweenelevations.Parameters"]: Typecast

["Public.Procedures.StInterpolatepoint.Parameters"]: Typecast

["Public.Procedures.StHexagon.Parameters"]: Typecast

["Public.Procedures.StSquare.Parameters"]: Typecast

["Public.Procedures.StHexagongrid.Parameters"]: Typecast

["Public.Procedures.StSquaregrid.Parameters"]: Typecast

["Public.Procedures.Contains_2d_3f2a.Parameters"]: Typecast

["Public.Procedures.IsContained_2d_3f2a.Parameters"]: Typecast

["Public.Procedures.Overlaps_2d_3f2a.Parameters"]: Typecast

["Public.Procedures.Overlaps_2d_4f71.Parameters"]: Typecast

["Public.Procedures.Contains_2d_4f71.Parameters"]: Typecast

["Public.Procedures.IsContained_2d_4f71.Parameters"]: Typecast

["Public.Procedures.Contains_2d_7d4f.Parameters"]: Typecast

["Public.Procedures.IsContained_2d_7d4f.Parameters"]: Typecast

["Public.Procedures.Overlaps_2d_7d4f.Parameters"]: Typecast

["Public.Procedures.OverlapsNd_6173.Parameters"]: Typecast

["Public.Procedures.OverlapsNd_25ba.Parameters"]: Typecast

["Public.Procedures.OverlapsNd_40b7.Parameters"]: Typecast

["Public.Procedures.Geom2dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.Geom3dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.Geom4dBrinInclusionAddValue.Parameters"]: Typecast

["Public.Procedures.StSimplifypolygonhull.Parameters"]: Typecast

["Public.Procedures.StConcavehull.Parameters"]: Typecast

["Public.Procedures.StAsx3d.Parameters"]: Typecast

["Public.Procedures.StAngle_3651.Parameters"]: Typecast

["Public.Procedures.St_3dlineinterpolatepoint.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfig_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChoose_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplit_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompress_2d.Parameters"]: Typecast

["Public.Procedures.GeometryOverlaps_3d.Parameters"]: Typecast

["Public.Procedures.GeometryContains_3d.Parameters"]: Typecast

["Public.Procedures.GeometryContained_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySame_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfig_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChoose_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplit_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompress_3d.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistConfigNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistChooseNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeometrySpgistCompressNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistConfigNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistChooseNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistPicksplitNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistInnerConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistLeafConsistentNd.Parameters"]: Typecast

["Public.Procedures.GeographySpgistCompressNd.Parameters"]: Typecast

["Public.Procedures.StLetters.Parameters"]: Typecast
[47575]: Typecast;
["PgToast.Types.PgToast_47570Index"]: Typecast
[48332]: Typecast;
["PgToast.Types.PgToast_48328Index"]: Typecast
[48338]: Typecast;
["PgToast.Types.PgToast_48334Index"]: Typecast
[2837]: Typecast;
["PgToast.Types.PgToast_1255Index"]: Typecast
[4172]: Typecast;
["PgToast.Types.PgToast_1247Index"]: Typecast
[2831]: Typecast;
["PgToast.Types.PgToast_2604Index"]: Typecast
[2833]: Typecast;
["PgToast.Types.PgToast_2606Index"]: Typecast
[4158]: Typecast;
["PgToast.Types.PgToast_2612Index"]: Typecast
[4160]: Typecast;
["PgToast.Types.PgToast_2600Index"]: Typecast
[2841]: Typecast;
["PgToast.Types.PgToast_2619Index"]: Typecast
[3440]: Typecast;
["PgToast.Types.PgToast_3381Index"]: Typecast
[3431]: Typecast;
["PgToast.Types.PgToast_3429Index"]: Typecast
[2839]: Typecast;
["PgToast.Types.PgToast_2618Index"]: Typecast
[2337]: Typecast;
["PgToast.Types.PgToast_2620Index"]: Typecast
[4146]: Typecast;
["PgToast.Types.PgToast_3466Index"]: Typecast
[2835]: Typecast;
["PgToast.Types.PgToast_2609Index"]: Typecast
[48344]: Typecast;
["PgToast.Types.PgToast_48340Index"]: Typecast
[4164]: Typecast;
["PgToast.Types.PgToast_2615Index"]: Typecast
[4178]: Typecast;
["PgToast.Types.PgToast_1262Index"]: Typecast
[2967]: Typecast;
["PgToast.Types.PgToast_2964Index"]: Typecast
[4186]: Typecast;
["PgToast.Types.PgToast_1213Index"]: Typecast
[4176]: Typecast;
["PgToast.Types.PgToast_1260Index"]: Typecast
[2847]: Typecast;
["PgToast.Types.PgToast_2396Index"]: Typecast
[4170]: Typecast;
["PgToast.Types.PgToast_3600Index"]: Typecast
[4148]: Typecast;
["PgToast.Types.PgToast_3079Index"]: Typecast
[4150]: Typecast;
["PgToast.Types.PgToast_2328Index"]: Typecast
[4152]: Typecast;
["PgToast.Types.PgToast_1417Index"]: Typecast
[4174]: Typecast;
["PgToast.Types.PgToast_1418Index"]: Typecast
[4154]: Typecast;
["PgToast.Types.PgToast_3118Index"]: Typecast
[4168]: Typecast;
["PgToast.Types.PgToast_3256Index"]: Typecast
[4182]: Typecast;
["PgToast.Types.PgToast_6000Index"]: Typecast
[4144]: Typecast;
["PgToast.Types.PgToast_826Index"]: Typecast
[4156]: Typecast;
["PgToast.Types.PgToast_3394Index"]: Typecast
[3599]: Typecast;
["PgToast.Types.PgToast_3596Index"]: Typecast
[4061]: Typecast;
["PgToast.Types.PgToast_3592Index"]: Typecast
[6176]: Typecast;
["PgToast.Types.PgToast_3456Index"]: Typecast
[6245]: Typecast;
["PgToast.Types.PgToast_6243Index"]: Typecast
[4166]: Typecast;
["PgToast.Types.PgToast_3350Index"]: Typecast
[6229]: Typecast;
["PgToast.Types.PgToast_6106Index"]: Typecast
[4184]: Typecast;
["PgToast.Types.PgToast_6100Index"]: Typecast
[48350]: Typecast;
["PgToast.Types.PgToast_48346Index"]: Typecast
[48356]: Typecast;
["PgToast.Types.PgToast_48352Index"]: Typecast
[13662]: Typecast;
["PgToast.Types.PgToast_13658Index"]: Typecast
[13667]: Typecast;
["PgToast.Types.PgToast_13663Index"]: Typecast
[13672]: Typecast;
["PgToast.Types.PgToast_13668Index"]: Typecast
[13677]: Typecast;
["PgToast.Types.PgToast_13673Index"]: Typecast
}

            interface HasDatabase {
              database: Database;
            }
          
export class Database extends PostgresDatabase<PostgresTypecasts> implements HasDatabase { 
get database() { return this };
get settings() { return this.context.settings as Settings };

          /**
           * Connect to your database server via URL, and return 
           * a fully typed database you can use to access it.
           */
          static async connect(postgresUrl: string, props?: postgres.Options<never>) {
              return new Database(await initializeContext(postgresUrl, props));
          }
        
        

            get Public() { return new Public(this); }
            
}

          export class Public implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
get Procedures () { return new Public.Procedures(this)} 
get Tables () { return new Public.Tables(this)} 
}
export namespace Public {

          export class Procedures implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
get StForcepolygoncw () { return new Public.Procedures.StForcepolygoncw(this)} 
get SpheroidIn () { return new Public.Procedures.SpheroidIn(this)} 
get SpheroidOut () { return new Public.Procedures.SpheroidOut(this)} 
get GeometryIn () { return new Public.Procedures.GeometryIn(this)} 
get GeometryOut () { return new Public.Procedures.GeometryOut(this)} 
get GeometryTypmodIn () { return new Public.Procedures.GeometryTypmodIn(this)} 
get GeometryTypmodOut () { return new Public.Procedures.GeometryTypmodOut(this)} 
get GeometryAnalyze () { return new Public.Procedures.GeometryAnalyze(this)} 
get GeometryRecv () { return new Public.Procedures.GeometryRecv(this)} 
get GeometrySend () { return new Public.Procedures.GeometrySend(this)} 
get Geometry_6564 () { return new Public.Procedures.Geometry_6564(this)} 
get Geometry_8997 () { return new Public.Procedures.Geometry_8997(this)} 
get Point () { return new Public.Procedures.Point(this)} 
get GeometryB0d8 () { return new Public.Procedures.GeometryB0d8(this)} 
get Path () { return new Public.Procedures.Path(this)} 
get GeometryF1be () { return new Public.Procedures.GeometryF1be(this)} 
get Polygon () { return new Public.Procedures.Polygon(this)} 
get StX () { return new Public.Procedures.StX(this)} 
get StY () { return new Public.Procedures.StY(this)} 
get StZ () { return new Public.Procedures.StZ(this)} 
get StM () { return new Public.Procedures.StM(this)} 
get Box3dIn () { return new Public.Procedures.Box3dIn(this)} 
get Box3dOut () { return new Public.Procedures.Box3dOut(this)} 
get Box2dIn () { return new Public.Procedures.Box2dIn(this)} 
get Box2dOut () { return new Public.Procedures.Box2dOut(this)} 
get Box2dfIn () { return new Public.Procedures.Box2dfIn(this)} 
get Box2dfOut () { return new Public.Procedures.Box2dfOut(this)} 
get GidxIn () { return new Public.Procedures.GidxIn(this)} 
get GidxOut () { return new Public.Procedures.GidxOut(this)} 
get GeometryLt () { return new Public.Procedures.GeometryLt(this)} 
get GeometryLe () { return new Public.Procedures.GeometryLe(this)} 
get GeometryGt () { return new Public.Procedures.GeometryGt(this)} 
get GeometryGe () { return new Public.Procedures.GeometryGe(this)} 
get GeometryEq () { return new Public.Procedures.GeometryEq(this)} 
get GeometryCmp () { return new Public.Procedures.GeometryCmp(this)} 
get GeometrySortsupport () { return new Public.Procedures.GeometrySortsupport(this)} 
get GeometryHash () { return new Public.Procedures.GeometryHash(this)} 
get GeometryGistDistance_2d () { return new Public.Procedures.GeometryGistDistance_2d(this)} 
get GeometryGistConsistent_2d () { return new Public.Procedures.GeometryGistConsistent_2d(this)} 
get GeometryGistCompress_2d () { return new Public.Procedures.GeometryGistCompress_2d(this)} 
get GeometryGistPenalty_2d () { return new Public.Procedures.GeometryGistPenalty_2d(this)} 
get GeometryGistPicksplit_2d () { return new Public.Procedures.GeometryGistPicksplit_2d(this)} 
get GeometryGistUnion_2d () { return new Public.Procedures.GeometryGistUnion_2d(this)} 
get GeometryGistSame_2d () { return new Public.Procedures.GeometryGistSame_2d(this)} 
get GeometryGistDecompress_2d () { return new Public.Procedures.GeometryGistDecompress_2d(this)} 
get GeometryGistSortsupport_2d () { return new Public.Procedures.GeometryGistSortsupport_2d(this)} 
get StForcerhr () { return new Public.Procedures.StForcerhr(this)} 
get PostgisNoop () { return new Public.Procedures.PostgisNoop(this)} 
get StForcepolygonccw () { return new Public.Procedures.StForcepolygonccw(this)} 
get GserializedGistSel_2d () { return new Public.Procedures.GserializedGistSel_2d(this)} 
get GserializedGistSelNd () { return new Public.Procedures.GserializedGistSelNd(this)} 
get GserializedGistJoinsel_2d () { return new Public.Procedures.GserializedGistJoinsel_2d(this)} 
get GserializedGistJoinselNd () { return new Public.Procedures.GserializedGistJoinselNd(this)} 
get GeometryOverlaps () { return new Public.Procedures.GeometryOverlaps(this)} 
get GeometrySame () { return new Public.Procedures.GeometrySame(this)} 
get GeometryDistanceCentroid () { return new Public.Procedures.GeometryDistanceCentroid(this)} 
get GeometryDistanceBox () { return new Public.Procedures.GeometryDistanceBox(this)} 
get GeometryContains () { return new Public.Procedures.GeometryContains(this)} 
get GeometryWithin () { return new Public.Procedures.GeometryWithin(this)} 
get GeometryLeft () { return new Public.Procedures.GeometryLeft(this)} 
get GeometryOverleft () { return new Public.Procedures.GeometryOverleft(this)} 
get GeometryBelow () { return new Public.Procedures.GeometryBelow(this)} 
get GeometryOverbelow () { return new Public.Procedures.GeometryOverbelow(this)} 
get GeometryOverright () { return new Public.Procedures.GeometryOverright(this)} 
get GeometryRight () { return new Public.Procedures.GeometryRight(this)} 
get GeometryOverabove () { return new Public.Procedures.GeometryOverabove(this)} 
get GeometryAbove () { return new Public.Procedures.GeometryAbove(this)} 
get GeometryGistConsistentNd () { return new Public.Procedures.GeometryGistConsistentNd(this)} 
get GeometryGistCompressNd () { return new Public.Procedures.GeometryGistCompressNd(this)} 
get GeometryGistPenaltyNd () { return new Public.Procedures.GeometryGistPenaltyNd(this)} 
get GeometryGistPicksplitNd () { return new Public.Procedures.GeometryGistPicksplitNd(this)} 
get GeometryGistUnionNd () { return new Public.Procedures.GeometryGistUnionNd(this)} 
get GeometryGistSameNd () { return new Public.Procedures.GeometryGistSameNd(this)} 
get GeometryGistDecompressNd () { return new Public.Procedures.GeometryGistDecompressNd(this)} 
get GeometryOverlapsNd () { return new Public.Procedures.GeometryOverlapsNd(this)} 
get GeometryContainsNd () { return new Public.Procedures.GeometryContainsNd(this)} 
get GeometryWithinNd () { return new Public.Procedures.GeometryWithinNd(this)} 
get GeometrySameNd () { return new Public.Procedures.GeometrySameNd(this)} 
get GeometryDistanceCentroidNd () { return new Public.Procedures.GeometryDistanceCentroidNd(this)} 
get GeometryDistanceCpa () { return new Public.Procedures.GeometryDistanceCpa(this)} 
get GeometryGistDistanceNd () { return new Public.Procedures.GeometryGistDistanceNd(this)} 
get StShiftlongitude () { return new Public.Procedures.StShiftlongitude(this)} 
get StWrapx () { return new Public.Procedures.StWrapx(this)} 
get StXmin () { return new Public.Procedures.StXmin(this)} 
get StYmin () { return new Public.Procedures.StYmin(this)} 
get StZmin () { return new Public.Procedures.StZmin(this)} 
get StXmax () { return new Public.Procedures.StXmax(this)} 
get StYmax () { return new Public.Procedures.StYmax(this)} 
get StZmax () { return new Public.Procedures.StZmax(this)} 
get StExpand_269a () { return new Public.Procedures.StExpand_269a(this)} 
get StExpand_96e3 () { return new Public.Procedures.StExpand_96e3(this)} 
get PostgisGetbbox () { return new Public.Procedures.PostgisGetbbox(this)} 
get StMakebox2d () { return new Public.Procedures.StMakebox2d(this)} 
get StEstimatedextentD2f5 () { return new Public.Procedures.StEstimatedextentD2f5(this)} 
get StEstimatedextent_27e1 () { return new Public.Procedures.StEstimatedextent_27e1(this)} 
get StEstimatedextent_2ec2 () { return new Public.Procedures.StEstimatedextent_2ec2(this)} 
get StFindextent_27e1 () { return new Public.Procedures.StFindextent_27e1(this)} 
get StFindextent_2ec2 () { return new Public.Procedures.StFindextent_2ec2(this)} 
get PostgisAddbbox () { return new Public.Procedures.PostgisAddbbox(this)} 
get PostgisDropbbox () { return new Public.Procedures.PostgisDropbbox(this)} 
get PostgisHasbbox () { return new Public.Procedures.PostgisHasbbox(this)} 
get StQuantizecoordinates () { return new Public.Procedures.StQuantizecoordinates(this)} 
get StMemsize () { return new Public.Procedures.StMemsize(this)} 
get StSummary_0cdb () { return new Public.Procedures.StSummary_0cdb(this)} 
get StNpoints () { return new Public.Procedures.StNpoints(this)} 
get StNrings () { return new Public.Procedures.StNrings(this)} 
get St_3dlength () { return new Public.Procedures.St_3dlength(this)} 
get StLength2d () { return new Public.Procedures.StLength2d(this)} 
get StLength_0cdb () { return new Public.Procedures.StLength_0cdb(this)} 
get StLengthspheroid () { return new Public.Procedures.StLengthspheroid(this)} 
get StLength2dspheroid () { return new Public.Procedures.StLength2dspheroid(this)} 
get St_3dperimeter () { return new Public.Procedures.St_3dperimeter(this)} 
get StPerimeter2d () { return new Public.Procedures.StPerimeter2d(this)} 
get StPerimeter_0cdb () { return new Public.Procedures.StPerimeter_0cdb(this)} 
get StArea2d () { return new Public.Procedures.StArea2d(this)} 
get StArea_0cdb () { return new Public.Procedures.StArea_0cdb(this)} 
get StIspolygoncw () { return new Public.Procedures.StIspolygoncw(this)} 
get StIspolygonccw () { return new Public.Procedures.StIspolygonccw(this)} 
get StDistancespheroidCd56 () { return new Public.Procedures.StDistancespheroidCd56(this)} 
get StDistancespheroid_3651 () { return new Public.Procedures.StDistancespheroid_3651(this)} 
get StDistance_3651 () { return new Public.Procedures.StDistance_3651(this)} 
get StPointinsidecircle () { return new Public.Procedures.StPointinsidecircle(this)} 
get StAzimuth_3651 () { return new Public.Procedures.StAzimuth_3651(this)} 
get StProjectD5eb () { return new Public.Procedures.StProjectD5eb(this)} 
get StProject_6961 () { return new Public.Procedures.StProject_6961(this)} 
get StAngleE1dd () { return new Public.Procedures.StAngleE1dd(this)} 
get StLineextend () { return new Public.Procedures.StLineextend(this)} 
get StForce2d () { return new Public.Procedures.StForce2d(this)} 
get StForce3dz () { return new Public.Procedures.StForce3dz(this)} 
get StForce3d () { return new Public.Procedures.StForce3d(this)} 
get StForce3dm () { return new Public.Procedures.StForce3dm(this)} 
get StForce4d () { return new Public.Procedures.StForce4d(this)} 
get StForcecollection () { return new Public.Procedures.StForcecollection(this)} 
get StCollectionextract_6cbe () { return new Public.Procedures.StCollectionextract_6cbe(this)} 
get StCollectionextract_0cdb () { return new Public.Procedures.StCollectionextract_0cdb(this)} 
get StCollectionhomogenize () { return new Public.Procedures.StCollectionhomogenize(this)} 
get StMulti () { return new Public.Procedures.StMulti(this)} 
get StForcecurve () { return new Public.Procedures.StForcecurve(this)} 
get StForcesfs_0cdb () { return new Public.Procedures.StForcesfs_0cdb(this)} 
get StForcesfs_88bc () { return new Public.Procedures.StForcesfs_88bc(this)} 
get StExpand_2074 () { return new Public.Procedures.StExpand_2074(this)} 
get StExpand_704e () { return new Public.Procedures.StExpand_704e(this)} 
get StExpand_7163 () { return new Public.Procedures.StExpand_7163(this)} 
get StExpand_5500 () { return new Public.Procedures.StExpand_5500(this)} 
get StEnvelope () { return new Public.Procedures.StEnvelope(this)} 
get StBoundingdiagonal () { return new Public.Procedures.StBoundingdiagonal(this)} 
get StReverse () { return new Public.Procedures.StReverse(this)} 
get StScroll () { return new Public.Procedures.StScroll(this)} 
get PostgisGeosNoop () { return new Public.Procedures.PostgisGeosNoop(this)} 
get StNormalize () { return new Public.Procedures.StNormalize(this)} 
get StZmflag () { return new Public.Procedures.StZmflag(this)} 
get StNdims () { return new Public.Procedures.StNdims(this)} 
get StAsewkt_0cdb () { return new Public.Procedures.StAsewkt_0cdb(this)} 
get StAsewkt_6cbe () { return new Public.Procedures.StAsewkt_6cbe(this)} 
get StAstwkb_652e () { return new Public.Procedures.StAstwkb_652e(this)} 
get StAstwkbF3fd () { return new Public.Procedures.StAstwkbF3fd(this)} 
get StAsewkb_0cdb () { return new Public.Procedures.StAsewkb_0cdb(this)} 
get StAshexewkb_0cdb () { return new Public.Procedures.StAshexewkb_0cdb(this)} 
get StAshexewkb_88bc () { return new Public.Procedures.StAshexewkb_88bc(this)} 
get StAsewkb_88bc () { return new Public.Procedures.StAsewkb_88bc(this)} 
get StAslatlontext () { return new Public.Procedures.StAslatlontext(this)} 
get Geomfromewkb () { return new Public.Procedures.Geomfromewkb(this)} 
get StGeomfromewkb () { return new Public.Procedures.StGeomfromewkb(this)} 
get StGeomfromtwkb () { return new Public.Procedures.StGeomfromtwkb(this)} 
get Geomfromewkt () { return new Public.Procedures.Geomfromewkt(this)} 
get StGeomfromewkt () { return new Public.Procedures.StGeomfromewkt(this)} 
get PostgisCacheBbox () { return new Public.Procedures.PostgisCacheBbox(this)} 
get StMakepoint_0aec () { return new Public.Procedures.StMakepoint_0aec(this)} 
get StMakepoint_81ec () { return new Public.Procedures.StMakepoint_81ec(this)} 
get StMakepoint_570b () { return new Public.Procedures.StMakepoint_570b(this)} 
get StMakepointm () { return new Public.Procedures.StMakepointm(this)} 
get St_3dmakebox () { return new Public.Procedures.St_3dmakebox(this)} 
get StMakelineA4b6 () { return new Public.Procedures.StMakelineA4b6(this)} 
get StLinefrommultipoint () { return new Public.Procedures.StLinefrommultipoint(this)} 
get StMakeline_3651 () { return new Public.Procedures.StMakeline_3651(this)} 
get StAddpoint_3651 () { return new Public.Procedures.StAddpoint_3651(this)} 
get StScaleD5eb () { return new Public.Procedures.StScaleD5eb(this)} 
get StAddpointAa17 () { return new Public.Procedures.StAddpointAa17(this)} 
get StRemovepoint () { return new Public.Procedures.StRemovepoint(this)} 
get StSetpoint () { return new Public.Procedures.StSetpoint(this)} 
get StMakeenvelope () { return new Public.Procedures.StMakeenvelope(this)} 
get StTileenvelope () { return new Public.Procedures.StTileenvelope(this)} 
get StMakepolygonE2e3 () { return new Public.Procedures.StMakepolygonE2e3(this)} 
get StMakepolygon_0cdb () { return new Public.Procedures.StMakepolygon_0cdb(this)} 
get StBuildarea () { return new Public.Procedures.StBuildarea(this)} 
get StPolygonizeA4b6 () { return new Public.Procedures.StPolygonizeA4b6(this)} 
get StClusterintersectingA4b6 () { return new Public.Procedures.StClusterintersectingA4b6(this)} 
get StClusterwithin_0e49 () { return new Public.Procedures.StClusterwithin_0e49(this)} 
get StLinemerge_0cdb () { return new Public.Procedures.StLinemerge_0cdb(this)} 
get StLinemerge_4ba2 () { return new Public.Procedures.StLinemerge_4ba2(this)} 
get StAffineE42d () { return new Public.Procedures.StAffineE42d(this)} 
get StAffine_1962 () { return new Public.Procedures.StAffine_1962(this)} 
get StRotate_7163 () { return new Public.Procedures.StRotate_7163(this)} 
get StRotate_8b9f () { return new Public.Procedures.StRotate_8b9f(this)} 
get StRotate_463e () { return new Public.Procedures.StRotate_463e(this)} 
get StRotatez () { return new Public.Procedures.StRotatez(this)} 
get StRotatex () { return new Public.Procedures.StRotatex(this)} 
get StRotatey () { return new Public.Procedures.StRotatey(this)} 
get StTranslate_8b9f () { return new Public.Procedures.StTranslate_8b9f(this)} 
get StTranslateD5eb () { return new Public.Procedures.StTranslateD5eb(this)} 
get StScale_3651 () { return new Public.Procedures.StScale_3651(this)} 
get StScale_1bee () { return new Public.Procedures.StScale_1bee(this)} 
get StScale_8b9f () { return new Public.Procedures.StScale_8b9f(this)} 
get StTransscale () { return new Public.Procedures.StTransscale(this)} 
get StDump () { return new Public.Procedures.StDump(this)} 
get StDumprings () { return new Public.Procedures.StDumprings(this)} 
get StDumppoints () { return new Public.Procedures.StDumppoints(this)} 
get StDumpsegments () { return new Public.Procedures.StDumpsegments(this)} 
get PopulateGeometryColumns_23fc () { return new Public.Procedures.PopulateGeometryColumns_23fc(this)} 
get PopulateGeometryColumns_4174 () { return new Public.Procedures.PopulateGeometryColumns_4174(this)} 
get Addgeometrycolumn_8fbb () { return new Public.Procedures.Addgeometrycolumn_8fbb(this)} 
get Addgeometrycolumn_4617 () { return new Public.Procedures.Addgeometrycolumn_4617(this)} 
get Addgeometrycolumn_093c () { return new Public.Procedures.Addgeometrycolumn_093c(this)} 
get Dropgeometrycolumn_0412 () { return new Public.Procedures.Dropgeometrycolumn_0412(this)} 
get Dropgeometrycolumn_2253 () { return new Public.Procedures.Dropgeometrycolumn_2253(this)} 
get DropgeometrycolumnF11a () { return new Public.Procedures.DropgeometrycolumnF11a(this)} 
get Dropgeometrytable_2253 () { return new Public.Procedures.Dropgeometrytable_2253(this)} 
get StSegmentize_7163 () { return new Public.Procedures.StSegmentize_7163(this)} 
get DropgeometrytableF11a () { return new Public.Procedures.DropgeometrytableF11a(this)} 
get DropgeometrytableBfde () { return new Public.Procedures.DropgeometrytableBfde(this)} 
get UpdategeometrysridB2ee () { return new Public.Procedures.UpdategeometrysridB2ee(this)} 
get Updategeometrysrid_7b58 () { return new Public.Procedures.Updategeometrysrid_7b58(this)} 
get Updategeometrysrid_11c8 () { return new Public.Procedures.Updategeometrysrid_11c8(this)} 
get FindSrid () { return new Public.Procedures.FindSrid(this)} 
get GetProj4FromSrid () { return new Public.Procedures.GetProj4FromSrid(this)} 
get StSetsrid_6cbe () { return new Public.Procedures.StSetsrid_6cbe(this)} 
get StSrid_0cdb () { return new Public.Procedures.StSrid_0cdb(this)} 
get PostgisTransformGeometry () { return new Public.Procedures.PostgisTransformGeometry(this)} 
get PostgisSrsCodes () { return new Public.Procedures.PostgisSrsCodes(this)} 
get PostgisSrs () { return new Public.Procedures.PostgisSrs(this)} 
get PostgisSrsAll () { return new Public.Procedures.PostgisSrsAll(this)} 
get PostgisSrsSearch () { return new Public.Procedures.PostgisSrsSearch(this)} 
get StTransform_6cbe () { return new Public.Procedures.StTransform_6cbe(this)} 
get StTransform_88bc () { return new Public.Procedures.StTransform_88bc(this)} 
get StTransform_655c () { return new Public.Procedures.StTransform_655c(this)} 
get StTransform_5016 () { return new Public.Procedures.StTransform_5016(this)} 
get PostgisTransformPipelineGeometry () { return new Public.Procedures.PostgisTransformPipelineGeometry(this)} 
get StTransformpipeline () { return new Public.Procedures.StTransformpipeline(this)} 
get StInversetransformpipeline () { return new Public.Procedures.StInversetransformpipeline(this)} 
get PostgisVersion () { return new Public.Procedures.PostgisVersion(this)} 
get PostgisLiblwgeomVersion () { return new Public.Procedures.PostgisLiblwgeomVersion(this)} 
get PostgisProjVersion () { return new Public.Procedures.PostgisProjVersion(this)} 
get PostgisWagyuVersion () { return new Public.Procedures.PostgisWagyuVersion(this)} 
get PostgisScriptsInstalled () { return new Public.Procedures.PostgisScriptsInstalled(this)} 
get PostgisLibVersion () { return new Public.Procedures.PostgisLibVersion(this)} 
get PostgisScriptsReleased () { return new Public.Procedures.PostgisScriptsReleased(this)} 
get PostgisGeosVersion () { return new Public.Procedures.PostgisGeosVersion(this)} 
get PostgisGeosCompiledVersion () { return new Public.Procedures.PostgisGeosCompiledVersion(this)} 
get PostgisLibRevision () { return new Public.Procedures.PostgisLibRevision(this)} 
get PostgisSvnVersion () { return new Public.Procedures.PostgisSvnVersion(this)} 
get PostgisLibxmlVersion () { return new Public.Procedures.PostgisLibxmlVersion(this)} 
get PostgisScriptsBuildDate () { return new Public.Procedures.PostgisScriptsBuildDate(this)} 
get PostgisLibBuildDate () { return new Public.Procedures.PostgisLibBuildDate(this)} 
get PostgisExtensionsUpgrade () { return new Public.Procedures.PostgisExtensionsUpgrade(this)} 
get StLineinterpolatepoint_7163 () { return new Public.Procedures.StLineinterpolatepoint_7163(this)} 
get StLineinterpolatepoints_8fda () { return new Public.Procedures.StLineinterpolatepoints_8fda(this)} 
get StLinesubstringD5eb () { return new Public.Procedures.StLinesubstringD5eb(this)} 
get StLinelocatepoint_3651 () { return new Public.Procedures.StLinelocatepoint_3651(this)} 
get StAddmeasure () { return new Public.Procedures.StAddmeasure(this)} 
get StClosestpointofapproach () { return new Public.Procedures.StClosestpointofapproach(this)} 
get PostgisFullVersion () { return new Public.Procedures.PostgisFullVersion(this)} 
get Box2d_0cdb () { return new Public.Procedures.Box2d_0cdb(this)} 
get Box3d_0cdb () { return new Public.Procedures.Box3d_0cdb(this)} 
get Box_0cdb () { return new Public.Procedures.Box_0cdb(this)} 
get Box2d_07e9 () { return new Public.Procedures.Box2d_07e9(this)} 
get Box3dE505 () { return new Public.Procedures.Box3dE505(this)} 
get Box_07e9 () { return new Public.Procedures.Box_07e9(this)} 
get Text () { return new Public.Procedures.Text(this)} 
get Box3dtobox () { return new Public.Procedures.Box3dtobox(this)} 
get GeometryE505 () { return new Public.Procedures.GeometryE505(this)} 
get Geometry_07e9 () { return new Public.Procedures.Geometry_07e9(this)} 
get GeometryE728 () { return new Public.Procedures.GeometryE728(this)} 
get Geometry_2d19 () { return new Public.Procedures.Geometry_2d19(this)} 
get Bytea_0cdb () { return new Public.Procedures.Bytea_0cdb(this)} 
get StSimplify_7163 () { return new Public.Procedures.StSimplify_7163(this)} 
get StSimplify_8fda () { return new Public.Procedures.StSimplify_8fda(this)} 
get StSimplifyvw () { return new Public.Procedures.StSimplifyvw(this)} 
get StSeteffectivearea () { return new Public.Procedures.StSeteffectivearea(this)} 
get StFilterbym () { return new Public.Procedures.StFilterbym(this)} 
get StChaikinsmoothing () { return new Public.Procedures.StChaikinsmoothing(this)} 
get StSnaptogrid_5500 () { return new Public.Procedures.StSnaptogrid_5500(this)} 
get StSnaptogridD5eb () { return new Public.Procedures.StSnaptogridD5eb(this)} 
get StSnaptogrid_7163 () { return new Public.Procedures.StSnaptogrid_7163(this)} 
get StSnaptogrid_7f2e () { return new Public.Procedures.StSnaptogrid_7f2e(this)} 
get StDistancecpa () { return new Public.Procedures.StDistancecpa(this)} 
get StCpawithin () { return new Public.Procedures.StCpawithin(this)} 
get StIsvalidtrajectory () { return new Public.Procedures.StIsvalidtrajectory(this)} 
get StIntersection_6961 () { return new Public.Procedures.StIntersection_6961(this)} 
get StBufferBf44 () { return new Public.Procedures.StBufferBf44(this)} 
get StBufferC33e () { return new Public.Procedures.StBufferC33e(this)} 
get StMinimumboundingradius () { return new Public.Procedures.StMinimumboundingradius(this)} 
get StMinimumboundingcircle () { return new Public.Procedures.StMinimumboundingcircle(this)} 
get StOrientedenvelope () { return new Public.Procedures.StOrientedenvelope(this)} 
get StOffsetcurve () { return new Public.Procedures.StOffsetcurve(this)} 
get StGeneratepoints_6cbe () { return new Public.Procedures.StGeneratepoints_6cbe(this)} 
get StGeneratepointsD341 () { return new Public.Procedures.StGeneratepointsD341(this)} 
get StConvexhull () { return new Public.Procedures.StConvexhull(this)} 
get StSimplifypreservetopology () { return new Public.Procedures.StSimplifypreservetopology(this)} 
get StIsvalidreason_0cdb () { return new Public.Procedures.StIsvalidreason_0cdb(this)} 
get StIsvaliddetail () { return new Public.Procedures.StIsvaliddetail(this)} 
get StIsvalidreason_6cbe () { return new Public.Procedures.StIsvalidreason_6cbe(this)} 
get StIsvalid_6cbe () { return new Public.Procedures.StIsvalid_6cbe(this)} 
get StHausdorffdistance_3651 () { return new Public.Procedures.StHausdorffdistance_3651(this)} 
get StHausdorffdistance_6961 () { return new Public.Procedures.StHausdorffdistance_6961(this)} 
get StFrechetdistance () { return new Public.Procedures.StFrechetdistance(this)} 
get StMaximuminscribedcircle () { return new Public.Procedures.StMaximuminscribedcircle(this)} 
get StLargestemptycircle () { return new Public.Procedures.StLargestemptycircle(this)} 
get StDifference () { return new Public.Procedures.StDifference(this)} 
get StBoundary () { return new Public.Procedures.StBoundary(this)} 
get StPoints () { return new Public.Procedures.StPoints(this)} 
get StSymdifference () { return new Public.Procedures.StSymdifference(this)} 
get StSymmetricdifference () { return new Public.Procedures.StSymmetricdifference(this)} 
get StUnion_3651 () { return new Public.Procedures.StUnion_3651(this)} 
get StUnion_6961 () { return new Public.Procedures.StUnion_6961(this)} 
get StUnaryunion () { return new Public.Procedures.StUnaryunion(this)} 
get StRemoverepeatedpoints () { return new Public.Procedures.StRemoverepeatedpoints(this)} 
get StClipbybox2d () { return new Public.Procedures.StClipbybox2d(this)} 
get StSubdivide () { return new Public.Procedures.StSubdivide(this)} 
get StReduceprecision () { return new Public.Procedures.StReduceprecision(this)} 
get StMakevalid_0cdb () { return new Public.Procedures.StMakevalid_0cdb(this)} 
get StMakevalid_88bc () { return new Public.Procedures.StMakevalid_88bc(this)} 
get StCleangeometry () { return new Public.Procedures.StCleangeometry(this)} 
get StSplit () { return new Public.Procedures.StSplit(this)} 
get StSharedpaths () { return new Public.Procedures.StSharedpaths(this)} 
get StSnap () { return new Public.Procedures.StSnap(this)} 
get StRelatematch () { return new Public.Procedures.StRelatematch(this)} 
get StNode () { return new Public.Procedures.StNode(this)} 
get StDelaunaytriangles () { return new Public.Procedures.StDelaunaytriangles(this)} 
get StTriangulatepolygon () { return new Public.Procedures.StTriangulatepolygon(this)} 
get StVoronoipolygons () { return new Public.Procedures.StVoronoipolygons(this)} 
get StVoronoilines () { return new Public.Procedures.StVoronoilines(this)} 
get StCombinebbox_1ee2 () { return new Public.Procedures.StCombinebbox_1ee2(this)} 
get StCombinebbox_9d67 () { return new Public.Procedures.StCombinebbox_9d67(this)} 
get StCombinebbox_1a7e () { return new Public.Procedures.StCombinebbox_1a7e(this)} 
get StCollect_3651 () { return new Public.Procedures.StCollect_3651(this)} 
get StCollectA4b6 () { return new Public.Procedures.StCollectA4b6(this)} 
get PgisGeometryAccumTransfn_43cf () { return new Public.Procedures.PgisGeometryAccumTransfn_43cf(this)} 
get PgisGeometryAccumTransfn_7c68 () { return new Public.Procedures.PgisGeometryAccumTransfn_7c68(this)} 
get PgisGeometryAccumTransfn_0b93 () { return new Public.Procedures.PgisGeometryAccumTransfn_0b93(this)} 
get PgisGeometryCollectFinalfn () { return new Public.Procedures.PgisGeometryCollectFinalfn(this)} 
get PgisGeometryPolygonizeFinalfn () { return new Public.Procedures.PgisGeometryPolygonizeFinalfn(this)} 
get PgisGeometryClusterintersectingFinalfn () { return new Public.Procedures.PgisGeometryClusterintersectingFinalfn(this)} 
get PgisGeometryClusterwithinFinalfn () { return new Public.Procedures.PgisGeometryClusterwithinFinalfn(this)} 
get PgisGeometryMakelineFinalfn () { return new Public.Procedures.PgisGeometryMakelineFinalfn(this)} 
get PgisGeometryCoverageunionFinalfn () { return new Public.Procedures.PgisGeometryCoverageunionFinalfn(this)} 
get PgisGeometryUnionParallelTransfn_43cf () { return new Public.Procedures.PgisGeometryUnionParallelTransfn_43cf(this)} 
get PgisGeometryUnionParallelTransfn_7c68 () { return new Public.Procedures.PgisGeometryUnionParallelTransfn_7c68(this)} 
get PgisGeometryUnionParallelCombinefn () { return new Public.Procedures.PgisGeometryUnionParallelCombinefn(this)} 
get PgisGeometryUnionParallelSerialfn () { return new Public.Procedures.PgisGeometryUnionParallelSerialfn(this)} 
get PgisGeometryUnionParallelDeserialfn () { return new Public.Procedures.PgisGeometryUnionParallelDeserialfn(this)} 
get PgisGeometryUnionParallelFinalfn () { return new Public.Procedures.PgisGeometryUnionParallelFinalfn(this)} 
get StUnionA4b6 () { return new Public.Procedures.StUnionA4b6(this)} 
get StCoverageunionA4b6 () { return new Public.Procedures.StCoverageunionA4b6(this)} 
get StRelate_3651 () { return new Public.Procedures.StRelate_3651(this)} 
get StRelateAa17 () { return new Public.Procedures.StRelateAa17(this)} 
get StRelateCaf9 () { return new Public.Procedures.StRelateCaf9(this)} 
get StDisjoint () { return new Public.Procedures.StDisjoint(this)} 
get PostgisIndexSupportfn () { return new Public.Procedures.PostgisIndexSupportfn(this)} 
get StLinecrossingdirection () { return new Public.Procedures.StLinecrossingdirection(this)} 
get StDwithin_6961 () { return new Public.Procedures.StDwithin_6961(this)} 
get StTouches () { return new Public.Procedures.StTouches(this)} 
get StIntersects_3651 () { return new Public.Procedures.StIntersects_3651(this)} 
get StCrosses () { return new Public.Procedures.StCrosses(this)} 
get StContains () { return new Public.Procedures.StContains(this)} 
get StContainsproperly () { return new Public.Procedures.StContainsproperly(this)} 
get StWithin () { return new Public.Procedures.StWithin(this)} 
get StCovers_3651 () { return new Public.Procedures.StCovers_3651(this)} 
get StCoveredby_3651 () { return new Public.Procedures.StCoveredby_3651(this)} 
get StOverlaps () { return new Public.Procedures.StOverlaps(this)} 
get StDfullywithin () { return new Public.Procedures.StDfullywithin(this)} 
get St_3ddwithin () { return new Public.Procedures.St_3ddwithin(this)} 
get St_3ddfullywithin () { return new Public.Procedures.St_3ddfullywithin(this)} 
get St_3dintersects () { return new Public.Procedures.St_3dintersects(this)} 
get StOrderingequals () { return new Public.Procedures.StOrderingequals(this)} 
get StEquals () { return new Public.Procedures.StEquals(this)} 
get StIsvalid_0cdb () { return new Public.Procedures.StIsvalid_0cdb(this)} 
get StMinimumclearance () { return new Public.Procedures.StMinimumclearance(this)} 
get StMinimumclearanceline () { return new Public.Procedures.StMinimumclearanceline(this)} 
get StCentroid_0cdb () { return new Public.Procedures.StCentroid_0cdb(this)} 
get StGeometricmedian () { return new Public.Procedures.StGeometricmedian(this)} 
get StIsring () { return new Public.Procedures.StIsring(this)} 
get StPointonsurface () { return new Public.Procedures.StPointonsurface(this)} 
get StIssimple () { return new Public.Procedures.StIssimple(this)} 
get StIscollection () { return new Public.Procedures.StIscollection(this)} 
get Equals () { return new Public.Procedures.Equals(this)} 
get StGeomfromgml_27e2 () { return new Public.Procedures.StGeomfromgml_27e2(this)} 
get StGeomfromgmlE728 () { return new Public.Procedures.StGeomfromgmlE728(this)} 
get StGmltosqlE728 () { return new Public.Procedures.StGmltosqlE728(this)} 
get StGmltosql_27e2 () { return new Public.Procedures.StGmltosql_27e2(this)} 
get StGeomfromkml () { return new Public.Procedures.StGeomfromkml(this)} 
get StGeomfrommarc21 () { return new Public.Procedures.StGeomfrommarc21(this)} 
get StAsmarc21 () { return new Public.Procedures.StAsmarc21(this)} 
get StGeomfromgeojsonE728 () { return new Public.Procedures.StGeomfromgeojsonE728(this)} 
get StGeomfromgeojson_608f () { return new Public.Procedures.StGeomfromgeojson_608f(this)} 
get StGeomfromgeojson_3c9d () { return new Public.Procedures.StGeomfromgeojson_3c9d(this)} 
get PostgisLibjsonVersion () { return new Public.Procedures.PostgisLibjsonVersion(this)} 
get StLinefromencodedpolyline () { return new Public.Procedures.StLinefromencodedpolyline(this)} 
get StAsencodedpolyline () { return new Public.Procedures.StAsencodedpolyline(this)} 
get StAssvgD341 () { return new Public.Procedures.StAssvgD341(this)} 
get StAsgmlD341 () { return new Public.Procedures.StAsgmlD341(this)} 
get StAsgml_32a0 () { return new Public.Procedures.StAsgml_32a0(this)} 
get StAskmlCce7 () { return new Public.Procedures.StAskmlCce7(this)} 
get StAsgeojsonD341 () { return new Public.Procedures.StAsgeojsonD341(this)} 
get StAsgeojsonF2c6 () { return new Public.Procedures.StAsgeojsonF2c6(this)} 
get Json () { return new Public.Procedures.Json(this)} 
get Jsonb () { return new Public.Procedures.Jsonb(this)} 
get PgisAsmvtTransfn_647f () { return new Public.Procedures.PgisAsmvtTransfn_647f(this)} 
get PgisAsmvtTransfn_27f4 () { return new Public.Procedures.PgisAsmvtTransfn_27f4(this)} 
get PgisAsmvtTransfnF57f () { return new Public.Procedures.PgisAsmvtTransfnF57f(this)} 
get PgisAsmvtTransfn_92c1 () { return new Public.Procedures.PgisAsmvtTransfn_92c1(this)} 
get PgisAsmvtTransfnF5be () { return new Public.Procedures.PgisAsmvtTransfnF5be(this)} 
get PgisAsmvtFinalfn () { return new Public.Procedures.PgisAsmvtFinalfn(this)} 
get PgisAsmvtCombinefn () { return new Public.Procedures.PgisAsmvtCombinefn(this)} 
get PgisAsmvtSerialfn () { return new Public.Procedures.PgisAsmvtSerialfn(this)} 
get PgisAsmvtDeserialfn () { return new Public.Procedures.PgisAsmvtDeserialfn(this)} 
get StAsmvtgeom () { return new Public.Procedures.StAsmvtgeom(this)} 
get PostgisLibprotobufVersion () { return new Public.Procedures.PostgisLibprotobufVersion(this)} 
get PgisAsgeobufTransfn_647f () { return new Public.Procedures.PgisAsgeobufTransfn_647f(this)} 
get PgisAsgeobufTransfn_27f4 () { return new Public.Procedures.PgisAsgeobufTransfn_27f4(this)} 
get PgisAsgeobufFinalfn () { return new Public.Procedures.PgisAsgeobufFinalfn(this)} 
get PgisAsflatgeobufTransfn_647f () { return new Public.Procedures.PgisAsflatgeobufTransfn_647f(this)} 
get PgisAsflatgeobufTransfn_9633 () { return new Public.Procedures.PgisAsflatgeobufTransfn_9633(this)} 
get PgisAsflatgeobufTransfn_521f () { return new Public.Procedures.PgisAsflatgeobufTransfn_521f(this)} 
get PgisAsflatgeobufFinalfn () { return new Public.Procedures.PgisAsflatgeobufFinalfn(this)} 
get StFromflatgeobuftotable () { return new Public.Procedures.StFromflatgeobuftotable(this)} 
get StFromflatgeobuf () { return new Public.Procedures.StFromflatgeobuf(this)} 
get StGeohash_6cbe () { return new Public.Procedures.StGeohash_6cbe(this)} 
get StBox2dfromgeohash () { return new Public.Procedures.StBox2dfromgeohash(this)} 
get StPointfromgeohash () { return new Public.Procedures.StPointfromgeohash(this)} 
get StGeomfromgeohash () { return new Public.Procedures.StGeomfromgeohash(this)} 
get StNumpoints () { return new Public.Procedures.StNumpoints(this)} 
get StNumgeometries () { return new Public.Procedures.StNumgeometries(this)} 
get StGeometryn () { return new Public.Procedures.StGeometryn(this)} 
get StDimension () { return new Public.Procedures.StDimension(this)} 
get StExteriorring () { return new Public.Procedures.StExteriorring(this)} 
get StNuminteriorrings () { return new Public.Procedures.StNuminteriorrings(this)} 
get StNuminteriorring () { return new Public.Procedures.StNuminteriorring(this)} 
get StInteriorringn () { return new Public.Procedures.StInteriorringn(this)} 
get Geometrytype_0cdb () { return new Public.Procedures.Geometrytype_0cdb(this)} 
get StGeometrytype () { return new Public.Procedures.StGeometrytype(this)} 
get StPointn () { return new Public.Procedures.StPointn(this)} 
get StNumpatches () { return new Public.Procedures.StNumpatches(this)} 
get StPatchn () { return new Public.Procedures.StPatchn(this)} 
get StStartpoint () { return new Public.Procedures.StStartpoint(this)} 
get StEndpoint () { return new Public.Procedures.StEndpoint(this)} 
get StIsclosed () { return new Public.Procedures.StIsclosed(this)} 
get StIsempty () { return new Public.Procedures.StIsempty(this)} 
get StAsbinary_88bc () { return new Public.Procedures.StAsbinary_88bc(this)} 
get StAsbinary_0cdb () { return new Public.Procedures.StAsbinary_0cdb(this)} 
get StAstext_0cdb () { return new Public.Procedures.StAstext_0cdb(this)} 
get StAstext_6cbe () { return new Public.Procedures.StAstext_6cbe(this)} 
get StGeometryfromtextE728 () { return new Public.Procedures.StGeometryfromtextE728(this)} 
get StGeometryfromtext_27e2 () { return new Public.Procedures.StGeometryfromtext_27e2(this)} 
get StGeomfromtextE728 () { return new Public.Procedures.StGeomfromtextE728(this)} 
get StGeomfromtext_27e2 () { return new Public.Procedures.StGeomfromtext_27e2(this)} 
get StWkttosql () { return new Public.Procedures.StWkttosql(this)} 
get StPointfromtextE728 () { return new Public.Procedures.StPointfromtextE728(this)} 
get StPointfromtext_27e2 () { return new Public.Procedures.StPointfromtext_27e2(this)} 
get StLinefromtextE728 () { return new Public.Procedures.StLinefromtextE728(this)} 
get StLinefromtext_27e2 () { return new Public.Procedures.StLinefromtext_27e2(this)} 
get StPolyfromtextE728 () { return new Public.Procedures.StPolyfromtextE728(this)} 
get StPolyfromtext_27e2 () { return new Public.Procedures.StPolyfromtext_27e2(this)} 
get StPolygonfromtext_27e2 () { return new Public.Procedures.StPolygonfromtext_27e2(this)} 
get StPolygonfromtextE728 () { return new Public.Procedures.StPolygonfromtextE728(this)} 
get StMlinefromtext_27e2 () { return new Public.Procedures.StMlinefromtext_27e2(this)} 
get StMlinefromtextE728 () { return new Public.Procedures.StMlinefromtextE728(this)} 
get StMultilinestringfromtextE728 () { return new Public.Procedures.StMultilinestringfromtextE728(this)} 
get StMultilinestringfromtext_27e2 () { return new Public.Procedures.StMultilinestringfromtext_27e2(this)} 
get StMpointfromtext_27e2 () { return new Public.Procedures.StMpointfromtext_27e2(this)} 
get StMpointfromtextE728 () { return new Public.Procedures.StMpointfromtextE728(this)} 
get StMultipointfromtext () { return new Public.Procedures.StMultipointfromtext(this)} 
get StMpolyfromtext_27e2 () { return new Public.Procedures.StMpolyfromtext_27e2(this)} 
get StMpolyfromtextE728 () { return new Public.Procedures.StMpolyfromtextE728(this)} 
get StMultipolygonfromtext_27e2 () { return new Public.Procedures.StMultipolygonfromtext_27e2(this)} 
get StMultipolygonfromtextE728 () { return new Public.Procedures.StMultipolygonfromtextE728(this)} 
get StGeomcollfromtext_27e2 () { return new Public.Procedures.StGeomcollfromtext_27e2(this)} 
get StGeomcollfromtextE728 () { return new Public.Procedures.StGeomcollfromtextE728(this)} 
get StGeomfromwkb_2d19 () { return new Public.Procedures.StGeomfromwkb_2d19(this)} 
get StGeomfromwkbD8af () { return new Public.Procedures.StGeomfromwkbD8af(this)} 
get StPointfromwkbD8af () { return new Public.Procedures.StPointfromwkbD8af(this)} 
get StPointfromwkb_2d19 () { return new Public.Procedures.StPointfromwkb_2d19(this)} 
get StLinefromwkbD8af () { return new Public.Procedures.StLinefromwkbD8af(this)} 
get StLinefromwkb_2d19 () { return new Public.Procedures.StLinefromwkb_2d19(this)} 
get StLinestringfromwkbD8af () { return new Public.Procedures.StLinestringfromwkbD8af(this)} 
get StLinestringfromwkb_2d19 () { return new Public.Procedures.StLinestringfromwkb_2d19(this)} 
get StPolyfromwkbD8af () { return new Public.Procedures.StPolyfromwkbD8af(this)} 
get StPolyfromwkb_2d19 () { return new Public.Procedures.StPolyfromwkb_2d19(this)} 
get StPolygonfromwkbD8af () { return new Public.Procedures.StPolygonfromwkbD8af(this)} 
get StPolygonfromwkb_2d19 () { return new Public.Procedures.StPolygonfromwkb_2d19(this)} 
get StMpointfromwkbD8af () { return new Public.Procedures.StMpointfromwkbD8af(this)} 
get StMpointfromwkb_2d19 () { return new Public.Procedures.StMpointfromwkb_2d19(this)} 
get StMultipointfromwkbD8af () { return new Public.Procedures.StMultipointfromwkbD8af(this)} 
get GeographyAnalyze () { return new Public.Procedures.GeographyAnalyze(this)} 
get StMultipointfromwkb_2d19 () { return new Public.Procedures.StMultipointfromwkb_2d19(this)} 
get StMultilinefromwkb () { return new Public.Procedures.StMultilinefromwkb(this)} 
get StMlinefromwkbD8af () { return new Public.Procedures.StMlinefromwkbD8af(this)} 
get StMlinefromwkb_2d19 () { return new Public.Procedures.StMlinefromwkb_2d19(this)} 
get StMpolyfromwkbD8af () { return new Public.Procedures.StMpolyfromwkbD8af(this)} 
get StMpolyfromwkb_2d19 () { return new Public.Procedures.StMpolyfromwkb_2d19(this)} 
get StMultipolyfromwkbD8af () { return new Public.Procedures.StMultipolyfromwkbD8af(this)} 
get StMultipolyfromwkb_2d19 () { return new Public.Procedures.StMultipolyfromwkb_2d19(this)} 
get StGeomcollfromwkbD8af () { return new Public.Procedures.StGeomcollfromwkbD8af(this)} 
get StGeomcollfromwkb_2d19 () { return new Public.Procedures.StGeomcollfromwkb_2d19(this)} 
get StMaxdistance () { return new Public.Procedures.StMaxdistance(this)} 
get StClosestpoint_3651 () { return new Public.Procedures.StClosestpoint_3651(this)} 
get StShortestline_3651 () { return new Public.Procedures.StShortestline_3651(this)} 
get StLongestline () { return new Public.Procedures.StLongestline(this)} 
get StSwapordinates () { return new Public.Procedures.StSwapordinates(this)} 
get StFlipcoordinates () { return new Public.Procedures.StFlipcoordinates(this)} 
get StBdpolyfromtext () { return new Public.Procedures.StBdpolyfromtext(this)} 
get StBdmpolyfromtext () { return new Public.Procedures.StBdmpolyfromtext(this)} 
get Unlockrows () { return new Public.Procedures.Unlockrows(this)} 
get Geography_28e9 () { return new Public.Procedures.Geography_28e9(this)} 
get Geography_2d19 () { return new Public.Procedures.Geography_2d19(this)} 
get Bytea_7902 () { return new Public.Procedures.Bytea_7902(this)} 
get StAstext_7902 () { return new Public.Procedures.StAstext_7902(this)} 
get StAstext_3181 () { return new Public.Procedures.StAstext_3181(this)} 
get LockrowE9aa () { return new Public.Procedures.LockrowE9aa(this)} 
get Lockrow_02b4 () { return new Public.Procedures.Lockrow_02b4(this)} 
get Lockrow_27e1 () { return new Public.Procedures.Lockrow_27e1(this)} 
get Lockrow_9a8a () { return new Public.Procedures.Lockrow_9a8a(this)} 
get Addauth () { return new Public.Procedures.Addauth(this)} 
get Checkauth_27e1 () { return new Public.Procedures.Checkauth_27e1(this)} 
get Checkauth_2ec2 () { return new Public.Procedures.Checkauth_2ec2(this)} 
get Checkauthtrigger () { return new Public.Procedures.Checkauthtrigger(this)} 
get Gettransactionid () { return new Public.Procedures.Gettransactionid(this)} 
get Enablelongtransactions () { return new Public.Procedures.Enablelongtransactions(this)} 
get Longtransactionsenabled () { return new Public.Procedures.Longtransactionsenabled(this)} 
get Disablelongtransactions () { return new Public.Procedures.Disablelongtransactions(this)} 
get GeographyTypmodIn () { return new Public.Procedures.GeographyTypmodIn(this)} 
get GeographyTypmodOut () { return new Public.Procedures.GeographyTypmodOut(this)} 
get GeographyIn () { return new Public.Procedures.GeographyIn(this)} 
get GeographyOut () { return new Public.Procedures.GeographyOut(this)} 
get GeographyRecv () { return new Public.Procedures.GeographyRecv(this)} 
get GeographySend () { return new Public.Procedures.GeographySend(this)} 
get StAstextE728 () { return new Public.Procedures.StAstextE728(this)} 
get StGeographyfromtext () { return new Public.Procedures.StGeographyfromtext(this)} 
get StGeogfromtext () { return new Public.Procedures.StGeogfromtext(this)} 
get StGeogfromwkb () { return new Public.Procedures.StGeogfromwkb(this)} 
get PostgisTypmodDims () { return new Public.Procedures.PostgisTypmodDims(this)} 
get PostgisTypmodSrid () { return new Public.Procedures.PostgisTypmodSrid(this)} 
get PostgisTypmodType () { return new Public.Procedures.PostgisTypmodType(this)} 
get Geography_0cdb () { return new Public.Procedures.Geography_0cdb(this)} 
get Geometry_7902 () { return new Public.Procedures.Geometry_7902(this)} 
get GeographyGistConsistent () { return new Public.Procedures.GeographyGistConsistent(this)} 
get GeographyGistCompress () { return new Public.Procedures.GeographyGistCompress(this)} 
get GeographyGistPenalty () { return new Public.Procedures.GeographyGistPenalty(this)} 
get GeographyGistPicksplit () { return new Public.Procedures.GeographyGistPicksplit(this)} 
get GeographyGistUnion () { return new Public.Procedures.GeographyGistUnion(this)} 
get GeographyGistSame () { return new Public.Procedures.GeographyGistSame(this)} 
get GeographyGistDecompress () { return new Public.Procedures.GeographyGistDecompress(this)} 
get GeographyOverlaps () { return new Public.Procedures.GeographyOverlaps(this)} 
get GeographyDistanceKnn () { return new Public.Procedures.GeographyDistanceKnn(this)} 
get GeographyGistDistance () { return new Public.Procedures.GeographyGistDistance(this)} 
get OverlapsGeog_52a8 () { return new Public.Procedures.OverlapsGeog_52a8(this)} 
get OverlapsGeog_25ba () { return new Public.Procedures.OverlapsGeog_25ba(this)} 
get OverlapsGeog_8fd3 () { return new Public.Procedures.OverlapsGeog_8fd3(this)} 
get GeogBrinInclusionAddValue () { return new Public.Procedures.GeogBrinInclusionAddValue(this)} 
get GeographyLt () { return new Public.Procedures.GeographyLt(this)} 
get GeographyLe () { return new Public.Procedures.GeographyLe(this)} 
get GeographyGt () { return new Public.Procedures.GeographyGt(this)} 
get GeographyGe () { return new Public.Procedures.GeographyGe(this)} 
get GeographyEq () { return new Public.Procedures.GeographyEq(this)} 
get GeographyCmp () { return new Public.Procedures.GeographyCmp(this)} 
get StAssvg_6ec5 () { return new Public.Procedures.StAssvg_6ec5(this)} 
get StAssvgE728 () { return new Public.Procedures.StAssvgE728(this)} 
get StProjectD4ec () { return new Public.Procedures.StProjectD4ec(this)} 
get StAzimuthE452 () { return new Public.Procedures.StAzimuthE452(this)} 
get StBuffer_49f7 () { return new Public.Procedures.StBuffer_49f7(this)} 
get StAsgmlE888 () { return new Public.Procedures.StAsgmlE888(this)} 
get StAsgml_2160 () { return new Public.Procedures.StAsgml_2160(this)} 
get StAsgmlE728 () { return new Public.Procedures.StAsgmlE728(this)} 
get StAskmlF40a () { return new Public.Procedures.StAskmlF40a(this)} 
get StAskmlE728 () { return new Public.Procedures.StAskmlE728(this)} 
get StAsgeojson_6ec5 () { return new Public.Procedures.StAsgeojson_6ec5(this)} 
get StAsgeojsonE728 () { return new Public.Procedures.StAsgeojsonE728(this)} 
get StDistance_8dcd () { return new Public.Procedures.StDistance_8dcd(this)} 
get StDistance_2ec2 () { return new Public.Procedures.StDistance_2ec2(this)} 
get StAreaEcae () { return new Public.Procedures.StAreaEcae(this)} 
get StAreaE728 () { return new Public.Procedures.StAreaE728(this)} 
get StLengthEcae () { return new Public.Procedures.StLengthEcae(this)} 
get StLengthE728 () { return new Public.Procedures.StLengthE728(this)} 
get StProjectEd46 () { return new Public.Procedures.StProjectEd46(this)} 
get StPerimeterEcae () { return new Public.Procedures.StPerimeterEcae(this)} 
get StSegmentizeCadf () { return new Public.Procedures.StSegmentizeCadf(this)} 
get StAsbinary_7902 () { return new Public.Procedures.StAsbinary_7902(this)} 
get StAsbinary_734d () { return new Public.Procedures.StAsbinary_734d(this)} 
get StAsewkt_7902 () { return new Public.Procedures.StAsewkt_7902(this)} 
get StAsewkt_3181 () { return new Public.Procedures.StAsewkt_3181(this)} 
get StAsewktE728 () { return new Public.Procedures.StAsewktE728(this)} 
get Geometrytype_7902 () { return new Public.Procedures.Geometrytype_7902(this)} 
get StSummary_7902 () { return new Public.Procedures.StSummary_7902(this)} 
get StGeohash_3181 () { return new Public.Procedures.StGeohash_3181(this)} 
get StSrid_7902 () { return new Public.Procedures.StSrid_7902(this)} 
get StSetsrid_3181 () { return new Public.Procedures.StSetsrid_3181(this)} 
get StCentroidEcae () { return new Public.Procedures.StCentroidEcae(this)} 
get StCentroidE728 () { return new Public.Procedures.StCentroidE728(this)} 
get StCoversE452 () { return new Public.Procedures.StCoversE452(this)} 
get StDwithin_55df () { return new Public.Procedures.StDwithin_55df(this)} 
get StCoveredbyE452 () { return new Public.Procedures.StCoveredbyE452(this)} 
get StIntersectsE452 () { return new Public.Procedures.StIntersectsE452(this)} 
get StBufferCadf () { return new Public.Procedures.StBufferCadf(this)} 
get StBuffer_12e3 () { return new Public.Procedures.StBuffer_12e3(this)} 
get StBuffer_3aaa () { return new Public.Procedures.StBuffer_3aaa(this)} 
get StBufferC349 () { return new Public.Procedures.StBufferC349(this)} 
get StBufferF7c6 () { return new Public.Procedures.StBufferF7c6(this)} 
get StIntersectionE452 () { return new Public.Procedures.StIntersectionE452(this)} 
get StIntersection_2ec2 () { return new Public.Procedures.StIntersection_2ec2(this)} 
get StCovers_2ec2 () { return new Public.Procedures.StCovers_2ec2(this)} 
get StCoveredby_2ec2 () { return new Public.Procedures.StCoveredby_2ec2(this)} 
get StDwithinEfc0 () { return new Public.Procedures.StDwithinEfc0(this)} 
get StIntersects_2ec2 () { return new Public.Procedures.StIntersects_2ec2(this)} 
get StClosestpoint_8dcd () { return new Public.Procedures.StClosestpoint_8dcd(this)} 
get StClosestpoint_2ec2 () { return new Public.Procedures.StClosestpoint_2ec2(this)} 
get StShortestline_8dcd () { return new Public.Procedures.StShortestline_8dcd(this)} 
get StShortestline_2ec2 () { return new Public.Procedures.StShortestline_2ec2(this)} 
get StLinesubstringEd46 () { return new Public.Procedures.StLinesubstringEd46(this)} 
get StLinesubstringE586 () { return new Public.Procedures.StLinesubstringE586(this)} 
get StLinelocatepoint_8dcd () { return new Public.Procedures.StLinelocatepoint_8dcd(this)} 
get StLinelocatepoint_2ec2 () { return new Public.Procedures.StLinelocatepoint_2ec2(this)} 
get StLineinterpolatepoints_8796 () { return new Public.Procedures.StLineinterpolatepoints_8796(this)} 
get StLineinterpolatepointsC349 () { return new Public.Procedures.StLineinterpolatepointsC349(this)} 
get StLineinterpolatepoint_612b () { return new Public.Procedures.StLineinterpolatepoint_612b(this)} 
get StLineinterpolatepointC349 () { return new Public.Procedures.StLineinterpolatepointC349(this)} 
get StDistancesphere_3651 () { return new Public.Procedures.StDistancesphere_3651(this)} 
get StDistancesphere_6961 () { return new Public.Procedures.StDistancesphere_6961(this)} 
get PostgisTypeName () { return new Public.Procedures.PostgisTypeName(this)} 
get PostgisConstraintSrid () { return new Public.Procedures.PostgisConstraintSrid(this)} 
get PostgisConstraintDims () { return new Public.Procedures.PostgisConstraintDims(this)} 
get PostgisConstraintType () { return new Public.Procedures.PostgisConstraintType(this)} 
get St_3ddistance () { return new Public.Procedures.St_3ddistance(this)} 
get St_3dmaxdistance () { return new Public.Procedures.St_3dmaxdistance(this)} 
get St_3dclosestpoint () { return new Public.Procedures.St_3dclosestpoint(this)} 
get St_3dshortestline () { return new Public.Procedures.St_3dshortestline(this)} 
get St_3dlongestline () { return new Public.Procedures.St_3dlongestline(this)} 
get StCoorddim () { return new Public.Procedures.StCoorddim(this)} 
get StCurvetoline () { return new Public.Procedures.StCurvetoline(this)} 
get StHasarc () { return new Public.Procedures.StHasarc(this)} 
get StLinetocurve () { return new Public.Procedures.StLinetocurve(this)} 
get StPoint_0aec () { return new Public.Procedures.StPoint_0aec(this)} 
get StPoint_0b7f () { return new Public.Procedures.StPoint_0b7f(this)} 
get StPointz () { return new Public.Procedures.StPointz(this)} 
get StPointm () { return new Public.Procedures.StPointm(this)} 
get StPointzm () { return new Public.Procedures.StPointzm(this)} 
get StPolygon () { return new Public.Procedures.StPolygon(this)} 
get StWkbtosql () { return new Public.Procedures.StWkbtosql(this)} 
get StLocatebetween () { return new Public.Procedures.StLocatebetween(this)} 
get StLocatealong () { return new Public.Procedures.StLocatealong(this)} 
get StLocatebetweenelevations () { return new Public.Procedures.StLocatebetweenelevations(this)} 
get StInterpolatepoint () { return new Public.Procedures.StInterpolatepoint(this)} 
get StHexagon () { return new Public.Procedures.StHexagon(this)} 
get StSquare () { return new Public.Procedures.StSquare(this)} 
get StHexagongrid () { return new Public.Procedures.StHexagongrid(this)} 
get StSquaregrid () { return new Public.Procedures.StSquaregrid(this)} 
get Contains_2d_3f2a () { return new Public.Procedures.Contains_2d_3f2a(this)} 
get IsContained_2d_3f2a () { return new Public.Procedures.IsContained_2d_3f2a(this)} 
get Overlaps_2d_3f2a () { return new Public.Procedures.Overlaps_2d_3f2a(this)} 
get Overlaps_2d_4f71 () { return new Public.Procedures.Overlaps_2d_4f71(this)} 
get Contains_2d_4f71 () { return new Public.Procedures.Contains_2d_4f71(this)} 
get IsContained_2d_4f71 () { return new Public.Procedures.IsContained_2d_4f71(this)} 
get Contains_2d_7d4f () { return new Public.Procedures.Contains_2d_7d4f(this)} 
get IsContained_2d_7d4f () { return new Public.Procedures.IsContained_2d_7d4f(this)} 
get Overlaps_2d_7d4f () { return new Public.Procedures.Overlaps_2d_7d4f(this)} 
get OverlapsNd_6173 () { return new Public.Procedures.OverlapsNd_6173(this)} 
get OverlapsNd_25ba () { return new Public.Procedures.OverlapsNd_25ba(this)} 
get OverlapsNd_40b7 () { return new Public.Procedures.OverlapsNd_40b7(this)} 
get Geom2dBrinInclusionAddValue () { return new Public.Procedures.Geom2dBrinInclusionAddValue(this)} 
get Geom3dBrinInclusionAddValue () { return new Public.Procedures.Geom3dBrinInclusionAddValue(this)} 
get Geom4dBrinInclusionAddValue () { return new Public.Procedures.Geom4dBrinInclusionAddValue(this)} 
get StSimplifypolygonhull () { return new Public.Procedures.StSimplifypolygonhull(this)} 
get StConcavehull () { return new Public.Procedures.StConcavehull(this)} 
get StAsx3d () { return new Public.Procedures.StAsx3d(this)} 
get StAngle_3651 () { return new Public.Procedures.StAngle_3651(this)} 
get St_3dlineinterpolatepoint () { return new Public.Procedures.St_3dlineinterpolatepoint(this)} 
get GeometrySpgistConfig_2d () { return new Public.Procedures.GeometrySpgistConfig_2d(this)} 
get GeometrySpgistChoose_2d () { return new Public.Procedures.GeometrySpgistChoose_2d(this)} 
get GeometrySpgistPicksplit_2d () { return new Public.Procedures.GeometrySpgistPicksplit_2d(this)} 
get GeometrySpgistInnerConsistent_2d () { return new Public.Procedures.GeometrySpgistInnerConsistent_2d(this)} 
get GeometrySpgistLeafConsistent_2d () { return new Public.Procedures.GeometrySpgistLeafConsistent_2d(this)} 
get GeometrySpgistCompress_2d () { return new Public.Procedures.GeometrySpgistCompress_2d(this)} 
get GeometryOverlaps_3d () { return new Public.Procedures.GeometryOverlaps_3d(this)} 
get GeometryContains_3d () { return new Public.Procedures.GeometryContains_3d(this)} 
get GeometryContained_3d () { return new Public.Procedures.GeometryContained_3d(this)} 
get GeometrySame_3d () { return new Public.Procedures.GeometrySame_3d(this)} 
get GeometrySpgistConfig_3d () { return new Public.Procedures.GeometrySpgistConfig_3d(this)} 
get GeometrySpgistChoose_3d () { return new Public.Procedures.GeometrySpgistChoose_3d(this)} 
get GeometrySpgistPicksplit_3d () { return new Public.Procedures.GeometrySpgistPicksplit_3d(this)} 
get GeometrySpgistInnerConsistent_3d () { return new Public.Procedures.GeometrySpgistInnerConsistent_3d(this)} 
get GeometrySpgistLeafConsistent_3d () { return new Public.Procedures.GeometrySpgistLeafConsistent_3d(this)} 
get GeometrySpgistCompress_3d () { return new Public.Procedures.GeometrySpgistCompress_3d(this)} 
get GeometrySpgistConfigNd () { return new Public.Procedures.GeometrySpgistConfigNd(this)} 
get GeometrySpgistChooseNd () { return new Public.Procedures.GeometrySpgistChooseNd(this)} 
get GeometrySpgistPicksplitNd () { return new Public.Procedures.GeometrySpgistPicksplitNd(this)} 
get GeometrySpgistInnerConsistentNd () { return new Public.Procedures.GeometrySpgistInnerConsistentNd(this)} 
get GeometrySpgistLeafConsistentNd () { return new Public.Procedures.GeometrySpgistLeafConsistentNd(this)} 
get GeometrySpgistCompressNd () { return new Public.Procedures.GeometrySpgistCompressNd(this)} 
get GeographySpgistConfigNd () { return new Public.Procedures.GeographySpgistConfigNd(this)} 
get GeographySpgistChooseNd () { return new Public.Procedures.GeographySpgistChooseNd(this)} 
get GeographySpgistPicksplitNd () { return new Public.Procedures.GeographySpgistPicksplitNd(this)} 
get GeographySpgistInnerConsistentNd () { return new Public.Procedures.GeographySpgistInnerConsistentNd(this)} 
get GeographySpgistLeafConsistentNd () { return new Public.Procedures.GeographySpgistLeafConsistentNd(this)} 
get GeographySpgistCompressNd () { return new Public.Procedures.GeographySpgistCompressNd(this)} 
get StLetters () { return new Public.Procedures.StLetters(this)} 
}
}
export namespace Public {
export namespace Procedures {
export class StForcepolygoncw implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcepolygoncw"; }
async call(parameters : Public.Procedures.StForcepolygoncw.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcepolygoncw( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcepolygoncw) );
              return responseBody;
           
}
}
export class SpheroidIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "spheroid_in"; }
async call(parameters : Public.Procedures.SpheroidIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Spheroid.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.spheroid_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Spheroid.parse(results?.[0].spheroid_in) );
              return responseBody;
           
}
}
export class SpheroidOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "spheroid_out"; }
async call(parameters : Public.Procedures.SpheroidOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.spheroid_out( ${ typed[47254](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].spheroid_out) );
              return responseBody;
           
}
}
export class GeometryIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_in"; }
async call(parameters : Public.Procedures.GeometryIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry_in) );
              return responseBody;
           
}
}
export class GeometryOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_out"; }
async call(parameters : Public.Procedures.GeometryOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_out( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geometry_out) );
              return responseBody;
           
}
}
export class GeometryTypmodIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_typmod_in"; }
async call(parameters : Public.Procedures.GeometryTypmodIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_typmod_in( ${ typed[1263](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_typmod_in) );
              return responseBody;
           
}
}
export class GeometryTypmodOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_typmod_out"; }
async call(parameters : Public.Procedures.GeometryTypmodOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_typmod_out( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geometry_typmod_out) );
              return responseBody;
           
}
}
export class GeometryAnalyze implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_analyze"; }
async call(parameters : Public.Procedures.GeometryAnalyze.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_analyze( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_analyze) );
              return responseBody;
           
}
}
export class GeometryRecv implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_recv"; }
async call(parameters : Public.Procedures.GeometryRecv.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_recv( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry_recv) );
              return responseBody;
           
}
}
export class GeometrySend implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_send"; }
async call(parameters : Public.Procedures.GeometrySend.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_send( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].geometry_send) );
              return responseBody;
           
}
}
export class Geometry_6564 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_6564"; }
async call(parameters : Public.Procedures.Geometry_6564.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Geometry_8997 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_8997"; }
async call(parameters : Public.Procedures.Geometry_8997.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[600](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Point implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "point"; }
async call(parameters : Public.Procedures.Point.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Point.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.point( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Point.parse(results?.[0].point) );
              return responseBody;
           
}
}
export class GeometryB0d8 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_b0d8"; }
async call(parameters : Public.Procedures.GeometryB0d8.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[602](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Path implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "path"; }
async call(parameters : Public.Procedures.Path.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Path.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.path( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Path.parse(results?.[0].path) );
              return responseBody;
           
}
}
export class GeometryF1be implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_f1be"; }
async call(parameters : Public.Procedures.GeometryF1be.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[604](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Polygon implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "polygon"; }
async call(parameters : Public.Procedures.Polygon.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Polygon.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.polygon( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Polygon.parse(results?.[0].polygon) );
              return responseBody;
           
}
}
export class StX implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_x"; }
async call(parameters : Public.Procedures.StX.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_x( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_x) );
              return responseBody;
           
}
}
export class StY implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_y"; }
async call(parameters : Public.Procedures.StY.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_y( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_y) );
              return responseBody;
           
}
}
export class StZ implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_z"; }
async call(parameters : Public.Procedures.StZ.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_z( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_z) );
              return responseBody;
           
}
}
export class StM implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_m"; }
async call(parameters : Public.Procedures.StM.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_m( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_m) );
              return responseBody;
           
}
}
export class Box3dIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box3d_in"; }
async call(parameters : Public.Procedures.Box3dIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box3d_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d_in) );
              return responseBody;
           
}
}
export class Box3dOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box3d_out"; }
async call(parameters : Public.Procedures.Box3dOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box3d_out( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box3d_out) );
              return responseBody;
           
}
}
export class Box2dIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2d_in"; }
async call(parameters : Public.Procedures.Box2dIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2d_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d_in) );
              return responseBody;
           
}
}
export class Box2dOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2d_out"; }
async call(parameters : Public.Procedures.Box2dOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2d_out( ${ typed[47289](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box2d_out) );
              return responseBody;
           
}
}
export class Box2dfIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2df_in"; }
async call(parameters : Public.Procedures.Box2dfIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2df.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2df_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2df.parse(results?.[0].box2df_in) );
              return responseBody;
           
}
}
export class Box2dfOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2df_out"; }
async call(parameters : Public.Procedures.Box2dfOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2df_out( ${ typed[47293](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].box2df_out) );
              return responseBody;
           
}
}
export class GidxIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gidx_in"; }
async call(parameters : Public.Procedures.GidxIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Gidx.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gidx_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Gidx.parse(results?.[0].gidx_in) );
              return responseBody;
           
}
}
export class GidxOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gidx_out"; }
async call(parameters : Public.Procedures.GidxOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gidx_out( ${ typed[47297](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].gidx_out) );
              return responseBody;
           
}
}
export class GeometryLt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_lt"; }
async call(parameters : Public.Procedures.GeometryLt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_lt(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_lt) );
              return responseBody;
           
}
}
export class GeometryLe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_le"; }
async call(parameters : Public.Procedures.GeometryLe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_le(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_le) );
              return responseBody;
           
}
}
export class GeometryGt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gt"; }
async call(parameters : Public.Procedures.GeometryGt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gt(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gt) );
              return responseBody;
           
}
}
export class GeometryGe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_ge"; }
async call(parameters : Public.Procedures.GeometryGe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_ge(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_ge) );
              return responseBody;
           
}
}
export class GeometryEq implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_eq"; }
async call(parameters : Public.Procedures.GeometryEq.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_eq(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_eq) );
              return responseBody;
           
}
}
export class GeometryCmp implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_cmp"; }
async call(parameters : Public.Procedures.GeometryCmp.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_cmp(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_cmp) );
              return responseBody;
           
}
}
export class GeometrySortsupport implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_sortsupport"; }
async call(parameters : Public.Procedures.GeometrySortsupport.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_sortsupport( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_sortsupport) );
              return responseBody;
           
}
}
export class GeometryHash implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_hash"; }
async call(parameters : Public.Procedures.GeometryHash.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_hash( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geometry_hash) );
              return responseBody;
           
}
}
export class GeometryGistDistance_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_distance_2d"; }
async call(parameters : Public.Procedures.GeometryGistDistance_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_distance_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_gist_distance_2d) );
              return responseBody;
           
}
}
export class GeometryGistConsistent_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_consistent_2d"; }
async call(parameters : Public.Procedures.GeometryGistConsistent_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gist_consistent_2d) );
              return responseBody;
           
}
}
export class GeometryGistCompress_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_compress_2d"; }
async call(parameters : Public.Procedures.GeometryGistCompress_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_compress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_compress_2d) );
              return responseBody;
           
}
}
export class GeometryGistPenalty_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_penalty_2d"; }
async call(parameters : Public.Procedures.GeometryGistPenalty_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_penalty_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_penalty_2d) );
              return responseBody;
           
}
}
export class GeometryGistPicksplit_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_picksplit_2d"; }
async call(parameters : Public.Procedures.GeometryGistPicksplit_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_picksplit_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_picksplit_2d) );
              return responseBody;
           
}
}
export class GeometryGistUnion_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_union_2d"; }
async call(parameters : Public.Procedures.GeometryGistUnion_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_union_2d( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_union_2d) );
              return responseBody;
           
}
}
export class GeometryGistSame_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_same_2d"; }
async call(parameters : Public.Procedures.GeometryGistSame_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_same_2d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_same_2d) );
              return responseBody;
           
}
}
export class GeometryGistDecompress_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_decompress_2d"; }
async call(parameters : Public.Procedures.GeometryGistDecompress_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_decompress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_decompress_2d) );
              return responseBody;
           
}
}
export class GeometryGistSortsupport_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_sortsupport_2d"; }
async call(parameters : Public.Procedures.GeometryGistSortsupport_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_sortsupport_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_gist_sortsupport_2d) );
              return responseBody;
           
}
}
export class StForcerhr implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcerhr"; }
async call(parameters : Public.Procedures.StForcerhr.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcerhr( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcerhr) );
              return responseBody;
           
}
}
export class PostgisNoop implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_noop"; }
async call(parameters : Public.Procedures.PostgisNoop.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_noop( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_noop) );
              return responseBody;
           
}
}
export class StForcepolygonccw implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcepolygonccw"; }
async call(parameters : Public.Procedures.StForcepolygonccw.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcepolygonccw( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcepolygonccw) );
              return responseBody;
           
}
}
export class GserializedGistSel_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gserialized_gist_sel_2d"; }
async call(parameters : Public.Procedures.GserializedGistSel_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gserialized_gist_sel_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_sel_2d) );
              return responseBody;
           
}
}
export class GserializedGistSelNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gserialized_gist_sel_nd"; }
async call(parameters : Public.Procedures.GserializedGistSelNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gserialized_gist_sel_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_sel_nd) );
              return responseBody;
           
}
}
export class GserializedGistJoinsel_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gserialized_gist_joinsel_2d"; }
async call(parameters : Public.Procedures.GserializedGistJoinsel_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gserialized_gist_joinsel_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[21](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_joinsel_2d) );
              return responseBody;
           
}
}
export class GserializedGistJoinselNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gserialized_gist_joinsel_nd"; }
async call(parameters : Public.Procedures.GserializedGistJoinselNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gserialized_gist_joinsel_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[21](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].gserialized_gist_joinsel_nd) );
              return responseBody;
           
}
}
export class GeometryOverlaps implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overlaps"; }
async call(parameters : Public.Procedures.GeometryOverlaps.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overlaps(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps) );
              return responseBody;
           
}
}
export class GeometrySame implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_same"; }
async call(parameters : Public.Procedures.GeometrySame.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_same(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same) );
              return responseBody;
           
}
}
export class GeometryDistanceCentroid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_distance_centroid"; }
async call(parameters : Public.Procedures.GeometryDistanceCentroid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_distance_centroid(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_centroid) );
              return responseBody;
           
}
}
export class GeometryDistanceBox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_distance_box"; }
async call(parameters : Public.Procedures.GeometryDistanceBox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_distance_box(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_box) );
              return responseBody;
           
}
}
export class GeometryContains implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_contains"; }
async call(parameters : Public.Procedures.GeometryContains.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_contains(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains) );
              return responseBody;
           
}
}
export class GeometryWithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_within"; }
async call(parameters : Public.Procedures.GeometryWithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_within(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_within) );
              return responseBody;
           
}
}
export class GeometryLeft implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_left"; }
async call(parameters : Public.Procedures.GeometryLeft.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_left(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_left) );
              return responseBody;
           
}
}
export class GeometryOverleft implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overleft"; }
async call(parameters : Public.Procedures.GeometryOverleft.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overleft(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overleft) );
              return responseBody;
           
}
}
export class GeometryBelow implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_below"; }
async call(parameters : Public.Procedures.GeometryBelow.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_below(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_below) );
              return responseBody;
           
}
}
export class GeometryOverbelow implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overbelow"; }
async call(parameters : Public.Procedures.GeometryOverbelow.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overbelow(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overbelow) );
              return responseBody;
           
}
}
export class GeometryOverright implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overright"; }
async call(parameters : Public.Procedures.GeometryOverright.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overright(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overright) );
              return responseBody;
           
}
}
export class GeometryRight implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_right"; }
async call(parameters : Public.Procedures.GeometryRight.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_right(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_right) );
              return responseBody;
           
}
}
export class GeometryOverabove implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overabove"; }
async call(parameters : Public.Procedures.GeometryOverabove.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overabove(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overabove) );
              return responseBody;
           
}
}
export class GeometryAbove implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_above"; }
async call(parameters : Public.Procedures.GeometryAbove.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_above(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_above) );
              return responseBody;
           
}
}
export class GeometryGistConsistentNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_consistent_nd"; }
async call(parameters : Public.Procedures.GeometryGistConsistentNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_gist_consistent_nd) );
              return responseBody;
           
}
}
export class GeometryGistCompressNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_compress_nd"; }
async call(parameters : Public.Procedures.GeometryGistCompressNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_compress_nd) );
              return responseBody;
           
}
}
export class GeometryGistPenaltyNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_penalty_nd"; }
async call(parameters : Public.Procedures.GeometryGistPenaltyNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_penalty_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_penalty_nd) );
              return responseBody;
           
}
}
export class GeometryGistPicksplitNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_picksplit_nd"; }
async call(parameters : Public.Procedures.GeometryGistPicksplitNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_picksplit_nd) );
              return responseBody;
           
}
}
export class GeometryGistUnionNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_union_nd"; }
async call(parameters : Public.Procedures.GeometryGistUnionNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_union_nd( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_union_nd) );
              return responseBody;
           
}
}
export class GeometryGistSameNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_same_nd"; }
async call(parameters : Public.Procedures.GeometryGistSameNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_same_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_same_nd) );
              return responseBody;
           
}
}
export class GeometryGistDecompressNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_decompress_nd"; }
async call(parameters : Public.Procedures.GeometryGistDecompressNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_decompress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_gist_decompress_nd) );
              return responseBody;
           
}
}
export class GeometryOverlapsNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overlaps_nd"; }
async call(parameters : Public.Procedures.GeometryOverlapsNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overlaps_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps_nd) );
              return responseBody;
           
}
}
export class GeometryContainsNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_contains_nd"; }
async call(parameters : Public.Procedures.GeometryContainsNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_contains_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains_nd) );
              return responseBody;
           
}
}
export class GeometryWithinNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_within_nd"; }
async call(parameters : Public.Procedures.GeometryWithinNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_within_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_within_nd) );
              return responseBody;
           
}
}
export class GeometrySameNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_same_nd"; }
async call(parameters : Public.Procedures.GeometrySameNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_same_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same_nd) );
              return responseBody;
           
}
}
export class GeometryDistanceCentroidNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_distance_centroid_nd"; }
async call(parameters : Public.Procedures.GeometryDistanceCentroidNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_distance_centroid_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_centroid_nd) );
              return responseBody;
           
}
}
export class GeometryDistanceCpa implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_distance_cpa"; }
async call(parameters : Public.Procedures.GeometryDistanceCpa.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_distance_cpa( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_distance_cpa) );
              return responseBody;
           
}
}
export class GeometryGistDistanceNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_gist_distance_nd"; }
async call(parameters : Public.Procedures.GeometryGistDistanceNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_gist_distance_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geometry_gist_distance_nd) );
              return responseBody;
           
}
}
export class StShiftlongitude implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_shiftlongitude"; }
async call(parameters : Public.Procedures.StShiftlongitude.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_shiftlongitude( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shiftlongitude) );
              return responseBody;
           
}
}
export class StWrapx implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_wrapx"; }
async call(parameters : Public.Procedures.StWrapx.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_wrapx(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },wrap => ${ typed[701](undefinedIsNull(parameters.wrap)) },move => ${ typed[701](undefinedIsNull(parameters.move)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wrapx) );
              return responseBody;
           
}
}
export class StXmin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_xmin"; }
async call(parameters : Public.Procedures.StXmin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_xmin( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_xmin) );
              return responseBody;
           
}
}
export class StYmin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ymin"; }
async call(parameters : Public.Procedures.StYmin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ymin( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_ymin) );
              return responseBody;
           
}
}
export class StZmin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_zmin"; }
async call(parameters : Public.Procedures.StZmin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_zmin( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_zmin) );
              return responseBody;
           
}
}
export class StXmax implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_xmax"; }
async call(parameters : Public.Procedures.StXmax.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_xmax( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_xmax) );
              return responseBody;
           
}
}
export class StYmax implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ymax"; }
async call(parameters : Public.Procedures.StYmax.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ymax( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_ymax) );
              return responseBody;
           
}
}
export class StZmax implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_zmax"; }
async call(parameters : Public.Procedures.StZmax.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_zmax( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_zmax) );
              return responseBody;
           
}
}
export class StExpand_269a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_269a"; }
async call(parameters : Public.Procedures.StExpand_269a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand( ${ typed[47289](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class StExpand_96e3 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_96e3"; }
async call(parameters : Public.Procedures.StExpand_96e3.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand(box => ${ typed[47289](undefinedIsNull(parameters.box)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class PostgisGetbbox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_getbbox"; }
async call(parameters : Public.Procedures.PostgisGetbbox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_getbbox( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].postgis_getbbox) );
              return responseBody;
           
}
}
export class StMakebox2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makebox2d"; }
async call(parameters : Public.Procedures.StMakebox2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makebox2d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_makebox2d) );
              return responseBody;
           
}
}
export class StEstimatedextentD2f5 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_estimatedextent_d2f5"; }
async call(parameters : Public.Procedures.StEstimatedextentD2f5.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[16](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}
export class StEstimatedextent_27e1 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_estimatedextent_27e1"; }
async call(parameters : Public.Procedures.StEstimatedextent_27e1.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}
export class StEstimatedextent_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_estimatedextent_2ec2"; }
async call(parameters : Public.Procedures.StEstimatedextent_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_estimatedextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_estimatedextent) );
              return responseBody;
           
}
}
export class StFindextent_27e1 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_findextent_27e1"; }
async call(parameters : Public.Procedures.StFindextent_27e1.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_findextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_findextent) );
              return responseBody;
           
}
}
export class StFindextent_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_findextent_2ec2"; }
async call(parameters : Public.Procedures.StFindextent_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_findextent( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_findextent) );
              return responseBody;
           
}
}
export class PostgisAddbbox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_addbbox"; }
async call(parameters : Public.Procedures.PostgisAddbbox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_addbbox( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_addbbox) );
              return responseBody;
           
}
}
export class PostgisDropbbox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_dropbbox"; }
async call(parameters : Public.Procedures.PostgisDropbbox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_dropbbox( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_dropbbox) );
              return responseBody;
           
}
}
export class PostgisHasbbox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_hasbbox"; }
async call(parameters : Public.Procedures.PostgisHasbbox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_hasbbox( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].postgis_hasbbox) );
              return responseBody;
           
}
}
export class StQuantizecoordinates implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_quantizecoordinates"; }
async call(parameters : Public.Procedures.StQuantizecoordinates.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_quantizecoordinates(g => ${ typed[47258](undefinedIsNull(parameters.g)) },prec_x => ${ typed[23](undefinedIsNull(parameters.precX)) },prec_y => ${ typed[23](undefinedIsNull(parameters.precY)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_quantizecoordinates) );
              return responseBody;
           
}
}
export class StMemsize implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_memsize"; }
async call(parameters : Public.Procedures.StMemsize.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_memsize( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_memsize) );
              return responseBody;
           
}
}
export class StSummary_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_summary_0cdb"; }
async call(parameters : Public.Procedures.StSummary_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_summary( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_summary) );
              return responseBody;
           
}
}
export class StNpoints implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_npoints"; }
async call(parameters : Public.Procedures.StNpoints.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_npoints( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_npoints) );
              return responseBody;
           
}
}
export class StNrings implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_nrings"; }
async call(parameters : Public.Procedures.StNrings.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_nrings( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_nrings) );
              return responseBody;
           
}
}
export class St_3dlength implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dlength"; }
async call(parameters : Public.Procedures.St_3dlength.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dlength( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dlength) );
              return responseBody;
           
}
}
export class StLength2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_length2d"; }
async call(parameters : Public.Procedures.StLength2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_length2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length2d) );
              return responseBody;
           
}
}
export class StLength_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_length_0cdb"; }
async call(parameters : Public.Procedures.StLength_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_length( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}
export class StLengthspheroid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lengthspheroid"; }
async call(parameters : Public.Procedures.StLengthspheroid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lengthspheroid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47254](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_lengthspheroid) );
              return responseBody;
           
}
}
export class StLength2dspheroid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_length2dspheroid"; }
async call(parameters : Public.Procedures.StLength2dspheroid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_length2dspheroid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47254](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length2dspheroid) );
              return responseBody;
           
}
}
export class St_3dperimeter implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dperimeter"; }
async call(parameters : Public.Procedures.St_3dperimeter.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dperimeter( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dperimeter) );
              return responseBody;
           
}
}
export class StPerimeter2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_perimeter2d"; }
async call(parameters : Public.Procedures.StPerimeter2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_perimeter2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter2d) );
              return responseBody;
           
}
}
export class StPerimeter_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_perimeter_0cdb"; }
async call(parameters : Public.Procedures.StPerimeter_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_perimeter( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter) );
              return responseBody;
           
}
}
export class StArea2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_area2d"; }
async call(parameters : Public.Procedures.StArea2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_area2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area2d) );
              return responseBody;
           
}
}
export class StArea_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_area_0cdb"; }
async call(parameters : Public.Procedures.StArea_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_area( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}
export class StIspolygoncw implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ispolygoncw"; }
async call(parameters : Public.Procedures.StIspolygoncw.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ispolygoncw( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_ispolygoncw) );
              return responseBody;
           
}
}
export class StIspolygonccw implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ispolygonccw"; }
async call(parameters : Public.Procedures.StIspolygonccw.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ispolygonccw( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_ispolygonccw) );
              return responseBody;
           
}
}
export class StDistancespheroidCd56 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distancespheroid_cd56"; }
async call(parameters : Public.Procedures.StDistancespheroidCd56.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distancespheroid(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[47254](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancespheroid) );
              return responseBody;
           
}
}
export class StDistancespheroid_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distancespheroid_3651"; }
async call(parameters : Public.Procedures.StDistancespheroid_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distancespheroid(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancespheroid) );
              return responseBody;
           
}
}
export class StDistance_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distance_3651"; }
async call(parameters : Public.Procedures.StDistance_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}
export class StPointinsidecircle implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointinsidecircle"; }
async call(parameters : Public.Procedures.StPointinsidecircle.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointinsidecircle( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_pointinsidecircle) );
              return responseBody;
           
}
}
export class StAzimuth_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_azimuth_3651"; }
async call(parameters : Public.Procedures.StAzimuth_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_azimuth(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_azimuth) );
              return responseBody;
           
}
}
export class StProjectD5eb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_project_d5eb"; }
async call(parameters : Public.Procedures.StProjectD5eb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_project(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },azimuth => ${ typed[701](undefinedIsNull(parameters.azimuth)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_project) );
              return responseBody;
           
}
}
export class StProject_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_project_6961"; }
async call(parameters : Public.Procedures.StProject_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_project(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_project) );
              return responseBody;
           
}
}
export class StAngleE1dd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_angle_e1dd"; }
async call(parameters : Public.Procedures.StAngleE1dd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_angle(pt1 => ${ typed[47258](undefinedIsNull(parameters.pt1)) },pt2 => ${ typed[47258](undefinedIsNull(parameters.pt2)) },pt3 => ${ typed[47258](undefinedIsNull(parameters.pt3)) },pt4 => ${ typed[47258](undefinedIsNull(parameters.pt4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_angle) );
              return responseBody;
           
}
}
export class StLineextend implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineextend"; }
async call(parameters : Public.Procedures.StLineextend.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineextend(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },distance_forward => ${ typed[701](undefinedIsNull(parameters.distanceForward)) },distance_backward => ${ typed[701](undefinedIsNull(parameters.distanceBackward)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineextend) );
              return responseBody;
           
}
}
export class StForce2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_force2d"; }
async call(parameters : Public.Procedures.StForce2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_force2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force2d) );
              return responseBody;
           
}
}
export class StForce3dz implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_force3dz"; }
async call(parameters : Public.Procedures.StForce3dz.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_force3dz(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3dz) );
              return responseBody;
           
}
}
export class StForce3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_force3d"; }
async call(parameters : Public.Procedures.StForce3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_force3d(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3d) );
              return responseBody;
           
}
}
export class StForce3dm implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_force3dm"; }
async call(parameters : Public.Procedures.StForce3dm.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_force3dm(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },mvalue => ${ typed[701](undefinedIsNull(parameters.mvalue)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force3dm) );
              return responseBody;
           
}
}
export class StForce4d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_force4d"; }
async call(parameters : Public.Procedures.StForce4d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_force4d(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },zvalue => ${ typed[701](undefinedIsNull(parameters.zvalue)) },mvalue => ${ typed[701](undefinedIsNull(parameters.mvalue)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_force4d) );
              return responseBody;
           
}
}
export class StForcecollection implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcecollection"; }
async call(parameters : Public.Procedures.StForcecollection.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcecollection( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcecollection) );
              return responseBody;
           
}
}
export class StCollectionextract_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_collectionextract_6cbe"; }
async call(parameters : Public.Procedures.StCollectionextract_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_collectionextract( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionextract) );
              return responseBody;
           
}
}
export class StCollectionextract_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_collectionextract_0cdb"; }
async call(parameters : Public.Procedures.StCollectionextract_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_collectionextract( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionextract) );
              return responseBody;
           
}
}
export class StCollectionhomogenize implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_collectionhomogenize"; }
async call(parameters : Public.Procedures.StCollectionhomogenize.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_collectionhomogenize( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collectionhomogenize) );
              return responseBody;
           
}
}
export class StMulti implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multi"; }
async call(parameters : Public.Procedures.StMulti.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multi( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multi) );
              return responseBody;
           
}
}
export class StForcecurve implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcecurve"; }
async call(parameters : Public.Procedures.StForcecurve.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcecurve( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcecurve) );
              return responseBody;
           
}
}
export class StForcesfs_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcesfs_0cdb"; }
async call(parameters : Public.Procedures.StForcesfs_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcesfs( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcesfs) );
              return responseBody;
           
}
}
export class StForcesfs_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_forcesfs_88bc"; }
async call(parameters : Public.Procedures.StForcesfs_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_forcesfs(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) },version => ${ typed[25](undefinedIsNull(parameters.version)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_forcesfs) );
              return responseBody;
           
}
}
export class StExpand_2074 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_2074"; }
async call(parameters : Public.Procedures.StExpand_2074.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand( ${ typed[47285](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class StExpand_704e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_704e"; }
async call(parameters : Public.Procedures.StExpand_704e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand(box => ${ typed[47285](undefinedIsNull(parameters.box)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) },dz => ${ typed[701](undefinedIsNull(parameters.dz)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class StExpand_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_7163"; }
async call(parameters : Public.Procedures.StExpand_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class StExpand_5500 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_expand_5500"; }
async call(parameters : Public.Procedures.StExpand_5500.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_expand(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },dx => ${ typed[701](undefinedIsNull(parameters.dx)) },dy => ${ typed[701](undefinedIsNull(parameters.dy)) },dz => ${ typed[701](undefinedIsNull(parameters.dz)) },dm => ${ typed[701](undefinedIsNull(parameters.dm)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_expand) );
              return responseBody;
           
}
}
export class StEnvelope implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_envelope"; }
async call(parameters : Public.Procedures.StEnvelope.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_envelope( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_envelope) );
              return responseBody;
           
}
}
export class StBoundingdiagonal implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_boundingdiagonal"; }
async call(parameters : Public.Procedures.StBoundingdiagonal.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_boundingdiagonal(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },fits => ${ typed[16](undefinedIsNull(parameters.fits)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_boundingdiagonal) );
              return responseBody;
           
}
}
export class StReverse implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_reverse"; }
async call(parameters : Public.Procedures.StReverse.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_reverse( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_reverse) );
              return responseBody;
           
}
}
export class StScroll implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_scroll"; }
async call(parameters : Public.Procedures.StScroll.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_scroll( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scroll) );
              return responseBody;
           
}
}
export class PostgisGeosNoop implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_geos_noop"; }
async call(parameters : Public.Procedures.PostgisGeosNoop.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_geos_noop( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_geos_noop) );
              return responseBody;
           
}
}
export class StNormalize implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_normalize"; }
async call(parameters : Public.Procedures.StNormalize.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_normalize(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_normalize) );
              return responseBody;
           
}
}
export class StZmflag implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_zmflag"; }
async call(parameters : Public.Procedures.StZmflag.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_zmflag( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_zmflag) );
              return responseBody;
           
}
}
export class StNdims implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ndims"; }
async call(parameters : Public.Procedures.StNdims.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ndims( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_ndims) );
              return responseBody;
           
}
}
export class StAsewkt_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkt_0cdb"; }
async call(parameters : Public.Procedures.StAsewkt_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkt( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}
export class StAsewkt_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkt_6cbe"; }
async call(parameters : Public.Procedures.StAsewkt_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkt( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}
export class StAstwkb_652e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astwkb_652e"; }
async call(parameters : Public.Procedures.StAstwkb_652e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astwkb(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },prec => ${ typed[23](undefinedIsNull(parameters.prec)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) },with_sizes => ${ typed[16](undefinedIsNull(parameters.withSizes)) },with_boxes => ${ typed[16](undefinedIsNull(parameters.withBoxes)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_astwkb) );
              return responseBody;
           
}
}
export class StAstwkbF3fd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astwkb_f3fd"; }
async call(parameters : Public.Procedures.StAstwkbF3fd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astwkb(geom => ${ typed[47266](undefinedIsNull(parameters.geom)) },ids => ${ typed[1016](undefinedIsNull(parameters.ids)) },prec => ${ typed[23](undefinedIsNull(parameters.prec)) },prec_z => ${ typed[23](undefinedIsNull(parameters.precZ)) },prec_m => ${ typed[23](undefinedIsNull(parameters.precM)) },with_sizes => ${ typed[16](undefinedIsNull(parameters.withSizes)) },with_boxes => ${ typed[16](undefinedIsNull(parameters.withBoxes)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_astwkb) );
              return responseBody;
           
}
}
export class StAsewkb_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkb_0cdb"; }
async call(parameters : Public.Procedures.StAsewkb_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkb( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asewkb) );
              return responseBody;
           
}
}
export class StAshexewkb_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ashexewkb_0cdb"; }
async call(parameters : Public.Procedures.StAshexewkb_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ashexewkb( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_ashexewkb) );
              return responseBody;
           
}
}
export class StAshexewkb_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_ashexewkb_88bc"; }
async call(parameters : Public.Procedures.StAshexewkb_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_ashexewkb( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_ashexewkb) );
              return responseBody;
           
}
}
export class StAsewkb_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkb_88bc"; }
async call(parameters : Public.Procedures.StAsewkb_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkb( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asewkb) );
              return responseBody;
           
}
}
export class StAslatlontext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_aslatlontext"; }
async call(parameters : Public.Procedures.StAslatlontext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_aslatlontext(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },tmpl => ${ typed[25](undefinedIsNull(parameters.tmpl)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_aslatlontext) );
              return responseBody;
           
}
}
export class Geomfromewkb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geomfromewkb"; }
async call(parameters : Public.Procedures.Geomfromewkb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geomfromewkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geomfromewkb) );
              return responseBody;
           
}
}
export class StGeomfromewkb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromewkb"; }
async call(parameters : Public.Procedures.StGeomfromewkb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromewkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromewkb) );
              return responseBody;
           
}
}
export class StGeomfromtwkb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromtwkb"; }
async call(parameters : Public.Procedures.StGeomfromtwkb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromtwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtwkb) );
              return responseBody;
           
}
}
export class Geomfromewkt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geomfromewkt"; }
async call(parameters : Public.Procedures.Geomfromewkt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geomfromewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geomfromewkt) );
              return responseBody;
           
}
}
export class StGeomfromewkt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromewkt"; }
async call(parameters : Public.Procedures.StGeomfromewkt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromewkt) );
              return responseBody;
           
}
}
export class PostgisCacheBbox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_cache_bbox"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Trigger.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_cache_bbox()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Trigger.parse(results?.[0].postgis_cache_bbox) );
              return responseBody;
           
}
}
export class StMakepoint_0aec implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepoint_0aec"; }
async call(parameters : Public.Procedures.StMakepoint_0aec.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}
export class StMakepoint_81ec implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepoint_81ec"; }
async call(parameters : Public.Procedures.StMakepoint_81ec.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}
export class StMakepoint_570b implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepoint_570b"; }
async call(parameters : Public.Procedures.StMakepoint_570b.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepoint( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepoint) );
              return responseBody;
           
}
}
export class StMakepointm implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepointm"; }
async call(parameters : Public.Procedures.StMakepointm.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepointm( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepointm) );
              return responseBody;
           
}
}
export class St_3dmakebox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dmakebox"; }
async call(parameters : Public.Procedures.St_3dmakebox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dmakebox(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_3dmakebox) );
              return responseBody;
           
}
}
export class StMakelineA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makeline_a4b6"; }
async call(parameters : Public.Procedures.StMakelineA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makeline( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeline) );
              return responseBody;
           
}
}
export class StLinefrommultipoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefrommultipoint"; }
async call(parameters : Public.Procedures.StLinefrommultipoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefrommultipoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefrommultipoint) );
              return responseBody;
           
}
}
export class StMakeline_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makeline_3651"; }
async call(parameters : Public.Procedures.StMakeline_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makeline(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeline) );
              return responseBody;
           
}
}
export class StAddpoint_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_addpoint_3651"; }
async call(parameters : Public.Procedures.StAddpoint_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_addpoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addpoint) );
              return responseBody;
           
}
}
export class StScaleD5eb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_scale_d5eb"; }
async call(parameters : Public.Procedures.StScaleD5eb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_scale( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}
export class StAddpointAa17 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_addpoint_aa17"; }
async call(parameters : Public.Procedures.StAddpointAa17.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_addpoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addpoint) );
              return responseBody;
           
}
}
export class StRemovepoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_removepoint"; }
async call(parameters : Public.Procedures.StRemovepoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_removepoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_removepoint) );
              return responseBody;
           
}
}
export class StSetpoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_setpoint"; }
async call(parameters : Public.Procedures.StSetpoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_setpoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[47258](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_setpoint) );
              return responseBody;
           
}
}
export class StMakeenvelope implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makeenvelope"; }
async call(parameters : Public.Procedures.StMakeenvelope.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makeenvelope( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[23](undefinedIsNull(parameters.argument_4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makeenvelope) );
              return responseBody;
           
}
}
export class StTileenvelope implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_tileenvelope"; }
async call(parameters : Public.Procedures.StTileenvelope.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_tileenvelope(zoom => ${ typed[23](undefinedIsNull(parameters.zoom)) },x => ${ typed[23](undefinedIsNull(parameters.x)) },y => ${ typed[23](undefinedIsNull(parameters.y)) },bounds => ${ typed[47258](undefinedIsNull(parameters.bounds)) },margin => ${ typed[701](undefinedIsNull(parameters.margin)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_tileenvelope) );
              return responseBody;
           
}
}
export class StMakepolygonE2e3 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepolygon_e2e3"; }
async call(parameters : Public.Procedures.StMakepolygonE2e3.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepolygon( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47266](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepolygon) );
              return responseBody;
           
}
}
export class StMakepolygon_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makepolygon_0cdb"; }
async call(parameters : Public.Procedures.StMakepolygon_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makepolygon( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makepolygon) );
              return responseBody;
           
}
}
export class StBuildarea implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buildarea"; }
async call(parameters : Public.Procedures.StBuildarea.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buildarea( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buildarea) );
              return responseBody;
           
}
}
export class StPolygonizeA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygonize_a4b6"; }
async call(parameters : Public.Procedures.StPolygonizeA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygonize( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonize) );
              return responseBody;
           
}
}
export class StClusterintersectingA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_clusterintersecting_a4b6"; }
async call(parameters : Public.Procedures.StClusterintersectingA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_clusterintersecting( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].st_clusterintersecting) );
              return responseBody;
           
}
}
export class StClusterwithin_0e49 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_clusterwithin_0e49"; }
async call(parameters : Public.Procedures.StClusterwithin_0e49.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_clusterwithin( ${ typed[47266](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].st_clusterwithin) );
              return responseBody;
           
}
}
export class StLinemerge_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linemerge_0cdb"; }
async call(parameters : Public.Procedures.StLinemerge_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linemerge( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linemerge) );
              return responseBody;
           
}
}
export class StLinemerge_4ba2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linemerge_4ba2"; }
async call(parameters : Public.Procedures.StLinemerge_4ba2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linemerge( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[16](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linemerge) );
              return responseBody;
           
}
}
export class StAffineE42d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_affine_e42d"; }
async call(parameters : Public.Procedures.StAffineE42d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_affine( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) }, ${ typed[701](undefinedIsNull(parameters.argument_5)) }, ${ typed[701](undefinedIsNull(parameters.argument_6)) }, ${ typed[701](undefinedIsNull(parameters.argument_7)) }, ${ typed[701](undefinedIsNull(parameters.argument_8)) }, ${ typed[701](undefinedIsNull(parameters.argument_9)) }, ${ typed[701](undefinedIsNull(parameters.argument_10)) }, ${ typed[701](undefinedIsNull(parameters.argument_11)) }, ${ typed[701](undefinedIsNull(parameters.argument_12)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_affine) );
              return responseBody;
           
}
}
export class StAffine_1962 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_affine_1962"; }
async call(parameters : Public.Procedures.StAffine_1962.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_affine( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) }, ${ typed[701](undefinedIsNull(parameters.argument_5)) }, ${ typed[701](undefinedIsNull(parameters.argument_6)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_affine) );
              return responseBody;
           
}
}
export class StRotate_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotate_7163"; }
async call(parameters : Public.Procedures.StRotate_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotate( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}
export class StRotate_8b9f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotate_8b9f"; }
async call(parameters : Public.Procedures.StRotate_8b9f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotate( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}
export class StRotate_463e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotate_463e"; }
async call(parameters : Public.Procedures.StRotate_463e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotate( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[47258](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotate) );
              return responseBody;
           
}
}
export class StRotatez implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotatez"; }
async call(parameters : Public.Procedures.StRotatez.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotatez( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatez) );
              return responseBody;
           
}
}
export class StRotatex implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotatex"; }
async call(parameters : Public.Procedures.StRotatex.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotatex( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatex) );
              return responseBody;
           
}
}
export class StRotatey implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_rotatey"; }
async call(parameters : Public.Procedures.StRotatey.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_rotatey( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_rotatey) );
              return responseBody;
           
}
}
export class StTranslate_8b9f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_translate_8b9f"; }
async call(parameters : Public.Procedures.StTranslate_8b9f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_translate( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_translate) );
              return responseBody;
           
}
}
export class StTranslateD5eb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_translate_d5eb"; }
async call(parameters : Public.Procedures.StTranslateD5eb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_translate( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_translate) );
              return responseBody;
           
}
}
export class StScale_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_scale_3651"; }
async call(parameters : Public.Procedures.StScale_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_scale( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}
export class StScale_1bee implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_scale_1bee"; }
async call(parameters : Public.Procedures.StScale_1bee.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_scale(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[47258](undefinedIsNull(parameters.argument_1)) },origin => ${ typed[47258](undefinedIsNull(parameters.origin)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}
export class StScale_8b9f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_scale_8b9f"; }
async call(parameters : Public.Procedures.StScale_8b9f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_scale( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_scale) );
              return responseBody;
           
}
}
export class StTransscale implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transscale"; }
async call(parameters : Public.Procedures.StTransscale.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transscale( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transscale) );
              return responseBody;
           
}
}
export class StDump implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dump"; }
async call(parameters : Public.Procedures.StDump.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dump( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dump)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}
export class StDumprings implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dumprings"; }
async call(parameters : Public.Procedures.StDumprings.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dumprings( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumprings)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}
export class StDumppoints implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dumppoints"; }
async call(parameters : Public.Procedures.StDumppoints.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dumppoints( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumppoints)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}
export class StDumpsegments implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dumpsegments"; }
async call(parameters : Public.Procedures.StDumpsegments.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryDump.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dumpsegments( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_dumpsegments)).filter<Public.Types.GeometryDump>((r):r is Public.Types.GeometryDump => r !== null) );
              return responseBody;
           
}
}
export class PopulateGeometryColumns_23fc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "populate_geometry_columns_23fc"; }
async call(parameters : Public.Procedures.PopulateGeometryColumns_23fc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.populate_geometry_columns(use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].populate_geometry_columns) );
              return responseBody;
           
}
}
export class PopulateGeometryColumns_4174 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "populate_geometry_columns_4174"; }
async call(parameters : Public.Procedures.PopulateGeometryColumns_4174.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.populate_geometry_columns(tbl_oid => ${ typed[26](undefinedIsNull(parameters.tblOid)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].populate_geometry_columns) );
              return responseBody;
           
}
}
export class Addgeometrycolumn_8fbb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "addgeometrycolumn_8fbb"; }
async call(parameters : Public.Procedures.Addgeometrycolumn_8fbb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.addgeometrycolumn(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid_in => ${ typed[23](undefinedIsNull(parameters.newSridIn)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}
export class Addgeometrycolumn_4617 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "addgeometrycolumn_4617"; }
async call(parameters : Public.Procedures.Addgeometrycolumn_4617.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.addgeometrycolumn(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid => ${ typed[23](undefinedIsNull(parameters.newSrid)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}
export class Addgeometrycolumn_093c implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "addgeometrycolumn_093c"; }
async call(parameters : Public.Procedures.Addgeometrycolumn_093c.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.addgeometrycolumn(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid => ${ typed[23](undefinedIsNull(parameters.newSrid)) },new_type => ${ typed[1043](undefinedIsNull(parameters.newType)) },new_dim => ${ typed[23](undefinedIsNull(parameters.newDim)) },use_typmod => ${ typed[16](undefinedIsNull(parameters.useTypmod)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].addgeometrycolumn) );
              return responseBody;
           
}
}
export class Dropgeometrycolumn_0412 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrycolumn_0412"; }
async call(parameters : Public.Procedures.Dropgeometrycolumn_0412.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrycolumn(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}
export class Dropgeometrycolumn_2253 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrycolumn_2253"; }
async call(parameters : Public.Procedures.Dropgeometrycolumn_2253.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrycolumn(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}
export class DropgeometrycolumnF11a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrycolumn_f11a"; }
async call(parameters : Public.Procedures.DropgeometrycolumnF11a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrycolumn(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrycolumn) );
              return responseBody;
           
}
}
export class Dropgeometrytable_2253 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrytable_2253"; }
async call(parameters : Public.Procedures.Dropgeometrytable_2253.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrytable(catalog_name => ${ typed[1043](undefinedIsNull(parameters.catalogName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}
export class StSegmentize_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_segmentize_7163"; }
async call(parameters : Public.Procedures.StSegmentize_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_segmentize( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_segmentize) );
              return responseBody;
           
}
}
export class DropgeometrytableF11a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrytable_f11a"; }
async call(parameters : Public.Procedures.DropgeometrytableF11a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrytable(schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}
export class DropgeometrytableBfde implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "dropgeometrytable_bfde"; }
async call(parameters : Public.Procedures.DropgeometrytableBfde.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.dropgeometrytable(table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].dropgeometrytable) );
              return responseBody;
           
}
}
export class UpdategeometrysridB2ee implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "updategeometrysrid_b2ee"; }
async call(parameters : Public.Procedures.UpdategeometrysridB2ee.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.updategeometrysrid(catalogn_name => ${ typed[1043](undefinedIsNull(parameters.catalognName)) },schema_name => ${ typed[1043](undefinedIsNull(parameters.schemaName)) },table_name => ${ typed[1043](undefinedIsNull(parameters.tableName)) },column_name => ${ typed[1043](undefinedIsNull(parameters.columnName)) },new_srid_in => ${ typed[23](undefinedIsNull(parameters.newSridIn)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}
export class Updategeometrysrid_7b58 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "updategeometrysrid_7b58"; }
async call(parameters : Public.Procedures.Updategeometrysrid_7b58.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.updategeometrysrid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[1043](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}
export class Updategeometrysrid_11c8 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "updategeometrysrid_11c8"; }
async call(parameters : Public.Procedures.Updategeometrysrid_11c8.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.updategeometrysrid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].updategeometrysrid) );
              return responseBody;
           
}
}
export class FindSrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "find_srid"; }
async call(parameters : Public.Procedures.FindSrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.find_srid( ${ typed[1043](undefinedIsNull(parameters.argument_0)) }, ${ typed[1043](undefinedIsNull(parameters.argument_1)) }, ${ typed[1043](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].find_srid) );
              return responseBody;
           
}
}
export class GetProj4FromSrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "get_proj4_from_srid"; }
async call(parameters : Public.Procedures.GetProj4FromSrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.get_proj4_from_srid( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].get_proj4_from_srid) );
              return responseBody;
           
}
}
export class StSetsrid_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_setsrid_6cbe"; }
async call(parameters : Public.Procedures.StSetsrid_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_setsrid(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_setsrid) );
              return responseBody;
           
}
}
export class StSrid_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_srid_0cdb"; }
async call(parameters : Public.Procedures.StSrid_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_srid(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_srid) );
              return responseBody;
           
}
}
export class PostgisTransformGeometry implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_transform_geometry"; }
async call(parameters : Public.Procedures.PostgisTransformGeometry.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_transform_geometry(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },argument_1 => ${ typed[25](undefinedIsNull(parameters.argument_1)) },argument_2 => ${ typed[25](undefinedIsNull(parameters.argument_2)) },argument_3 => ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_transform_geometry) );
              return responseBody;
           
}
}
export class PostgisSrsCodes implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_srs_codes"; }
async call(parameters : Public.Procedures.PostgisSrsCodes.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_srs_codes(auth_name => ${ typed[25](undefinedIsNull(parameters.authName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_codes)).filter<PgCatalog.Types.Text>((r):r is PgCatalog.Types.Text => r !== null) );
              return responseBody;
           
}
}
export class PostgisSrs implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_srs"; }
async call(parameters : Public.Procedures.PostgisSrs.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47600].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrs;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_srs(auth_name => ${ typed[25](undefinedIsNull(parameters.authName)) },auth_srid => ${ typed[25](undefinedIsNull(parameters.authSrid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs)).filter<Public.Types.PostgisSrs>((r):r is Public.Types.PostgisSrs => r !== null) );
              return responseBody;
           
}
}
export class PostgisSrsAll implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_srs_all"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47601].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrsAll;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_srs_all()`, {options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_all)).filter<Public.Types.PostgisSrsAll>((r):r is Public.Types.PostgisSrsAll => r !== null) );
              return responseBody;
           
}
}
export class PostgisSrsSearch implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_srs_search"; }
async call(parameters : Public.Procedures.PostgisSrsSearch.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47602].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.PostgisSrsSearch;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_srs_search(bounds => ${ typed[47258](undefinedIsNull(parameters.bounds)) },authname => ${ typed[25](undefinedIsNull(parameters.authname)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.postgis_srs_search)).filter<Public.Types.PostgisSrsSearch>((r):r is Public.Types.PostgisSrsSearch => r !== null) );
              return responseBody;
           
}
}
export class StTransform_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transform_6cbe"; }
async call(parameters : Public.Procedures.StTransform_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transform( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}
export class StTransform_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transform_88bc"; }
async call(parameters : Public.Procedures.StTransform_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transform(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },to_proj => ${ typed[25](undefinedIsNull(parameters.toProj)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}
export class StTransform_655c implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transform_655c"; }
async call(parameters : Public.Procedures.StTransform_655c.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transform(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },from_proj => ${ typed[25](undefinedIsNull(parameters.fromProj)) },to_proj => ${ typed[25](undefinedIsNull(parameters.toProj)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}
export class StTransform_5016 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transform_5016"; }
async call(parameters : Public.Procedures.StTransform_5016.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transform(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },from_proj => ${ typed[25](undefinedIsNull(parameters.fromProj)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transform) );
              return responseBody;
           
}
}
export class PostgisTransformPipelineGeometry implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_transform_pipeline_geometry"; }
async call(parameters : Public.Procedures.PostgisTransformPipelineGeometry.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_transform_pipeline_geometry(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },forward => ${ typed[16](undefinedIsNull(parameters.forward)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].postgis_transform_pipeline_geometry) );
              return responseBody;
           
}
}
export class StTransformpipeline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_transformpipeline"; }
async call(parameters : Public.Procedures.StTransformpipeline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_transformpipeline(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_transformpipeline) );
              return responseBody;
           
}
}
export class StInversetransformpipeline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_inversetransformpipeline"; }
async call(parameters : Public.Procedures.StInversetransformpipeline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_inversetransformpipeline(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },pipeline => ${ typed[25](undefinedIsNull(parameters.pipeline)) },to_srid => ${ typed[23](undefinedIsNull(parameters.toSrid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_inversetransformpipeline) );
              return responseBody;
           
}
}
export class PostgisVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_version) );
              return responseBody;
           
}
}
export class PostgisLiblwgeomVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_liblwgeom_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_liblwgeom_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_liblwgeom_version) );
              return responseBody;
           
}
}
export class PostgisProjVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_proj_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_proj_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_proj_version) );
              return responseBody;
           
}
}
export class PostgisWagyuVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_wagyu_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_wagyu_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_wagyu_version) );
              return responseBody;
           
}
}
export class PostgisScriptsInstalled implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_scripts_installed"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_scripts_installed()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_installed) );
              return responseBody;
           
}
}
export class PostgisLibVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_lib_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_lib_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_version) );
              return responseBody;
           
}
}
export class PostgisScriptsReleased implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_scripts_released"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_scripts_released()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_released) );
              return responseBody;
           
}
}
export class PostgisGeosVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_geos_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_geos_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_geos_version) );
              return responseBody;
           
}
}
export class PostgisGeosCompiledVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_geos_compiled_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_geos_compiled_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_geos_compiled_version) );
              return responseBody;
           
}
}
export class PostgisLibRevision implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_lib_revision"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_lib_revision()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_revision) );
              return responseBody;
           
}
}
export class PostgisSvnVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_svn_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_svn_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_svn_version) );
              return responseBody;
           
}
}
export class PostgisLibxmlVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_libxml_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_libxml_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libxml_version) );
              return responseBody;
           
}
}
export class PostgisScriptsBuildDate implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_scripts_build_date"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_scripts_build_date()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_scripts_build_date) );
              return responseBody;
           
}
}
export class PostgisLibBuildDate implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_lib_build_date"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_lib_build_date()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_lib_build_date) );
              return responseBody;
           
}
}
export class PostgisExtensionsUpgrade implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_extensions_upgrade"; }
async call(parameters : Public.Procedures.PostgisExtensionsUpgrade.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_extensions_upgrade(target_version => ${ typed[25](undefinedIsNull(parameters.targetVersion)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_extensions_upgrade) );
              return responseBody;
           
}
}
export class StLineinterpolatepoint_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoint_7163"; }
async call(parameters : Public.Procedures.StLineinterpolatepoint_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}
export class StLineinterpolatepoints_8fda implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoints_8fda"; }
async call(parameters : Public.Procedures.StLineinterpolatepoints_8fda.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoints(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },repeat => ${ typed[16](undefinedIsNull(parameters.repeat)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}
export class StLinesubstringD5eb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linesubstring_d5eb"; }
async call(parameters : Public.Procedures.StLinesubstringD5eb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linesubstring( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}
export class StLinelocatepoint_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linelocatepoint_3651"; }
async call(parameters : Public.Procedures.StLinelocatepoint_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linelocatepoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}
export class StAddmeasure implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_addmeasure"; }
async call(parameters : Public.Procedures.StAddmeasure.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_addmeasure( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_addmeasure) );
              return responseBody;
           
}
}
export class StClosestpointofapproach implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_closestpointofapproach"; }
async call(parameters : Public.Procedures.StClosestpointofapproach.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_closestpointofapproach( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_closestpointofapproach) );
              return responseBody;
           
}
}
export class PostgisFullVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_full_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_full_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_full_version) );
              return responseBody;
           
}
}
export class Box2d_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2d_0cdb"; }
async call(parameters : Public.Procedures.Box2d_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d) );
              return responseBody;
           
}
}
export class Box3d_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box3d_0cdb"; }
async call(parameters : Public.Procedures.Box3d_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box3d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d) );
              return responseBody;
           
}
}
export class Box_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box_0cdb"; }
async call(parameters : Public.Procedures.Box_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box) );
              return responseBody;
           
}
}
export class Box2d_07e9 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box2d_07e9"; }
async call(parameters : Public.Procedures.Box2d_07e9.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box2d( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].box2d) );
              return responseBody;
           
}
}
export class Box3dE505 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box3d_e505"; }
async call(parameters : Public.Procedures.Box3dE505.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box3d( ${ typed[47289](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].box3d) );
              return responseBody;
           
}
}
export class Box_07e9 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box_07e9"; }
async call(parameters : Public.Procedures.Box_07e9.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box) );
              return responseBody;
           
}
}
export class Text implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "text"; }
async call(parameters : Public.Procedures.Text.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.text( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].text) );
              return responseBody;
           
}
}
export class Box3dtobox implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "box3dtobox"; }
async call(parameters : Public.Procedures.Box3dtobox.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Box.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.box3dtobox( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Box.parse(results?.[0].box3dtobox) );
              return responseBody;
           
}
}
export class GeometryE505 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_e505"; }
async call(parameters : Public.Procedures.GeometryE505.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[47289](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Geometry_07e9 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_07e9"; }
async call(parameters : Public.Procedures.Geometry_07e9.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[47285](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class GeometryE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_e728"; }
async call(parameters : Public.Procedures.GeometryE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Geometry_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_2d19"; }
async call(parameters : Public.Procedures.Geometry_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class Bytea_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "bytea_0cdb"; }
async call(parameters : Public.Procedures.Bytea_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.bytea( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].bytea) );
              return responseBody;
           
}
}
export class StSimplify_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_simplify_7163"; }
async call(parameters : Public.Procedures.StSimplify_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_simplify( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplify) );
              return responseBody;
           
}
}
export class StSimplify_8fda implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_simplify_8fda"; }
async call(parameters : Public.Procedures.StSimplify_8fda.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_simplify( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplify) );
              return responseBody;
           
}
}
export class StSimplifyvw implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_simplifyvw"; }
async call(parameters : Public.Procedures.StSimplifyvw.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_simplifyvw( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifyvw) );
              return responseBody;
           
}
}
export class StSeteffectivearea implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_seteffectivearea"; }
async call(parameters : Public.Procedures.StSeteffectivearea.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_seteffectivearea( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_seteffectivearea) );
              return responseBody;
           
}
}
export class StFilterbym implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_filterbym"; }
async call(parameters : Public.Procedures.StFilterbym.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_filterbym( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[16](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_filterbym) );
              return responseBody;
           
}
}
export class StChaikinsmoothing implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_chaikinsmoothing"; }
async call(parameters : Public.Procedures.StChaikinsmoothing.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_chaikinsmoothing( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_chaikinsmoothing) );
              return responseBody;
           
}
}
export class StSnaptogrid_5500 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_snaptogrid_5500"; }
async call(parameters : Public.Procedures.StSnaptogrid_5500.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_snaptogrid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[701](undefinedIsNull(parameters.argument_3)) }, ${ typed[701](undefinedIsNull(parameters.argument_4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}
export class StSnaptogridD5eb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_snaptogrid_d5eb"; }
async call(parameters : Public.Procedures.StSnaptogridD5eb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_snaptogrid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}
export class StSnaptogrid_7163 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_snaptogrid_7163"; }
async call(parameters : Public.Procedures.StSnaptogrid_7163.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_snaptogrid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}
export class StSnaptogrid_7f2e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_snaptogrid_7f2e"; }
async call(parameters : Public.Procedures.StSnaptogrid_7f2e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_snaptogrid(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) },argument_3 => ${ typed[701](undefinedIsNull(parameters.argument_3)) },argument_4 => ${ typed[701](undefinedIsNull(parameters.argument_4)) },argument_5 => ${ typed[701](undefinedIsNull(parameters.argument_5)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snaptogrid) );
              return responseBody;
           
}
}
export class StDistancecpa implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distancecpa"; }
async call(parameters : Public.Procedures.StDistancecpa.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distancecpa( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancecpa) );
              return responseBody;
           
}
}
export class StCpawithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_cpawithin"; }
async call(parameters : Public.Procedures.StCpawithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_cpawithin( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_cpawithin) );
              return responseBody;
           
}
}
export class StIsvalidtrajectory implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvalidtrajectory"; }
async call(parameters : Public.Procedures.StIsvalidtrajectory.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvalidtrajectory( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalidtrajectory) );
              return responseBody;
           
}
}
export class StIntersection_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersection_6961"; }
async call(parameters : Public.Procedures.StIntersection_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersection(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}
export class StBufferBf44 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_bf44"; }
async call(parameters : Public.Procedures.StBufferBf44.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) },options => ${ typed[25](undefinedIsNull(parameters.options)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StBufferC33e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_c33e"; }
async call(parameters : Public.Procedures.StBufferC33e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) },quadsegs => ${ typed[23](undefinedIsNull(parameters.quadsegs)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StMinimumboundingradius implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_minimumboundingradius"; }
async call(parameters : Public.Procedures.StMinimumboundingradius.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47676].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StMinimumboundingradius;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_minimumboundingradius(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_minimumboundingradius)).filter<Public.Types.StMinimumboundingradius>((r):r is Public.Types.StMinimumboundingradius => r !== null) );
              return responseBody;
           
}
}
export class StMinimumboundingcircle implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_minimumboundingcircle"; }
async call(parameters : Public.Procedures.StMinimumboundingcircle.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_minimumboundingcircle(inputgeom => ${ typed[47258](undefinedIsNull(parameters.inputgeom)) },segs_per_quarter => ${ typed[23](undefinedIsNull(parameters.segsPerQuarter)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_minimumboundingcircle) );
              return responseBody;
           
}
}
export class StOrientedenvelope implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_orientedenvelope"; }
async call(parameters : Public.Procedures.StOrientedenvelope.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_orientedenvelope( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_orientedenvelope) );
              return responseBody;
           
}
}
export class StOffsetcurve implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_offsetcurve"; }
async call(parameters : Public.Procedures.StOffsetcurve.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_offsetcurve(line => ${ typed[47258](undefinedIsNull(parameters.line)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },params => ${ typed[25](undefinedIsNull(parameters.params)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_offsetcurve) );
              return responseBody;
           
}
}
export class StGeneratepoints_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_generatepoints_6cbe"; }
async call(parameters : Public.Procedures.StGeneratepoints_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_generatepoints(area => ${ typed[47258](undefinedIsNull(parameters.area)) },npoints => ${ typed[23](undefinedIsNull(parameters.npoints)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_generatepoints) );
              return responseBody;
           
}
}
export class StGeneratepointsD341 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_generatepoints_d341"; }
async call(parameters : Public.Procedures.StGeneratepointsD341.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_generatepoints(area => ${ typed[47258](undefinedIsNull(parameters.area)) },npoints => ${ typed[23](undefinedIsNull(parameters.npoints)) },seed => ${ typed[23](undefinedIsNull(parameters.seed)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_generatepoints) );
              return responseBody;
           
}
}
export class StConvexhull implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_convexhull"; }
async call(parameters : Public.Procedures.StConvexhull.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_convexhull( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_convexhull) );
              return responseBody;
           
}
}
export class StSimplifypreservetopology implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_simplifypreservetopology"; }
async call(parameters : Public.Procedures.StSimplifypreservetopology.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_simplifypreservetopology( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifypreservetopology) );
              return responseBody;
           
}
}
export class StIsvalidreason_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvalidreason_0cdb"; }
async call(parameters : Public.Procedures.StIsvalidreason_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvalidreason( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_isvalidreason) );
              return responseBody;
           
}
}
export class StIsvaliddetail implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvaliddetail"; }
async call(parameters : Public.Procedures.StIsvaliddetail.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.ValidDetail.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvaliddetail(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.ValidDetail.parse(results?.[0].st_isvaliddetail) );
              return responseBody;
           
}
}
export class StIsvalidreason_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvalidreason_6cbe"; }
async call(parameters : Public.Procedures.StIsvalidreason_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvalidreason( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_isvalidreason) );
              return responseBody;
           
}
}
export class StIsvalid_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvalid_6cbe"; }
async call(parameters : Public.Procedures.StIsvalid_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvalid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalid) );
              return responseBody;
           
}
}
export class StHausdorffdistance_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_hausdorffdistance_3651"; }
async call(parameters : Public.Procedures.StHausdorffdistance_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_hausdorffdistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_hausdorffdistance) );
              return responseBody;
           
}
}
export class StHausdorffdistance_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_hausdorffdistance_6961"; }
async call(parameters : Public.Procedures.StHausdorffdistance_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_hausdorffdistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_hausdorffdistance) );
              return responseBody;
           
}
}
export class StFrechetdistance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_frechetdistance"; }
async call(parameters : Public.Procedures.StFrechetdistance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_frechetdistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_frechetdistance) );
              return responseBody;
           
}
}
export class StMaximuminscribedcircle implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_maximuminscribedcircle"; }
async call(parameters : Public.Procedures.StMaximuminscribedcircle.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47694].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StMaximuminscribedcircle;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_maximuminscribedcircle(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_maximuminscribedcircle)).filter<Public.Types.StMaximuminscribedcircle>((r):r is Public.Types.StMaximuminscribedcircle => r !== null) );
              return responseBody;
           
}
}
export class StLargestemptycircle implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_largestemptycircle"; }
async call(parameters : Public.Procedures.StLargestemptycircle.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[47695].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StLargestemptycircle;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_largestemptycircle(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },boundary => ${ typed[47258](undefinedIsNull(parameters.boundary)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_largestemptycircle)).filter<Public.Types.StLargestemptycircle>((r):r is Public.Types.StLargestemptycircle => r !== null) );
              return responseBody;
           
}
}
export class StDifference implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_difference"; }
async call(parameters : Public.Procedures.StDifference.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_difference(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_difference) );
              return responseBody;
           
}
}
export class StBoundary implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_boundary"; }
async call(parameters : Public.Procedures.StBoundary.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_boundary( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_boundary) );
              return responseBody;
           
}
}
export class StPoints implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_points"; }
async call(parameters : Public.Procedures.StPoints.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_points( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_points) );
              return responseBody;
           
}
}
export class StSymdifference implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_symdifference"; }
async call(parameters : Public.Procedures.StSymdifference.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_symdifference(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_symdifference) );
              return responseBody;
           
}
}
export class StSymmetricdifference implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_symmetricdifference"; }
async call(parameters : Public.Procedures.StSymmetricdifference.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_symmetricdifference(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_symmetricdifference) );
              return responseBody;
           
}
}
export class StUnion_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_union_3651"; }
async call(parameters : Public.Procedures.StUnion_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_union(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}
export class StUnion_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_union_6961"; }
async call(parameters : Public.Procedures.StUnion_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_union(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}
export class StUnaryunion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_unaryunion"; }
async call(parameters : Public.Procedures.StUnaryunion.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_unaryunion(argument_0 => ${ typed[47258](undefinedIsNull(parameters.argument_0)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_unaryunion) );
              return responseBody;
           
}
}
export class StRemoverepeatedpoints implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_removerepeatedpoints"; }
async call(parameters : Public.Procedures.StRemoverepeatedpoints.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_removerepeatedpoints(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_removerepeatedpoints) );
              return responseBody;
           
}
}
export class StClipbybox2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_clipbybox2d"; }
async call(parameters : Public.Procedures.StClipbybox2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_clipbybox2d(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },box => ${ typed[47289](undefinedIsNull(parameters.box)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_clipbybox2d) );
              return responseBody;
           
}
}
export class StSubdivide implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_subdivide"; }
async call(parameters : Public.Procedures.StSubdivide.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_subdivide(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxvertices => ${ typed[23](undefinedIsNull(parameters.maxvertices)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_subdivide)).filter<Public.Types.Geometry>((r):r is Public.Types.Geometry => r !== null) );
              return responseBody;
           
}
}
export class StReduceprecision implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_reduceprecision"; }
async call(parameters : Public.Procedures.StReduceprecision.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_reduceprecision(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },gridsize => ${ typed[701](undefinedIsNull(parameters.gridsize)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_reduceprecision) );
              return responseBody;
           
}
}
export class StMakevalid_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makevalid_0cdb"; }
async call(parameters : Public.Procedures.StMakevalid_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makevalid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makevalid) );
              return responseBody;
           
}
}
export class StMakevalid_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_makevalid_88bc"; }
async call(parameters : Public.Procedures.StMakevalid_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_makevalid(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },params => ${ typed[25](undefinedIsNull(parameters.params)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_makevalid) );
              return responseBody;
           
}
}
export class StCleangeometry implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_cleangeometry"; }
async call(parameters : Public.Procedures.StCleangeometry.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_cleangeometry( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_cleangeometry) );
              return responseBody;
           
}
}
export class StSplit implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_split"; }
async call(parameters : Public.Procedures.StSplit.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_split(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_split) );
              return responseBody;
           
}
}
export class StSharedpaths implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_sharedpaths"; }
async call(parameters : Public.Procedures.StSharedpaths.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_sharedpaths(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_sharedpaths) );
              return responseBody;
           
}
}
export class StSnap implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_snap"; }
async call(parameters : Public.Procedures.StSnap.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_snap(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_snap) );
              return responseBody;
           
}
}
export class StRelatematch implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_relatematch"; }
async call(parameters : Public.Procedures.StRelatematch.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_relatematch( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_relatematch) );
              return responseBody;
           
}
}
export class StNode implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_node"; }
async call(parameters : Public.Procedures.StNode.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_node(g => ${ typed[47258](undefinedIsNull(parameters.g)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_node) );
              return responseBody;
           
}
}
export class StDelaunaytriangles implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_delaunaytriangles"; }
async call(parameters : Public.Procedures.StDelaunaytriangles.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_delaunaytriangles(g1 => ${ typed[47258](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_delaunaytriangles) );
              return responseBody;
           
}
}
export class StTriangulatepolygon implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_triangulatepolygon"; }
async call(parameters : Public.Procedures.StTriangulatepolygon.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_triangulatepolygon(g1 => ${ typed[47258](undefinedIsNull(parameters.g1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_triangulatepolygon) );
              return responseBody;
           
}
}
export class StVoronoipolygons implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_voronoipolygons"; }
async call(parameters : Public.Procedures.StVoronoipolygons.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_voronoipolygons(g1 => ${ typed[47258](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },extend_to => ${ typed[47258](undefinedIsNull(parameters.extendTo)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_voronoipolygons) );
              return responseBody;
           
}
}
export class StVoronoilines implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_voronoilines"; }
async call(parameters : Public.Procedures.StVoronoilines.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_voronoilines(g1 => ${ typed[47258](undefinedIsNull(parameters.g1)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },extend_to => ${ typed[47258](undefinedIsNull(parameters.extendTo)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_voronoilines) );
              return responseBody;
           
}
}
export class StCombinebbox_1ee2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_combinebbox_1ee2"; }
async call(parameters : Public.Procedures.StCombinebbox_1ee2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_combinebbox( ${ typed[47285](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}
export class StCombinebbox_9d67 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_combinebbox_9d67"; }
async call(parameters : Public.Procedures.StCombinebbox_9d67.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box3d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_combinebbox( ${ typed[47285](undefinedIsNull(parameters.argument_0)) }, ${ typed[47285](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box3d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}
export class StCombinebbox_1a7e implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_combinebbox_1a7e"; }
async call(parameters : Public.Procedures.StCombinebbox_1a7e.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_combinebbox( ${ typed[47289](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_combinebbox) );
              return responseBody;
           
}
}
export class StCollect_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_collect_3651"; }
async call(parameters : Public.Procedures.StCollect_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_collect(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collect) );
              return responseBody;
           
}
}
export class StCollectA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_collect_a4b6"; }
async call(parameters : Public.Procedures.StCollectA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_collect( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_collect) );
              return responseBody;
           
}
}
export class PgisGeometryAccumTransfn_43cf implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_accum_transfn_43cf"; }
async call(parameters : Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}
export class PgisGeometryAccumTransfn_7c68 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_accum_transfn_7c68"; }
async call(parameters : Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}
export class PgisGeometryAccumTransfn_0b93 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_accum_transfn_0b93"; }
async call(parameters : Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_accum_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_accum_transfn) );
              return responseBody;
           
}
}
export class PgisGeometryCollectFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_collect_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryCollectFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_collect_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_collect_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryPolygonizeFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_polygonize_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_polygonize_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_polygonize_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryClusterintersectingFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_clusterintersecting_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_clusterintersecting_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].pgis_geometry_clusterintersecting_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryClusterwithinFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_clusterwithin_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.GeometryArray.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_clusterwithin_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.GeometryArray.parse(results?.[0].pgis_geometry_clusterwithin_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryMakelineFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_makeline_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryMakelineFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_makeline_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_makeline_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryCoverageunionFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_coverageunion_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_coverageunion_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_coverageunion_finalfn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelTransfn_43cf implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_transfn_43cf"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_transfn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelTransfn_7c68 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_transfn_7c68"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_transfn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelCombinefn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_combinefn"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_combinefn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_combinefn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelSerialfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_serialfn"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_serialfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_geometry_union_parallel_serialfn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelDeserialfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_deserialfn"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_deserialfn( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_geometry_union_parallel_deserialfn) );
              return responseBody;
           
}
}
export class PgisGeometryUnionParallelFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_geometry_union_parallel_finalfn"; }
async call(parameters : Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_geometry_union_parallel_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].pgis_geometry_union_parallel_finalfn) );
              return responseBody;
           
}
}
export class StUnionA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_union_a4b6"; }
async call(parameters : Public.Procedures.StUnionA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_union( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_union) );
              return responseBody;
           
}
}
export class StCoverageunionA4b6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_coverageunion_a4b6"; }
async call(parameters : Public.Procedures.StCoverageunionA4b6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_coverageunion( ${ typed[47266](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_coverageunion) );
              return responseBody;
           
}
}
export class StRelate_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_relate_3651"; }
async call(parameters : Public.Procedures.StRelate_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_relate(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}
export class StRelateAa17 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_relate_aa17"; }
async call(parameters : Public.Procedures.StRelateAa17.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_relate(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}
export class StRelateCaf9 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_relate_caf9"; }
async call(parameters : Public.Procedures.StRelateCaf9.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_relate(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_relate) );
              return responseBody;
           
}
}
export class StDisjoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_disjoint"; }
async call(parameters : Public.Procedures.StDisjoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_disjoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_disjoint) );
              return responseBody;
           
}
}
export class PostgisIndexSupportfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_index_supportfn"; }
async call(parameters : Public.Procedures.PostgisIndexSupportfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_index_supportfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].postgis_index_supportfn) );
              return responseBody;
           
}
}
export class StLinecrossingdirection implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linecrossingdirection"; }
async call(parameters : Public.Procedures.StLinecrossingdirection.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linecrossingdirection(line1 => ${ typed[47258](undefinedIsNull(parameters.line1)) },line2 => ${ typed[47258](undefinedIsNull(parameters.line2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_linecrossingdirection) );
              return responseBody;
           
}
}
export class StDwithin_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dwithin_6961"; }
async call(parameters : Public.Procedures.StDwithin_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dwithin(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}
export class StTouches implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_touches"; }
async call(parameters : Public.Procedures.StTouches.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_touches(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_touches) );
              return responseBody;
           
}
}
export class StIntersects_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersects_3651"; }
async call(parameters : Public.Procedures.StIntersects_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersects(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}
export class StCrosses implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_crosses"; }
async call(parameters : Public.Procedures.StCrosses.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_crosses(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_crosses) );
              return responseBody;
           
}
}
export class StContains implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_contains"; }
async call(parameters : Public.Procedures.StContains.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_contains(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_contains) );
              return responseBody;
           
}
}
export class StContainsproperly implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_containsproperly"; }
async call(parameters : Public.Procedures.StContainsproperly.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_containsproperly(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_containsproperly) );
              return responseBody;
           
}
}
export class StWithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_within"; }
async call(parameters : Public.Procedures.StWithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_within(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_within) );
              return responseBody;
           
}
}
export class StCovers_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_covers_3651"; }
async call(parameters : Public.Procedures.StCovers_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_covers(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}
export class StCoveredby_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_coveredby_3651"; }
async call(parameters : Public.Procedures.StCoveredby_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_coveredby(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}
export class StOverlaps implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_overlaps"; }
async call(parameters : Public.Procedures.StOverlaps.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_overlaps(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_overlaps) );
              return responseBody;
           
}
}
export class StDfullywithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dfullywithin"; }
async call(parameters : Public.Procedures.StDfullywithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dfullywithin(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dfullywithin) );
              return responseBody;
           
}
}
export class St_3ddwithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3ddwithin"; }
async call(parameters : Public.Procedures.St_3ddwithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3ddwithin(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3ddwithin) );
              return responseBody;
           
}
}
export class St_3ddfullywithin implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3ddfullywithin"; }
async call(parameters : Public.Procedures.St_3ddfullywithin.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3ddfullywithin(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },argument_2 => ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3ddfullywithin) );
              return responseBody;
           
}
}
export class St_3dintersects implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dintersects"; }
async call(parameters : Public.Procedures.St_3dintersects.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dintersects(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_3dintersects) );
              return responseBody;
           
}
}
export class StOrderingequals implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_orderingequals"; }
async call(parameters : Public.Procedures.StOrderingequals.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_orderingequals(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_orderingequals) );
              return responseBody;
           
}
}
export class StEquals implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_equals"; }
async call(parameters : Public.Procedures.StEquals.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_equals(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_equals) );
              return responseBody;
           
}
}
export class StIsvalid_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isvalid_0cdb"; }
async call(parameters : Public.Procedures.StIsvalid_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isvalid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isvalid) );
              return responseBody;
           
}
}
export class StMinimumclearance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_minimumclearance"; }
async call(parameters : Public.Procedures.StMinimumclearance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_minimumclearance( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_minimumclearance) );
              return responseBody;
           
}
}
export class StMinimumclearanceline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_minimumclearanceline"; }
async call(parameters : Public.Procedures.StMinimumclearanceline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_minimumclearanceline( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_minimumclearanceline) );
              return responseBody;
           
}
}
export class StCentroid_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_centroid_0cdb"; }
async call(parameters : Public.Procedures.StCentroid_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_centroid( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}
export class StGeometricmedian implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geometricmedian"; }
async call(parameters : Public.Procedures.StGeometricmedian.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geometricmedian(g => ${ typed[47258](undefinedIsNull(parameters.g)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },max_iter => ${ typed[23](undefinedIsNull(parameters.maxIter)) },fail_if_not_converged => ${ typed[16](undefinedIsNull(parameters.failIfNotConverged)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometricmedian) );
              return responseBody;
           
}
}
export class StIsring implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isring"; }
async call(parameters : Public.Procedures.StIsring.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isring( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isring) );
              return responseBody;
           
}
}
export class StPointonsurface implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointonsurface"; }
async call(parameters : Public.Procedures.StPointonsurface.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointonsurface( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointonsurface) );
              return responseBody;
           
}
}
export class StIssimple implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_issimple"; }
async call(parameters : Public.Procedures.StIssimple.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_issimple( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_issimple) );
              return responseBody;
           
}
}
export class StIscollection implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_iscollection"; }
async call(parameters : Public.Procedures.StIscollection.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_iscollection( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_iscollection) );
              return responseBody;
           
}
}
export class Equals implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "equals"; }
async call(parameters : Public.Procedures.Equals.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.equals(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].equals) );
              return responseBody;
           
}
}
export class StGeomfromgml_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgml_27e2"; }
async call(parameters : Public.Procedures.StGeomfromgml_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgml) );
              return responseBody;
           
}
}
export class StGeomfromgmlE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgml_e728"; }
async call(parameters : Public.Procedures.StGeomfromgmlE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgml) );
              return responseBody;
           
}
}
export class StGmltosqlE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_gmltosql_e728"; }
async call(parameters : Public.Procedures.StGmltosqlE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_gmltosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_gmltosql) );
              return responseBody;
           
}
}
export class StGmltosql_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_gmltosql_27e2"; }
async call(parameters : Public.Procedures.StGmltosql_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_gmltosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_gmltosql) );
              return responseBody;
           
}
}
export class StGeomfromkml implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromkml"; }
async call(parameters : Public.Procedures.StGeomfromkml.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromkml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromkml) );
              return responseBody;
           
}
}
export class StGeomfrommarc21 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfrommarc21"; }
async call(parameters : Public.Procedures.StGeomfrommarc21.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfrommarc21(marc21xml => ${ typed[25](undefinedIsNull(parameters.marc21xml)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfrommarc21) );
              return responseBody;
           
}
}
export class StAsmarc21 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asmarc21"; }
async call(parameters : Public.Procedures.StAsmarc21.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asmarc21(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },format => ${ typed[25](undefinedIsNull(parameters.format)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asmarc21) );
              return responseBody;
           
}
}
export class StGeomfromgeojsonE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgeojson_e728"; }
async call(parameters : Public.Procedures.StGeomfromgeojsonE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgeojson( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}
export class StGeomfromgeojson_608f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgeojson_608f"; }
async call(parameters : Public.Procedures.StGeomfromgeojson_608f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgeojson( ${ typed[114](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}
export class StGeomfromgeojson_3c9d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgeojson_3c9d"; }
async call(parameters : Public.Procedures.StGeomfromgeojson_3c9d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgeojson( ${ typed[3802](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeojson) );
              return responseBody;
           
}
}
export class PostgisLibjsonVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_libjson_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_libjson_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libjson_version) );
              return responseBody;
           
}
}
export class StLinefromencodedpolyline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefromencodedpolyline"; }
async call(parameters : Public.Procedures.StLinefromencodedpolyline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefromencodedpolyline(txtin => ${ typed[25](undefinedIsNull(parameters.txtin)) },nprecision => ${ typed[23](undefinedIsNull(parameters.nprecision)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromencodedpolyline) );
              return responseBody;
           
}
}
export class StAsencodedpolyline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asencodedpolyline"; }
async call(parameters : Public.Procedures.StAsencodedpolyline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asencodedpolyline(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },nprecision => ${ typed[23](undefinedIsNull(parameters.nprecision)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asencodedpolyline) );
              return responseBody;
           
}
}
export class StAssvgD341 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_assvg_d341"; }
async call(parameters : Public.Procedures.StAssvgD341.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_assvg(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },rel => ${ typed[23](undefinedIsNull(parameters.rel)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}
export class StAsgmlD341 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgml_d341"; }
async call(parameters : Public.Procedures.StAsgmlD341.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgml(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}
export class StAsgml_32a0 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgml_32a0"; }
async call(parameters : Public.Procedures.StAsgml_32a0.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgml(version => ${ typed[23](undefinedIsNull(parameters.version)) },geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}
export class StAskmlCce7 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_askml_cce7"; }
async call(parameters : Public.Procedures.StAskmlCce7.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_askml(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}
export class StAsgeojsonD341 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgeojson_d341"; }
async call(parameters : Public.Procedures.StAsgeojsonD341.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgeojson(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}
export class StAsgeojsonF2c6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgeojson_f2c6"; }
async call(parameters : Public.Procedures.StAsgeojsonF2c6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgeojson(r => ${ typed[2249](undefinedIsNull(parameters.r)) },geom_column => ${ typed[25](undefinedIsNull(parameters.geomColumn)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },pretty_bool => ${ typed[16](undefinedIsNull(parameters.prettyBool)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}
export class Json implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "json"; }
async call(parameters : Public.Procedures.Json.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Json.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.json( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Json.parse(results?.[0].json) );
              return responseBody;
           
}
}
export class Jsonb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "jsonb"; }
async call(parameters : Public.Procedures.Jsonb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Jsonb.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.jsonb( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Jsonb.parse(results?.[0].jsonb) );
              return responseBody;
           
}
}
export class PgisAsmvtTransfn_647f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_transfn_647f"; }
async call(parameters : Public.Procedures.PgisAsmvtTransfn_647f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}
export class PgisAsmvtTransfn_27f4 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_transfn_27f4"; }
async call(parameters : Public.Procedures.PgisAsmvtTransfn_27f4.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}
export class PgisAsmvtTransfnF57f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_transfn_f57f"; }
async call(parameters : Public.Procedures.PgisAsmvtTransfnF57f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}
export class PgisAsmvtTransfn_92c1 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_transfn_92c1"; }
async call(parameters : Public.Procedures.PgisAsmvtTransfn_92c1.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) }, ${ typed[25](undefinedIsNull(parameters.argument_4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}
export class PgisAsmvtTransfnF5be implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_transfn_f5be"; }
async call(parameters : Public.Procedures.PgisAsmvtTransfnF5be.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[23](undefinedIsNull(parameters.argument_3)) }, ${ typed[25](undefinedIsNull(parameters.argument_4)) }, ${ typed[25](undefinedIsNull(parameters.argument_5)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_transfn) );
              return responseBody;
           
}
}
export class PgisAsmvtFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_finalfn"; }
async call(parameters : Public.Procedures.PgisAsmvtFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asmvt_finalfn) );
              return responseBody;
           
}
}
export class PgisAsmvtCombinefn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_combinefn"; }
async call(parameters : Public.Procedures.PgisAsmvtCombinefn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_combinefn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_combinefn) );
              return responseBody;
           
}
}
export class PgisAsmvtSerialfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_serialfn"; }
async call(parameters : Public.Procedures.PgisAsmvtSerialfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_serialfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asmvt_serialfn) );
              return responseBody;
           
}
}
export class PgisAsmvtDeserialfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asmvt_deserialfn"; }
async call(parameters : Public.Procedures.PgisAsmvtDeserialfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asmvt_deserialfn( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asmvt_deserialfn) );
              return responseBody;
           
}
}
export class StAsmvtgeom implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asmvtgeom"; }
async call(parameters : Public.Procedures.StAsmvtgeom.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asmvtgeom(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },bounds => ${ typed[47289](undefinedIsNull(parameters.bounds)) },extent => ${ typed[23](undefinedIsNull(parameters.extent)) },buffer => ${ typed[23](undefinedIsNull(parameters.buffer)) },clip_geom => ${ typed[16](undefinedIsNull(parameters.clipGeom)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_asmvtgeom) );
              return responseBody;
           
}
}
export class PostgisLibprotobufVersion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_libprotobuf_version"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_libprotobuf_version()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_libprotobuf_version) );
              return responseBody;
           
}
}
export class PgisAsgeobufTransfn_647f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asgeobuf_transfn_647f"; }
async call(parameters : Public.Procedures.PgisAsgeobufTransfn_647f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asgeobuf_transfn) );
              return responseBody;
           
}
}
export class PgisAsgeobufTransfn_27f4 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asgeobuf_transfn_27f4"; }
async call(parameters : Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asgeobuf_transfn) );
              return responseBody;
           
}
}
export class PgisAsgeobufFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asgeobuf_finalfn"; }
async call(parameters : Public.Procedures.PgisAsgeobufFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asgeobuf_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asgeobuf_finalfn) );
              return responseBody;
           
}
}
export class PgisAsflatgeobufTransfn_647f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asflatgeobuf_transfn_647f"; }
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}
export class PgisAsflatgeobufTransfn_9633 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asflatgeobuf_transfn_9633"; }
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}
export class PgisAsflatgeobufTransfn_521f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asflatgeobuf_transfn_521f"; }
async call(parameters : Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asflatgeobuf_transfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2283](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].pgis_asflatgeobuf_transfn) );
              return responseBody;
           
}
}
export class PgisAsflatgeobufFinalfn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "pgis_asflatgeobuf_finalfn"; }
async call(parameters : Public.Procedures.PgisAsflatgeobufFinalfn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.pgis_asflatgeobuf_finalfn( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].pgis_asflatgeobuf_finalfn) );
              return responseBody;
           
}
}
export class StFromflatgeobuftotable implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_fromflatgeobuftotable"; }
async call(parameters : Public.Procedures.StFromflatgeobuftotable.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_fromflatgeobuftotable( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[17](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].st_fromflatgeobuftotable) );
              return responseBody;
           
}
}
export class StFromflatgeobuf implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_fromflatgeobuf"; }
async call(parameters : Public.Procedures.StFromflatgeobuf.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Anyelement.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_fromflatgeobuf( ${ typed[2283](undefinedIsNull(parameters.argument_0)) }, ${ typed[17](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_fromflatgeobuf)).filter<PgCatalog.Types.Anyelement>((r):r is PgCatalog.Types.Anyelement => r !== null) );
              return responseBody;
           
}
}
export class StGeohash_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geohash_6cbe"; }
async call(parameters : Public.Procedures.StGeohash_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geohash(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxchars => ${ typed[23](undefinedIsNull(parameters.maxchars)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geohash) );
              return responseBody;
           
}
}
export class StBox2dfromgeohash implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_box2dfromgeohash"; }
async call(parameters : Public.Procedures.StBox2dfromgeohash.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Box2d.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_box2dfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Box2d.parse(results?.[0].st_box2dfromgeohash) );
              return responseBody;
           
}
}
export class StPointfromgeohash implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointfromgeohash"; }
async call(parameters : Public.Procedures.StPointfromgeohash.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromgeohash) );
              return responseBody;
           
}
}
export class StGeomfromgeohash implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromgeohash"; }
async call(parameters : Public.Procedures.StGeomfromgeohash.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromgeohash( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromgeohash) );
              return responseBody;
           
}
}
export class StNumpoints implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_numpoints"; }
async call(parameters : Public.Procedures.StNumpoints.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_numpoints( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numpoints) );
              return responseBody;
           
}
}
export class StNumgeometries implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_numgeometries"; }
async call(parameters : Public.Procedures.StNumgeometries.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_numgeometries( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numgeometries) );
              return responseBody;
           
}
}
export class StGeometryn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geometryn"; }
async call(parameters : Public.Procedures.StGeometryn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geometryn( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryn) );
              return responseBody;
           
}
}
export class StDimension implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dimension"; }
async call(parameters : Public.Procedures.StDimension.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dimension( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_dimension) );
              return responseBody;
           
}
}
export class StExteriorring implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_exteriorring"; }
async call(parameters : Public.Procedures.StExteriorring.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_exteriorring( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_exteriorring) );
              return responseBody;
           
}
}
export class StNuminteriorrings implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_numinteriorrings"; }
async call(parameters : Public.Procedures.StNuminteriorrings.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_numinteriorrings( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numinteriorrings) );
              return responseBody;
           
}
}
export class StNuminteriorring implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_numinteriorring"; }
async call(parameters : Public.Procedures.StNuminteriorring.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_numinteriorring( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numinteriorring) );
              return responseBody;
           
}
}
export class StInteriorringn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_interiorringn"; }
async call(parameters : Public.Procedures.StInteriorringn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_interiorringn( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_interiorringn) );
              return responseBody;
           
}
}
export class Geometrytype_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometrytype_0cdb"; }
async call(parameters : Public.Procedures.Geometrytype_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometrytype( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].geometrytype) );
              return responseBody;
           
}
}
export class StGeometrytype implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geometrytype"; }
async call(parameters : Public.Procedures.StGeometrytype.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geometrytype( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geometrytype) );
              return responseBody;
           
}
}
export class StPointn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointn"; }
async call(parameters : Public.Procedures.StPointn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointn( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointn) );
              return responseBody;
           
}
}
export class StNumpatches implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_numpatches"; }
async call(parameters : Public.Procedures.StNumpatches.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_numpatches( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_numpatches) );
              return responseBody;
           
}
}
export class StPatchn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_patchn"; }
async call(parameters : Public.Procedures.StPatchn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_patchn( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_patchn) );
              return responseBody;
           
}
}
export class StStartpoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_startpoint"; }
async call(parameters : Public.Procedures.StStartpoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_startpoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_startpoint) );
              return responseBody;
           
}
}
export class StEndpoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_endpoint"; }
async call(parameters : Public.Procedures.StEndpoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_endpoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_endpoint) );
              return responseBody;
           
}
}
export class StIsclosed implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isclosed"; }
async call(parameters : Public.Procedures.StIsclosed.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isclosed( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isclosed) );
              return responseBody;
           
}
}
export class StIsempty implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_isempty"; }
async call(parameters : Public.Procedures.StIsempty.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_isempty( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_isempty) );
              return responseBody;
           
}
}
export class StAsbinary_88bc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asbinary_88bc"; }
async call(parameters : Public.Procedures.StAsbinary_88bc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asbinary( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}
export class StAsbinary_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asbinary_0cdb"; }
async call(parameters : Public.Procedures.StAsbinary_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asbinary( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}
export class StAstext_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astext_0cdb"; }
async call(parameters : Public.Procedures.StAstext_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astext( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}
export class StAstext_6cbe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astext_6cbe"; }
async call(parameters : Public.Procedures.StAstext_6cbe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astext( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}
export class StGeometryfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geometryfromtext_e728"; }
async call(parameters : Public.Procedures.StGeometryfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geometryfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryfromtext) );
              return responseBody;
           
}
}
export class StGeometryfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geometryfromtext_27e2"; }
async call(parameters : Public.Procedures.StGeometryfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geometryfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geometryfromtext) );
              return responseBody;
           
}
}
export class StGeomfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromtext_e728"; }
async call(parameters : Public.Procedures.StGeomfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtext) );
              return responseBody;
           
}
}
export class StGeomfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromtext_27e2"; }
async call(parameters : Public.Procedures.StGeomfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromtext) );
              return responseBody;
           
}
}
export class StWkttosql implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_wkttosql"; }
async call(parameters : Public.Procedures.StWkttosql.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_wkttosql( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wkttosql) );
              return responseBody;
           
}
}
export class StPointfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointfromtext_e728"; }
async call(parameters : Public.Procedures.StPointfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromtext) );
              return responseBody;
           
}
}
export class StPointfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointfromtext_27e2"; }
async call(parameters : Public.Procedures.StPointfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromtext) );
              return responseBody;
           
}
}
export class StLinefromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefromtext_e728"; }
async call(parameters : Public.Procedures.StLinefromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromtext) );
              return responseBody;
           
}
}
export class StLinefromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefromtext_27e2"; }
async call(parameters : Public.Procedures.StLinefromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromtext) );
              return responseBody;
           
}
}
export class StPolyfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polyfromtext_e728"; }
async call(parameters : Public.Procedures.StPolyfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromtext) );
              return responseBody;
           
}
}
export class StPolyfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polyfromtext_27e2"; }
async call(parameters : Public.Procedures.StPolyfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromtext) );
              return responseBody;
           
}
}
export class StPolygonfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygonfromtext_27e2"; }
async call(parameters : Public.Procedures.StPolygonfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromtext) );
              return responseBody;
           
}
}
export class StPolygonfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygonfromtext_e728"; }
async call(parameters : Public.Procedures.StPolygonfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromtext) );
              return responseBody;
           
}
}
export class StMlinefromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mlinefromtext_27e2"; }
async call(parameters : Public.Procedures.StMlinefromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mlinefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromtext) );
              return responseBody;
           
}
}
export class StMlinefromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mlinefromtext_e728"; }
async call(parameters : Public.Procedures.StMlinefromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mlinefromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromtext) );
              return responseBody;
           
}
}
export class StMultilinestringfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multilinestringfromtext_e728"; }
async call(parameters : Public.Procedures.StMultilinestringfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multilinestringfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinestringfromtext) );
              return responseBody;
           
}
}
export class StMultilinestringfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multilinestringfromtext_27e2"; }
async call(parameters : Public.Procedures.StMultilinestringfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multilinestringfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinestringfromtext) );
              return responseBody;
           
}
}
export class StMpointfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpointfromtext_27e2"; }
async call(parameters : Public.Procedures.StMpointfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromtext) );
              return responseBody;
           
}
}
export class StMpointfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpointfromtext_e728"; }
async call(parameters : Public.Procedures.StMpointfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromtext) );
              return responseBody;
           
}
}
export class StMultipointfromtext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipointfromtext"; }
async call(parameters : Public.Procedures.StMultipointfromtext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipointfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromtext) );
              return responseBody;
           
}
}
export class StMpolyfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpolyfromtext_27e2"; }
async call(parameters : Public.Procedures.StMpolyfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromtext) );
              return responseBody;
           
}
}
export class StMpolyfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpolyfromtext_e728"; }
async call(parameters : Public.Procedures.StMpolyfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromtext) );
              return responseBody;
           
}
}
export class StMultipolygonfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipolygonfromtext_27e2"; }
async call(parameters : Public.Procedures.StMultipolygonfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipolygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolygonfromtext) );
              return responseBody;
           
}
}
export class StMultipolygonfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipolygonfromtext_e728"; }
async call(parameters : Public.Procedures.StMultipolygonfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipolygonfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolygonfromtext) );
              return responseBody;
           
}
}
export class StGeomcollfromtext_27e2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomcollfromtext_27e2"; }
async call(parameters : Public.Procedures.StGeomcollfromtext_27e2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomcollfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromtext) );
              return responseBody;
           
}
}
export class StGeomcollfromtextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomcollfromtext_e728"; }
async call(parameters : Public.Procedures.StGeomcollfromtextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomcollfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromtext) );
              return responseBody;
           
}
}
export class StGeomfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromwkb_2d19"; }
async call(parameters : Public.Procedures.StGeomfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromwkb) );
              return responseBody;
           
}
}
export class StGeomfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomfromwkb_d8af"; }
async call(parameters : Public.Procedures.StGeomfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomfromwkb) );
              return responseBody;
           
}
}
export class StPointfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointfromwkb_d8af"; }
async call(parameters : Public.Procedures.StPointfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromwkb) );
              return responseBody;
           
}
}
export class StPointfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointfromwkb_2d19"; }
async call(parameters : Public.Procedures.StPointfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointfromwkb) );
              return responseBody;
           
}
}
export class StLinefromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefromwkb_d8af"; }
async call(parameters : Public.Procedures.StLinefromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromwkb) );
              return responseBody;
           
}
}
export class StLinefromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linefromwkb_2d19"; }
async call(parameters : Public.Procedures.StLinefromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linefromwkb) );
              return responseBody;
           
}
}
export class StLinestringfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linestringfromwkb_d8af"; }
async call(parameters : Public.Procedures.StLinestringfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linestringfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linestringfromwkb) );
              return responseBody;
           
}
}
export class StLinestringfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linestringfromwkb_2d19"; }
async call(parameters : Public.Procedures.StLinestringfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linestringfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linestringfromwkb) );
              return responseBody;
           
}
}
export class StPolyfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polyfromwkb_d8af"; }
async call(parameters : Public.Procedures.StPolyfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromwkb) );
              return responseBody;
           
}
}
export class StPolyfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polyfromwkb_2d19"; }
async call(parameters : Public.Procedures.StPolyfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polyfromwkb) );
              return responseBody;
           
}
}
export class StPolygonfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygonfromwkb_d8af"; }
async call(parameters : Public.Procedures.StPolygonfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygonfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromwkb) );
              return responseBody;
           
}
}
export class StPolygonfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygonfromwkb_2d19"; }
async call(parameters : Public.Procedures.StPolygonfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygonfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygonfromwkb) );
              return responseBody;
           
}
}
export class StMpointfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpointfromwkb_d8af"; }
async call(parameters : Public.Procedures.StMpointfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromwkb) );
              return responseBody;
           
}
}
export class StMpointfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpointfromwkb_2d19"; }
async call(parameters : Public.Procedures.StMpointfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpointfromwkb) );
              return responseBody;
           
}
}
export class StMultipointfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipointfromwkb_d8af"; }
async call(parameters : Public.Procedures.StMultipointfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromwkb) );
              return responseBody;
           
}
}
export class GeographyAnalyze implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_analyze"; }
async call(parameters : Public.Procedures.GeographyAnalyze.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_analyze( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_analyze) );
              return responseBody;
           
}
}
export class StMultipointfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipointfromwkb_2d19"; }
async call(parameters : Public.Procedures.StMultipointfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipointfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipointfromwkb) );
              return responseBody;
           
}
}
export class StMultilinefromwkb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multilinefromwkb"; }
async call(parameters : Public.Procedures.StMultilinefromwkb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multilinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multilinefromwkb) );
              return responseBody;
           
}
}
export class StMlinefromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mlinefromwkb_d8af"; }
async call(parameters : Public.Procedures.StMlinefromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mlinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromwkb) );
              return responseBody;
           
}
}
export class StMlinefromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mlinefromwkb_2d19"; }
async call(parameters : Public.Procedures.StMlinefromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mlinefromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mlinefromwkb) );
              return responseBody;
           
}
}
export class StMpolyfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpolyfromwkb_d8af"; }
async call(parameters : Public.Procedures.StMpolyfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromwkb) );
              return responseBody;
           
}
}
export class StMpolyfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_mpolyfromwkb_2d19"; }
async call(parameters : Public.Procedures.StMpolyfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_mpolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_mpolyfromwkb) );
              return responseBody;
           
}
}
export class StMultipolyfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipolyfromwkb_d8af"; }
async call(parameters : Public.Procedures.StMultipolyfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolyfromwkb) );
              return responseBody;
           
}
}
export class StMultipolyfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_multipolyfromwkb_2d19"; }
async call(parameters : Public.Procedures.StMultipolyfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_multipolyfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_multipolyfromwkb) );
              return responseBody;
           
}
}
export class StGeomcollfromwkbD8af implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomcollfromwkb_d8af"; }
async call(parameters : Public.Procedures.StGeomcollfromwkbD8af.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomcollfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromwkb) );
              return responseBody;
           
}
}
export class StGeomcollfromwkb_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geomcollfromwkb_2d19"; }
async call(parameters : Public.Procedures.StGeomcollfromwkb_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geomcollfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_geomcollfromwkb) );
              return responseBody;
           
}
}
export class StMaxdistance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_maxdistance"; }
async call(parameters : Public.Procedures.StMaxdistance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_maxdistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_maxdistance) );
              return responseBody;
           
}
}
export class StClosestpoint_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_closestpoint_3651"; }
async call(parameters : Public.Procedures.StClosestpoint_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_closestpoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}
export class StShortestline_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_shortestline_3651"; }
async call(parameters : Public.Procedures.StShortestline_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_shortestline(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}
export class StLongestline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_longestline"; }
async call(parameters : Public.Procedures.StLongestline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_longestline(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_longestline) );
              return responseBody;
           
}
}
export class StSwapordinates implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_swapordinates"; }
async call(parameters : Public.Procedures.StSwapordinates.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_swapordinates(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },ords => ${ typed[2275](undefinedIsNull(parameters.ords)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_swapordinates) );
              return responseBody;
           
}
}
export class StFlipcoordinates implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_flipcoordinates"; }
async call(parameters : Public.Procedures.StFlipcoordinates.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_flipcoordinates( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_flipcoordinates) );
              return responseBody;
           
}
}
export class StBdpolyfromtext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_bdpolyfromtext"; }
async call(parameters : Public.Procedures.StBdpolyfromtext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_bdpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_bdpolyfromtext) );
              return responseBody;
           
}
}
export class StBdmpolyfromtext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_bdmpolyfromtext"; }
async call(parameters : Public.Procedures.StBdmpolyfromtext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_bdmpolyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_bdmpolyfromtext) );
              return responseBody;
           
}
}
export class Unlockrows implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "unlockrows"; }
async call(parameters : Public.Procedures.Unlockrows.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.unlockrows( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].unlockrows) );
              return responseBody;
           
}
}
export class Geography_28e9 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_28e9"; }
async call(parameters : Public.Procedures.Geography_28e9.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) }, ${ typed[16](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}
export class Geography_2d19 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_2d19"; }
async call(parameters : Public.Procedures.Geography_2d19.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}
export class Bytea_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "bytea_7902"; }
async call(parameters : Public.Procedures.Bytea_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.bytea( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].bytea) );
              return responseBody;
           
}
}
export class StAstext_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astext_7902"; }
async call(parameters : Public.Procedures.StAstext_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astext( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}
export class StAstext_3181 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astext_3181"; }
async call(parameters : Public.Procedures.StAstext_3181.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astext( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}
export class LockrowE9aa implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "lockrow_e9aa"; }
async call(parameters : Public.Procedures.LockrowE9aa.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) }, ${ typed[1114](undefinedIsNull(parameters.argument_4)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}
export class Lockrow_02b4 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "lockrow_02b4"; }
async call(parameters : Public.Procedures.Lockrow_02b4.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[25](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}
export class Lockrow_27e1 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "lockrow_27e1"; }
async call(parameters : Public.Procedures.Lockrow_27e1.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}
export class Lockrow_9a8a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "lockrow_9a8a"; }
async call(parameters : Public.Procedures.Lockrow_9a8a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.lockrow( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) }, ${ typed[1114](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].lockrow) );
              return responseBody;
           
}
}
export class Addauth implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "addauth"; }
async call(parameters : Public.Procedures.Addauth.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.addauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].addauth) );
              return responseBody;
           
}
}
export class Checkauth_27e1 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "checkauth_27e1"; }
async call(parameters : Public.Procedures.Checkauth_27e1.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.checkauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].checkauth) );
              return responseBody;
           
}
}
export class Checkauth_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "checkauth_2ec2"; }
async call(parameters : Public.Procedures.Checkauth_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.checkauth( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].checkauth) );
              return responseBody;
           
}
}
export class Checkauthtrigger implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "checkauthtrigger"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Trigger.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.checkauthtrigger()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Trigger.parse(results?.[0].checkauthtrigger) );
              return responseBody;
           
}
}
export class Gettransactionid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "gettransactionid"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Xid.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.gettransactionid()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Xid.parse(results?.[0].gettransactionid) );
              return responseBody;
           
}
}
export class Enablelongtransactions implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "enablelongtransactions"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.enablelongtransactions()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].enablelongtransactions) );
              return responseBody;
           
}
}
export class Longtransactionsenabled implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "longtransactionsenabled"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.longtransactionsenabled()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].longtransactionsenabled) );
              return responseBody;
           
}
}
export class Disablelongtransactions implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "disablelongtransactions"; }
async call(options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.disablelongtransactions()`, {options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].disablelongtransactions) );
              return responseBody;
           
}
}
export class GeographyTypmodIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_typmod_in"; }
async call(parameters : Public.Procedures.GeographyTypmodIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_typmod_in( ${ typed[1263](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geography_typmod_in) );
              return responseBody;
           
}
}
export class GeographyTypmodOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_typmod_out"; }
async call(parameters : Public.Procedures.GeographyTypmodOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_typmod_out( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geography_typmod_out) );
              return responseBody;
           
}
}
export class GeographyIn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_in"; }
async call(parameters : Public.Procedures.GeographyIn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_in( ${ typed[2275](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography_in) );
              return responseBody;
           
}
}
export class GeographyOut implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_out"; }
async call(parameters : Public.Procedures.GeographyOut.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Cstring.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_out( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Cstring.parse(results?.[0].geography_out) );
              return responseBody;
           
}
}
export class GeographyRecv implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_recv"; }
async call(parameters : Public.Procedures.GeographyRecv.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_recv( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[26](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography_recv) );
              return responseBody;
           
}
}
export class GeographySend implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_send"; }
async call(parameters : Public.Procedures.GeographySend.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_send( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].geography_send) );
              return responseBody;
           
}
}
export class StAstextE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_astext_e728"; }
async call(parameters : Public.Procedures.StAstextE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_astext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_astext) );
              return responseBody;
           
}
}
export class StGeographyfromtext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geographyfromtext"; }
async call(parameters : Public.Procedures.StGeographyfromtext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geographyfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geographyfromtext) );
              return responseBody;
           
}
}
export class StGeogfromtext implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geogfromtext"; }
async call(parameters : Public.Procedures.StGeogfromtext.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geogfromtext( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geogfromtext) );
              return responseBody;
           
}
}
export class StGeogfromwkb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geogfromwkb"; }
async call(parameters : Public.Procedures.StGeogfromwkb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geogfromwkb( ${ typed[17](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_geogfromwkb) );
              return responseBody;
           
}
}
export class PostgisTypmodDims implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_typmod_dims"; }
async call(parameters : Public.Procedures.PostgisTypmodDims.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_typmod_dims( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_typmod_dims) );
              return responseBody;
           
}
}
export class PostgisTypmodSrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_typmod_srid"; }
async call(parameters : Public.Procedures.PostgisTypmodSrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_typmod_srid( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_typmod_srid) );
              return responseBody;
           
}
}
export class PostgisTypmodType implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_typmod_type"; }
async call(parameters : Public.Procedures.PostgisTypmodType.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_typmod_type( ${ typed[23](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].postgis_typmod_type) );
              return responseBody;
           
}
}
export class Geography_0cdb implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_0cdb"; }
async call(parameters : Public.Procedures.Geography_0cdb.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography( ${ typed[47258](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].geography) );
              return responseBody;
           
}
}
export class Geometry_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_7902"; }
async call(parameters : Public.Procedures.Geometry_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].geometry) );
              return responseBody;
           
}
}
export class GeographyGistConsistent implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_consistent"; }
async call(parameters : Public.Procedures.GeographyGistConsistent.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_consistent( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_gist_consistent) );
              return responseBody;
           
}
}
export class GeographyGistCompress implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_compress"; }
async call(parameters : Public.Procedures.GeographyGistCompress.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_compress( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_compress) );
              return responseBody;
           
}
}
export class GeographyGistPenalty implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_penalty"; }
async call(parameters : Public.Procedures.GeographyGistPenalty.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_penalty( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_penalty) );
              return responseBody;
           
}
}
export class GeographyGistPicksplit implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_picksplit"; }
async call(parameters : Public.Procedures.GeographyGistPicksplit.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_picksplit( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_picksplit) );
              return responseBody;
           
}
}
export class GeographyGistUnion implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_union"; }
async call(parameters : Public.Procedures.GeographyGistUnion.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_union( ${ typed[17](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_union) );
              return responseBody;
           
}
}
export class GeographyGistSame implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_same"; }
async call(parameters : Public.Procedures.GeographyGistSame.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_same( ${ typed[47289](undefinedIsNull(parameters.argument_0)) }, ${ typed[47289](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_same) );
              return responseBody;
           
}
}
export class GeographyGistDecompress implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_decompress"; }
async call(parameters : Public.Procedures.GeographyGistDecompress.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_decompress( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_gist_decompress) );
              return responseBody;
           
}
}
export class GeographyOverlaps implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_overlaps"; }
async call(parameters : Public.Procedures.GeographyOverlaps.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_overlaps( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_overlaps) );
              return responseBody;
           
}
}
export class GeographyDistanceKnn implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_distance_knn"; }
async call(parameters : Public.Procedures.GeographyDistanceKnn.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_distance_knn( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geography_distance_knn) );
              return responseBody;
           
}
}
export class GeographyGistDistance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gist_distance"; }
async call(parameters : Public.Procedures.GeographyGistDistance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gist_distance( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].geography_gist_distance) );
              return responseBody;
           
}
}
export class OverlapsGeog_52a8 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_geog_52a8"; }
async call(parameters : Public.Procedures.OverlapsGeog_52a8.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_geog( ${ typed[47297](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}
export class OverlapsGeog_25ba implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_geog_25ba"; }
async call(parameters : Public.Procedures.OverlapsGeog_25ba.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_geog( ${ typed[47297](undefinedIsNull(parameters.argument_0)) }, ${ typed[47297](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}
export class OverlapsGeog_8fd3 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_geog_8fd3"; }
async call(parameters : Public.Procedures.OverlapsGeog_8fd3.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_geog( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47297](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_geog) );
              return responseBody;
           
}
}
export class GeogBrinInclusionAddValue implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geog_brin_inclusion_add_value"; }
async call(parameters : Public.Procedures.GeogBrinInclusionAddValue.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geog_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geog_brin_inclusion_add_value) );
              return responseBody;
           
}
}
export class GeographyLt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_lt"; }
async call(parameters : Public.Procedures.GeographyLt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_lt( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_lt) );
              return responseBody;
           
}
}
export class GeographyLe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_le"; }
async call(parameters : Public.Procedures.GeographyLe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_le( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_le) );
              return responseBody;
           
}
}
export class GeographyGt implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_gt"; }
async call(parameters : Public.Procedures.GeographyGt.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_gt( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_gt) );
              return responseBody;
           
}
}
export class GeographyGe implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_ge"; }
async call(parameters : Public.Procedures.GeographyGe.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_ge( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_ge) );
              return responseBody;
           
}
}
export class GeographyEq implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_eq"; }
async call(parameters : Public.Procedures.GeographyEq.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_eq( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_eq) );
              return responseBody;
           
}
}
export class GeographyCmp implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_cmp"; }
async call(parameters : Public.Procedures.GeographyCmp.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_cmp( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].geography_cmp) );
              return responseBody;
           
}
}
export class StAssvg_6ec5 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_assvg_6ec5"; }
async call(parameters : Public.Procedures.StAssvg_6ec5.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_assvg(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },rel => ${ typed[23](undefinedIsNull(parameters.rel)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}
export class StAssvgE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_assvg_e728"; }
async call(parameters : Public.Procedures.StAssvgE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_assvg( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_assvg) );
              return responseBody;
           
}
}
export class StProjectD4ec implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_project_d4ec"; }
async call(parameters : Public.Procedures.StProjectD4ec.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_project(geog_from => ${ typed[47964](undefinedIsNull(parameters.geogFrom)) },geog_to => ${ typed[47964](undefinedIsNull(parameters.geogTo)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_project) );
              return responseBody;
           
}
}
export class StAzimuthE452 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_azimuth_e452"; }
async call(parameters : Public.Procedures.StAzimuthE452.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_azimuth(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_azimuth) );
              return responseBody;
           
}
}
export class StBuffer_49f7 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_49f7"; }
async call(parameters : Public.Procedures.StBuffer_49f7.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StAsgmlE888 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgml_e888"; }
async call(parameters : Public.Procedures.StAsgmlE888.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgml(version => ${ typed[23](undefinedIsNull(parameters.version)) },geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}
export class StAsgml_2160 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgml_2160"; }
async call(parameters : Public.Procedures.StAsgml_2160.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgml(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) },id => ${ typed[25](undefinedIsNull(parameters.id)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}
export class StAsgmlE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgml_e728"; }
async call(parameters : Public.Procedures.StAsgmlE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgml) );
              return responseBody;
           
}
}
export class StAskmlF40a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_askml_f40a"; }
async call(parameters : Public.Procedures.StAskmlF40a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_askml(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },nprefix => ${ typed[25](undefinedIsNull(parameters.nprefix)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}
export class StAskmlE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_askml_e728"; }
async call(parameters : Public.Procedures.StAskmlE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_askml( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_askml) );
              return responseBody;
           
}
}
export class StAsgeojson_6ec5 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgeojson_6ec5"; }
async call(parameters : Public.Procedures.StAsgeojson_6ec5.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgeojson(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}
export class StAsgeojsonE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asgeojson_e728"; }
async call(parameters : Public.Procedures.StAsgeojsonE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asgeojson( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asgeojson) );
              return responseBody;
           
}
}
export class StDistance_8dcd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distance_8dcd"; }
async call(parameters : Public.Procedures.StDistance_8dcd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distance(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}
export class StDistance_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distance_2ec2"; }
async call(parameters : Public.Procedures.StDistance_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distance( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distance) );
              return responseBody;
           
}
}
export class StAreaEcae implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_area_ecae"; }
async call(parameters : Public.Procedures.StAreaEcae.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_area(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}
export class StAreaE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_area_e728"; }
async call(parameters : Public.Procedures.StAreaE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_area( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_area) );
              return responseBody;
           
}
}
export class StLengthEcae implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_length_ecae"; }
async call(parameters : Public.Procedures.StLengthEcae.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_length(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}
export class StLengthE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_length_e728"; }
async call(parameters : Public.Procedures.StLengthE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_length( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_length) );
              return responseBody;
           
}
}
export class StProjectEd46 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_project_ed46"; }
async call(parameters : Public.Procedures.StProjectEd46.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_project(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },distance => ${ typed[701](undefinedIsNull(parameters.distance)) },azimuth => ${ typed[701](undefinedIsNull(parameters.azimuth)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_project) );
              return responseBody;
           
}
}
export class StPerimeterEcae implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_perimeter_ecae"; }
async call(parameters : Public.Procedures.StPerimeterEcae.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_perimeter(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_perimeter) );
              return responseBody;
           
}
}
export class StSegmentizeCadf implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_segmentize_cadf"; }
async call(parameters : Public.Procedures.StSegmentizeCadf.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_segmentize(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },max_segment_length => ${ typed[701](undefinedIsNull(parameters.maxSegmentLength)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_segmentize) );
              return responseBody;
           
}
}
export class StAsbinary_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asbinary_7902"; }
async call(parameters : Public.Procedures.StAsbinary_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asbinary( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}
export class StAsbinary_734d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asbinary_734d"; }
async call(parameters : Public.Procedures.StAsbinary_734d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bytea.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asbinary( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bytea.parse(results?.[0].st_asbinary) );
              return responseBody;
           
}
}
export class StAsewkt_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkt_7902"; }
async call(parameters : Public.Procedures.StAsewkt_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkt( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}
export class StAsewkt_3181 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkt_3181"; }
async call(parameters : Public.Procedures.StAsewkt_3181.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkt( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}
export class StAsewktE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asewkt_e728"; }
async call(parameters : Public.Procedures.StAsewktE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asewkt( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asewkt) );
              return responseBody;
           
}
}
export class Geometrytype_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometrytype_7902"; }
async call(parameters : Public.Procedures.Geometrytype_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometrytype( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].geometrytype) );
              return responseBody;
           
}
}
export class StSummary_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_summary_7902"; }
async call(parameters : Public.Procedures.StSummary_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_summary( ${ typed[47964](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_summary) );
              return responseBody;
           
}
}
export class StGeohash_3181 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_geohash_3181"; }
async call(parameters : Public.Procedures.StGeohash_3181.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_geohash(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },maxchars => ${ typed[23](undefinedIsNull(parameters.maxchars)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_geohash) );
              return responseBody;
           
}
}
export class StSrid_7902 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_srid_7902"; }
async call(parameters : Public.Procedures.StSrid_7902.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_srid(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].st_srid) );
              return responseBody;
           
}
}
export class StSetsrid_3181 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_setsrid_3181"; }
async call(parameters : Public.Procedures.StSetsrid_3181.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_setsrid(geog => ${ typed[47964](undefinedIsNull(parameters.geog)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_setsrid) );
              return responseBody;
           
}
}
export class StCentroidEcae implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_centroid_ecae"; }
async call(parameters : Public.Procedures.StCentroidEcae.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_centroid(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}
export class StCentroidE728 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_centroid_e728"; }
async call(parameters : Public.Procedures.StCentroidE728.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_centroid( ${ typed[25](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_centroid) );
              return responseBody;
           
}
}
export class StCoversE452 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_covers_e452"; }
async call(parameters : Public.Procedures.StCoversE452.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_covers(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}
export class StDwithin_55df implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dwithin_55df"; }
async call(parameters : Public.Procedures.StDwithin_55df.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dwithin(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) },tolerance => ${ typed[701](undefinedIsNull(parameters.tolerance)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}
export class StCoveredbyE452 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_coveredby_e452"; }
async call(parameters : Public.Procedures.StCoveredbyE452.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_coveredby(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}
export class StIntersectsE452 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersects_e452"; }
async call(parameters : Public.Procedures.StIntersectsE452.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersects(geog1 => ${ typed[47964](undefinedIsNull(parameters.geog1)) },geog2 => ${ typed[47964](undefinedIsNull(parameters.geog2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}
export class StBufferCadf implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_cadf"; }
async call(parameters : Public.Procedures.StBufferCadf.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StBuffer_12e3 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_12e3"; }
async call(parameters : Public.Procedures.StBuffer_12e3.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[23](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StBuffer_3aaa implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_3aaa"; }
async call(parameters : Public.Procedures.StBuffer_3aaa.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StBufferC349 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_c349"; }
async call(parameters : Public.Procedures.StBufferC349.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StBufferF7c6 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_buffer_f7c6"; }
async call(parameters : Public.Procedures.StBufferF7c6.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_buffer( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[25](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_buffer) );
              return responseBody;
           
}
}
export class StIntersectionE452 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersection_e452"; }
async call(parameters : Public.Procedures.StIntersectionE452.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersection( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[47964](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}
export class StIntersection_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersection_2ec2"; }
async call(parameters : Public.Procedures.StIntersection_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersection( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_intersection) );
              return responseBody;
           
}
}
export class StCovers_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_covers_2ec2"; }
async call(parameters : Public.Procedures.StCovers_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_covers( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_covers) );
              return responseBody;
           
}
}
export class StCoveredby_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_coveredby_2ec2"; }
async call(parameters : Public.Procedures.StCoveredby_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_coveredby( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_coveredby) );
              return responseBody;
           
}
}
export class StDwithinEfc0 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_dwithin_efc0"; }
async call(parameters : Public.Procedures.StDwithinEfc0.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_dwithin( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_dwithin) );
              return responseBody;
           
}
}
export class StIntersects_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_intersects_2ec2"; }
async call(parameters : Public.Procedures.StIntersects_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_intersects( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_intersects) );
              return responseBody;
           
}
}
export class StClosestpoint_8dcd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_closestpoint_8dcd"; }
async call(parameters : Public.Procedures.StClosestpoint_8dcd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_closestpoint(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[47964](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}
export class StClosestpoint_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_closestpoint_2ec2"; }
async call(parameters : Public.Procedures.StClosestpoint_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_closestpoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_closestpoint) );
              return responseBody;
           
}
}
export class StShortestline_8dcd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_shortestline_8dcd"; }
async call(parameters : Public.Procedures.StShortestline_8dcd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_shortestline(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[47964](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}
export class StShortestline_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_shortestline_2ec2"; }
async call(parameters : Public.Procedures.StShortestline_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_shortestline( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_shortestline) );
              return responseBody;
           
}
}
export class StLinesubstringEd46 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linesubstring_ed46"; }
async call(parameters : Public.Procedures.StLinesubstringEd46.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linesubstring( ${ typed[47964](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}
export class StLinesubstringE586 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linesubstring_e586"; }
async call(parameters : Public.Procedures.StLinesubstringE586.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linesubstring( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) }, ${ typed[701](undefinedIsNull(parameters.argument_2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linesubstring) );
              return responseBody;
           
}
}
export class StLinelocatepoint_8dcd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linelocatepoint_8dcd"; }
async call(parameters : Public.Procedures.StLinelocatepoint_8dcd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linelocatepoint(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[47964](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}
export class StLinelocatepoint_2ec2 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linelocatepoint_2ec2"; }
async call(parameters : Public.Procedures.StLinelocatepoint_2ec2.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linelocatepoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[25](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_linelocatepoint) );
              return responseBody;
           
}
}
export class StLineinterpolatepoints_8796 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoints_8796"; }
async call(parameters : Public.Procedures.StLineinterpolatepoints_8796.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoints(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) },repeat => ${ typed[16](undefinedIsNull(parameters.repeat)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}
export class StLineinterpolatepointsC349 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoints_c349"; }
async call(parameters : Public.Procedures.StLineinterpolatepointsC349.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoints( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoints) );
              return responseBody;
           
}
}
export class StLineinterpolatepoint_612b implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoint_612b"; }
async call(parameters : Public.Procedures.StLineinterpolatepoint_612b.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geography.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoint(argument_0 => ${ typed[47964](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },use_spheroid => ${ typed[16](undefinedIsNull(parameters.useSpheroid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geography.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}
export class StLineinterpolatepointC349 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_lineinterpolatepoint_c349"; }
async call(parameters : Public.Procedures.StLineinterpolatepointC349.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_lineinterpolatepoint( ${ typed[25](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_lineinterpolatepoint) );
              return responseBody;
           
}
}
export class StDistancesphere_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distancesphere_3651"; }
async call(parameters : Public.Procedures.StDistancesphere_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distancesphere(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancesphere) );
              return responseBody;
           
}
}
export class StDistancesphere_6961 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_distancesphere_6961"; }
async call(parameters : Public.Procedures.StDistancesphere_6961.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_distancesphere(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) },radius => ${ typed[701](undefinedIsNull(parameters.radius)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_distancesphere) );
              return responseBody;
           
}
}
export class PostgisTypeName implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_type_name"; }
async call(parameters : Public.Procedures.PostgisTypeName.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Varchar.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_type_name(geomname => ${ typed[1043](undefinedIsNull(parameters.geomname)) },coord_dimension => ${ typed[23](undefinedIsNull(parameters.coordDimension)) },use_new_name => ${ typed[16](undefinedIsNull(parameters.useNewName)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Varchar.parse(results?.[0].postgis_type_name) );
              return responseBody;
           
}
}
export class PostgisConstraintSrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_constraint_srid"; }
async call(parameters : Public.Procedures.PostgisConstraintSrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_constraint_srid(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_constraint_srid) );
              return responseBody;
           
}
}
export class PostgisConstraintDims implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_constraint_dims"; }
async call(parameters : Public.Procedures.PostgisConstraintDims.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int4.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_constraint_dims(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int4.parse(results?.[0].postgis_constraint_dims) );
              return responseBody;
           
}
}
export class PostgisConstraintType implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "postgis_constraint_type"; }
async call(parameters : Public.Procedures.PostgisConstraintType.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Varchar.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.postgis_constraint_type(geomschema => ${ typed[25](undefinedIsNull(parameters.geomschema)) },geomtable => ${ typed[25](undefinedIsNull(parameters.geomtable)) },geomcolumn => ${ typed[25](undefinedIsNull(parameters.geomcolumn)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Varchar.parse(results?.[0].postgis_constraint_type) );
              return responseBody;
           
}
}
export class St_3ddistance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3ddistance"; }
async call(parameters : Public.Procedures.St_3ddistance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3ddistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3ddistance) );
              return responseBody;
           
}
}
export class St_3dmaxdistance implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dmaxdistance"; }
async call(parameters : Public.Procedures.St_3dmaxdistance.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dmaxdistance(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_3dmaxdistance) );
              return responseBody;
           
}
}
export class St_3dclosestpoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dclosestpoint"; }
async call(parameters : Public.Procedures.St_3dclosestpoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dclosestpoint(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dclosestpoint) );
              return responseBody;
           
}
}
export class St_3dshortestline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dshortestline"; }
async call(parameters : Public.Procedures.St_3dshortestline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dshortestline(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dshortestline) );
              return responseBody;
           
}
}
export class St_3dlongestline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dlongestline"; }
async call(parameters : Public.Procedures.St_3dlongestline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dlongestline(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dlongestline) );
              return responseBody;
           
}
}
export class StCoorddim implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_coorddim"; }
async call(parameters : Public.Procedures.StCoorddim.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Int2.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_coorddim(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Int2.parse(results?.[0].st_coorddim) );
              return responseBody;
           
}
}
export class StCurvetoline implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_curvetoline"; }
async call(parameters : Public.Procedures.StCurvetoline.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_curvetoline(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },tol => ${ typed[701](undefinedIsNull(parameters.tol)) },toltype => ${ typed[23](undefinedIsNull(parameters.toltype)) },flags => ${ typed[23](undefinedIsNull(parameters.flags)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_curvetoline) );
              return responseBody;
           
}
}
export class StHasarc implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_hasarc"; }
async call(parameters : Public.Procedures.StHasarc.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_hasarc(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].st_hasarc) );
              return responseBody;
           
}
}
export class StLinetocurve implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_linetocurve"; }
async call(parameters : Public.Procedures.StLinetocurve.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_linetocurve(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_linetocurve) );
              return responseBody;
           
}
}
export class StPoint_0aec implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_point_0aec"; }
async call(parameters : Public.Procedures.StPoint_0aec.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_point( ${ typed[701](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_point) );
              return responseBody;
           
}
}
export class StPoint_0b7f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_point_0b7f"; }
async call(parameters : Public.Procedures.StPoint_0b7f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_point(argument_0 => ${ typed[701](undefinedIsNull(parameters.argument_0)) },argument_1 => ${ typed[701](undefinedIsNull(parameters.argument_1)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_point) );
              return responseBody;
           
}
}
export class StPointz implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointz"; }
async call(parameters : Public.Procedures.StPointz.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointz(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },zcoordinate => ${ typed[701](undefinedIsNull(parameters.zcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointz) );
              return responseBody;
           
}
}
export class StPointm implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointm"; }
async call(parameters : Public.Procedures.StPointm.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointm(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },mcoordinate => ${ typed[701](undefinedIsNull(parameters.mcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointm) );
              return responseBody;
           
}
}
export class StPointzm implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_pointzm"; }
async call(parameters : Public.Procedures.StPointzm.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_pointzm(xcoordinate => ${ typed[701](undefinedIsNull(parameters.xcoordinate)) },ycoordinate => ${ typed[701](undefinedIsNull(parameters.ycoordinate)) },zcoordinate => ${ typed[701](undefinedIsNull(parameters.zcoordinate)) },mcoordinate => ${ typed[701](undefinedIsNull(parameters.mcoordinate)) },srid => ${ typed[23](undefinedIsNull(parameters.srid)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_pointzm) );
              return responseBody;
           
}
}
export class StPolygon implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_polygon"; }
async call(parameters : Public.Procedures.StPolygon.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_polygon( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[23](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_polygon) );
              return responseBody;
           
}
}
export class StWkbtosql implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_wkbtosql"; }
async call(parameters : Public.Procedures.StWkbtosql.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_wkbtosql(wkb => ${ typed[17](undefinedIsNull(parameters.wkb)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_wkbtosql) );
              return responseBody;
           
}
}
export class StLocatebetween implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_locatebetween"; }
async call(parameters : Public.Procedures.StLocatebetween.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_locatebetween(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) },frommeasure => ${ typed[701](undefinedIsNull(parameters.frommeasure)) },tomeasure => ${ typed[701](undefinedIsNull(parameters.tomeasure)) },leftrightoffset => ${ typed[701](undefinedIsNull(parameters.leftrightoffset)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatebetween) );
              return responseBody;
           
}
}
export class StLocatealong implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_locatealong"; }
async call(parameters : Public.Procedures.StLocatealong.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_locatealong(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) },measure => ${ typed[701](undefinedIsNull(parameters.measure)) },leftrightoffset => ${ typed[701](undefinedIsNull(parameters.leftrightoffset)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatealong) );
              return responseBody;
           
}
}
export class StLocatebetweenelevations implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_locatebetweenelevations"; }
async call(parameters : Public.Procedures.StLocatebetweenelevations.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_locatebetweenelevations(geometry => ${ typed[47258](undefinedIsNull(parameters.geometry)) },fromelevation => ${ typed[701](undefinedIsNull(parameters.fromelevation)) },toelevation => ${ typed[701](undefinedIsNull(parameters.toelevation)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_locatebetweenelevations) );
              return responseBody;
           
}
}
export class StInterpolatepoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_interpolatepoint"; }
async call(parameters : Public.Procedures.StInterpolatepoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_interpolatepoint(line => ${ typed[47258](undefinedIsNull(parameters.line)) },point => ${ typed[47258](undefinedIsNull(parameters.point)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_interpolatepoint) );
              return responseBody;
           
}
}
export class StHexagon implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_hexagon"; }
async call(parameters : Public.Procedures.StHexagon.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_hexagon(size => ${ typed[701](undefinedIsNull(parameters.size)) },cell_i => ${ typed[23](undefinedIsNull(parameters.cellI)) },cell_j => ${ typed[23](undefinedIsNull(parameters.cellJ)) },origin => ${ typed[47258](undefinedIsNull(parameters.origin)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_hexagon) );
              return responseBody;
           
}
}
export class StSquare implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_square"; }
async call(parameters : Public.Procedures.StSquare.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_square(size => ${ typed[701](undefinedIsNull(parameters.size)) },cell_i => ${ typed[23](undefinedIsNull(parameters.cellI)) },cell_j => ${ typed[23](undefinedIsNull(parameters.cellJ)) },origin => ${ typed[47258](undefinedIsNull(parameters.origin)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_square) );
              return responseBody;
           
}
}
export class StHexagongrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_hexagongrid"; }
async call(parameters : Public.Procedures.StHexagongrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[48165].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StHexagongrid;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_hexagongrid(size => ${ typed[701](undefinedIsNull(parameters.size)) },bounds => ${ typed[47258](undefinedIsNull(parameters.bounds)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_hexagongrid)).filter<Public.Types.StHexagongrid>((r):r is Public.Types.StHexagongrid => r !== null) );
              return responseBody;
           
}
}
export class StSquaregrid implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_squaregrid"; }
async call(parameters : Public.Procedures.StSquaregrid.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              return context.procTypes[48166].parseFromPostgresIfPseudoType(context, result) as unknown as Public.Types.StSquaregrid;
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_squaregrid(size => ${ typed[701](undefinedIsNull(parameters.size)) },bounds => ${ typed[47258](undefinedIsNull(parameters.bounds)) })`, {parameters, options});
  const results = response;

              const responseBody = ( results.map(x => parseResult(this.database.context, x.st_squaregrid)).filter<Public.Types.StSquaregrid>((r):r is Public.Types.StSquaregrid => r !== null) );
              return responseBody;
           
}
}
export class Contains_2d_3f2a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "contains_2d_3f2a"; }
async call(parameters : Public.Procedures.Contains_2d_3f2a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.contains_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}
export class IsContained_2d_3f2a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "is_contained_2d_3f2a"; }
async call(parameters : Public.Procedures.IsContained_2d_3f2a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.is_contained_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}
export class Overlaps_2d_3f2a implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_2d_3f2a"; }
async call(parameters : Public.Procedures.Overlaps_2d_3f2a.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}
export class Overlaps_2d_4f71 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_2d_4f71"; }
async call(parameters : Public.Procedures.Overlaps_2d_4f71.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}
export class Contains_2d_4f71 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "contains_2d_4f71"; }
async call(parameters : Public.Procedures.Contains_2d_4f71.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.contains_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}
export class IsContained_2d_4f71 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "is_contained_2d_4f71"; }
async call(parameters : Public.Procedures.IsContained_2d_4f71.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.is_contained_2d( ${ typed[47293](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}
export class Contains_2d_7d4f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "contains_2d_7d4f"; }
async call(parameters : Public.Procedures.Contains_2d_7d4f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.contains_2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].contains_2d) );
              return responseBody;
           
}
}
export class IsContained_2d_7d4f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "is_contained_2d_7d4f"; }
async call(parameters : Public.Procedures.IsContained_2d_7d4f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.is_contained_2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].is_contained_2d) );
              return responseBody;
           
}
}
export class Overlaps_2d_7d4f implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_2d_7d4f"; }
async call(parameters : Public.Procedures.Overlaps_2d_7d4f.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_2d( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47293](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_2d) );
              return responseBody;
           
}
}
export class OverlapsNd_6173 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_nd_6173"; }
async call(parameters : Public.Procedures.OverlapsNd_6173.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_nd( ${ typed[47297](undefinedIsNull(parameters.argument_0)) }, ${ typed[47258](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}
export class OverlapsNd_25ba implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_nd_25ba"; }
async call(parameters : Public.Procedures.OverlapsNd_25ba.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_nd( ${ typed[47297](undefinedIsNull(parameters.argument_0)) }, ${ typed[47297](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}
export class OverlapsNd_40b7 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "overlaps_nd_40b7"; }
async call(parameters : Public.Procedures.OverlapsNd_40b7.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.overlaps_nd( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[47297](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].overlaps_nd) );
              return responseBody;
           
}
}
export class Geom2dBrinInclusionAddValue implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geom2d_brin_inclusion_add_value"; }
async call(parameters : Public.Procedures.Geom2dBrinInclusionAddValue.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geom2d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom2d_brin_inclusion_add_value) );
              return responseBody;
           
}
}
export class Geom3dBrinInclusionAddValue implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geom3d_brin_inclusion_add_value"; }
async call(parameters : Public.Procedures.Geom3dBrinInclusionAddValue.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geom3d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom3d_brin_inclusion_add_value) );
              return responseBody;
           
}
}
export class Geom4dBrinInclusionAddValue implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geom4d_brin_inclusion_add_value"; }
async call(parameters : Public.Procedures.Geom4dBrinInclusionAddValue.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geom4d_brin_inclusion_add_value( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) }, ${ typed[2281](undefinedIsNull(parameters.argument_2)) }, ${ typed[2281](undefinedIsNull(parameters.argument_3)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geom4d_brin_inclusion_add_value) );
              return responseBody;
           
}
}
export class StSimplifypolygonhull implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_simplifypolygonhull"; }
async call(parameters : Public.Procedures.StSimplifypolygonhull.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_simplifypolygonhull(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },vertex_fraction => ${ typed[701](undefinedIsNull(parameters.vertexFraction)) },is_outer => ${ typed[16](undefinedIsNull(parameters.isOuter)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_simplifypolygonhull) );
              return responseBody;
           
}
}
export class StConcavehull implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_concavehull"; }
async call(parameters : Public.Procedures.StConcavehull.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_concavehull(param_geom => ${ typed[47258](undefinedIsNull(parameters.paramGeom)) },param_pctconvex => ${ typed[701](undefinedIsNull(parameters.paramPctconvex)) },param_allow_holes => ${ typed[16](undefinedIsNull(parameters.paramAllowHoles)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_concavehull) );
              return responseBody;
           
}
}
export class StAsx3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_asx3d"; }
async call(parameters : Public.Procedures.StAsx3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Text.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_asx3d(geom => ${ typed[47258](undefinedIsNull(parameters.geom)) },maxdecimaldigits => ${ typed[23](undefinedIsNull(parameters.maxdecimaldigits)) },options => ${ typed[23](undefinedIsNull(parameters.options)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Text.parse(results?.[0].st_asx3d) );
              return responseBody;
           
}
}
export class StAngle_3651 implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_angle_3651"; }
async call(parameters : Public.Procedures.StAngle_3651.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Float8.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_angle(line1 => ${ typed[47258](undefinedIsNull(parameters.line1)) },line2 => ${ typed[47258](undefinedIsNull(parameters.line2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Float8.parse(results?.[0].st_angle) );
              return responseBody;
           
}
}
export class St_3dlineinterpolatepoint implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_3dlineinterpolatepoint"; }
async call(parameters : Public.Procedures.St_3dlineinterpolatepoint.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_3dlineinterpolatepoint( ${ typed[47258](undefinedIsNull(parameters.argument_0)) }, ${ typed[701](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_3dlineinterpolatepoint) );
              return responseBody;
           
}
}
export class GeometrySpgistConfig_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_config_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistConfig_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_config_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_2d) );
              return responseBody;
           
}
}
export class GeometrySpgistChoose_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_choose_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistChoose_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_choose_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_2d) );
              return responseBody;
           
}
}
export class GeometrySpgistPicksplit_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_picksplit_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistPicksplit_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_picksplit_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_2d) );
              return responseBody;
           
}
}
export class GeometrySpgistInnerConsistent_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_inner_consistent_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_inner_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_2d) );
              return responseBody;
           
}
}
export class GeometrySpgistLeafConsistent_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_leaf_consistent_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_leaf_consistent_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_2d) );
              return responseBody;
           
}
}
export class GeometrySpgistCompress_2d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_compress_2d"; }
async call(parameters : Public.Procedures.GeometrySpgistCompress_2d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_compress_2d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_2d) );
              return responseBody;
           
}
}
export class GeometryOverlaps_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_overlaps_3d"; }
async call(parameters : Public.Procedures.GeometryOverlaps_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_overlaps_3d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_overlaps_3d) );
              return responseBody;
           
}
}
export class GeometryContains_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_contains_3d"; }
async call(parameters : Public.Procedures.GeometryContains_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_contains_3d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contains_3d) );
              return responseBody;
           
}
}
export class GeometryContained_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_contained_3d"; }
async call(parameters : Public.Procedures.GeometryContained_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_contained_3d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_contained_3d) );
              return responseBody;
           
}
}
export class GeometrySame_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_same_3d"; }
async call(parameters : Public.Procedures.GeometrySame_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_same_3d(geom1 => ${ typed[47258](undefinedIsNull(parameters.geom1)) },geom2 => ${ typed[47258](undefinedIsNull(parameters.geom2)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_same_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistConfig_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_config_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistConfig_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_config_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistChoose_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_choose_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistChoose_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_choose_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistPicksplit_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_picksplit_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistPicksplit_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_picksplit_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistInnerConsistent_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_inner_consistent_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_inner_consistent_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistLeafConsistent_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_leaf_consistent_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_leaf_consistent_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistCompress_3d implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_compress_3d"; }
async call(parameters : Public.Procedures.GeometrySpgistCompress_3d.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_compress_3d( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_3d) );
              return responseBody;
           
}
}
export class GeometrySpgistConfigNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_config_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistConfigNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_config_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_config_nd) );
              return responseBody;
           
}
}
export class GeometrySpgistChooseNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_choose_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistChooseNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_choose_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_choose_nd) );
              return responseBody;
           
}
}
export class GeometrySpgistPicksplitNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_picksplit_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistPicksplitNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_picksplit_nd) );
              return responseBody;
           
}
}
export class GeometrySpgistInnerConsistentNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_inner_consistent_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_inner_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geometry_spgist_inner_consistent_nd) );
              return responseBody;
           
}
}
export class GeometrySpgistLeafConsistentNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_leaf_consistent_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_leaf_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geometry_spgist_leaf_consistent_nd) );
              return responseBody;
           
}
}
export class GeometrySpgistCompressNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geometry_spgist_compress_nd"; }
async call(parameters : Public.Procedures.GeometrySpgistCompressNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geometry_spgist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geometry_spgist_compress_nd) );
              return responseBody;
           
}
}
export class GeographySpgistConfigNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_config_nd"; }
async call(parameters : Public.Procedures.GeographySpgistConfigNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_config_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_config_nd) );
              return responseBody;
           
}
}
export class GeographySpgistChooseNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_choose_nd"; }
async call(parameters : Public.Procedures.GeographySpgistChooseNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_choose_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_choose_nd) );
              return responseBody;
           
}
}
export class GeographySpgistPicksplitNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_picksplit_nd"; }
async call(parameters : Public.Procedures.GeographySpgistPicksplitNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_picksplit_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_picksplit_nd) );
              return responseBody;
           
}
}
export class GeographySpgistInnerConsistentNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_inner_consistent_nd"; }
async call(parameters : Public.Procedures.GeographySpgistInnerConsistentNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Void.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_inner_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Void.parse(results?.[0].geography_spgist_inner_consistent_nd) );
              return responseBody;
           
}
}
export class GeographySpgistLeafConsistentNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_leaf_consistent_nd"; }
async call(parameters : Public.Procedures.GeographySpgistLeafConsistentNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Bool.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_leaf_consistent_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) }, ${ typed[2281](undefinedIsNull(parameters.argument_1)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Bool.parse(results?.[0].geography_spgist_leaf_consistent_nd) );
              return responseBody;
           
}
}
export class GeographySpgistCompressNd implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "geography_spgist_compress_nd"; }
async call(parameters : Public.Procedures.GeographySpgistCompressNd.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return PgCatalog.Types.Internal.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.geography_spgist_compress_nd( ${ typed[2281](undefinedIsNull(parameters.argument_0)) })`, {parameters, options});
  const results = response;

              const responseBody = ( PgCatalog.Types.Internal.parse(results?.[0].geography_spgist_compress_nd) );
              return responseBody;
           
}
}
export class StLetters implements HasDatabase {
  constructor(private hasDatabase: HasDatabase) {}
  get database() { return this.hasDatabase.database; }
  get name() { return "st_letters"; }
async call(parameters : Public.Procedures.StLetters.Parameters, options?: InvokeQueryOptions) {
  
            const parseResult = (context: Context, result: unknown) => {
              console.assert(context);
              return Public.Types.Geometry.parse(result);
            };
          
  const typed = this.database.typed;
  const response = await this.database.invoke( (sql, request) => sql`SELECT public.st_letters(letters => ${ typed[25](undefinedIsNull(parameters.letters)) },font => ${ typed[114](undefinedIsNull(parameters.font)) })`, {parameters, options});
  const results = response;

              const responseBody = ( Public.Types.Geometry.parse(results?.[0].st_letters) );
              return responseBody;
           
}
}
}
}
export namespace Public {

          export class Tables implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        
get SpatialRefSys () { return new Public.Tables.SpatialRefSys(this)} 
get NycCensusBlocks () { return new Public.Tables.NycCensusBlocks(this)} 
get NycHomicides () { return new Public.Tables.NycHomicides(this)} 
get NycNeighborhoods () { return new Public.Tables.NycNeighborhoods(this)} 
get NycStreets () { return new Public.Tables.NycStreets(this)} 
get NycSubwayStations () { return new Public.Tables.NycSubwayStations(this)} 
}
}
export namespace Public {
export namespace Tables {

          export class SpatialRefSys implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.SpatialRefSys>, options?: Public.Tables.SpatialRefSys.Options): Promise<Public.Types.SpatialRefSys>{

      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.spatial_ref_sys (srid,auth_name,auth_srid,srtext,proj4text)
    VALUES (${ values.srid === undefined ? sql`DEFAULT` : typed[23](values.srid) },${ values.authName === undefined ? sql`DEFAULT` : typed[1043](values.authName) },${ values.authSrid === undefined ? sql`DEFAULT` : typed[23](values.authSrid) },${ values.srtext === undefined ? sql`DEFAULT` : typed[1043](values.srtext) },${ values.proj4text === undefined ? sql`DEFAULT` : typed[1043](values.proj4text) })
    ON CONFLICT (srid) DO UPDATE
    SET
      auth_name = EXCLUDED.auth_name,auth_srid = EXCLUDED.auth_srid,srtext = EXCLUDED.srtext,proj4text = EXCLUDED.proj4text
    RETURNING
      srid,auth_name,auth_srid,srtext,proj4text
    `, {values, options});
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
async all(options?: Public.Tables.SpatialRefSys.Options) : Promise<Public.Types.SpatialRefSys[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      srid,auth_name,auth_srid,srtext,proj4text 
    FROM
      public.spatial_ref_sys 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))
}
public get ByPrimaryKey () { return new Public.Tables.SpatialRefSys.SpatialRefSysPkey(this)}
get SpatialRefSysPkey () { return new Public.Tables.SpatialRefSys.SpatialRefSysPkey(this)} 
}

          export class NycCensusBlocks implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.NycCensusBlocks>, options?: Public.Tables.NycCensusBlocks.Options): Promise<Public.Types.NycCensusBlocks>{

      const typed = this.database.typed;
      

      if (!Public.Tables.NycCensusBlocks.includesPrimaryKey(values)) {
      
const response = await this.database.invoke( (sql, request) => sql`
      --
      INSERT INTO
        public.nyc_census_blocks (blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom)
      VALUES (${ values.blkid === undefined ? sql`DEFAULT` : typed[1043](values.blkid) },${ values.popnTotal === undefined ? sql`DEFAULT` : typed[701](values.popnTotal) },${ values.popnWhite === undefined ? sql`DEFAULT` : typed[701](values.popnWhite) },${ values.popnBlack === undefined ? sql`DEFAULT` : typed[701](values.popnBlack) },${ values.popnNativ === undefined ? sql`DEFAULT` : typed[701](values.popnNativ) },${ values.popnAsian === undefined ? sql`DEFAULT` : typed[701](values.popnAsian) },${ values.popnOther === undefined ? sql`DEFAULT` : typed[701](values.popnOther) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
      RETURNING
        gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.nyc_census_blocks (gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.blkid === undefined ? sql`DEFAULT` : typed[1043](values.blkid) },${ values.popnTotal === undefined ? sql`DEFAULT` : typed[701](values.popnTotal) },${ values.popnWhite === undefined ? sql`DEFAULT` : typed[701](values.popnWhite) },${ values.popnBlack === undefined ? sql`DEFAULT` : typed[701](values.popnBlack) },${ values.popnNativ === undefined ? sql`DEFAULT` : typed[701](values.popnNativ) },${ values.popnAsian === undefined ? sql`DEFAULT` : typed[701](values.popnAsian) },${ values.popnOther === undefined ? sql`DEFAULT` : typed[701](values.popnOther) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      blkid = EXCLUDED.blkid,popn_total = EXCLUDED.popn_total,popn_white = EXCLUDED.popn_white,popn_black = EXCLUDED.popn_black,popn_nativ = EXCLUDED.popn_nativ,popn_asian = EXCLUDED.popn_asian,popn_other = EXCLUDED.popn_other,boroname = EXCLUDED.boroname,geom = EXCLUDED.geom
    RETURNING
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}
public get ByPrimaryKey () { return new Public.Tables.NycCensusBlocks.NycCensusBlocksPkey(this)}
get NycCensusBlocksPkey () { return new Public.Tables.NycCensusBlocks.NycCensusBlocksPkey(this)} 

get NycCensusBlocksGeomIdx () { return new Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx(this)} 
}

          export class NycHomicides implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.NycHomicides>, options?: Public.Tables.NycHomicides.Options): Promise<Public.Types.NycHomicides>{

      const typed = this.database.typed;
      

      if (!Public.Tables.NycHomicides.includesPrimaryKey(values)) {
      
const response = await this.database.invoke( (sql, request) => sql`
      --
      INSERT INTO
        public.nyc_homicides (incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom)
      VALUES (${ values.incidentD === undefined ? sql`DEFAULT` : typed[1082](values.incidentD) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.numVictim === undefined ? sql`DEFAULT` : typed[1043](values.numVictim) },${ values.primaryMo === undefined ? sql`DEFAULT` : typed[1043](values.primaryMo) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.weapon === undefined ? sql`DEFAULT` : typed[1043](values.weapon) },${ values.lightDark === undefined ? sql`DEFAULT` : typed[1043](values.lightDark) },${ values.year === undefined ? sql`DEFAULT` : typed[701](values.year) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
      RETURNING
        gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.nyc_homicides (gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.incidentD === undefined ? sql`DEFAULT` : typed[1082](values.incidentD) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.numVictim === undefined ? sql`DEFAULT` : typed[1043](values.numVictim) },${ values.primaryMo === undefined ? sql`DEFAULT` : typed[1043](values.primaryMo) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.weapon === undefined ? sql`DEFAULT` : typed[1043](values.weapon) },${ values.lightDark === undefined ? sql`DEFAULT` : typed[1043](values.lightDark) },${ values.year === undefined ? sql`DEFAULT` : typed[701](values.year) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      incident_d = EXCLUDED.incident_d,boroname = EXCLUDED.boroname,num_victim = EXCLUDED.num_victim,primary_mo = EXCLUDED.primary_mo,id = EXCLUDED.id,weapon = EXCLUDED.weapon,light_dark = EXCLUDED.light_dark,year = EXCLUDED.year,geom = EXCLUDED.geom
    RETURNING
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}
public get ByPrimaryKey () { return new Public.Tables.NycHomicides.NycHomicidesPkey(this)}
get NycHomicidesPkey () { return new Public.Tables.NycHomicides.NycHomicidesPkey(this)} 

get NycHomicidesGeomIdx () { return new Public.Tables.NycHomicides.NycHomicidesGeomIdx(this)} 
}

          export class NycNeighborhoods implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.NycNeighborhoods>, options?: Public.Tables.NycNeighborhoods.Options): Promise<Public.Types.NycNeighborhoods>{

      const typed = this.database.typed;
      

      if (!Public.Tables.NycNeighborhoods.includesPrimaryKey(values)) {
      
const response = await this.database.invoke( (sql, request) => sql`
      --
      INSERT INTO
        public.nyc_neighborhoods (boroname,name,geom)
      VALUES (${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
      RETURNING
        gid,boroname,name,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.nyc_neighborhoods (gid,boroname,name,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.boroname === undefined ? sql`DEFAULT` : typed[1043](values.boroname) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      boroname = EXCLUDED.boroname,name = EXCLUDED.name,geom = EXCLUDED.geom
    RETURNING
      gid,boroname,name,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}
public get ByPrimaryKey () { return new Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey(this)}
get NycNeighborhoodsPkey () { return new Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey(this)} 

get NycNeighborhoodsGeomIdx () { return new Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx(this)} 
}

          export class NycStreets implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.NycStreets>, options?: Public.Tables.NycStreets.Options): Promise<Public.Types.NycStreets>{

      const typed = this.database.typed;
      

      if (!Public.Tables.NycStreets.includesPrimaryKey(values)) {
      
const response = await this.database.invoke( (sql, request) => sql`
      --
      INSERT INTO
        public.nyc_streets (id,name,oneway,type,geom)
      VALUES (${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.oneway === undefined ? sql`DEFAULT` : typed[1043](values.oneway) },${ values.type === undefined ? sql`DEFAULT` : typed[1043](values.type) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
      RETURNING
        gid,id,name,oneway,type,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.nyc_streets (gid,id,name,oneway,type,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.id === undefined ? sql`DEFAULT` : typed[701](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.oneway === undefined ? sql`DEFAULT` : typed[1043](values.oneway) },${ values.type === undefined ? sql`DEFAULT` : typed[1043](values.type) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      id = EXCLUDED.id,name = EXCLUDED.name,oneway = EXCLUDED.oneway,type = EXCLUDED.type,geom = EXCLUDED.geom
    RETURNING
      gid,id,name,oneway,type,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}
public get ByPrimaryKey () { return new Public.Tables.NycStreets.NycStreetsPkey(this)}
get NycStreetsPkey () { return new Public.Tables.NycStreets.NycStreetsPkey(this)} 

get NycStreetsGeomIdx () { return new Public.Tables.NycStreets.NycStreetsGeomIdx(this)} 
}

          export class NycSubwayStations implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }
        

async create(values: Partial<Public.Types.NycSubwayStations>, options?: Public.Tables.NycSubwayStations.Options): Promise<Public.Types.NycSubwayStations>{

      const typed = this.database.typed;
      

      if (!Public.Tables.NycSubwayStations.includesPrimaryKey(values)) {
      
const response = await this.database.invoke( (sql, request) => sql`
      --
      INSERT INTO
        public.nyc_subway_stations (objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom)
      VALUES (${ values.objectid === undefined ? sql`DEFAULT` : typed[1700](values.objectid) },${ values.id === undefined ? sql`DEFAULT` : typed[1700](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.altName === undefined ? sql`DEFAULT` : typed[1043](values.altName) },${ values.crossSt === undefined ? sql`DEFAULT` : typed[1043](values.crossSt) },${ values.longName === undefined ? sql`DEFAULT` : typed[1043](values.longName) },${ values.label === undefined ? sql`DEFAULT` : typed[1043](values.label) },${ values.borough === undefined ? sql`DEFAULT` : typed[1043](values.borough) },${ values.nghbhd === undefined ? sql`DEFAULT` : typed[1043](values.nghbhd) },${ values.routes === undefined ? sql`DEFAULT` : typed[1043](values.routes) },${ values.transfers === undefined ? sql`DEFAULT` : typed[1043](values.transfers) },${ values.color === undefined ? sql`DEFAULT` : typed[1043](values.color) },${ values.express === undefined ? sql`DEFAULT` : typed[1043](values.express) },${ values.closed === undefined ? sql`DEFAULT` : typed[1043](values.closed) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
      RETURNING
        gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
const response = await this.database.invoke( (sql, request) => sql`
    INSERT INTO
      public.nyc_subway_stations (gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom)
    VALUES (${ values.gid === undefined ? sql`DEFAULT` : typed[23](values.gid) },${ values.objectid === undefined ? sql`DEFAULT` : typed[1700](values.objectid) },${ values.id === undefined ? sql`DEFAULT` : typed[1700](values.id) },${ values.name === undefined ? sql`DEFAULT` : typed[1043](values.name) },${ values.altName === undefined ? sql`DEFAULT` : typed[1043](values.altName) },${ values.crossSt === undefined ? sql`DEFAULT` : typed[1043](values.crossSt) },${ values.longName === undefined ? sql`DEFAULT` : typed[1043](values.longName) },${ values.label === undefined ? sql`DEFAULT` : typed[1043](values.label) },${ values.borough === undefined ? sql`DEFAULT` : typed[1043](values.borough) },${ values.nghbhd === undefined ? sql`DEFAULT` : typed[1043](values.nghbhd) },${ values.routes === undefined ? sql`DEFAULT` : typed[1043](values.routes) },${ values.transfers === undefined ? sql`DEFAULT` : typed[1043](values.transfers) },${ values.color === undefined ? sql`DEFAULT` : typed[1043](values.color) },${ values.express === undefined ? sql`DEFAULT` : typed[1043](values.express) },${ values.closed === undefined ? sql`DEFAULT` : typed[1043](values.closed) },${ values.geom === undefined ? sql`DEFAULT` : typed[47258](values.geom) })
    ON CONFLICT (gid) DO UPDATE
    SET
      objectid = EXCLUDED.objectid,id = EXCLUDED.id,name = EXCLUDED.name,alt_name = EXCLUDED.alt_name,cross_st = EXCLUDED.cross_st,long_name = EXCLUDED.long_name,label = EXCLUDED.label,borough = EXCLUDED.borough,nghbhd = EXCLUDED.nghbhd,routes = EXCLUDED.routes,transfers = EXCLUDED.transfers,color = EXCLUDED.color,express = EXCLUDED.express,closed = EXCLUDED.closed,geom = EXCLUDED.geom
    RETURNING
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom
    `, {values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
async all(options?: Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations[]>{

      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}
public get ByPrimaryKey () { return new Public.Tables.NycSubwayStations.NycSubwayStationsPkey(this)}
get NycSubwayStationsPkey () { return new Public.Tables.NycSubwayStations.NycSubwayStationsPkey(this)} 

get NycSubwayStationsGeomIdx () { return new Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx(this)} 
}
}
}
export namespace Public {
export namespace Tables {
export namespace SpatialRefSys {

          export class SpatialRefSysPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.SpatialRefSysPkey, options?: Public.Types.SpatialRefSysPkey.Options & Public.Tables.SpatialRefSys.Options) : Promise<Public.Types.SpatialRefSys>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      srid,auth_name,auth_srid,srtext,proj4text 
    FROM
      public.spatial_ref_sys 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
async update(parameters: Public.Types.SpatialRefSysPkey, values: Partial<Public.Tables.SpatialRefSys.Values>, options?: Public.Types.SpatialRefSysPkey.Options & Public.Tables.SpatialRefSys.Options) : Promise<Public.Types.SpatialRefSys>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.spatial_ref_sys 
    SET
      srid = ${ values.srid === undefined ? sql`srid` : typed[23](values.srid) } , auth_name = ${ values.authName === undefined ? sql`auth_name` : typed[1043](values.authName) } , auth_srid = ${ values.authSrid === undefined ? sql`auth_srid` : typed[23](values.authSrid) } , srtext = ${ values.srtext === undefined ? sql`srtext` : typed[1043](values.srtext) } , proj4text = ${ values.proj4text === undefined ? sql`proj4text` : typed[1043](values.proj4text) } 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    RETURNING srid,auth_name,auth_srid,srtext,proj4text`, {parameters, values, options});
return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
},
async delete(parameters: Public.Types.SpatialRefSysPkey, options?: Public.Types.SpatialRefSysPkey.Options & Public.Tables.SpatialRefSys.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.spatial_ref_sys 
    WHERE
      srid = ${ parameters.srid === undefined ? sql`DEFAULT` : typed[23](parameters.srid) }
    RETURNING srid,auth_name,auth_srid,srtext,proj4text`, {parameters, options});
 return response.map(r => ({ srid: undefinedIsNull(r.srid),authName: undefinedIsNull(r.auth_name),authSrid: undefinedIsNull(r.auth_srid),srtext: undefinedIsNull(r.srtext),proj4text: undefinedIsNull(r.proj4text) }))[0]
}
}
}
export namespace NycCensusBlocks {

          export class NycCensusBlocksPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycCensusBlocksPkey, options?: Public.Types.NycCensusBlocksPkey.Options & Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
async update(parameters: Public.Types.NycCensusBlocksPkey, values: Partial<Public.Tables.NycCensusBlocks.Values>, options?: Public.Types.NycCensusBlocksPkey.Options & Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_census_blocks 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , blkid = ${ values.blkid === undefined ? sql`blkid` : typed[1043](values.blkid) } , popn_total = ${ values.popnTotal === undefined ? sql`popn_total` : typed[701](values.popnTotal) } , popn_white = ${ values.popnWhite === undefined ? sql`popn_white` : typed[701](values.popnWhite) } , popn_black = ${ values.popnBlack === undefined ? sql`popn_black` : typed[701](values.popnBlack) } , popn_nativ = ${ values.popnNativ === undefined ? sql`popn_nativ` : typed[701](values.popnNativ) } , popn_asian = ${ values.popnAsian === undefined ? sql`popn_asian` : typed[701](values.popnAsian) } , popn_other = ${ values.popnOther === undefined ? sql`popn_other` : typed[701](values.popnOther) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
},
async delete(parameters: Public.Types.NycCensusBlocksPkey, options?: Public.Types.NycCensusBlocksPkey.Options & Public.Tables.NycCensusBlocks.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_census_blocks 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))[0]
}
}

          export class NycCensusBlocksGeomIdx implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycCensusBlocksGeomIdx, options?: Public.Types.NycCensusBlocksGeomIdx.Options & Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks[]>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom 
    FROM
      public.nyc_census_blocks 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}
async update(parameters: Public.Types.NycCensusBlocksGeomIdx, values: Partial<Public.Tables.NycCensusBlocks.Values>, options?: Public.Types.NycCensusBlocksGeomIdx.Options & Public.Tables.NycCensusBlocks.Options) : Promise<Public.Types.NycCensusBlocks[]>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_census_blocks 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , blkid = ${ values.blkid === undefined ? sql`blkid` : typed[1043](values.blkid) } , popn_total = ${ values.popnTotal === undefined ? sql`popn_total` : typed[701](values.popnTotal) } , popn_white = ${ values.popnWhite === undefined ? sql`popn_white` : typed[701](values.popnWhite) } , popn_black = ${ values.popnBlack === undefined ? sql`popn_black` : typed[701](values.popnBlack) } , popn_nativ = ${ values.popnNativ === undefined ? sql`popn_nativ` : typed[701](values.popnNativ) } , popn_asian = ${ values.popnAsian === undefined ? sql`popn_asian` : typed[701](values.popnAsian) } , popn_other = ${ values.popnOther === undefined ? sql`popn_other` : typed[701](values.popnOther) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
},
async delete(parameters: Public.Types.NycCensusBlocksGeomIdx, options?: Public.Types.NycCensusBlocksGeomIdx.Options & Public.Tables.NycCensusBlocks.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_census_blocks 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,blkid,popn_total,popn_white,popn_black,popn_nativ,popn_asian,popn_other,boroname,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),blkid: undefinedIsNull(r.blkid),popnTotal: undefinedIsNull(r.popn_total),popnWhite: undefinedIsNull(r.popn_white),popnBlack: undefinedIsNull(r.popn_black),popnNativ: undefinedIsNull(r.popn_nativ),popnAsian: undefinedIsNull(r.popn_asian),popnOther: undefinedIsNull(r.popn_other),boroname: undefinedIsNull(r.boroname),geom: undefinedIsNull(r.geom) }))
}
}
}
export namespace NycHomicides {

          export class NycHomicidesPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycHomicidesPkey, options?: Public.Types.NycHomicidesPkey.Options & Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
async update(parameters: Public.Types.NycHomicidesPkey, values: Partial<Public.Tables.NycHomicides.Values>, options?: Public.Types.NycHomicidesPkey.Options & Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_homicides 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , incident_d = ${ values.incidentD === undefined ? sql`incident_d` : typed[1082](values.incidentD) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , num_victim = ${ values.numVictim === undefined ? sql`num_victim` : typed[1043](values.numVictim) } , primary_mo = ${ values.primaryMo === undefined ? sql`primary_mo` : typed[1043](values.primaryMo) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , weapon = ${ values.weapon === undefined ? sql`weapon` : typed[1043](values.weapon) } , light_dark = ${ values.lightDark === undefined ? sql`light_dark` : typed[1043](values.lightDark) } , year = ${ values.year === undefined ? sql`year` : typed[701](values.year) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
},
async delete(parameters: Public.Types.NycHomicidesPkey, options?: Public.Types.NycHomicidesPkey.Options & Public.Tables.NycHomicides.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_homicides 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))[0]
}
}

          export class NycHomicidesGeomIdx implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycHomicidesGeomIdx, options?: Public.Types.NycHomicidesGeomIdx.Options & Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides[]>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom 
    FROM
      public.nyc_homicides 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}
async update(parameters: Public.Types.NycHomicidesGeomIdx, values: Partial<Public.Tables.NycHomicides.Values>, options?: Public.Types.NycHomicidesGeomIdx.Options & Public.Tables.NycHomicides.Options) : Promise<Public.Types.NycHomicides[]>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_homicides 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , incident_d = ${ values.incidentD === undefined ? sql`incident_d` : typed[1082](values.incidentD) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , num_victim = ${ values.numVictim === undefined ? sql`num_victim` : typed[1043](values.numVictim) } , primary_mo = ${ values.primaryMo === undefined ? sql`primary_mo` : typed[1043](values.primaryMo) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , weapon = ${ values.weapon === undefined ? sql`weapon` : typed[1043](values.weapon) } , light_dark = ${ values.lightDark === undefined ? sql`light_dark` : typed[1043](values.lightDark) } , year = ${ values.year === undefined ? sql`year` : typed[701](values.year) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
},
async delete(parameters: Public.Types.NycHomicidesGeomIdx, options?: Public.Types.NycHomicidesGeomIdx.Options & Public.Tables.NycHomicides.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_homicides 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,incident_d,boroname,num_victim,primary_mo,id,weapon,light_dark,year,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),incidentD: undefinedIsNull(r.incident_d),boroname: undefinedIsNull(r.boroname),numVictim: undefinedIsNull(r.num_victim),primaryMo: undefinedIsNull(r.primary_mo),id: undefinedIsNull(r.id),weapon: undefinedIsNull(r.weapon),lightDark: undefinedIsNull(r.light_dark),year: undefinedIsNull(r.year),geom: undefinedIsNull(r.geom) }))
}
}
}
export namespace NycNeighborhoods {

          export class NycNeighborhoodsPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycNeighborhoodsPkey, options?: Public.Types.NycNeighborhoodsPkey.Options & Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
async update(parameters: Public.Types.NycNeighborhoodsPkey, values: Partial<Public.Tables.NycNeighborhoods.Values>, options?: Public.Types.NycNeighborhoodsPkey.Options & Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_neighborhoods 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,boroname,name,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
},
async delete(parameters: Public.Types.NycNeighborhoodsPkey, options?: Public.Types.NycNeighborhoodsPkey.Options & Public.Tables.NycNeighborhoods.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_neighborhoods 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,boroname,name,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))[0]
}
}

          export class NycNeighborhoodsGeomIdx implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycNeighborhoodsGeomIdx, options?: Public.Types.NycNeighborhoodsGeomIdx.Options & Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods[]>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,boroname,name,geom 
    FROM
      public.nyc_neighborhoods 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}
async update(parameters: Public.Types.NycNeighborhoodsGeomIdx, values: Partial<Public.Tables.NycNeighborhoods.Values>, options?: Public.Types.NycNeighborhoodsGeomIdx.Options & Public.Tables.NycNeighborhoods.Options) : Promise<Public.Types.NycNeighborhoods[]>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_neighborhoods 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , boroname = ${ values.boroname === undefined ? sql`boroname` : typed[1043](values.boroname) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,boroname,name,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
},
async delete(parameters: Public.Types.NycNeighborhoodsGeomIdx, options?: Public.Types.NycNeighborhoodsGeomIdx.Options & Public.Tables.NycNeighborhoods.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_neighborhoods 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,boroname,name,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),boroname: undefinedIsNull(r.boroname),name: undefinedIsNull(r.name),geom: undefinedIsNull(r.geom) }))
}
}
}
export namespace NycStreets {

          export class NycStreetsPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycStreetsPkey, options?: Public.Types.NycStreetsPkey.Options & Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
async update(parameters: Public.Types.NycStreetsPkey, values: Partial<Public.Tables.NycStreets.Values>, options?: Public.Types.NycStreetsPkey.Options & Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_streets 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , oneway = ${ values.oneway === undefined ? sql`oneway` : typed[1043](values.oneway) } , type = ${ values.type === undefined ? sql`type` : typed[1043](values.type) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,id,name,oneway,type,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
},
async delete(parameters: Public.Types.NycStreetsPkey, options?: Public.Types.NycStreetsPkey.Options & Public.Tables.NycStreets.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_streets 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,id,name,oneway,type,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))[0]
}
}

          export class NycStreetsGeomIdx implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycStreetsGeomIdx, options?: Public.Types.NycStreetsGeomIdx.Options & Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets[]>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,id,name,oneway,type,geom 
    FROM
      public.nyc_streets 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}
async update(parameters: Public.Types.NycStreetsGeomIdx, values: Partial<Public.Tables.NycStreets.Values>, options?: Public.Types.NycStreetsGeomIdx.Options & Public.Tables.NycStreets.Options) : Promise<Public.Types.NycStreets[]>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_streets 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , id = ${ values.id === undefined ? sql`id` : typed[701](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , oneway = ${ values.oneway === undefined ? sql`oneway` : typed[1043](values.oneway) } , type = ${ values.type === undefined ? sql`type` : typed[1043](values.type) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,id,name,oneway,type,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
},
async delete(parameters: Public.Types.NycStreetsGeomIdx, options?: Public.Types.NycStreetsGeomIdx.Options & Public.Tables.NycStreets.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_streets 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,id,name,oneway,type,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),oneway: undefinedIsNull(r.oneway),type: undefinedIsNull(r.type),geom: undefinedIsNull(r.geom) }))
}
}
}
export namespace NycSubwayStations {

          export class NycSubwayStationsPkey implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycSubwayStationsPkey, options?: Public.Types.NycSubwayStationsPkey.Options & Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
async update(parameters: Public.Types.NycSubwayStationsPkey, values: Partial<Public.Tables.NycSubwayStations.Values>, options?: Public.Types.NycSubwayStationsPkey.Options & Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_subway_stations 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , objectid = ${ values.objectid === undefined ? sql`objectid` : typed[1700](values.objectid) } , id = ${ values.id === undefined ? sql`id` : typed[1700](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , alt_name = ${ values.altName === undefined ? sql`alt_name` : typed[1043](values.altName) } , cross_st = ${ values.crossSt === undefined ? sql`cross_st` : typed[1043](values.crossSt) } , long_name = ${ values.longName === undefined ? sql`long_name` : typed[1043](values.longName) } , label = ${ values.label === undefined ? sql`label` : typed[1043](values.label) } , borough = ${ values.borough === undefined ? sql`borough` : typed[1043](values.borough) } , nghbhd = ${ values.nghbhd === undefined ? sql`nghbhd` : typed[1043](values.nghbhd) } , routes = ${ values.routes === undefined ? sql`routes` : typed[1043](values.routes) } , transfers = ${ values.transfers === undefined ? sql`transfers` : typed[1043](values.transfers) } , color = ${ values.color === undefined ? sql`color` : typed[1043](values.color) } , express = ${ values.express === undefined ? sql`express` : typed[1043](values.express) } , closed = ${ values.closed === undefined ? sql`closed` : typed[1043](values.closed) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
},
async delete(parameters: Public.Types.NycSubwayStationsPkey, options?: Public.Types.NycSubwayStationsPkey.Options & Public.Tables.NycSubwayStations.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_subway_stations 
    WHERE
      gid = ${ parameters.gid === undefined ? sql`DEFAULT` : typed[23](parameters.gid) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))[0]
}
}

          export class NycSubwayStationsGeomIdx implements HasDatabase {
       		  constructor(private hasDatabase: HasDatabase) {
            }

            get database() {
              return this.hasDatabase.database;
            }

        
async read(parameters: Public.Types.NycSubwayStationsGeomIdx, options?: Public.Types.NycSubwayStationsGeomIdx.Options & Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations[]>{

      console.assert(parameters);
      const typed = this.database.typed;
      const orderBy = options?.sort ? `ORDER BY ${options.sort.join(",")}` : "";
      
const response = await this.database.invoke( (sql, request) => sql`
    -- 
    SELECT 
      gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom 
    FROM
      public.nyc_subway_stations 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    ${sql.unsafe(`${orderBy}`)}
    LIMIT ${options?.limitNumberOfRows ?? Number.MAX_SAFE_INTEGER} 
    OFFSET ${options?.offsetNumberOfRows ?? 0} 
    `, {parameters, ...(options ?? {})});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}
async update(parameters: Public.Types.NycSubwayStationsGeomIdx, values: Partial<Public.Tables.NycSubwayStations.Values>, options?: Public.Types.NycSubwayStationsGeomIdx.Options & Public.Tables.NycSubwayStations.Options) : Promise<Public.Types.NycSubwayStations[]>{

      console.assert(parameters);
      console.assert(values);
      const typed = this.database.typed;
      
const response = await this.database.invoke( (sql, request) => sql`
    --
    UPDATE 
      public.nyc_subway_stations 
    SET
      gid = ${ values.gid === undefined ? sql`gid` : typed[23](values.gid) } , objectid = ${ values.objectid === undefined ? sql`objectid` : typed[1700](values.objectid) } , id = ${ values.id === undefined ? sql`id` : typed[1700](values.id) } , name = ${ values.name === undefined ? sql`name` : typed[1043](values.name) } , alt_name = ${ values.altName === undefined ? sql`alt_name` : typed[1043](values.altName) } , cross_st = ${ values.crossSt === undefined ? sql`cross_st` : typed[1043](values.crossSt) } , long_name = ${ values.longName === undefined ? sql`long_name` : typed[1043](values.longName) } , label = ${ values.label === undefined ? sql`label` : typed[1043](values.label) } , borough = ${ values.borough === undefined ? sql`borough` : typed[1043](values.borough) } , nghbhd = ${ values.nghbhd === undefined ? sql`nghbhd` : typed[1043](values.nghbhd) } , routes = ${ values.routes === undefined ? sql`routes` : typed[1043](values.routes) } , transfers = ${ values.transfers === undefined ? sql`transfers` : typed[1043](values.transfers) } , color = ${ values.color === undefined ? sql`color` : typed[1043](values.color) } , express = ${ values.express === undefined ? sql`express` : typed[1043](values.express) } , closed = ${ values.closed === undefined ? sql`closed` : typed[1043](values.closed) } , geom = ${ values.geom === undefined ? sql`geom` : typed[47258](values.geom) } 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`, {parameters, values, options});
return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
},
async delete(parameters: Public.Types.NycSubwayStationsGeomIdx, options?: Public.Types.NycSubwayStationsGeomIdx.Options & Public.Tables.NycSubwayStations.Options) {
 console.assert(parameters);
 const typed = this.database.typed;
 const response = await this.database.invoke( (sql, request) => sql`
    --
    DELETE FROM 
      public.nyc_subway_stations 
    WHERE
      geom = ${ parameters.geom === undefined ? sql`DEFAULT` : typed[47258](parameters.geom) }
    RETURNING gid,objectid,id,name,alt_name,cross_st,long_name,label,borough,nghbhd,routes,transfers,color,express,closed,geom`, {parameters, options});
 return response.map(r => ({ gid: undefinedIsNull(r.gid),objectid: undefinedIsNull(r.objectid),id: undefinedIsNull(r.id),name: undefinedIsNull(r.name),altName: undefinedIsNull(r.alt_name),crossSt: undefinedIsNull(r.cross_st),longName: undefinedIsNull(r.long_name),label: undefinedIsNull(r.label),borough: undefinedIsNull(r.borough),nghbhd: undefinedIsNull(r.nghbhd),routes: undefinedIsNull(r.routes),transfers: undefinedIsNull(r.transfers),color: undefinedIsNull(r.color),express: undefinedIsNull(r.express),closed: undefinedIsNull(r.closed),geom: undefinedIsNull(r.geom) }))
}
}
}
}
}

          // begin - operation dispatch map
          import { EmbraceSQLRequest, OperationDispatchMethod } from "@embracesql/shared";
          export class OperationDispatcher {
            private dispatchMap: Record<string, OperationDispatchMethod>;
            constructor(private database: Database){
              this.dispatchMap = {

          
"Public.Procedures.StForcepolygoncw.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcepolygoncw.call(request.parameters as Public.Procedures.StForcepolygoncw.Parameters,request.options),
"Public.Procedures.SpheroidIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.SpheroidIn.call(request.parameters as Public.Procedures.SpheroidIn.Parameters,request.options),
"Public.Procedures.SpheroidOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.SpheroidOut.call(request.parameters as Public.Procedures.SpheroidOut.Parameters,request.options),
"Public.Procedures.GeometryIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryIn.call(request.parameters as Public.Procedures.GeometryIn.Parameters,request.options),
"Public.Procedures.GeometryOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOut.call(request.parameters as Public.Procedures.GeometryOut.Parameters,request.options),
"Public.Procedures.GeometryTypmodIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryTypmodIn.call(request.parameters as Public.Procedures.GeometryTypmodIn.Parameters,request.options),
"Public.Procedures.GeometryTypmodOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryTypmodOut.call(request.parameters as Public.Procedures.GeometryTypmodOut.Parameters,request.options),
"Public.Procedures.GeometryAnalyze.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryAnalyze.call(request.parameters as Public.Procedures.GeometryAnalyze.Parameters,request.options),
"Public.Procedures.GeometryRecv.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryRecv.call(request.parameters as Public.Procedures.GeometryRecv.Parameters,request.options),
"Public.Procedures.GeometrySend.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySend.call(request.parameters as Public.Procedures.GeometrySend.Parameters,request.options),
"Public.Procedures.Geometry_6564.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometry_6564.call(request.parameters as Public.Procedures.Geometry_6564.Parameters,request.options),
"Public.Procedures.Geometry_8997.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometry_8997.call(request.parameters as Public.Procedures.Geometry_8997.Parameters,request.options),
"Public.Procedures.Point.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Point.call(request.parameters as Public.Procedures.Point.Parameters,request.options),
"Public.Procedures.GeometryB0d8.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryB0d8.call(request.parameters as Public.Procedures.GeometryB0d8.Parameters,request.options),
"Public.Procedures.Path.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Path.call(request.parameters as Public.Procedures.Path.Parameters,request.options),
"Public.Procedures.GeometryF1be.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryF1be.call(request.parameters as Public.Procedures.GeometryF1be.Parameters,request.options),
"Public.Procedures.Polygon.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Polygon.call(request.parameters as Public.Procedures.Polygon.Parameters,request.options),
"Public.Procedures.StX.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StX.call(request.parameters as Public.Procedures.StX.Parameters,request.options),
"Public.Procedures.StY.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StY.call(request.parameters as Public.Procedures.StY.Parameters,request.options),
"Public.Procedures.StZ.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StZ.call(request.parameters as Public.Procedures.StZ.Parameters,request.options),
"Public.Procedures.StM.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StM.call(request.parameters as Public.Procedures.StM.Parameters,request.options),
"Public.Procedures.Box3dIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box3dIn.call(request.parameters as Public.Procedures.Box3dIn.Parameters,request.options),
"Public.Procedures.Box3dOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box3dOut.call(request.parameters as Public.Procedures.Box3dOut.Parameters,request.options),
"Public.Procedures.Box2dIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2dIn.call(request.parameters as Public.Procedures.Box2dIn.Parameters,request.options),
"Public.Procedures.Box2dOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2dOut.call(request.parameters as Public.Procedures.Box2dOut.Parameters,request.options),
"Public.Procedures.Box2dfIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2dfIn.call(request.parameters as Public.Procedures.Box2dfIn.Parameters,request.options),
"Public.Procedures.Box2dfOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2dfOut.call(request.parameters as Public.Procedures.Box2dfOut.Parameters,request.options),
"Public.Procedures.GidxIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GidxIn.call(request.parameters as Public.Procedures.GidxIn.Parameters,request.options),
"Public.Procedures.GidxOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GidxOut.call(request.parameters as Public.Procedures.GidxOut.Parameters,request.options),
"Public.Procedures.GeometryLt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryLt.call(request.parameters as Public.Procedures.GeometryLt.Parameters,request.options),
"Public.Procedures.GeometryLe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryLe.call(request.parameters as Public.Procedures.GeometryLe.Parameters,request.options),
"Public.Procedures.GeometryGt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGt.call(request.parameters as Public.Procedures.GeometryGt.Parameters,request.options),
"Public.Procedures.GeometryGe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGe.call(request.parameters as Public.Procedures.GeometryGe.Parameters,request.options),
"Public.Procedures.GeometryEq.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryEq.call(request.parameters as Public.Procedures.GeometryEq.Parameters,request.options),
"Public.Procedures.GeometryCmp.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryCmp.call(request.parameters as Public.Procedures.GeometryCmp.Parameters,request.options),
"Public.Procedures.GeometrySortsupport.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySortsupport.call(request.parameters as Public.Procedures.GeometrySortsupport.Parameters,request.options),
"Public.Procedures.GeometryHash.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryHash.call(request.parameters as Public.Procedures.GeometryHash.Parameters,request.options),
"Public.Procedures.GeometryGistDistance_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistDistance_2d.call(request.parameters as Public.Procedures.GeometryGistDistance_2d.Parameters,request.options),
"Public.Procedures.GeometryGistConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistConsistent_2d.call(request.parameters as Public.Procedures.GeometryGistConsistent_2d.Parameters,request.options),
"Public.Procedures.GeometryGistCompress_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistCompress_2d.call(request.parameters as Public.Procedures.GeometryGistCompress_2d.Parameters,request.options),
"Public.Procedures.GeometryGistPenalty_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistPenalty_2d.call(request.parameters as Public.Procedures.GeometryGistPenalty_2d.Parameters,request.options),
"Public.Procedures.GeometryGistPicksplit_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistPicksplit_2d.call(request.parameters as Public.Procedures.GeometryGistPicksplit_2d.Parameters,request.options),
"Public.Procedures.GeometryGistUnion_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistUnion_2d.call(request.parameters as Public.Procedures.GeometryGistUnion_2d.Parameters,request.options),
"Public.Procedures.GeometryGistSame_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistSame_2d.call(request.parameters as Public.Procedures.GeometryGistSame_2d.Parameters,request.options),
"Public.Procedures.GeometryGistDecompress_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistDecompress_2d.call(request.parameters as Public.Procedures.GeometryGistDecompress_2d.Parameters,request.options),
"Public.Procedures.GeometryGistSortsupport_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistSortsupport_2d.call(request.parameters as Public.Procedures.GeometryGistSortsupport_2d.Parameters,request.options),
"Public.Procedures.StForcerhr.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcerhr.call(request.parameters as Public.Procedures.StForcerhr.Parameters,request.options),
"Public.Procedures.PostgisNoop.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisNoop.call(request.parameters as Public.Procedures.PostgisNoop.Parameters,request.options),
"Public.Procedures.StForcepolygonccw.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcepolygonccw.call(request.parameters as Public.Procedures.StForcepolygonccw.Parameters,request.options),
"Public.Procedures.GserializedGistSel_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GserializedGistSel_2d.call(request.parameters as Public.Procedures.GserializedGistSel_2d.Parameters,request.options),
"Public.Procedures.GserializedGistSelNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GserializedGistSelNd.call(request.parameters as Public.Procedures.GserializedGistSelNd.Parameters,request.options),
"Public.Procedures.GserializedGistJoinsel_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GserializedGistJoinsel_2d.call(request.parameters as Public.Procedures.GserializedGistJoinsel_2d.Parameters,request.options),
"Public.Procedures.GserializedGistJoinselNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GserializedGistJoinselNd.call(request.parameters as Public.Procedures.GserializedGistJoinselNd.Parameters,request.options),
"Public.Procedures.GeometryOverlaps.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverlaps.call(request.parameters as Public.Procedures.GeometryOverlaps.Parameters,request.options),
"Public.Procedures.GeometrySame.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySame.call(request.parameters as Public.Procedures.GeometrySame.Parameters,request.options),
"Public.Procedures.GeometryDistanceCentroid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryDistanceCentroid.call(request.parameters as Public.Procedures.GeometryDistanceCentroid.Parameters,request.options),
"Public.Procedures.GeometryDistanceBox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryDistanceBox.call(request.parameters as Public.Procedures.GeometryDistanceBox.Parameters,request.options),
"Public.Procedures.GeometryContains.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryContains.call(request.parameters as Public.Procedures.GeometryContains.Parameters,request.options),
"Public.Procedures.GeometryWithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryWithin.call(request.parameters as Public.Procedures.GeometryWithin.Parameters,request.options),
"Public.Procedures.GeometryLeft.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryLeft.call(request.parameters as Public.Procedures.GeometryLeft.Parameters,request.options),
"Public.Procedures.GeometryOverleft.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverleft.call(request.parameters as Public.Procedures.GeometryOverleft.Parameters,request.options),
"Public.Procedures.GeometryBelow.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryBelow.call(request.parameters as Public.Procedures.GeometryBelow.Parameters,request.options),
"Public.Procedures.GeometryOverbelow.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverbelow.call(request.parameters as Public.Procedures.GeometryOverbelow.Parameters,request.options),
"Public.Procedures.GeometryOverright.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverright.call(request.parameters as Public.Procedures.GeometryOverright.Parameters,request.options),
"Public.Procedures.GeometryRight.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryRight.call(request.parameters as Public.Procedures.GeometryRight.Parameters,request.options),
"Public.Procedures.GeometryOverabove.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverabove.call(request.parameters as Public.Procedures.GeometryOverabove.Parameters,request.options),
"Public.Procedures.GeometryAbove.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryAbove.call(request.parameters as Public.Procedures.GeometryAbove.Parameters,request.options),
"Public.Procedures.GeometryGistConsistentNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistConsistentNd.call(request.parameters as Public.Procedures.GeometryGistConsistentNd.Parameters,request.options),
"Public.Procedures.GeometryGistCompressNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistCompressNd.call(request.parameters as Public.Procedures.GeometryGistCompressNd.Parameters,request.options),
"Public.Procedures.GeometryGistPenaltyNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistPenaltyNd.call(request.parameters as Public.Procedures.GeometryGistPenaltyNd.Parameters,request.options),
"Public.Procedures.GeometryGistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistPicksplitNd.call(request.parameters as Public.Procedures.GeometryGistPicksplitNd.Parameters,request.options),
"Public.Procedures.GeometryGistUnionNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistUnionNd.call(request.parameters as Public.Procedures.GeometryGistUnionNd.Parameters,request.options),
"Public.Procedures.GeometryGistSameNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistSameNd.call(request.parameters as Public.Procedures.GeometryGistSameNd.Parameters,request.options),
"Public.Procedures.GeometryGistDecompressNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistDecompressNd.call(request.parameters as Public.Procedures.GeometryGistDecompressNd.Parameters,request.options),
"Public.Procedures.GeometryOverlapsNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverlapsNd.call(request.parameters as Public.Procedures.GeometryOverlapsNd.Parameters,request.options),
"Public.Procedures.GeometryContainsNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryContainsNd.call(request.parameters as Public.Procedures.GeometryContainsNd.Parameters,request.options),
"Public.Procedures.GeometryWithinNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryWithinNd.call(request.parameters as Public.Procedures.GeometryWithinNd.Parameters,request.options),
"Public.Procedures.GeometrySameNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySameNd.call(request.parameters as Public.Procedures.GeometrySameNd.Parameters,request.options),
"Public.Procedures.GeometryDistanceCentroidNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryDistanceCentroidNd.call(request.parameters as Public.Procedures.GeometryDistanceCentroidNd.Parameters,request.options),
"Public.Procedures.GeometryDistanceCpa.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryDistanceCpa.call(request.parameters as Public.Procedures.GeometryDistanceCpa.Parameters,request.options),
"Public.Procedures.GeometryGistDistanceNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryGistDistanceNd.call(request.parameters as Public.Procedures.GeometryGistDistanceNd.Parameters,request.options),
"Public.Procedures.StShiftlongitude.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StShiftlongitude.call(request.parameters as Public.Procedures.StShiftlongitude.Parameters,request.options),
"Public.Procedures.StWrapx.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StWrapx.call(request.parameters as Public.Procedures.StWrapx.Parameters,request.options),
"Public.Procedures.StXmin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StXmin.call(request.parameters as Public.Procedures.StXmin.Parameters,request.options),
"Public.Procedures.StYmin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StYmin.call(request.parameters as Public.Procedures.StYmin.Parameters,request.options),
"Public.Procedures.StZmin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StZmin.call(request.parameters as Public.Procedures.StZmin.Parameters,request.options),
"Public.Procedures.StXmax.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StXmax.call(request.parameters as Public.Procedures.StXmax.Parameters,request.options),
"Public.Procedures.StYmax.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StYmax.call(request.parameters as Public.Procedures.StYmax.Parameters,request.options),
"Public.Procedures.StZmax.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StZmax.call(request.parameters as Public.Procedures.StZmax.Parameters,request.options),
"Public.Procedures.StExpand_269a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_269a.call(request.parameters as Public.Procedures.StExpand_269a.Parameters,request.options),
"Public.Procedures.StExpand_96e3.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_96e3.call(request.parameters as Public.Procedures.StExpand_96e3.Parameters,request.options),
"Public.Procedures.PostgisGetbbox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisGetbbox.call(request.parameters as Public.Procedures.PostgisGetbbox.Parameters,request.options),
"Public.Procedures.StMakebox2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakebox2d.call(request.parameters as Public.Procedures.StMakebox2d.Parameters,request.options),
"Public.Procedures.StEstimatedextentD2f5.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEstimatedextentD2f5.call(request.parameters as Public.Procedures.StEstimatedextentD2f5.Parameters,request.options),
"Public.Procedures.StEstimatedextent_27e1.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEstimatedextent_27e1.call(request.parameters as Public.Procedures.StEstimatedextent_27e1.Parameters,request.options),
"Public.Procedures.StEstimatedextent_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEstimatedextent_2ec2.call(request.parameters as Public.Procedures.StEstimatedextent_2ec2.Parameters,request.options),
"Public.Procedures.StFindextent_27e1.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFindextent_27e1.call(request.parameters as Public.Procedures.StFindextent_27e1.Parameters,request.options),
"Public.Procedures.StFindextent_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFindextent_2ec2.call(request.parameters as Public.Procedures.StFindextent_2ec2.Parameters,request.options),
"Public.Procedures.PostgisAddbbox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisAddbbox.call(request.parameters as Public.Procedures.PostgisAddbbox.Parameters,request.options),
"Public.Procedures.PostgisDropbbox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisDropbbox.call(request.parameters as Public.Procedures.PostgisDropbbox.Parameters,request.options),
"Public.Procedures.PostgisHasbbox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisHasbbox.call(request.parameters as Public.Procedures.PostgisHasbbox.Parameters,request.options),
"Public.Procedures.StQuantizecoordinates.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StQuantizecoordinates.call(request.parameters as Public.Procedures.StQuantizecoordinates.Parameters,request.options),
"Public.Procedures.StMemsize.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMemsize.call(request.parameters as Public.Procedures.StMemsize.Parameters,request.options),
"Public.Procedures.StSummary_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSummary_0cdb.call(request.parameters as Public.Procedures.StSummary_0cdb.Parameters,request.options),
"Public.Procedures.StNpoints.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNpoints.call(request.parameters as Public.Procedures.StNpoints.Parameters,request.options),
"Public.Procedures.StNrings.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNrings.call(request.parameters as Public.Procedures.StNrings.Parameters,request.options),
"Public.Procedures.St_3dlength.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dlength.call(request.parameters as Public.Procedures.St_3dlength.Parameters,request.options),
"Public.Procedures.StLength2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLength2d.call(request.parameters as Public.Procedures.StLength2d.Parameters,request.options),
"Public.Procedures.StLength_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLength_0cdb.call(request.parameters as Public.Procedures.StLength_0cdb.Parameters,request.options),
"Public.Procedures.StLengthspheroid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLengthspheroid.call(request.parameters as Public.Procedures.StLengthspheroid.Parameters,request.options),
"Public.Procedures.StLength2dspheroid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLength2dspheroid.call(request.parameters as Public.Procedures.StLength2dspheroid.Parameters,request.options),
"Public.Procedures.St_3dperimeter.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dperimeter.call(request.parameters as Public.Procedures.St_3dperimeter.Parameters,request.options),
"Public.Procedures.StPerimeter2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPerimeter2d.call(request.parameters as Public.Procedures.StPerimeter2d.Parameters,request.options),
"Public.Procedures.StPerimeter_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPerimeter_0cdb.call(request.parameters as Public.Procedures.StPerimeter_0cdb.Parameters,request.options),
"Public.Procedures.StArea2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StArea2d.call(request.parameters as Public.Procedures.StArea2d.Parameters,request.options),
"Public.Procedures.StArea_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StArea_0cdb.call(request.parameters as Public.Procedures.StArea_0cdb.Parameters,request.options),
"Public.Procedures.StIspolygoncw.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIspolygoncw.call(request.parameters as Public.Procedures.StIspolygoncw.Parameters,request.options),
"Public.Procedures.StIspolygonccw.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIspolygonccw.call(request.parameters as Public.Procedures.StIspolygonccw.Parameters,request.options),
"Public.Procedures.StDistancespheroidCd56.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistancespheroidCd56.call(request.parameters as Public.Procedures.StDistancespheroidCd56.Parameters,request.options),
"Public.Procedures.StDistancespheroid_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistancespheroid_3651.call(request.parameters as Public.Procedures.StDistancespheroid_3651.Parameters,request.options),
"Public.Procedures.StDistance_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistance_3651.call(request.parameters as Public.Procedures.StDistance_3651.Parameters,request.options),
"Public.Procedures.StPointinsidecircle.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointinsidecircle.call(request.parameters as Public.Procedures.StPointinsidecircle.Parameters,request.options),
"Public.Procedures.StAzimuth_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAzimuth_3651.call(request.parameters as Public.Procedures.StAzimuth_3651.Parameters,request.options),
"Public.Procedures.StProjectD5eb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StProjectD5eb.call(request.parameters as Public.Procedures.StProjectD5eb.Parameters,request.options),
"Public.Procedures.StProject_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StProject_6961.call(request.parameters as Public.Procedures.StProject_6961.Parameters,request.options),
"Public.Procedures.StAngleE1dd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAngleE1dd.call(request.parameters as Public.Procedures.StAngleE1dd.Parameters,request.options),
"Public.Procedures.StLineextend.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineextend.call(request.parameters as Public.Procedures.StLineextend.Parameters,request.options),
"Public.Procedures.StForce2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForce2d.call(request.parameters as Public.Procedures.StForce2d.Parameters,request.options),
"Public.Procedures.StForce3dz.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForce3dz.call(request.parameters as Public.Procedures.StForce3dz.Parameters,request.options),
"Public.Procedures.StForce3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForce3d.call(request.parameters as Public.Procedures.StForce3d.Parameters,request.options),
"Public.Procedures.StForce3dm.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForce3dm.call(request.parameters as Public.Procedures.StForce3dm.Parameters,request.options),
"Public.Procedures.StForce4d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForce4d.call(request.parameters as Public.Procedures.StForce4d.Parameters,request.options),
"Public.Procedures.StForcecollection.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcecollection.call(request.parameters as Public.Procedures.StForcecollection.Parameters,request.options),
"Public.Procedures.StCollectionextract_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCollectionextract_6cbe.call(request.parameters as Public.Procedures.StCollectionextract_6cbe.Parameters,request.options),
"Public.Procedures.StCollectionextract_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCollectionextract_0cdb.call(request.parameters as Public.Procedures.StCollectionextract_0cdb.Parameters,request.options),
"Public.Procedures.StCollectionhomogenize.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCollectionhomogenize.call(request.parameters as Public.Procedures.StCollectionhomogenize.Parameters,request.options),
"Public.Procedures.StMulti.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMulti.call(request.parameters as Public.Procedures.StMulti.Parameters,request.options),
"Public.Procedures.StForcecurve.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcecurve.call(request.parameters as Public.Procedures.StForcecurve.Parameters,request.options),
"Public.Procedures.StForcesfs_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcesfs_0cdb.call(request.parameters as Public.Procedures.StForcesfs_0cdb.Parameters,request.options),
"Public.Procedures.StForcesfs_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StForcesfs_88bc.call(request.parameters as Public.Procedures.StForcesfs_88bc.Parameters,request.options),
"Public.Procedures.StExpand_2074.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_2074.call(request.parameters as Public.Procedures.StExpand_2074.Parameters,request.options),
"Public.Procedures.StExpand_704e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_704e.call(request.parameters as Public.Procedures.StExpand_704e.Parameters,request.options),
"Public.Procedures.StExpand_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_7163.call(request.parameters as Public.Procedures.StExpand_7163.Parameters,request.options),
"Public.Procedures.StExpand_5500.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExpand_5500.call(request.parameters as Public.Procedures.StExpand_5500.Parameters,request.options),
"Public.Procedures.StEnvelope.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEnvelope.call(request.parameters as Public.Procedures.StEnvelope.Parameters,request.options),
"Public.Procedures.StBoundingdiagonal.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBoundingdiagonal.call(request.parameters as Public.Procedures.StBoundingdiagonal.Parameters,request.options),
"Public.Procedures.StReverse.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StReverse.call(request.parameters as Public.Procedures.StReverse.Parameters,request.options),
"Public.Procedures.StScroll.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StScroll.call(request.parameters as Public.Procedures.StScroll.Parameters,request.options),
"Public.Procedures.PostgisGeosNoop.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisGeosNoop.call(request.parameters as Public.Procedures.PostgisGeosNoop.Parameters,request.options),
"Public.Procedures.StNormalize.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNormalize.call(request.parameters as Public.Procedures.StNormalize.Parameters,request.options),
"Public.Procedures.StZmflag.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StZmflag.call(request.parameters as Public.Procedures.StZmflag.Parameters,request.options),
"Public.Procedures.StNdims.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNdims.call(request.parameters as Public.Procedures.StNdims.Parameters,request.options),
"Public.Procedures.StAsewkt_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkt_0cdb.call(request.parameters as Public.Procedures.StAsewkt_0cdb.Parameters,request.options),
"Public.Procedures.StAsewkt_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkt_6cbe.call(request.parameters as Public.Procedures.StAsewkt_6cbe.Parameters,request.options),
"Public.Procedures.StAstwkb_652e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstwkb_652e.call(request.parameters as Public.Procedures.StAstwkb_652e.Parameters,request.options),
"Public.Procedures.StAstwkbF3fd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstwkbF3fd.call(request.parameters as Public.Procedures.StAstwkbF3fd.Parameters,request.options),
"Public.Procedures.StAsewkb_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkb_0cdb.call(request.parameters as Public.Procedures.StAsewkb_0cdb.Parameters,request.options),
"Public.Procedures.StAshexewkb_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAshexewkb_0cdb.call(request.parameters as Public.Procedures.StAshexewkb_0cdb.Parameters,request.options),
"Public.Procedures.StAshexewkb_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAshexewkb_88bc.call(request.parameters as Public.Procedures.StAshexewkb_88bc.Parameters,request.options),
"Public.Procedures.StAsewkb_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkb_88bc.call(request.parameters as Public.Procedures.StAsewkb_88bc.Parameters,request.options),
"Public.Procedures.StAslatlontext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAslatlontext.call(request.parameters as Public.Procedures.StAslatlontext.Parameters,request.options),
"Public.Procedures.Geomfromewkb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geomfromewkb.call(request.parameters as Public.Procedures.Geomfromewkb.Parameters,request.options),
"Public.Procedures.StGeomfromewkb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromewkb.call(request.parameters as Public.Procedures.StGeomfromewkb.Parameters,request.options),
"Public.Procedures.StGeomfromtwkb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromtwkb.call(request.parameters as Public.Procedures.StGeomfromtwkb.Parameters,request.options),
"Public.Procedures.Geomfromewkt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geomfromewkt.call(request.parameters as Public.Procedures.Geomfromewkt.Parameters,request.options),
"Public.Procedures.StGeomfromewkt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromewkt.call(request.parameters as Public.Procedures.StGeomfromewkt.Parameters,request.options),
"Public.Procedures.PostgisCacheBbox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisCacheBbox.call(request.options),
"Public.Procedures.StMakepoint_0aec.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepoint_0aec.call(request.parameters as Public.Procedures.StMakepoint_0aec.Parameters,request.options),
"Public.Procedures.StMakepoint_81ec.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepoint_81ec.call(request.parameters as Public.Procedures.StMakepoint_81ec.Parameters,request.options),
"Public.Procedures.StMakepoint_570b.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepoint_570b.call(request.parameters as Public.Procedures.StMakepoint_570b.Parameters,request.options),
"Public.Procedures.StMakepointm.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepointm.call(request.parameters as Public.Procedures.StMakepointm.Parameters,request.options),
"Public.Procedures.St_3dmakebox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dmakebox.call(request.parameters as Public.Procedures.St_3dmakebox.Parameters,request.options),
"Public.Procedures.StMakelineA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakelineA4b6.call(request.parameters as Public.Procedures.StMakelineA4b6.Parameters,request.options),
"Public.Procedures.StLinefrommultipoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefrommultipoint.call(request.parameters as Public.Procedures.StLinefrommultipoint.Parameters,request.options),
"Public.Procedures.StMakeline_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakeline_3651.call(request.parameters as Public.Procedures.StMakeline_3651.Parameters,request.options),
"Public.Procedures.StAddpoint_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAddpoint_3651.call(request.parameters as Public.Procedures.StAddpoint_3651.Parameters,request.options),
"Public.Procedures.StScaleD5eb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StScaleD5eb.call(request.parameters as Public.Procedures.StScaleD5eb.Parameters,request.options),
"Public.Procedures.StAddpointAa17.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAddpointAa17.call(request.parameters as Public.Procedures.StAddpointAa17.Parameters,request.options),
"Public.Procedures.StRemovepoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRemovepoint.call(request.parameters as Public.Procedures.StRemovepoint.Parameters,request.options),
"Public.Procedures.StSetpoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSetpoint.call(request.parameters as Public.Procedures.StSetpoint.Parameters,request.options),
"Public.Procedures.StMakeenvelope.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakeenvelope.call(request.parameters as Public.Procedures.StMakeenvelope.Parameters,request.options),
"Public.Procedures.StTileenvelope.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTileenvelope.call(request.parameters as Public.Procedures.StTileenvelope.Parameters,request.options),
"Public.Procedures.StMakepolygonE2e3.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepolygonE2e3.call(request.parameters as Public.Procedures.StMakepolygonE2e3.Parameters,request.options),
"Public.Procedures.StMakepolygon_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakepolygon_0cdb.call(request.parameters as Public.Procedures.StMakepolygon_0cdb.Parameters,request.options),
"Public.Procedures.StBuildarea.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBuildarea.call(request.parameters as Public.Procedures.StBuildarea.Parameters,request.options),
"Public.Procedures.StPolygonizeA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygonizeA4b6.call(request.parameters as Public.Procedures.StPolygonizeA4b6.Parameters,request.options),
"Public.Procedures.StClusterintersectingA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClusterintersectingA4b6.call(request.parameters as Public.Procedures.StClusterintersectingA4b6.Parameters,request.options),
"Public.Procedures.StClusterwithin_0e49.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClusterwithin_0e49.call(request.parameters as Public.Procedures.StClusterwithin_0e49.Parameters,request.options),
"Public.Procedures.StLinemerge_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinemerge_0cdb.call(request.parameters as Public.Procedures.StLinemerge_0cdb.Parameters,request.options),
"Public.Procedures.StLinemerge_4ba2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinemerge_4ba2.call(request.parameters as Public.Procedures.StLinemerge_4ba2.Parameters,request.options),
"Public.Procedures.StAffineE42d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAffineE42d.call(request.parameters as Public.Procedures.StAffineE42d.Parameters,request.options),
"Public.Procedures.StAffine_1962.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAffine_1962.call(request.parameters as Public.Procedures.StAffine_1962.Parameters,request.options),
"Public.Procedures.StRotate_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotate_7163.call(request.parameters as Public.Procedures.StRotate_7163.Parameters,request.options),
"Public.Procedures.StRotate_8b9f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotate_8b9f.call(request.parameters as Public.Procedures.StRotate_8b9f.Parameters,request.options),
"Public.Procedures.StRotate_463e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotate_463e.call(request.parameters as Public.Procedures.StRotate_463e.Parameters,request.options),
"Public.Procedures.StRotatez.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotatez.call(request.parameters as Public.Procedures.StRotatez.Parameters,request.options),
"Public.Procedures.StRotatex.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotatex.call(request.parameters as Public.Procedures.StRotatex.Parameters,request.options),
"Public.Procedures.StRotatey.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRotatey.call(request.parameters as Public.Procedures.StRotatey.Parameters,request.options),
"Public.Procedures.StTranslate_8b9f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTranslate_8b9f.call(request.parameters as Public.Procedures.StTranslate_8b9f.Parameters,request.options),
"Public.Procedures.StTranslateD5eb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTranslateD5eb.call(request.parameters as Public.Procedures.StTranslateD5eb.Parameters,request.options),
"Public.Procedures.StScale_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StScale_3651.call(request.parameters as Public.Procedures.StScale_3651.Parameters,request.options),
"Public.Procedures.StScale_1bee.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StScale_1bee.call(request.parameters as Public.Procedures.StScale_1bee.Parameters,request.options),
"Public.Procedures.StScale_8b9f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StScale_8b9f.call(request.parameters as Public.Procedures.StScale_8b9f.Parameters,request.options),
"Public.Procedures.StTransscale.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransscale.call(request.parameters as Public.Procedures.StTransscale.Parameters,request.options),
"Public.Procedures.StDump.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDump.call(request.parameters as Public.Procedures.StDump.Parameters,request.options),
"Public.Procedures.StDumprings.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDumprings.call(request.parameters as Public.Procedures.StDumprings.Parameters,request.options),
"Public.Procedures.StDumppoints.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDumppoints.call(request.parameters as Public.Procedures.StDumppoints.Parameters,request.options),
"Public.Procedures.StDumpsegments.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDumpsegments.call(request.parameters as Public.Procedures.StDumpsegments.Parameters,request.options),
"Public.Procedures.PopulateGeometryColumns_23fc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PopulateGeometryColumns_23fc.call(request.parameters as Public.Procedures.PopulateGeometryColumns_23fc.Parameters,request.options),
"Public.Procedures.PopulateGeometryColumns_4174.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PopulateGeometryColumns_4174.call(request.parameters as Public.Procedures.PopulateGeometryColumns_4174.Parameters,request.options),
"Public.Procedures.Addgeometrycolumn_8fbb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Addgeometrycolumn_8fbb.call(request.parameters as Public.Procedures.Addgeometrycolumn_8fbb.Parameters,request.options),
"Public.Procedures.Addgeometrycolumn_4617.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Addgeometrycolumn_4617.call(request.parameters as Public.Procedures.Addgeometrycolumn_4617.Parameters,request.options),
"Public.Procedures.Addgeometrycolumn_093c.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Addgeometrycolumn_093c.call(request.parameters as Public.Procedures.Addgeometrycolumn_093c.Parameters,request.options),
"Public.Procedures.Dropgeometrycolumn_0412.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Dropgeometrycolumn_0412.call(request.parameters as Public.Procedures.Dropgeometrycolumn_0412.Parameters,request.options),
"Public.Procedures.Dropgeometrycolumn_2253.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Dropgeometrycolumn_2253.call(request.parameters as Public.Procedures.Dropgeometrycolumn_2253.Parameters,request.options),
"Public.Procedures.DropgeometrycolumnF11a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.DropgeometrycolumnF11a.call(request.parameters as Public.Procedures.DropgeometrycolumnF11a.Parameters,request.options),
"Public.Procedures.Dropgeometrytable_2253.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Dropgeometrytable_2253.call(request.parameters as Public.Procedures.Dropgeometrytable_2253.Parameters,request.options),
"Public.Procedures.StSegmentize_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSegmentize_7163.call(request.parameters as Public.Procedures.StSegmentize_7163.Parameters,request.options),
"Public.Procedures.DropgeometrytableF11a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.DropgeometrytableF11a.call(request.parameters as Public.Procedures.DropgeometrytableF11a.Parameters,request.options),
"Public.Procedures.DropgeometrytableBfde.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.DropgeometrytableBfde.call(request.parameters as Public.Procedures.DropgeometrytableBfde.Parameters,request.options),
"Public.Procedures.UpdategeometrysridB2ee.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.UpdategeometrysridB2ee.call(request.parameters as Public.Procedures.UpdategeometrysridB2ee.Parameters,request.options),
"Public.Procedures.Updategeometrysrid_7b58.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Updategeometrysrid_7b58.call(request.parameters as Public.Procedures.Updategeometrysrid_7b58.Parameters,request.options),
"Public.Procedures.Updategeometrysrid_11c8.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Updategeometrysrid_11c8.call(request.parameters as Public.Procedures.Updategeometrysrid_11c8.Parameters,request.options),
"Public.Procedures.FindSrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.FindSrid.call(request.parameters as Public.Procedures.FindSrid.Parameters,request.options),
"Public.Procedures.GetProj4FromSrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GetProj4FromSrid.call(request.parameters as Public.Procedures.GetProj4FromSrid.Parameters,request.options),
"Public.Procedures.StSetsrid_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSetsrid_6cbe.call(request.parameters as Public.Procedures.StSetsrid_6cbe.Parameters,request.options),
"Public.Procedures.StSrid_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSrid_0cdb.call(request.parameters as Public.Procedures.StSrid_0cdb.Parameters,request.options),
"Public.Procedures.PostgisTransformGeometry.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTransformGeometry.call(request.parameters as Public.Procedures.PostgisTransformGeometry.Parameters,request.options),
"Public.Procedures.PostgisSrsCodes.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisSrsCodes.call(request.parameters as Public.Procedures.PostgisSrsCodes.Parameters,request.options),
"Public.Procedures.PostgisSrs.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisSrs.call(request.parameters as Public.Procedures.PostgisSrs.Parameters,request.options),
"Public.Procedures.PostgisSrsAll.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisSrsAll.call(request.options),
"Public.Procedures.PostgisSrsSearch.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisSrsSearch.call(request.parameters as Public.Procedures.PostgisSrsSearch.Parameters,request.options),
"Public.Procedures.StTransform_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransform_6cbe.call(request.parameters as Public.Procedures.StTransform_6cbe.Parameters,request.options),
"Public.Procedures.StTransform_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransform_88bc.call(request.parameters as Public.Procedures.StTransform_88bc.Parameters,request.options),
"Public.Procedures.StTransform_655c.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransform_655c.call(request.parameters as Public.Procedures.StTransform_655c.Parameters,request.options),
"Public.Procedures.StTransform_5016.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransform_5016.call(request.parameters as Public.Procedures.StTransform_5016.Parameters,request.options),
"Public.Procedures.PostgisTransformPipelineGeometry.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTransformPipelineGeometry.call(request.parameters as Public.Procedures.PostgisTransformPipelineGeometry.Parameters,request.options),
"Public.Procedures.StTransformpipeline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTransformpipeline.call(request.parameters as Public.Procedures.StTransformpipeline.Parameters,request.options),
"Public.Procedures.StInversetransformpipeline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StInversetransformpipeline.call(request.parameters as Public.Procedures.StInversetransformpipeline.Parameters,request.options),
"Public.Procedures.PostgisVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisVersion.call(request.options),
"Public.Procedures.PostgisLiblwgeomVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLiblwgeomVersion.call(request.options),
"Public.Procedures.PostgisProjVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisProjVersion.call(request.options),
"Public.Procedures.PostgisWagyuVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisWagyuVersion.call(request.options),
"Public.Procedures.PostgisScriptsInstalled.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisScriptsInstalled.call(request.options),
"Public.Procedures.PostgisLibVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibVersion.call(request.options),
"Public.Procedures.PostgisScriptsReleased.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisScriptsReleased.call(request.options),
"Public.Procedures.PostgisGeosVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisGeosVersion.call(request.options),
"Public.Procedures.PostgisGeosCompiledVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisGeosCompiledVersion.call(request.options),
"Public.Procedures.PostgisLibRevision.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibRevision.call(request.options),
"Public.Procedures.PostgisSvnVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisSvnVersion.call(request.options),
"Public.Procedures.PostgisLibxmlVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibxmlVersion.call(request.options),
"Public.Procedures.PostgisScriptsBuildDate.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisScriptsBuildDate.call(request.options),
"Public.Procedures.PostgisLibBuildDate.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibBuildDate.call(request.options),
"Public.Procedures.PostgisExtensionsUpgrade.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisExtensionsUpgrade.call(request.parameters as Public.Procedures.PostgisExtensionsUpgrade.Parameters,request.options),
"Public.Procedures.StLineinterpolatepoint_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepoint_7163.call(request.parameters as Public.Procedures.StLineinterpolatepoint_7163.Parameters,request.options),
"Public.Procedures.StLineinterpolatepoints_8fda.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepoints_8fda.call(request.parameters as Public.Procedures.StLineinterpolatepoints_8fda.Parameters,request.options),
"Public.Procedures.StLinesubstringD5eb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinesubstringD5eb.call(request.parameters as Public.Procedures.StLinesubstringD5eb.Parameters,request.options),
"Public.Procedures.StLinelocatepoint_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinelocatepoint_3651.call(request.parameters as Public.Procedures.StLinelocatepoint_3651.Parameters,request.options),
"Public.Procedures.StAddmeasure.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAddmeasure.call(request.parameters as Public.Procedures.StAddmeasure.Parameters,request.options),
"Public.Procedures.StClosestpointofapproach.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClosestpointofapproach.call(request.parameters as Public.Procedures.StClosestpointofapproach.Parameters,request.options),
"Public.Procedures.PostgisFullVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisFullVersion.call(request.options),
"Public.Procedures.Box2d_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2d_0cdb.call(request.parameters as Public.Procedures.Box2d_0cdb.Parameters,request.options),
"Public.Procedures.Box3d_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box3d_0cdb.call(request.parameters as Public.Procedures.Box3d_0cdb.Parameters,request.options),
"Public.Procedures.Box_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box_0cdb.call(request.parameters as Public.Procedures.Box_0cdb.Parameters,request.options),
"Public.Procedures.Box2d_07e9.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box2d_07e9.call(request.parameters as Public.Procedures.Box2d_07e9.Parameters,request.options),
"Public.Procedures.Box3dE505.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box3dE505.call(request.parameters as Public.Procedures.Box3dE505.Parameters,request.options),
"Public.Procedures.Box_07e9.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box_07e9.call(request.parameters as Public.Procedures.Box_07e9.Parameters,request.options),
"Public.Procedures.Text.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Text.call(request.parameters as Public.Procedures.Text.Parameters,request.options),
"Public.Procedures.Box3dtobox.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Box3dtobox.call(request.parameters as Public.Procedures.Box3dtobox.Parameters,request.options),
"Public.Procedures.GeometryE505.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryE505.call(request.parameters as Public.Procedures.GeometryE505.Parameters,request.options),
"Public.Procedures.Geometry_07e9.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometry_07e9.call(request.parameters as Public.Procedures.Geometry_07e9.Parameters,request.options),
"Public.Procedures.GeometryE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryE728.call(request.parameters as Public.Procedures.GeometryE728.Parameters,request.options),
"Public.Procedures.Geometry_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometry_2d19.call(request.parameters as Public.Procedures.Geometry_2d19.Parameters,request.options),
"Public.Procedures.Bytea_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Bytea_0cdb.call(request.parameters as Public.Procedures.Bytea_0cdb.Parameters,request.options),
"Public.Procedures.StSimplify_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSimplify_7163.call(request.parameters as Public.Procedures.StSimplify_7163.Parameters,request.options),
"Public.Procedures.StSimplify_8fda.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSimplify_8fda.call(request.parameters as Public.Procedures.StSimplify_8fda.Parameters,request.options),
"Public.Procedures.StSimplifyvw.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSimplifyvw.call(request.parameters as Public.Procedures.StSimplifyvw.Parameters,request.options),
"Public.Procedures.StSeteffectivearea.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSeteffectivearea.call(request.parameters as Public.Procedures.StSeteffectivearea.Parameters,request.options),
"Public.Procedures.StFilterbym.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFilterbym.call(request.parameters as Public.Procedures.StFilterbym.Parameters,request.options),
"Public.Procedures.StChaikinsmoothing.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StChaikinsmoothing.call(request.parameters as Public.Procedures.StChaikinsmoothing.Parameters,request.options),
"Public.Procedures.StSnaptogrid_5500.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSnaptogrid_5500.call(request.parameters as Public.Procedures.StSnaptogrid_5500.Parameters,request.options),
"Public.Procedures.StSnaptogridD5eb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSnaptogridD5eb.call(request.parameters as Public.Procedures.StSnaptogridD5eb.Parameters,request.options),
"Public.Procedures.StSnaptogrid_7163.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSnaptogrid_7163.call(request.parameters as Public.Procedures.StSnaptogrid_7163.Parameters,request.options),
"Public.Procedures.StSnaptogrid_7f2e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSnaptogrid_7f2e.call(request.parameters as Public.Procedures.StSnaptogrid_7f2e.Parameters,request.options),
"Public.Procedures.StDistancecpa.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistancecpa.call(request.parameters as Public.Procedures.StDistancecpa.Parameters,request.options),
"Public.Procedures.StCpawithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCpawithin.call(request.parameters as Public.Procedures.StCpawithin.Parameters,request.options),
"Public.Procedures.StIsvalidtrajectory.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvalidtrajectory.call(request.parameters as Public.Procedures.StIsvalidtrajectory.Parameters,request.options),
"Public.Procedures.StIntersection_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersection_6961.call(request.parameters as Public.Procedures.StIntersection_6961.Parameters,request.options),
"Public.Procedures.StBufferBf44.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBufferBf44.call(request.parameters as Public.Procedures.StBufferBf44.Parameters,request.options),
"Public.Procedures.StBufferC33e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBufferC33e.call(request.parameters as Public.Procedures.StBufferC33e.Parameters,request.options),
"Public.Procedures.StMinimumboundingradius.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMinimumboundingradius.call(request.parameters as Public.Procedures.StMinimumboundingradius.Parameters,request.options),
"Public.Procedures.StMinimumboundingcircle.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMinimumboundingcircle.call(request.parameters as Public.Procedures.StMinimumboundingcircle.Parameters,request.options),
"Public.Procedures.StOrientedenvelope.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StOrientedenvelope.call(request.parameters as Public.Procedures.StOrientedenvelope.Parameters,request.options),
"Public.Procedures.StOffsetcurve.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StOffsetcurve.call(request.parameters as Public.Procedures.StOffsetcurve.Parameters,request.options),
"Public.Procedures.StGeneratepoints_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeneratepoints_6cbe.call(request.parameters as Public.Procedures.StGeneratepoints_6cbe.Parameters,request.options),
"Public.Procedures.StGeneratepointsD341.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeneratepointsD341.call(request.parameters as Public.Procedures.StGeneratepointsD341.Parameters,request.options),
"Public.Procedures.StConvexhull.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StConvexhull.call(request.parameters as Public.Procedures.StConvexhull.Parameters,request.options),
"Public.Procedures.StSimplifypreservetopology.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSimplifypreservetopology.call(request.parameters as Public.Procedures.StSimplifypreservetopology.Parameters,request.options),
"Public.Procedures.StIsvalidreason_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvalidreason_0cdb.call(request.parameters as Public.Procedures.StIsvalidreason_0cdb.Parameters,request.options),
"Public.Procedures.StIsvaliddetail.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvaliddetail.call(request.parameters as Public.Procedures.StIsvaliddetail.Parameters,request.options),
"Public.Procedures.StIsvalidreason_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvalidreason_6cbe.call(request.parameters as Public.Procedures.StIsvalidreason_6cbe.Parameters,request.options),
"Public.Procedures.StIsvalid_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvalid_6cbe.call(request.parameters as Public.Procedures.StIsvalid_6cbe.Parameters,request.options),
"Public.Procedures.StHausdorffdistance_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StHausdorffdistance_3651.call(request.parameters as Public.Procedures.StHausdorffdistance_3651.Parameters,request.options),
"Public.Procedures.StHausdorffdistance_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StHausdorffdistance_6961.call(request.parameters as Public.Procedures.StHausdorffdistance_6961.Parameters,request.options),
"Public.Procedures.StFrechetdistance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFrechetdistance.call(request.parameters as Public.Procedures.StFrechetdistance.Parameters,request.options),
"Public.Procedures.StMaximuminscribedcircle.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMaximuminscribedcircle.call(request.parameters as Public.Procedures.StMaximuminscribedcircle.Parameters,request.options),
"Public.Procedures.StLargestemptycircle.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLargestemptycircle.call(request.parameters as Public.Procedures.StLargestemptycircle.Parameters,request.options),
"Public.Procedures.StDifference.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDifference.call(request.parameters as Public.Procedures.StDifference.Parameters,request.options),
"Public.Procedures.StBoundary.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBoundary.call(request.parameters as Public.Procedures.StBoundary.Parameters,request.options),
"Public.Procedures.StPoints.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPoints.call(request.parameters as Public.Procedures.StPoints.Parameters,request.options),
"Public.Procedures.StSymdifference.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSymdifference.call(request.parameters as Public.Procedures.StSymdifference.Parameters,request.options),
"Public.Procedures.StSymmetricdifference.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSymmetricdifference.call(request.parameters as Public.Procedures.StSymmetricdifference.Parameters,request.options),
"Public.Procedures.StUnion_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StUnion_3651.call(request.parameters as Public.Procedures.StUnion_3651.Parameters,request.options),
"Public.Procedures.StUnion_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StUnion_6961.call(request.parameters as Public.Procedures.StUnion_6961.Parameters,request.options),
"Public.Procedures.StUnaryunion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StUnaryunion.call(request.parameters as Public.Procedures.StUnaryunion.Parameters,request.options),
"Public.Procedures.StRemoverepeatedpoints.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRemoverepeatedpoints.call(request.parameters as Public.Procedures.StRemoverepeatedpoints.Parameters,request.options),
"Public.Procedures.StClipbybox2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClipbybox2d.call(request.parameters as Public.Procedures.StClipbybox2d.Parameters,request.options),
"Public.Procedures.StSubdivide.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSubdivide.call(request.parameters as Public.Procedures.StSubdivide.Parameters,request.options),
"Public.Procedures.StReduceprecision.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StReduceprecision.call(request.parameters as Public.Procedures.StReduceprecision.Parameters,request.options),
"Public.Procedures.StMakevalid_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakevalid_0cdb.call(request.parameters as Public.Procedures.StMakevalid_0cdb.Parameters,request.options),
"Public.Procedures.StMakevalid_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMakevalid_88bc.call(request.parameters as Public.Procedures.StMakevalid_88bc.Parameters,request.options),
"Public.Procedures.StCleangeometry.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCleangeometry.call(request.parameters as Public.Procedures.StCleangeometry.Parameters,request.options),
"Public.Procedures.StSplit.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSplit.call(request.parameters as Public.Procedures.StSplit.Parameters,request.options),
"Public.Procedures.StSharedpaths.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSharedpaths.call(request.parameters as Public.Procedures.StSharedpaths.Parameters,request.options),
"Public.Procedures.StSnap.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSnap.call(request.parameters as Public.Procedures.StSnap.Parameters,request.options),
"Public.Procedures.StRelatematch.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRelatematch.call(request.parameters as Public.Procedures.StRelatematch.Parameters,request.options),
"Public.Procedures.StNode.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNode.call(request.parameters as Public.Procedures.StNode.Parameters,request.options),
"Public.Procedures.StDelaunaytriangles.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDelaunaytriangles.call(request.parameters as Public.Procedures.StDelaunaytriangles.Parameters,request.options),
"Public.Procedures.StTriangulatepolygon.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTriangulatepolygon.call(request.parameters as Public.Procedures.StTriangulatepolygon.Parameters,request.options),
"Public.Procedures.StVoronoipolygons.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StVoronoipolygons.call(request.parameters as Public.Procedures.StVoronoipolygons.Parameters,request.options),
"Public.Procedures.StVoronoilines.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StVoronoilines.call(request.parameters as Public.Procedures.StVoronoilines.Parameters,request.options),
"Public.Procedures.StCombinebbox_1ee2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCombinebbox_1ee2.call(request.parameters as Public.Procedures.StCombinebbox_1ee2.Parameters,request.options),
"Public.Procedures.StCombinebbox_9d67.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCombinebbox_9d67.call(request.parameters as Public.Procedures.StCombinebbox_9d67.Parameters,request.options),
"Public.Procedures.StCombinebbox_1a7e.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCombinebbox_1a7e.call(request.parameters as Public.Procedures.StCombinebbox_1a7e.Parameters,request.options),
"Public.Procedures.StCollect_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCollect_3651.call(request.parameters as Public.Procedures.StCollect_3651.Parameters,request.options),
"Public.Procedures.StCollectA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCollectA4b6.call(request.parameters as Public.Procedures.StCollectA4b6.Parameters,request.options),
"Public.Procedures.PgisGeometryAccumTransfn_43cf.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryAccumTransfn_43cf.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters,request.options),
"Public.Procedures.PgisGeometryAccumTransfn_7c68.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryAccumTransfn_7c68.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters,request.options),
"Public.Procedures.PgisGeometryAccumTransfn_0b93.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryAccumTransfn_0b93.call(request.parameters as Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters,request.options),
"Public.Procedures.PgisGeometryCollectFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryCollectFinalfn.call(request.parameters as Public.Procedures.PgisGeometryCollectFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryPolygonizeFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryPolygonizeFinalfn.call(request.parameters as Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryClusterintersectingFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryClusterintersectingFinalfn.call(request.parameters as Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryClusterwithinFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryClusterwithinFinalfn.call(request.parameters as Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryMakelineFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryMakelineFinalfn.call(request.parameters as Public.Procedures.PgisGeometryMakelineFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryCoverageunionFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryCoverageunionFinalfn.call(request.parameters as Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelCombinefn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelCombinefn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelSerialfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelSerialfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelDeserialfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelDeserialfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters,request.options),
"Public.Procedures.PgisGeometryUnionParallelFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisGeometryUnionParallelFinalfn.call(request.parameters as Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters,request.options),
"Public.Procedures.StUnionA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StUnionA4b6.call(request.parameters as Public.Procedures.StUnionA4b6.Parameters,request.options),
"Public.Procedures.StCoverageunionA4b6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoverageunionA4b6.call(request.parameters as Public.Procedures.StCoverageunionA4b6.Parameters,request.options),
"Public.Procedures.StRelate_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRelate_3651.call(request.parameters as Public.Procedures.StRelate_3651.Parameters,request.options),
"Public.Procedures.StRelateAa17.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRelateAa17.call(request.parameters as Public.Procedures.StRelateAa17.Parameters,request.options),
"Public.Procedures.StRelateCaf9.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StRelateCaf9.call(request.parameters as Public.Procedures.StRelateCaf9.Parameters,request.options),
"Public.Procedures.StDisjoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDisjoint.call(request.parameters as Public.Procedures.StDisjoint.Parameters,request.options),
"Public.Procedures.PostgisIndexSupportfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisIndexSupportfn.call(request.parameters as Public.Procedures.PostgisIndexSupportfn.Parameters,request.options),
"Public.Procedures.StLinecrossingdirection.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinecrossingdirection.call(request.parameters as Public.Procedures.StLinecrossingdirection.Parameters,request.options),
"Public.Procedures.StDwithin_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDwithin_6961.call(request.parameters as Public.Procedures.StDwithin_6961.Parameters,request.options),
"Public.Procedures.StTouches.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StTouches.call(request.parameters as Public.Procedures.StTouches.Parameters,request.options),
"Public.Procedures.StIntersects_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersects_3651.call(request.parameters as Public.Procedures.StIntersects_3651.Parameters,request.options),
"Public.Procedures.StCrosses.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCrosses.call(request.parameters as Public.Procedures.StCrosses.Parameters,request.options),
"Public.Procedures.StContains.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StContains.call(request.parameters as Public.Procedures.StContains.Parameters,request.options),
"Public.Procedures.StContainsproperly.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StContainsproperly.call(request.parameters as Public.Procedures.StContainsproperly.Parameters,request.options),
"Public.Procedures.StWithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StWithin.call(request.parameters as Public.Procedures.StWithin.Parameters,request.options),
"Public.Procedures.StCovers_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCovers_3651.call(request.parameters as Public.Procedures.StCovers_3651.Parameters,request.options),
"Public.Procedures.StCoveredby_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoveredby_3651.call(request.parameters as Public.Procedures.StCoveredby_3651.Parameters,request.options),
"Public.Procedures.StOverlaps.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StOverlaps.call(request.parameters as Public.Procedures.StOverlaps.Parameters,request.options),
"Public.Procedures.StDfullywithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDfullywithin.call(request.parameters as Public.Procedures.StDfullywithin.Parameters,request.options),
"Public.Procedures.St_3ddwithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3ddwithin.call(request.parameters as Public.Procedures.St_3ddwithin.Parameters,request.options),
"Public.Procedures.St_3ddfullywithin.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3ddfullywithin.call(request.parameters as Public.Procedures.St_3ddfullywithin.Parameters,request.options),
"Public.Procedures.St_3dintersects.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dintersects.call(request.parameters as Public.Procedures.St_3dintersects.Parameters,request.options),
"Public.Procedures.StOrderingequals.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StOrderingequals.call(request.parameters as Public.Procedures.StOrderingequals.Parameters,request.options),
"Public.Procedures.StEquals.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEquals.call(request.parameters as Public.Procedures.StEquals.Parameters,request.options),
"Public.Procedures.StIsvalid_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsvalid_0cdb.call(request.parameters as Public.Procedures.StIsvalid_0cdb.Parameters,request.options),
"Public.Procedures.StMinimumclearance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMinimumclearance.call(request.parameters as Public.Procedures.StMinimumclearance.Parameters,request.options),
"Public.Procedures.StMinimumclearanceline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMinimumclearanceline.call(request.parameters as Public.Procedures.StMinimumclearanceline.Parameters,request.options),
"Public.Procedures.StCentroid_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCentroid_0cdb.call(request.parameters as Public.Procedures.StCentroid_0cdb.Parameters,request.options),
"Public.Procedures.StGeometricmedian.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeometricmedian.call(request.parameters as Public.Procedures.StGeometricmedian.Parameters,request.options),
"Public.Procedures.StIsring.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsring.call(request.parameters as Public.Procedures.StIsring.Parameters,request.options),
"Public.Procedures.StPointonsurface.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointonsurface.call(request.parameters as Public.Procedures.StPointonsurface.Parameters,request.options),
"Public.Procedures.StIssimple.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIssimple.call(request.parameters as Public.Procedures.StIssimple.Parameters,request.options),
"Public.Procedures.StIscollection.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIscollection.call(request.parameters as Public.Procedures.StIscollection.Parameters,request.options),
"Public.Procedures.Equals.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Equals.call(request.parameters as Public.Procedures.Equals.Parameters,request.options),
"Public.Procedures.StGeomfromgml_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgml_27e2.call(request.parameters as Public.Procedures.StGeomfromgml_27e2.Parameters,request.options),
"Public.Procedures.StGeomfromgmlE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgmlE728.call(request.parameters as Public.Procedures.StGeomfromgmlE728.Parameters,request.options),
"Public.Procedures.StGmltosqlE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGmltosqlE728.call(request.parameters as Public.Procedures.StGmltosqlE728.Parameters,request.options),
"Public.Procedures.StGmltosql_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGmltosql_27e2.call(request.parameters as Public.Procedures.StGmltosql_27e2.Parameters,request.options),
"Public.Procedures.StGeomfromkml.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromkml.call(request.parameters as Public.Procedures.StGeomfromkml.Parameters,request.options),
"Public.Procedures.StGeomfrommarc21.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfrommarc21.call(request.parameters as Public.Procedures.StGeomfrommarc21.Parameters,request.options),
"Public.Procedures.StAsmarc21.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsmarc21.call(request.parameters as Public.Procedures.StAsmarc21.Parameters,request.options),
"Public.Procedures.StGeomfromgeojsonE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgeojsonE728.call(request.parameters as Public.Procedures.StGeomfromgeojsonE728.Parameters,request.options),
"Public.Procedures.StGeomfromgeojson_608f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgeojson_608f.call(request.parameters as Public.Procedures.StGeomfromgeojson_608f.Parameters,request.options),
"Public.Procedures.StGeomfromgeojson_3c9d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgeojson_3c9d.call(request.parameters as Public.Procedures.StGeomfromgeojson_3c9d.Parameters,request.options),
"Public.Procedures.PostgisLibjsonVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibjsonVersion.call(request.options),
"Public.Procedures.StLinefromencodedpolyline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefromencodedpolyline.call(request.parameters as Public.Procedures.StLinefromencodedpolyline.Parameters,request.options),
"Public.Procedures.StAsencodedpolyline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsencodedpolyline.call(request.parameters as Public.Procedures.StAsencodedpolyline.Parameters,request.options),
"Public.Procedures.StAssvgD341.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAssvgD341.call(request.parameters as Public.Procedures.StAssvgD341.Parameters,request.options),
"Public.Procedures.StAsgmlD341.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgmlD341.call(request.parameters as Public.Procedures.StAsgmlD341.Parameters,request.options),
"Public.Procedures.StAsgml_32a0.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgml_32a0.call(request.parameters as Public.Procedures.StAsgml_32a0.Parameters,request.options),
"Public.Procedures.StAskmlCce7.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAskmlCce7.call(request.parameters as Public.Procedures.StAskmlCce7.Parameters,request.options),
"Public.Procedures.StAsgeojsonD341.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgeojsonD341.call(request.parameters as Public.Procedures.StAsgeojsonD341.Parameters,request.options),
"Public.Procedures.StAsgeojsonF2c6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgeojsonF2c6.call(request.parameters as Public.Procedures.StAsgeojsonF2c6.Parameters,request.options),
"Public.Procedures.Json.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Json.call(request.parameters as Public.Procedures.Json.Parameters,request.options),
"Public.Procedures.Jsonb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Jsonb.call(request.parameters as Public.Procedures.Jsonb.Parameters,request.options),
"Public.Procedures.PgisAsmvtTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtTransfn_647f.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_647f.Parameters,request.options),
"Public.Procedures.PgisAsmvtTransfn_27f4.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtTransfn_27f4.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_27f4.Parameters,request.options),
"Public.Procedures.PgisAsmvtTransfnF57f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtTransfnF57f.call(request.parameters as Public.Procedures.PgisAsmvtTransfnF57f.Parameters,request.options),
"Public.Procedures.PgisAsmvtTransfn_92c1.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtTransfn_92c1.call(request.parameters as Public.Procedures.PgisAsmvtTransfn_92c1.Parameters,request.options),
"Public.Procedures.PgisAsmvtTransfnF5be.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtTransfnF5be.call(request.parameters as Public.Procedures.PgisAsmvtTransfnF5be.Parameters,request.options),
"Public.Procedures.PgisAsmvtFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtFinalfn.call(request.parameters as Public.Procedures.PgisAsmvtFinalfn.Parameters,request.options),
"Public.Procedures.PgisAsmvtCombinefn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtCombinefn.call(request.parameters as Public.Procedures.PgisAsmvtCombinefn.Parameters,request.options),
"Public.Procedures.PgisAsmvtSerialfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtSerialfn.call(request.parameters as Public.Procedures.PgisAsmvtSerialfn.Parameters,request.options),
"Public.Procedures.PgisAsmvtDeserialfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsmvtDeserialfn.call(request.parameters as Public.Procedures.PgisAsmvtDeserialfn.Parameters,request.options),
"Public.Procedures.StAsmvtgeom.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsmvtgeom.call(request.parameters as Public.Procedures.StAsmvtgeom.Parameters,request.options),
"Public.Procedures.PostgisLibprotobufVersion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisLibprotobufVersion.call(request.options),
"Public.Procedures.PgisAsgeobufTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsgeobufTransfn_647f.call(request.parameters as Public.Procedures.PgisAsgeobufTransfn_647f.Parameters,request.options),
"Public.Procedures.PgisAsgeobufTransfn_27f4.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsgeobufTransfn_27f4.call(request.parameters as Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters,request.options),
"Public.Procedures.PgisAsgeobufFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsgeobufFinalfn.call(request.parameters as Public.Procedures.PgisAsgeobufFinalfn.Parameters,request.options),
"Public.Procedures.PgisAsflatgeobufTransfn_647f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsflatgeobufTransfn_647f.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters,request.options),
"Public.Procedures.PgisAsflatgeobufTransfn_9633.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsflatgeobufTransfn_9633.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters,request.options),
"Public.Procedures.PgisAsflatgeobufTransfn_521f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsflatgeobufTransfn_521f.call(request.parameters as Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters,request.options),
"Public.Procedures.PgisAsflatgeobufFinalfn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PgisAsflatgeobufFinalfn.call(request.parameters as Public.Procedures.PgisAsflatgeobufFinalfn.Parameters,request.options),
"Public.Procedures.StFromflatgeobuftotable.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFromflatgeobuftotable.call(request.parameters as Public.Procedures.StFromflatgeobuftotable.Parameters,request.options),
"Public.Procedures.StFromflatgeobuf.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFromflatgeobuf.call(request.parameters as Public.Procedures.StFromflatgeobuf.Parameters,request.options),
"Public.Procedures.StGeohash_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeohash_6cbe.call(request.parameters as Public.Procedures.StGeohash_6cbe.Parameters,request.options),
"Public.Procedures.StBox2dfromgeohash.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBox2dfromgeohash.call(request.parameters as Public.Procedures.StBox2dfromgeohash.Parameters,request.options),
"Public.Procedures.StPointfromgeohash.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointfromgeohash.call(request.parameters as Public.Procedures.StPointfromgeohash.Parameters,request.options),
"Public.Procedures.StGeomfromgeohash.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromgeohash.call(request.parameters as Public.Procedures.StGeomfromgeohash.Parameters,request.options),
"Public.Procedures.StNumpoints.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNumpoints.call(request.parameters as Public.Procedures.StNumpoints.Parameters,request.options),
"Public.Procedures.StNumgeometries.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNumgeometries.call(request.parameters as Public.Procedures.StNumgeometries.Parameters,request.options),
"Public.Procedures.StGeometryn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeometryn.call(request.parameters as Public.Procedures.StGeometryn.Parameters,request.options),
"Public.Procedures.StDimension.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDimension.call(request.parameters as Public.Procedures.StDimension.Parameters,request.options),
"Public.Procedures.StExteriorring.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StExteriorring.call(request.parameters as Public.Procedures.StExteriorring.Parameters,request.options),
"Public.Procedures.StNuminteriorrings.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNuminteriorrings.call(request.parameters as Public.Procedures.StNuminteriorrings.Parameters,request.options),
"Public.Procedures.StNuminteriorring.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNuminteriorring.call(request.parameters as Public.Procedures.StNuminteriorring.Parameters,request.options),
"Public.Procedures.StInteriorringn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StInteriorringn.call(request.parameters as Public.Procedures.StInteriorringn.Parameters,request.options),
"Public.Procedures.Geometrytype_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometrytype_0cdb.call(request.parameters as Public.Procedures.Geometrytype_0cdb.Parameters,request.options),
"Public.Procedures.StGeometrytype.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeometrytype.call(request.parameters as Public.Procedures.StGeometrytype.Parameters,request.options),
"Public.Procedures.StPointn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointn.call(request.parameters as Public.Procedures.StPointn.Parameters,request.options),
"Public.Procedures.StNumpatches.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StNumpatches.call(request.parameters as Public.Procedures.StNumpatches.Parameters,request.options),
"Public.Procedures.StPatchn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPatchn.call(request.parameters as Public.Procedures.StPatchn.Parameters,request.options),
"Public.Procedures.StStartpoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StStartpoint.call(request.parameters as Public.Procedures.StStartpoint.Parameters,request.options),
"Public.Procedures.StEndpoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StEndpoint.call(request.parameters as Public.Procedures.StEndpoint.Parameters,request.options),
"Public.Procedures.StIsclosed.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsclosed.call(request.parameters as Public.Procedures.StIsclosed.Parameters,request.options),
"Public.Procedures.StIsempty.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIsempty.call(request.parameters as Public.Procedures.StIsempty.Parameters,request.options),
"Public.Procedures.StAsbinary_88bc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsbinary_88bc.call(request.parameters as Public.Procedures.StAsbinary_88bc.Parameters,request.options),
"Public.Procedures.StAsbinary_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsbinary_0cdb.call(request.parameters as Public.Procedures.StAsbinary_0cdb.Parameters,request.options),
"Public.Procedures.StAstext_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstext_0cdb.call(request.parameters as Public.Procedures.StAstext_0cdb.Parameters,request.options),
"Public.Procedures.StAstext_6cbe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstext_6cbe.call(request.parameters as Public.Procedures.StAstext_6cbe.Parameters,request.options),
"Public.Procedures.StGeometryfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeometryfromtextE728.call(request.parameters as Public.Procedures.StGeometryfromtextE728.Parameters,request.options),
"Public.Procedures.StGeometryfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeometryfromtext_27e2.call(request.parameters as Public.Procedures.StGeometryfromtext_27e2.Parameters,request.options),
"Public.Procedures.StGeomfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromtextE728.call(request.parameters as Public.Procedures.StGeomfromtextE728.Parameters,request.options),
"Public.Procedures.StGeomfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromtext_27e2.call(request.parameters as Public.Procedures.StGeomfromtext_27e2.Parameters,request.options),
"Public.Procedures.StWkttosql.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StWkttosql.call(request.parameters as Public.Procedures.StWkttosql.Parameters,request.options),
"Public.Procedures.StPointfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointfromtextE728.call(request.parameters as Public.Procedures.StPointfromtextE728.Parameters,request.options),
"Public.Procedures.StPointfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointfromtext_27e2.call(request.parameters as Public.Procedures.StPointfromtext_27e2.Parameters,request.options),
"Public.Procedures.StLinefromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefromtextE728.call(request.parameters as Public.Procedures.StLinefromtextE728.Parameters,request.options),
"Public.Procedures.StLinefromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefromtext_27e2.call(request.parameters as Public.Procedures.StLinefromtext_27e2.Parameters,request.options),
"Public.Procedures.StPolyfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolyfromtextE728.call(request.parameters as Public.Procedures.StPolyfromtextE728.Parameters,request.options),
"Public.Procedures.StPolyfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolyfromtext_27e2.call(request.parameters as Public.Procedures.StPolyfromtext_27e2.Parameters,request.options),
"Public.Procedures.StPolygonfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygonfromtext_27e2.call(request.parameters as Public.Procedures.StPolygonfromtext_27e2.Parameters,request.options),
"Public.Procedures.StPolygonfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygonfromtextE728.call(request.parameters as Public.Procedures.StPolygonfromtextE728.Parameters,request.options),
"Public.Procedures.StMlinefromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMlinefromtext_27e2.call(request.parameters as Public.Procedures.StMlinefromtext_27e2.Parameters,request.options),
"Public.Procedures.StMlinefromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMlinefromtextE728.call(request.parameters as Public.Procedures.StMlinefromtextE728.Parameters,request.options),
"Public.Procedures.StMultilinestringfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultilinestringfromtextE728.call(request.parameters as Public.Procedures.StMultilinestringfromtextE728.Parameters,request.options),
"Public.Procedures.StMultilinestringfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultilinestringfromtext_27e2.call(request.parameters as Public.Procedures.StMultilinestringfromtext_27e2.Parameters,request.options),
"Public.Procedures.StMpointfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpointfromtext_27e2.call(request.parameters as Public.Procedures.StMpointfromtext_27e2.Parameters,request.options),
"Public.Procedures.StMpointfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpointfromtextE728.call(request.parameters as Public.Procedures.StMpointfromtextE728.Parameters,request.options),
"Public.Procedures.StMultipointfromtext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipointfromtext.call(request.parameters as Public.Procedures.StMultipointfromtext.Parameters,request.options),
"Public.Procedures.StMpolyfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpolyfromtext_27e2.call(request.parameters as Public.Procedures.StMpolyfromtext_27e2.Parameters,request.options),
"Public.Procedures.StMpolyfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpolyfromtextE728.call(request.parameters as Public.Procedures.StMpolyfromtextE728.Parameters,request.options),
"Public.Procedures.StMultipolygonfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipolygonfromtext_27e2.call(request.parameters as Public.Procedures.StMultipolygonfromtext_27e2.Parameters,request.options),
"Public.Procedures.StMultipolygonfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipolygonfromtextE728.call(request.parameters as Public.Procedures.StMultipolygonfromtextE728.Parameters,request.options),
"Public.Procedures.StGeomcollfromtext_27e2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomcollfromtext_27e2.call(request.parameters as Public.Procedures.StGeomcollfromtext_27e2.Parameters,request.options),
"Public.Procedures.StGeomcollfromtextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomcollfromtextE728.call(request.parameters as Public.Procedures.StGeomcollfromtextE728.Parameters,request.options),
"Public.Procedures.StGeomfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromwkb_2d19.call(request.parameters as Public.Procedures.StGeomfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StGeomfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomfromwkbD8af.call(request.parameters as Public.Procedures.StGeomfromwkbD8af.Parameters,request.options),
"Public.Procedures.StPointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointfromwkbD8af.call(request.parameters as Public.Procedures.StPointfromwkbD8af.Parameters,request.options),
"Public.Procedures.StPointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointfromwkb_2d19.call(request.parameters as Public.Procedures.StPointfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StLinefromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefromwkbD8af.call(request.parameters as Public.Procedures.StLinefromwkbD8af.Parameters,request.options),
"Public.Procedures.StLinefromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinefromwkb_2d19.call(request.parameters as Public.Procedures.StLinefromwkb_2d19.Parameters,request.options),
"Public.Procedures.StLinestringfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinestringfromwkbD8af.call(request.parameters as Public.Procedures.StLinestringfromwkbD8af.Parameters,request.options),
"Public.Procedures.StLinestringfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinestringfromwkb_2d19.call(request.parameters as Public.Procedures.StLinestringfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StPolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolyfromwkbD8af.call(request.parameters as Public.Procedures.StPolyfromwkbD8af.Parameters,request.options),
"Public.Procedures.StPolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolyfromwkb_2d19.call(request.parameters as Public.Procedures.StPolyfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StPolygonfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygonfromwkbD8af.call(request.parameters as Public.Procedures.StPolygonfromwkbD8af.Parameters,request.options),
"Public.Procedures.StPolygonfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygonfromwkb_2d19.call(request.parameters as Public.Procedures.StPolygonfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMpointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpointfromwkbD8af.call(request.parameters as Public.Procedures.StMpointfromwkbD8af.Parameters,request.options),
"Public.Procedures.StMpointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpointfromwkb_2d19.call(request.parameters as Public.Procedures.StMpointfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMultipointfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipointfromwkbD8af.call(request.parameters as Public.Procedures.StMultipointfromwkbD8af.Parameters,request.options),
"Public.Procedures.GeographyAnalyze.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyAnalyze.call(request.parameters as Public.Procedures.GeographyAnalyze.Parameters,request.options),
"Public.Procedures.StMultipointfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipointfromwkb_2d19.call(request.parameters as Public.Procedures.StMultipointfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMultilinefromwkb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultilinefromwkb.call(request.parameters as Public.Procedures.StMultilinefromwkb.Parameters,request.options),
"Public.Procedures.StMlinefromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMlinefromwkbD8af.call(request.parameters as Public.Procedures.StMlinefromwkbD8af.Parameters,request.options),
"Public.Procedures.StMlinefromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMlinefromwkb_2d19.call(request.parameters as Public.Procedures.StMlinefromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMpolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpolyfromwkbD8af.call(request.parameters as Public.Procedures.StMpolyfromwkbD8af.Parameters,request.options),
"Public.Procedures.StMpolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMpolyfromwkb_2d19.call(request.parameters as Public.Procedures.StMpolyfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMultipolyfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipolyfromwkbD8af.call(request.parameters as Public.Procedures.StMultipolyfromwkbD8af.Parameters,request.options),
"Public.Procedures.StMultipolyfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMultipolyfromwkb_2d19.call(request.parameters as Public.Procedures.StMultipolyfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StGeomcollfromwkbD8af.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomcollfromwkbD8af.call(request.parameters as Public.Procedures.StGeomcollfromwkbD8af.Parameters,request.options),
"Public.Procedures.StGeomcollfromwkb_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeomcollfromwkb_2d19.call(request.parameters as Public.Procedures.StGeomcollfromwkb_2d19.Parameters,request.options),
"Public.Procedures.StMaxdistance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StMaxdistance.call(request.parameters as Public.Procedures.StMaxdistance.Parameters,request.options),
"Public.Procedures.StClosestpoint_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClosestpoint_3651.call(request.parameters as Public.Procedures.StClosestpoint_3651.Parameters,request.options),
"Public.Procedures.StShortestline_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StShortestline_3651.call(request.parameters as Public.Procedures.StShortestline_3651.Parameters,request.options),
"Public.Procedures.StLongestline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLongestline.call(request.parameters as Public.Procedures.StLongestline.Parameters,request.options),
"Public.Procedures.StSwapordinates.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSwapordinates.call(request.parameters as Public.Procedures.StSwapordinates.Parameters,request.options),
"Public.Procedures.StFlipcoordinates.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StFlipcoordinates.call(request.parameters as Public.Procedures.StFlipcoordinates.Parameters,request.options),
"Public.Procedures.StBdpolyfromtext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBdpolyfromtext.call(request.parameters as Public.Procedures.StBdpolyfromtext.Parameters,request.options),
"Public.Procedures.StBdmpolyfromtext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBdmpolyfromtext.call(request.parameters as Public.Procedures.StBdmpolyfromtext.Parameters,request.options),
"Public.Procedures.Unlockrows.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Unlockrows.call(request.parameters as Public.Procedures.Unlockrows.Parameters,request.options),
"Public.Procedures.Geography_28e9.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geography_28e9.call(request.parameters as Public.Procedures.Geography_28e9.Parameters,request.options),
"Public.Procedures.Geography_2d19.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geography_2d19.call(request.parameters as Public.Procedures.Geography_2d19.Parameters,request.options),
"Public.Procedures.Bytea_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Bytea_7902.call(request.parameters as Public.Procedures.Bytea_7902.Parameters,request.options),
"Public.Procedures.StAstext_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstext_7902.call(request.parameters as Public.Procedures.StAstext_7902.Parameters,request.options),
"Public.Procedures.StAstext_3181.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstext_3181.call(request.parameters as Public.Procedures.StAstext_3181.Parameters,request.options),
"Public.Procedures.LockrowE9aa.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.LockrowE9aa.call(request.parameters as Public.Procedures.LockrowE9aa.Parameters,request.options),
"Public.Procedures.Lockrow_02b4.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Lockrow_02b4.call(request.parameters as Public.Procedures.Lockrow_02b4.Parameters,request.options),
"Public.Procedures.Lockrow_27e1.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Lockrow_27e1.call(request.parameters as Public.Procedures.Lockrow_27e1.Parameters,request.options),
"Public.Procedures.Lockrow_9a8a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Lockrow_9a8a.call(request.parameters as Public.Procedures.Lockrow_9a8a.Parameters,request.options),
"Public.Procedures.Addauth.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Addauth.call(request.parameters as Public.Procedures.Addauth.Parameters,request.options),
"Public.Procedures.Checkauth_27e1.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Checkauth_27e1.call(request.parameters as Public.Procedures.Checkauth_27e1.Parameters,request.options),
"Public.Procedures.Checkauth_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Checkauth_2ec2.call(request.parameters as Public.Procedures.Checkauth_2ec2.Parameters,request.options),
"Public.Procedures.Checkauthtrigger.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Checkauthtrigger.call(request.options),
"Public.Procedures.Gettransactionid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Gettransactionid.call(request.options),
"Public.Procedures.Enablelongtransactions.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Enablelongtransactions.call(request.options),
"Public.Procedures.Longtransactionsenabled.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Longtransactionsenabled.call(request.options),
"Public.Procedures.Disablelongtransactions.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Disablelongtransactions.call(request.options),
"Public.Procedures.GeographyTypmodIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyTypmodIn.call(request.parameters as Public.Procedures.GeographyTypmodIn.Parameters,request.options),
"Public.Procedures.GeographyTypmodOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyTypmodOut.call(request.parameters as Public.Procedures.GeographyTypmodOut.Parameters,request.options),
"Public.Procedures.GeographyIn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyIn.call(request.parameters as Public.Procedures.GeographyIn.Parameters,request.options),
"Public.Procedures.GeographyOut.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyOut.call(request.parameters as Public.Procedures.GeographyOut.Parameters,request.options),
"Public.Procedures.GeographyRecv.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyRecv.call(request.parameters as Public.Procedures.GeographyRecv.Parameters,request.options),
"Public.Procedures.GeographySend.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySend.call(request.parameters as Public.Procedures.GeographySend.Parameters,request.options),
"Public.Procedures.StAstextE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAstextE728.call(request.parameters as Public.Procedures.StAstextE728.Parameters,request.options),
"Public.Procedures.StGeographyfromtext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeographyfromtext.call(request.parameters as Public.Procedures.StGeographyfromtext.Parameters,request.options),
"Public.Procedures.StGeogfromtext.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeogfromtext.call(request.parameters as Public.Procedures.StGeogfromtext.Parameters,request.options),
"Public.Procedures.StGeogfromwkb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeogfromwkb.call(request.parameters as Public.Procedures.StGeogfromwkb.Parameters,request.options),
"Public.Procedures.PostgisTypmodDims.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTypmodDims.call(request.parameters as Public.Procedures.PostgisTypmodDims.Parameters,request.options),
"Public.Procedures.PostgisTypmodSrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTypmodSrid.call(request.parameters as Public.Procedures.PostgisTypmodSrid.Parameters,request.options),
"Public.Procedures.PostgisTypmodType.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTypmodType.call(request.parameters as Public.Procedures.PostgisTypmodType.Parameters,request.options),
"Public.Procedures.Geography_0cdb.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geography_0cdb.call(request.parameters as Public.Procedures.Geography_0cdb.Parameters,request.options),
"Public.Procedures.Geometry_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometry_7902.call(request.parameters as Public.Procedures.Geometry_7902.Parameters,request.options),
"Public.Procedures.GeographyGistConsistent.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistConsistent.call(request.parameters as Public.Procedures.GeographyGistConsistent.Parameters,request.options),
"Public.Procedures.GeographyGistCompress.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistCompress.call(request.parameters as Public.Procedures.GeographyGistCompress.Parameters,request.options),
"Public.Procedures.GeographyGistPenalty.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistPenalty.call(request.parameters as Public.Procedures.GeographyGistPenalty.Parameters,request.options),
"Public.Procedures.GeographyGistPicksplit.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistPicksplit.call(request.parameters as Public.Procedures.GeographyGistPicksplit.Parameters,request.options),
"Public.Procedures.GeographyGistUnion.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistUnion.call(request.parameters as Public.Procedures.GeographyGistUnion.Parameters,request.options),
"Public.Procedures.GeographyGistSame.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistSame.call(request.parameters as Public.Procedures.GeographyGistSame.Parameters,request.options),
"Public.Procedures.GeographyGistDecompress.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistDecompress.call(request.parameters as Public.Procedures.GeographyGistDecompress.Parameters,request.options),
"Public.Procedures.GeographyOverlaps.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyOverlaps.call(request.parameters as Public.Procedures.GeographyOverlaps.Parameters,request.options),
"Public.Procedures.GeographyDistanceKnn.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyDistanceKnn.call(request.parameters as Public.Procedures.GeographyDistanceKnn.Parameters,request.options),
"Public.Procedures.GeographyGistDistance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGistDistance.call(request.parameters as Public.Procedures.GeographyGistDistance.Parameters,request.options),
"Public.Procedures.OverlapsGeog_52a8.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsGeog_52a8.call(request.parameters as Public.Procedures.OverlapsGeog_52a8.Parameters,request.options),
"Public.Procedures.OverlapsGeog_25ba.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsGeog_25ba.call(request.parameters as Public.Procedures.OverlapsGeog_25ba.Parameters,request.options),
"Public.Procedures.OverlapsGeog_8fd3.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsGeog_8fd3.call(request.parameters as Public.Procedures.OverlapsGeog_8fd3.Parameters,request.options),
"Public.Procedures.GeogBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeogBrinInclusionAddValue.call(request.parameters as Public.Procedures.GeogBrinInclusionAddValue.Parameters,request.options),
"Public.Procedures.GeographyLt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyLt.call(request.parameters as Public.Procedures.GeographyLt.Parameters,request.options),
"Public.Procedures.GeographyLe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyLe.call(request.parameters as Public.Procedures.GeographyLe.Parameters,request.options),
"Public.Procedures.GeographyGt.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGt.call(request.parameters as Public.Procedures.GeographyGt.Parameters,request.options),
"Public.Procedures.GeographyGe.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyGe.call(request.parameters as Public.Procedures.GeographyGe.Parameters,request.options),
"Public.Procedures.GeographyEq.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyEq.call(request.parameters as Public.Procedures.GeographyEq.Parameters,request.options),
"Public.Procedures.GeographyCmp.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographyCmp.call(request.parameters as Public.Procedures.GeographyCmp.Parameters,request.options),
"Public.Procedures.StAssvg_6ec5.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAssvg_6ec5.call(request.parameters as Public.Procedures.StAssvg_6ec5.Parameters,request.options),
"Public.Procedures.StAssvgE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAssvgE728.call(request.parameters as Public.Procedures.StAssvgE728.Parameters,request.options),
"Public.Procedures.StProjectD4ec.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StProjectD4ec.call(request.parameters as Public.Procedures.StProjectD4ec.Parameters,request.options),
"Public.Procedures.StAzimuthE452.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAzimuthE452.call(request.parameters as Public.Procedures.StAzimuthE452.Parameters,request.options),
"Public.Procedures.StBuffer_49f7.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBuffer_49f7.call(request.parameters as Public.Procedures.StBuffer_49f7.Parameters,request.options),
"Public.Procedures.StAsgmlE888.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgmlE888.call(request.parameters as Public.Procedures.StAsgmlE888.Parameters,request.options),
"Public.Procedures.StAsgml_2160.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgml_2160.call(request.parameters as Public.Procedures.StAsgml_2160.Parameters,request.options),
"Public.Procedures.StAsgmlE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgmlE728.call(request.parameters as Public.Procedures.StAsgmlE728.Parameters,request.options),
"Public.Procedures.StAskmlF40a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAskmlF40a.call(request.parameters as Public.Procedures.StAskmlF40a.Parameters,request.options),
"Public.Procedures.StAskmlE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAskmlE728.call(request.parameters as Public.Procedures.StAskmlE728.Parameters,request.options),
"Public.Procedures.StAsgeojson_6ec5.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgeojson_6ec5.call(request.parameters as Public.Procedures.StAsgeojson_6ec5.Parameters,request.options),
"Public.Procedures.StAsgeojsonE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsgeojsonE728.call(request.parameters as Public.Procedures.StAsgeojsonE728.Parameters,request.options),
"Public.Procedures.StDistance_8dcd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistance_8dcd.call(request.parameters as Public.Procedures.StDistance_8dcd.Parameters,request.options),
"Public.Procedures.StDistance_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistance_2ec2.call(request.parameters as Public.Procedures.StDistance_2ec2.Parameters,request.options),
"Public.Procedures.StAreaEcae.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAreaEcae.call(request.parameters as Public.Procedures.StAreaEcae.Parameters,request.options),
"Public.Procedures.StAreaE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAreaE728.call(request.parameters as Public.Procedures.StAreaE728.Parameters,request.options),
"Public.Procedures.StLengthEcae.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLengthEcae.call(request.parameters as Public.Procedures.StLengthEcae.Parameters,request.options),
"Public.Procedures.StLengthE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLengthE728.call(request.parameters as Public.Procedures.StLengthE728.Parameters,request.options),
"Public.Procedures.StProjectEd46.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StProjectEd46.call(request.parameters as Public.Procedures.StProjectEd46.Parameters,request.options),
"Public.Procedures.StPerimeterEcae.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPerimeterEcae.call(request.parameters as Public.Procedures.StPerimeterEcae.Parameters,request.options),
"Public.Procedures.StSegmentizeCadf.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSegmentizeCadf.call(request.parameters as Public.Procedures.StSegmentizeCadf.Parameters,request.options),
"Public.Procedures.StAsbinary_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsbinary_7902.call(request.parameters as Public.Procedures.StAsbinary_7902.Parameters,request.options),
"Public.Procedures.StAsbinary_734d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsbinary_734d.call(request.parameters as Public.Procedures.StAsbinary_734d.Parameters,request.options),
"Public.Procedures.StAsewkt_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkt_7902.call(request.parameters as Public.Procedures.StAsewkt_7902.Parameters,request.options),
"Public.Procedures.StAsewkt_3181.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewkt_3181.call(request.parameters as Public.Procedures.StAsewkt_3181.Parameters,request.options),
"Public.Procedures.StAsewktE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsewktE728.call(request.parameters as Public.Procedures.StAsewktE728.Parameters,request.options),
"Public.Procedures.Geometrytype_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geometrytype_7902.call(request.parameters as Public.Procedures.Geometrytype_7902.Parameters,request.options),
"Public.Procedures.StSummary_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSummary_7902.call(request.parameters as Public.Procedures.StSummary_7902.Parameters,request.options),
"Public.Procedures.StGeohash_3181.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StGeohash_3181.call(request.parameters as Public.Procedures.StGeohash_3181.Parameters,request.options),
"Public.Procedures.StSrid_7902.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSrid_7902.call(request.parameters as Public.Procedures.StSrid_7902.Parameters,request.options),
"Public.Procedures.StSetsrid_3181.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSetsrid_3181.call(request.parameters as Public.Procedures.StSetsrid_3181.Parameters,request.options),
"Public.Procedures.StCentroidEcae.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCentroidEcae.call(request.parameters as Public.Procedures.StCentroidEcae.Parameters,request.options),
"Public.Procedures.StCentroidE728.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCentroidE728.call(request.parameters as Public.Procedures.StCentroidE728.Parameters,request.options),
"Public.Procedures.StCoversE452.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoversE452.call(request.parameters as Public.Procedures.StCoversE452.Parameters,request.options),
"Public.Procedures.StDwithin_55df.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDwithin_55df.call(request.parameters as Public.Procedures.StDwithin_55df.Parameters,request.options),
"Public.Procedures.StCoveredbyE452.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoveredbyE452.call(request.parameters as Public.Procedures.StCoveredbyE452.Parameters,request.options),
"Public.Procedures.StIntersectsE452.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersectsE452.call(request.parameters as Public.Procedures.StIntersectsE452.Parameters,request.options),
"Public.Procedures.StBufferCadf.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBufferCadf.call(request.parameters as Public.Procedures.StBufferCadf.Parameters,request.options),
"Public.Procedures.StBuffer_12e3.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBuffer_12e3.call(request.parameters as Public.Procedures.StBuffer_12e3.Parameters,request.options),
"Public.Procedures.StBuffer_3aaa.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBuffer_3aaa.call(request.parameters as Public.Procedures.StBuffer_3aaa.Parameters,request.options),
"Public.Procedures.StBufferC349.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBufferC349.call(request.parameters as Public.Procedures.StBufferC349.Parameters,request.options),
"Public.Procedures.StBufferF7c6.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StBufferF7c6.call(request.parameters as Public.Procedures.StBufferF7c6.Parameters,request.options),
"Public.Procedures.StIntersectionE452.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersectionE452.call(request.parameters as Public.Procedures.StIntersectionE452.Parameters,request.options),
"Public.Procedures.StIntersection_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersection_2ec2.call(request.parameters as Public.Procedures.StIntersection_2ec2.Parameters,request.options),
"Public.Procedures.StCovers_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCovers_2ec2.call(request.parameters as Public.Procedures.StCovers_2ec2.Parameters,request.options),
"Public.Procedures.StCoveredby_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoveredby_2ec2.call(request.parameters as Public.Procedures.StCoveredby_2ec2.Parameters,request.options),
"Public.Procedures.StDwithinEfc0.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDwithinEfc0.call(request.parameters as Public.Procedures.StDwithinEfc0.Parameters,request.options),
"Public.Procedures.StIntersects_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StIntersects_2ec2.call(request.parameters as Public.Procedures.StIntersects_2ec2.Parameters,request.options),
"Public.Procedures.StClosestpoint_8dcd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClosestpoint_8dcd.call(request.parameters as Public.Procedures.StClosestpoint_8dcd.Parameters,request.options),
"Public.Procedures.StClosestpoint_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StClosestpoint_2ec2.call(request.parameters as Public.Procedures.StClosestpoint_2ec2.Parameters,request.options),
"Public.Procedures.StShortestline_8dcd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StShortestline_8dcd.call(request.parameters as Public.Procedures.StShortestline_8dcd.Parameters,request.options),
"Public.Procedures.StShortestline_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StShortestline_2ec2.call(request.parameters as Public.Procedures.StShortestline_2ec2.Parameters,request.options),
"Public.Procedures.StLinesubstringEd46.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinesubstringEd46.call(request.parameters as Public.Procedures.StLinesubstringEd46.Parameters,request.options),
"Public.Procedures.StLinesubstringE586.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinesubstringE586.call(request.parameters as Public.Procedures.StLinesubstringE586.Parameters,request.options),
"Public.Procedures.StLinelocatepoint_8dcd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinelocatepoint_8dcd.call(request.parameters as Public.Procedures.StLinelocatepoint_8dcd.Parameters,request.options),
"Public.Procedures.StLinelocatepoint_2ec2.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinelocatepoint_2ec2.call(request.parameters as Public.Procedures.StLinelocatepoint_2ec2.Parameters,request.options),
"Public.Procedures.StLineinterpolatepoints_8796.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepoints_8796.call(request.parameters as Public.Procedures.StLineinterpolatepoints_8796.Parameters,request.options),
"Public.Procedures.StLineinterpolatepointsC349.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepointsC349.call(request.parameters as Public.Procedures.StLineinterpolatepointsC349.Parameters,request.options),
"Public.Procedures.StLineinterpolatepoint_612b.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepoint_612b.call(request.parameters as Public.Procedures.StLineinterpolatepoint_612b.Parameters,request.options),
"Public.Procedures.StLineinterpolatepointC349.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLineinterpolatepointC349.call(request.parameters as Public.Procedures.StLineinterpolatepointC349.Parameters,request.options),
"Public.Procedures.StDistancesphere_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistancesphere_3651.call(request.parameters as Public.Procedures.StDistancesphere_3651.Parameters,request.options),
"Public.Procedures.StDistancesphere_6961.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StDistancesphere_6961.call(request.parameters as Public.Procedures.StDistancesphere_6961.Parameters,request.options),
"Public.Procedures.PostgisTypeName.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisTypeName.call(request.parameters as Public.Procedures.PostgisTypeName.Parameters,request.options),
"Public.Procedures.PostgisConstraintSrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisConstraintSrid.call(request.parameters as Public.Procedures.PostgisConstraintSrid.Parameters,request.options),
"Public.Procedures.PostgisConstraintDims.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisConstraintDims.call(request.parameters as Public.Procedures.PostgisConstraintDims.Parameters,request.options),
"Public.Procedures.PostgisConstraintType.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.PostgisConstraintType.call(request.parameters as Public.Procedures.PostgisConstraintType.Parameters,request.options),
"Public.Procedures.St_3ddistance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3ddistance.call(request.parameters as Public.Procedures.St_3ddistance.Parameters,request.options),
"Public.Procedures.St_3dmaxdistance.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dmaxdistance.call(request.parameters as Public.Procedures.St_3dmaxdistance.Parameters,request.options),
"Public.Procedures.St_3dclosestpoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dclosestpoint.call(request.parameters as Public.Procedures.St_3dclosestpoint.Parameters,request.options),
"Public.Procedures.St_3dshortestline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dshortestline.call(request.parameters as Public.Procedures.St_3dshortestline.Parameters,request.options),
"Public.Procedures.St_3dlongestline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dlongestline.call(request.parameters as Public.Procedures.St_3dlongestline.Parameters,request.options),
"Public.Procedures.StCoorddim.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCoorddim.call(request.parameters as Public.Procedures.StCoorddim.Parameters,request.options),
"Public.Procedures.StCurvetoline.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StCurvetoline.call(request.parameters as Public.Procedures.StCurvetoline.Parameters,request.options),
"Public.Procedures.StHasarc.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StHasarc.call(request.parameters as Public.Procedures.StHasarc.Parameters,request.options),
"Public.Procedures.StLinetocurve.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLinetocurve.call(request.parameters as Public.Procedures.StLinetocurve.Parameters,request.options),
"Public.Procedures.StPoint_0aec.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPoint_0aec.call(request.parameters as Public.Procedures.StPoint_0aec.Parameters,request.options),
"Public.Procedures.StPoint_0b7f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPoint_0b7f.call(request.parameters as Public.Procedures.StPoint_0b7f.Parameters,request.options),
"Public.Procedures.StPointz.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointz.call(request.parameters as Public.Procedures.StPointz.Parameters,request.options),
"Public.Procedures.StPointm.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointm.call(request.parameters as Public.Procedures.StPointm.Parameters,request.options),
"Public.Procedures.StPointzm.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPointzm.call(request.parameters as Public.Procedures.StPointzm.Parameters,request.options),
"Public.Procedures.StPolygon.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StPolygon.call(request.parameters as Public.Procedures.StPolygon.Parameters,request.options),
"Public.Procedures.StWkbtosql.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StWkbtosql.call(request.parameters as Public.Procedures.StWkbtosql.Parameters,request.options),
"Public.Procedures.StLocatebetween.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLocatebetween.call(request.parameters as Public.Procedures.StLocatebetween.Parameters,request.options),
"Public.Procedures.StLocatealong.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLocatealong.call(request.parameters as Public.Procedures.StLocatealong.Parameters,request.options),
"Public.Procedures.StLocatebetweenelevations.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLocatebetweenelevations.call(request.parameters as Public.Procedures.StLocatebetweenelevations.Parameters,request.options),
"Public.Procedures.StInterpolatepoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StInterpolatepoint.call(request.parameters as Public.Procedures.StInterpolatepoint.Parameters,request.options),
"Public.Procedures.StHexagon.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StHexagon.call(request.parameters as Public.Procedures.StHexagon.Parameters,request.options),
"Public.Procedures.StSquare.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSquare.call(request.parameters as Public.Procedures.StSquare.Parameters,request.options),
"Public.Procedures.StHexagongrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StHexagongrid.call(request.parameters as Public.Procedures.StHexagongrid.Parameters,request.options),
"Public.Procedures.StSquaregrid.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSquaregrid.call(request.parameters as Public.Procedures.StSquaregrid.Parameters,request.options),
"Public.Procedures.Contains_2d_3f2a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Contains_2d_3f2a.call(request.parameters as Public.Procedures.Contains_2d_3f2a.Parameters,request.options),
"Public.Procedures.IsContained_2d_3f2a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.IsContained_2d_3f2a.call(request.parameters as Public.Procedures.IsContained_2d_3f2a.Parameters,request.options),
"Public.Procedures.Overlaps_2d_3f2a.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Overlaps_2d_3f2a.call(request.parameters as Public.Procedures.Overlaps_2d_3f2a.Parameters,request.options),
"Public.Procedures.Overlaps_2d_4f71.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Overlaps_2d_4f71.call(request.parameters as Public.Procedures.Overlaps_2d_4f71.Parameters,request.options),
"Public.Procedures.Contains_2d_4f71.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Contains_2d_4f71.call(request.parameters as Public.Procedures.Contains_2d_4f71.Parameters,request.options),
"Public.Procedures.IsContained_2d_4f71.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.IsContained_2d_4f71.call(request.parameters as Public.Procedures.IsContained_2d_4f71.Parameters,request.options),
"Public.Procedures.Contains_2d_7d4f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Contains_2d_7d4f.call(request.parameters as Public.Procedures.Contains_2d_7d4f.Parameters,request.options),
"Public.Procedures.IsContained_2d_7d4f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.IsContained_2d_7d4f.call(request.parameters as Public.Procedures.IsContained_2d_7d4f.Parameters,request.options),
"Public.Procedures.Overlaps_2d_7d4f.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Overlaps_2d_7d4f.call(request.parameters as Public.Procedures.Overlaps_2d_7d4f.Parameters,request.options),
"Public.Procedures.OverlapsNd_6173.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsNd_6173.call(request.parameters as Public.Procedures.OverlapsNd_6173.Parameters,request.options),
"Public.Procedures.OverlapsNd_25ba.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsNd_25ba.call(request.parameters as Public.Procedures.OverlapsNd_25ba.Parameters,request.options),
"Public.Procedures.OverlapsNd_40b7.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.OverlapsNd_40b7.call(request.parameters as Public.Procedures.OverlapsNd_40b7.Parameters,request.options),
"Public.Procedures.Geom2dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geom2dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom2dBrinInclusionAddValue.Parameters,request.options),
"Public.Procedures.Geom3dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geom3dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom3dBrinInclusionAddValue.Parameters,request.options),
"Public.Procedures.Geom4dBrinInclusionAddValue.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.Geom4dBrinInclusionAddValue.call(request.parameters as Public.Procedures.Geom4dBrinInclusionAddValue.Parameters,request.options),
"Public.Procedures.StSimplifypolygonhull.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StSimplifypolygonhull.call(request.parameters as Public.Procedures.StSimplifypolygonhull.Parameters,request.options),
"Public.Procedures.StConcavehull.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StConcavehull.call(request.parameters as Public.Procedures.StConcavehull.Parameters,request.options),
"Public.Procedures.StAsx3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAsx3d.call(request.parameters as Public.Procedures.StAsx3d.Parameters,request.options),
"Public.Procedures.StAngle_3651.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StAngle_3651.call(request.parameters as Public.Procedures.StAngle_3651.Parameters,request.options),
"Public.Procedures.St_3dlineinterpolatepoint.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.St_3dlineinterpolatepoint.call(request.parameters as Public.Procedures.St_3dlineinterpolatepoint.Parameters,request.options),
"Public.Procedures.GeometrySpgistConfig_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistConfig_2d.call(request.parameters as Public.Procedures.GeometrySpgistConfig_2d.Parameters,request.options),
"Public.Procedures.GeometrySpgistChoose_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistChoose_2d.call(request.parameters as Public.Procedures.GeometrySpgistChoose_2d.Parameters,request.options),
"Public.Procedures.GeometrySpgistPicksplit_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistPicksplit_2d.call(request.parameters as Public.Procedures.GeometrySpgistPicksplit_2d.Parameters,request.options),
"Public.Procedures.GeometrySpgistInnerConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistInnerConsistent_2d.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters,request.options),
"Public.Procedures.GeometrySpgistLeafConsistent_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistLeafConsistent_2d.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters,request.options),
"Public.Procedures.GeometrySpgistCompress_2d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistCompress_2d.call(request.parameters as Public.Procedures.GeometrySpgistCompress_2d.Parameters,request.options),
"Public.Procedures.GeometryOverlaps_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryOverlaps_3d.call(request.parameters as Public.Procedures.GeometryOverlaps_3d.Parameters,request.options),
"Public.Procedures.GeometryContains_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryContains_3d.call(request.parameters as Public.Procedures.GeometryContains_3d.Parameters,request.options),
"Public.Procedures.GeometryContained_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometryContained_3d.call(request.parameters as Public.Procedures.GeometryContained_3d.Parameters,request.options),
"Public.Procedures.GeometrySame_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySame_3d.call(request.parameters as Public.Procedures.GeometrySame_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistConfig_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistConfig_3d.call(request.parameters as Public.Procedures.GeometrySpgistConfig_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistChoose_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistChoose_3d.call(request.parameters as Public.Procedures.GeometrySpgistChoose_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistPicksplit_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistPicksplit_3d.call(request.parameters as Public.Procedures.GeometrySpgistPicksplit_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistInnerConsistent_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistInnerConsistent_3d.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistLeafConsistent_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistLeafConsistent_3d.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistCompress_3d.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistCompress_3d.call(request.parameters as Public.Procedures.GeometrySpgistCompress_3d.Parameters,request.options),
"Public.Procedures.GeometrySpgistConfigNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistConfigNd.call(request.parameters as Public.Procedures.GeometrySpgistConfigNd.Parameters,request.options),
"Public.Procedures.GeometrySpgistChooseNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistChooseNd.call(request.parameters as Public.Procedures.GeometrySpgistChooseNd.Parameters,request.options),
"Public.Procedures.GeometrySpgistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistPicksplitNd.call(request.parameters as Public.Procedures.GeometrySpgistPicksplitNd.Parameters,request.options),
"Public.Procedures.GeometrySpgistInnerConsistentNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistInnerConsistentNd.call(request.parameters as Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters,request.options),
"Public.Procedures.GeometrySpgistLeafConsistentNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistLeafConsistentNd.call(request.parameters as Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters,request.options),
"Public.Procedures.GeometrySpgistCompressNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeometrySpgistCompressNd.call(request.parameters as Public.Procedures.GeometrySpgistCompressNd.Parameters,request.options),
"Public.Procedures.GeographySpgistConfigNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistConfigNd.call(request.parameters as Public.Procedures.GeographySpgistConfigNd.Parameters,request.options),
"Public.Procedures.GeographySpgistChooseNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistChooseNd.call(request.parameters as Public.Procedures.GeographySpgistChooseNd.Parameters,request.options),
"Public.Procedures.GeographySpgistPicksplitNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistPicksplitNd.call(request.parameters as Public.Procedures.GeographySpgistPicksplitNd.Parameters,request.options),
"Public.Procedures.GeographySpgistInnerConsistentNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistInnerConsistentNd.call(request.parameters as Public.Procedures.GeographySpgistInnerConsistentNd.Parameters,request.options),
"Public.Procedures.GeographySpgistLeafConsistentNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistLeafConsistentNd.call(request.parameters as Public.Procedures.GeographySpgistLeafConsistentNd.Parameters,request.options),
"Public.Procedures.GeographySpgistCompressNd.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.GeographySpgistCompressNd.call(request.parameters as Public.Procedures.GeographySpgistCompressNd.Parameters,request.options),
"Public.Procedures.StLetters.call": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Procedures.StLetters.call(request.parameters as Public.Procedures.StLetters.Parameters,request.options),
"Public.Tables.SpatialRefSys.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.SpatialRefSys.create(request.values as Public.Tables.SpatialRefSys.Values,request.options),

             "Public.Tables.SpatialRefSys.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.SpatialRefSys.all(request.options),
            
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.read(request.parameters as Public.Types.SpatialRefSysPkey,request.options),
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.update(request.parameters as Public.Types.SpatialRefSysPkey,request.values as Partial<Public.Tables.SpatialRefSys.Values>,request.options),
"Public.Tables.SpatialRefSys.SpatialRefSysPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.SpatialRefSys.SpatialRefSysPkey.delete(request.parameters as Public.Types.SpatialRefSysPkey,request.options),
"Public.Tables.NycCensusBlocks.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.create(request.values as Public.Tables.NycCensusBlocks.Values,request.options),

             "Public.Tables.NycCensusBlocks.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.NycCensusBlocks.all(request.options),
            
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.read(request.parameters as Public.Types.NycCensusBlocksPkey,request.options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.update(request.parameters as Public.Types.NycCensusBlocksPkey,request.values as Partial<Public.Tables.NycCensusBlocks.Values>,request.options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksPkey.delete(request.parameters as Public.Types.NycCensusBlocksPkey,request.options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.read(request.parameters as Public.Types.NycCensusBlocksGeomIdx,request.options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.update(request.parameters as Public.Types.NycCensusBlocksGeomIdx,request.values as Partial<Public.Tables.NycCensusBlocks.Values>,request.options),
"Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycCensusBlocks.NycCensusBlocksGeomIdx.delete(request.parameters as Public.Types.NycCensusBlocksGeomIdx,request.options),
"Public.Tables.NycHomicides.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.create(request.values as Public.Tables.NycHomicides.Values,request.options),

             "Public.Tables.NycHomicides.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.NycHomicides.all(request.options),
            
"Public.Tables.NycHomicides.NycHomicidesPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.read(request.parameters as Public.Types.NycHomicidesPkey,request.options),
"Public.Tables.NycHomicides.NycHomicidesPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.update(request.parameters as Public.Types.NycHomicidesPkey,request.values as Partial<Public.Tables.NycHomicides.Values>,request.options),
"Public.Tables.NycHomicides.NycHomicidesPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesPkey.delete(request.parameters as Public.Types.NycHomicidesPkey,request.options),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.read(request.parameters as Public.Types.NycHomicidesGeomIdx,request.options),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.update(request.parameters as Public.Types.NycHomicidesGeomIdx,request.values as Partial<Public.Tables.NycHomicides.Values>,request.options),
"Public.Tables.NycHomicides.NycHomicidesGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycHomicides.NycHomicidesGeomIdx.delete(request.parameters as Public.Types.NycHomicidesGeomIdx,request.options),
"Public.Tables.NycNeighborhoods.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.create(request.values as Public.Tables.NycNeighborhoods.Values,request.options),

             "Public.Tables.NycNeighborhoods.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.NycNeighborhoods.all(request.options),
            
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.read(request.parameters as Public.Types.NycNeighborhoodsPkey,request.options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.update(request.parameters as Public.Types.NycNeighborhoodsPkey,request.values as Partial<Public.Tables.NycNeighborhoods.Values>,request.options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsPkey.delete(request.parameters as Public.Types.NycNeighborhoodsPkey,request.options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.read(request.parameters as Public.Types.NycNeighborhoodsGeomIdx,request.options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.update(request.parameters as Public.Types.NycNeighborhoodsGeomIdx,request.values as Partial<Public.Tables.NycNeighborhoods.Values>,request.options),
"Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycNeighborhoods.NycNeighborhoodsGeomIdx.delete(request.parameters as Public.Types.NycNeighborhoodsGeomIdx,request.options),
"Public.Tables.NycStreets.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.create(request.values as Public.Tables.NycStreets.Values,request.options),

             "Public.Tables.NycStreets.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.NycStreets.all(request.options),
            
"Public.Tables.NycStreets.NycStreetsPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsPkey.read(request.parameters as Public.Types.NycStreetsPkey,request.options),
"Public.Tables.NycStreets.NycStreetsPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsPkey.update(request.parameters as Public.Types.NycStreetsPkey,request.values as Partial<Public.Tables.NycStreets.Values>,request.options),
"Public.Tables.NycStreets.NycStreetsPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsPkey.delete(request.parameters as Public.Types.NycStreetsPkey,request.options),
"Public.Tables.NycStreets.NycStreetsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.read(request.parameters as Public.Types.NycStreetsGeomIdx,request.options),
"Public.Tables.NycStreets.NycStreetsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.update(request.parameters as Public.Types.NycStreetsGeomIdx,request.values as Partial<Public.Tables.NycStreets.Values>,request.options),
"Public.Tables.NycStreets.NycStreetsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycStreets.NycStreetsGeomIdx.delete(request.parameters as Public.Types.NycStreetsGeomIdx,request.options),
"Public.Tables.NycSubwayStations.create": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.create(request.values as Public.Tables.NycSubwayStations.Values,request.options),

             "Public.Tables.NycSubwayStations.all": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) =>
              database.Public.Tables.NycSubwayStations.all(request.options),
            
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.read(request.parameters as Public.Types.NycSubwayStationsPkey,request.options),
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.update(request.parameters as Public.Types.NycSubwayStationsPkey,request.values as Partial<Public.Tables.NycSubwayStations.Values>,request.options),
"Public.Tables.NycSubwayStations.NycSubwayStationsPkey.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsPkey.delete(request.parameters as Public.Types.NycSubwayStationsPkey,request.options),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.read": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.read(request.parameters as Public.Types.NycSubwayStationsGeomIdx,request.options),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.update": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.update(request.parameters as Public.Types.NycSubwayStationsGeomIdx,request.values as Partial<Public.Tables.NycSubwayStations.Values>,request.options),
"Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.delete": async (request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) => database.Public.Tables.NycSubwayStations.NycSubwayStationsGeomIdx.delete(request.parameters as Public.Types.NycSubwayStationsGeomIdx,request.options),
}
}

            async dispatch(request: EmbraceSQLRequest<object, object, EmbraceSQLOptions>) {
              if (!this.dispatchMap[request.operation]) {
                throw new Error(`${request.operation} not available`);
              }
              return this.dispatchMap[request.operation](request);
            }
            
}

export type DatabaseRole = "postgres" | "pg_database_owner" | "pg_read_all_data" | "pg_write_all_data" | "pg_monitor" | "pg_read_all_settings" | "pg_read_all_stats" | "pg_stat_scan_tables" | "pg_read_server_files" | "pg_write_server_files" | "pg_execute_server_program" | "pg_signal_backend" | "pg_checkpoint" | "pg_use_reserved_connections" | "pg_create_subscription" | "wballard" | "no_access";
export type DatabaseHeaders = {
 ROLE?: DatabaseRole;
}
export type InvokeQueryOptions = GenericInvokeQueryOptions<DatabaseHeaders>;
export namespace PgCatalog {
export namespace Types {

export type Bool = boolean;

export type Bytea = Uint8Array;

export type Char = string;

export type Name = string;

export type Int8 = number;

export type Int2 = number;

export type Int2vector = Uint16Array;

export type Int4 = number;

export type Regproc = number;

export type Text = string;

export type Oid = number;

export type Tid = 
    {
      blockNumber: number;
      tupleIndex: number;
    }
    ;

export type Xid = number;

export type Cid = number;

export type Oidvector = 
     Array<PgCatalog.Types.Oid>
    ;

export type PgType = {
oid: PgCatalog.Types.Oid;
typname: PgCatalog.Types.Name;
typnamespace: PgCatalog.Types.Oid;
typowner: PgCatalog.Types.Oid;
typlen: PgCatalog.Types.Int2;
typbyval: PgCatalog.Types.Bool;
typtype: PgCatalog.Types.Char;
typcategory: PgCatalog.Types.Char;
typispreferred: PgCatalog.Types.Bool;
typisdefined: PgCatalog.Types.Bool;
typdelim: PgCatalog.Types.Char;
typrelid: PgCatalog.Types.Oid;
typsubscript: PgCatalog.Types.Regproc;
typelem: PgCatalog.Types.Oid;
typarray: PgCatalog.Types.Oid;
typinput: PgCatalog.Types.Regproc;
typoutput: PgCatalog.Types.Regproc;
typreceive: PgCatalog.Types.Regproc;
typsend: PgCatalog.Types.Regproc;
typmodin: PgCatalog.Types.Regproc;
typmodout: PgCatalog.Types.Regproc;
typanalyze: PgCatalog.Types.Regproc;
typalign: PgCatalog.Types.Char;
typstorage: PgCatalog.Types.Char;
typnotnull: PgCatalog.Types.Bool;
typbasetype: PgCatalog.Types.Oid;
typtypmod: PgCatalog.Types.Int4;
typndims: PgCatalog.Types.Int4;
typcollation: PgCatalog.Types.Oid;
typdefaultbin: Nullable<PgCatalog.Types.PgNodeTree>;
typdefault: Nullable<PgCatalog.Types.Text>;
typacl: PgCatalog.Types.AclitemArray;
}

export type PgAttribute = {
attrelid: PgCatalog.Types.Oid;
attname: PgCatalog.Types.Name;
atttypid: PgCatalog.Types.Oid;
attlen: PgCatalog.Types.Int2;
attnum: PgCatalog.Types.Int2;
attcacheoff: PgCatalog.Types.Int4;
atttypmod: PgCatalog.Types.Int4;
attndims: PgCatalog.Types.Int2;
attbyval: PgCatalog.Types.Bool;
attalign: PgCatalog.Types.Char;
attstorage: PgCatalog.Types.Char;
attcompression: PgCatalog.Types.Char;
attnotnull: PgCatalog.Types.Bool;
atthasdef: PgCatalog.Types.Bool;
atthasmissing: PgCatalog.Types.Bool;
attidentity: PgCatalog.Types.Char;
attgenerated: PgCatalog.Types.Char;
attisdropped: PgCatalog.Types.Bool;
attislocal: PgCatalog.Types.Bool;
attinhcount: PgCatalog.Types.Int2;
attstattarget: PgCatalog.Types.Int2;
attcollation: PgCatalog.Types.Oid;
attacl: PgCatalog.Types.AclitemArray;
attoptions: PgCatalog.Types.TextArray;
attfdwoptions: PgCatalog.Types.TextArray;
attmissingval: Nullable<PgCatalog.Types.Anyarray>;
}

export type PgProc = {
oid: PgCatalog.Types.Oid;
proname: PgCatalog.Types.Name;
pronamespace: PgCatalog.Types.Oid;
proowner: PgCatalog.Types.Oid;
prolang: PgCatalog.Types.Oid;
procost: PgCatalog.Types.Float4;
prorows: PgCatalog.Types.Float4;
provariadic: PgCatalog.Types.Oid;
prosupport: PgCatalog.Types.Regproc;
prokind: PgCatalog.Types.Char;
prosecdef: PgCatalog.Types.Bool;
proleakproof: PgCatalog.Types.Bool;
proisstrict: PgCatalog.Types.Bool;
proretset: PgCatalog.Types.Bool;
provolatile: PgCatalog.Types.Char;
proparallel: PgCatalog.Types.Char;
pronargs: PgCatalog.Types.Int2;
pronargdefaults: PgCatalog.Types.Int2;
prorettype: PgCatalog.Types.Oid;
proargtypes: PgCatalog.Types.Oidvector;
proallargtypes: PgCatalog.Types.OidArray;
proargmodes: PgCatalog.Types.CharArray;
proargnames: PgCatalog.Types.TextArray;
proargdefaults: Nullable<PgCatalog.Types.PgNodeTree>;
protrftypes: PgCatalog.Types.OidArray;
prosrc: PgCatalog.Types.Text;
probin: Nullable<PgCatalog.Types.Text>;
prosqlbody: Nullable<PgCatalog.Types.PgNodeTree>;
proconfig: PgCatalog.Types.TextArray;
proacl: PgCatalog.Types.AclitemArray;
}

export type PgClass = {
oid: PgCatalog.Types.Oid;
relname: PgCatalog.Types.Name;
relnamespace: PgCatalog.Types.Oid;
reltype: PgCatalog.Types.Oid;
reloftype: PgCatalog.Types.Oid;
relowner: PgCatalog.Types.Oid;
relam: PgCatalog.Types.Oid;
relfilenode: PgCatalog.Types.Oid;
reltablespace: PgCatalog.Types.Oid;
relpages: PgCatalog.Types.Int4;
reltuples: PgCatalog.Types.Float4;
relallvisible: PgCatalog.Types.Int4;
reltoastrelid: PgCatalog.Types.Oid;
relhasindex: PgCatalog.Types.Bool;
relisshared: PgCatalog.Types.Bool;
relpersistence: PgCatalog.Types.Char;
relkind: PgCatalog.Types.Char;
relnatts: PgCatalog.Types.Int2;
relchecks: PgCatalog.Types.Int2;
relhasrules: PgCatalog.Types.Bool;
relhastriggers: PgCatalog.Types.Bool;
relhassubclass: PgCatalog.Types.Bool;
relrowsecurity: PgCatalog.Types.Bool;
relforcerowsecurity: PgCatalog.Types.Bool;
relispopulated: PgCatalog.Types.Bool;
relreplident: PgCatalog.Types.Char;
relispartition: PgCatalog.Types.Bool;
relrewrite: PgCatalog.Types.Oid;
relfrozenxid: PgCatalog.Types.Xid;
relminmxid: PgCatalog.Types.Xid;
relacl: PgCatalog.Types.AclitemArray;
reloptions: PgCatalog.Types.TextArray;
relpartbound: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type Json = JSONObject;

export type Xml = string;

export type PgNodeTree = never;

export type PgNdistinct = never;

export type PgDependencies = never;

export type PgMcvList = never;

export type PgDdlCommand = unknown;

export type Xid8 = number;

export type Point = Geometry.Point;

export type Lseg = Geometry.LineSegment;

export type Path = Geometry.Path;

export type Box = Geometry.Box;

export type Polygon = Geometry.Polygon;

export type Line = Geometry.Line;

export type Float4 = number;

export type Float8 = number;

export type Unknown = unknown;

export type Circle = Geometry.Circle;

export type Money = number;

export type Macaddr = Uint8Array;

export type Inet = string;

export type Cidr = Uint8Array;

export type Macaddr8 = Uint8Array;

export type Aclitem = string;

export type Bpchar = string;

export type Varchar = string;

export type Date = JsDate;

export type Time = string;

export type Timestamp = JsDate;

export type Timestamptz = JsDate;

export type Interval = number;

export type Timetz = string;

export type Bit = boolean;

export type Varbit = boolean;

export type Numeric = number;

export type Refcursor = string;

export type Regprocedure = number;

export type Regoper = number;

export type Regoperator = number;

export type Regclass = number;

export type Regcollation = number;

export type Regtype = number;

export type Regrole = number;

export type Regnamespace = number;

export type Uuid = UUID;

export type PgLsn = bigint;

export type Tsvector = string;

export type Gtsvector = Array<string>;

export type Tsquery = string;

export type Regconfig = number;

export type Regdictionary = number;

export type Jsonb = JSONObject;

export type Jsonpath = string;

export type TxidSnapshot = never;

export type PgSnapshot = never;

export type Int4range = [PgCatalog.Types.Int4, PgCatalog.Types.Int4];

export type Numrange = [PgCatalog.Types.Numeric, PgCatalog.Types.Numeric];

export type Tsrange = [PgCatalog.Types.Timestamp, PgCatalog.Types.Timestamp];

export type Tstzrange = [PgCatalog.Types.Timestamptz, PgCatalog.Types.Timestamptz];

export type Daterange = [PgCatalog.Types.Date, PgCatalog.Types.Date];

export type Int8range = [PgCatalog.Types.Int8, PgCatalog.Types.Int8];

export type Int4multirange = unknown;

export type Nummultirange = unknown;

export type Tsmultirange = unknown;

export type Tstzmultirange = unknown;

export type Datemultirange = unknown;

export type Int8multirange = unknown;

export type Record = unknown;

export type RecordArray = 
     Array<PgCatalog.Types.Record>
    ;

export type Cstring = unknown;

export type Any = unknown;

export type Anyarray = unknown;

export type Void = unknown;

export type Trigger = unknown;

export type EventTrigger = unknown;

export type LanguageHandler = unknown;

export type Internal = unknown;

export type Anyelement = any;

export type Anynonarray = unknown;

export type Anyenum = unknown;

export type FdwHandler = unknown;

export type IndexAmHandler = unknown;

export type TsmHandler = unknown;

export type TableAmHandler = unknown;

export type Anyrange = unknown;

export type Anycompatible = unknown;

export type Anycompatiblearray = unknown;

export type Anycompatiblenonarray = unknown;

export type Anycompatiblerange = unknown;

export type Anymultirange = unknown;

export type Anycompatiblemultirange = unknown;

export type PgBrinBloomSummary = never;

export type PgBrinMinmaxMultiSummary = never;

export type BoolArray = 
     Array<PgCatalog.Types.Bool>
    ;

export type ByteaArray = 
     Array<PgCatalog.Types.Bytea>
    ;

export type CharArray = 
     Array<PgCatalog.Types.Char>
    ;

export type NameArray = 
     Array<PgCatalog.Types.Name>
    ;

export type Int8Array = 
     Array<PgCatalog.Types.Int8>
    ;

export type Int2Array = 
     Array<PgCatalog.Types.Int2>
    ;

export type Int2vectorArray = 
     Array<PgCatalog.Types.Int2vector>
    ;

export type Int4Array = 
     Array<PgCatalog.Types.Int4>
    ;

export type RegprocArray = 
     Array<PgCatalog.Types.Regproc>
    ;

export type TextArray = 
     Array<PgCatalog.Types.Text>
    ;

export type OidArray = 
     Array<PgCatalog.Types.Oid>
    ;

export type TidArray = 
     Array<PgCatalog.Types.Tid>
    ;

export type XidArray = 
     Array<PgCatalog.Types.Xid>
    ;

export type CidArray = 
     Array<PgCatalog.Types.Cid>
    ;

export type OidvectorArray = 
     Array<PgCatalog.Types.Oidvector>
    ;

export type PgTypeArray = 
     Array<PgCatalog.Types.PgType>
    ;

export type PgAttributeArray = 
     Array<PgCatalog.Types.PgAttribute>
    ;

export type PgProcArray = 
     Array<PgCatalog.Types.PgProc>
    ;

export type PgClassArray = 
     Array<PgCatalog.Types.PgClass>
    ;

export type JsonArray = 
     Array<PgCatalog.Types.Json>
    ;

export type XmlArray = 
     Array<PgCatalog.Types.Xml>
    ;

export type Xid8Array = 
     Array<PgCatalog.Types.Xid8>
    ;

export type PointArray = 
     Array<PgCatalog.Types.Point>
    ;

export type LsegArray = 
     Array<PgCatalog.Types.Lseg>
    ;

export type PathArray = 
     Array<PgCatalog.Types.Path>
    ;

export type BoxArray = 
     Array<PgCatalog.Types.Box>
    ;

export type PolygonArray = 
     Array<PgCatalog.Types.Polygon>
    ;

export type LineArray = 
     Array<PgCatalog.Types.Line>
    ;

export type Float4Array = 
     Array<PgCatalog.Types.Float4>
    ;

export type Float8Array = 
     Array<PgCatalog.Types.Float8>
    ;

export type CircleArray = 
     Array<PgCatalog.Types.Circle>
    ;

export type MoneyArray = 
     Array<PgCatalog.Types.Money>
    ;

export type MacaddrArray = 
     Array<PgCatalog.Types.Macaddr>
    ;

export type InetArray = 
     Array<PgCatalog.Types.Inet>
    ;

export type CidrArray = 
     Array<PgCatalog.Types.Cidr>
    ;

export type Macaddr8Array = 
     Array<PgCatalog.Types.Macaddr8>
    ;

export type AclitemArray = 
     Array<PgCatalog.Types.Aclitem>
    ;

export type BpcharArray = 
     Array<PgCatalog.Types.Bpchar>
    ;

export type VarcharArray = 
     Array<PgCatalog.Types.Varchar>
    ;

export type DateArray = 
     Array<PgCatalog.Types.Date>
    ;

export type TimeArray = 
     Array<PgCatalog.Types.Time>
    ;

export type TimestampArray = 
     Array<PgCatalog.Types.Timestamp>
    ;

export type TimestamptzArray = 
     Array<PgCatalog.Types.Timestamptz>
    ;

export type IntervalArray = 
     Array<PgCatalog.Types.Interval>
    ;

export type TimetzArray = 
     Array<PgCatalog.Types.Timetz>
    ;

export type BitArray = 
     Array<PgCatalog.Types.Bit>
    ;

export type VarbitArray = 
     Array<PgCatalog.Types.Varbit>
    ;

export type NumericArray = 
     Array<PgCatalog.Types.Numeric>
    ;

export type RefcursorArray = 
     Array<PgCatalog.Types.Refcursor>
    ;

export type RegprocedureArray = 
     Array<PgCatalog.Types.Regprocedure>
    ;

export type RegoperArray = 
     Array<PgCatalog.Types.Regoper>
    ;

export type RegoperatorArray = 
     Array<PgCatalog.Types.Regoperator>
    ;

export type RegclassArray = 
     Array<PgCatalog.Types.Regclass>
    ;

export type RegcollationArray = 
     Array<PgCatalog.Types.Regcollation>
    ;

export type RegtypeArray = 
     Array<PgCatalog.Types.Regtype>
    ;

export type RegroleArray = 
     Array<PgCatalog.Types.Regrole>
    ;

export type RegnamespaceArray = 
     Array<PgCatalog.Types.Regnamespace>
    ;

export type UuidArray = 
     Array<PgCatalog.Types.Uuid>
    ;

export type PgLsnArray = 
     Array<PgCatalog.Types.PgLsn>
    ;

export type TsvectorArray = 
     Array<PgCatalog.Types.Tsvector>
    ;

export type GtsvectorArray = 
     Array<PgCatalog.Types.Gtsvector>
    ;

export type TsqueryArray = 
     Array<PgCatalog.Types.Tsquery>
    ;

export type RegconfigArray = 
     Array<PgCatalog.Types.Regconfig>
    ;

export type RegdictionaryArray = 
     Array<PgCatalog.Types.Regdictionary>
    ;

export type JsonbArray = 
     Array<PgCatalog.Types.Jsonb>
    ;

export type JsonpathArray = 
     Array<PgCatalog.Types.Jsonpath>
    ;

export type TxidSnapshotArray = 
     Array<PgCatalog.Types.TxidSnapshot>
    ;

export type PgSnapshotArray = 
     Array<PgCatalog.Types.PgSnapshot>
    ;

export type Int4rangeArray = 
     Array<PgCatalog.Types.Int4range>
    ;

export type NumrangeArray = 
     Array<PgCatalog.Types.Numrange>
    ;

export type TsrangeArray = 
     Array<PgCatalog.Types.Tsrange>
    ;

export type TstzrangeArray = 
     Array<PgCatalog.Types.Tstzrange>
    ;

export type DaterangeArray = 
     Array<PgCatalog.Types.Daterange>
    ;

export type Int8rangeArray = 
     Array<PgCatalog.Types.Int8range>
    ;

export type Int4multirangeArray = 
     Array<PgCatalog.Types.Int4multirange>
    ;

export type NummultirangeArray = 
     Array<PgCatalog.Types.Nummultirange>
    ;

export type TsmultirangeArray = 
     Array<PgCatalog.Types.Tsmultirange>
    ;

export type TstzmultirangeArray = 
     Array<PgCatalog.Types.Tstzmultirange>
    ;

export type DatemultirangeArray = 
     Array<PgCatalog.Types.Datemultirange>
    ;

export type Int8multirangeArray = 
     Array<PgCatalog.Types.Int8multirange>
    ;

export type CstringArray = 
     Array<PgCatalog.Types.Cstring>
    ;

export type PgAttrdef = {
oid: PgCatalog.Types.Oid;
adrelid: PgCatalog.Types.Oid;
adnum: PgCatalog.Types.Int2;
adbin: PgCatalog.Types.PgNodeTree;
}

export type PgAttrdefArray = 
     Array<PgCatalog.Types.PgAttrdef>
    ;

export type PgConstraint = {
oid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
contype: PgCatalog.Types.Char;
condeferrable: PgCatalog.Types.Bool;
condeferred: PgCatalog.Types.Bool;
convalidated: PgCatalog.Types.Bool;
conrelid: PgCatalog.Types.Oid;
contypid: PgCatalog.Types.Oid;
conindid: PgCatalog.Types.Oid;
conparentid: PgCatalog.Types.Oid;
confrelid: PgCatalog.Types.Oid;
confupdtype: PgCatalog.Types.Char;
confdeltype: PgCatalog.Types.Char;
confmatchtype: PgCatalog.Types.Char;
conislocal: PgCatalog.Types.Bool;
coninhcount: PgCatalog.Types.Int2;
connoinherit: PgCatalog.Types.Bool;
conkey: PgCatalog.Types.Int2Array;
confkey: PgCatalog.Types.Int2Array;
conpfeqop: PgCatalog.Types.OidArray;
conppeqop: PgCatalog.Types.OidArray;
conffeqop: PgCatalog.Types.OidArray;
confdelsetcols: PgCatalog.Types.Int2Array;
conexclop: PgCatalog.Types.OidArray;
conbin: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgConstraintArray = 
     Array<PgCatalog.Types.PgConstraint>
    ;

export type PgInherits = {
inhrelid: PgCatalog.Types.Oid;
inhparent: PgCatalog.Types.Oid;
inhseqno: PgCatalog.Types.Int4;
inhdetachpending: PgCatalog.Types.Bool;
}

export type PgInheritsArray = 
     Array<PgCatalog.Types.PgInherits>
    ;

export type PgIndex = {
indexrelid: PgCatalog.Types.Oid;
indrelid: PgCatalog.Types.Oid;
indnatts: PgCatalog.Types.Int2;
indnkeyatts: PgCatalog.Types.Int2;
indisunique: PgCatalog.Types.Bool;
indnullsnotdistinct: PgCatalog.Types.Bool;
indisprimary: PgCatalog.Types.Bool;
indisexclusion: PgCatalog.Types.Bool;
indimmediate: PgCatalog.Types.Bool;
indisclustered: PgCatalog.Types.Bool;
indisvalid: PgCatalog.Types.Bool;
indcheckxmin: PgCatalog.Types.Bool;
indisready: PgCatalog.Types.Bool;
indislive: PgCatalog.Types.Bool;
indisreplident: PgCatalog.Types.Bool;
indkey: PgCatalog.Types.Int2vector;
indcollation: PgCatalog.Types.Oidvector;
indclass: PgCatalog.Types.Oidvector;
indoption: PgCatalog.Types.Int2vector;
indexprs: Nullable<PgCatalog.Types.PgNodeTree>;
indpred: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgIndexArray = 
     Array<PgCatalog.Types.PgIndex>
    ;

export type PgOperator = {
oid: PgCatalog.Types.Oid;
oprname: PgCatalog.Types.Name;
oprnamespace: PgCatalog.Types.Oid;
oprowner: PgCatalog.Types.Oid;
oprkind: PgCatalog.Types.Char;
oprcanmerge: PgCatalog.Types.Bool;
oprcanhash: PgCatalog.Types.Bool;
oprleft: PgCatalog.Types.Oid;
oprright: PgCatalog.Types.Oid;
oprresult: PgCatalog.Types.Oid;
oprcom: PgCatalog.Types.Oid;
oprnegate: PgCatalog.Types.Oid;
oprcode: PgCatalog.Types.Regproc;
oprrest: PgCatalog.Types.Regproc;
oprjoin: PgCatalog.Types.Regproc;
}

export type PgOperatorArray = 
     Array<PgCatalog.Types.PgOperator>
    ;

export type PgOpfamily = {
oid: PgCatalog.Types.Oid;
opfmethod: PgCatalog.Types.Oid;
opfname: PgCatalog.Types.Name;
opfnamespace: PgCatalog.Types.Oid;
opfowner: PgCatalog.Types.Oid;
}

export type PgOpfamilyArray = 
     Array<PgCatalog.Types.PgOpfamily>
    ;

export type PgOpclass = {
oid: PgCatalog.Types.Oid;
opcmethod: PgCatalog.Types.Oid;
opcname: PgCatalog.Types.Name;
opcnamespace: PgCatalog.Types.Oid;
opcowner: PgCatalog.Types.Oid;
opcfamily: PgCatalog.Types.Oid;
opcintype: PgCatalog.Types.Oid;
opcdefault: PgCatalog.Types.Bool;
opckeytype: PgCatalog.Types.Oid;
}

export type PgOpclassArray = 
     Array<PgCatalog.Types.PgOpclass>
    ;

export type PgAm = {
oid: PgCatalog.Types.Oid;
amname: PgCatalog.Types.Name;
amhandler: PgCatalog.Types.Regproc;
amtype: PgCatalog.Types.Char;
}

export type PgAmArray = 
     Array<PgCatalog.Types.PgAm>
    ;

export type PgAmop = {
oid: PgCatalog.Types.Oid;
amopfamily: PgCatalog.Types.Oid;
amoplefttype: PgCatalog.Types.Oid;
amoprighttype: PgCatalog.Types.Oid;
amopstrategy: PgCatalog.Types.Int2;
amoppurpose: PgCatalog.Types.Char;
amopopr: PgCatalog.Types.Oid;
amopmethod: PgCatalog.Types.Oid;
amopsortfamily: PgCatalog.Types.Oid;
}

export type PgAmopArray = 
     Array<PgCatalog.Types.PgAmop>
    ;

export type PgAmproc = {
oid: PgCatalog.Types.Oid;
amprocfamily: PgCatalog.Types.Oid;
amproclefttype: PgCatalog.Types.Oid;
amprocrighttype: PgCatalog.Types.Oid;
amprocnum: PgCatalog.Types.Int2;
amproc: PgCatalog.Types.Regproc;
}

export type PgAmprocArray = 
     Array<PgCatalog.Types.PgAmproc>
    ;

export type PgLanguage = {
oid: PgCatalog.Types.Oid;
lanname: PgCatalog.Types.Name;
lanowner: PgCatalog.Types.Oid;
lanispl: PgCatalog.Types.Bool;
lanpltrusted: PgCatalog.Types.Bool;
lanplcallfoid: PgCatalog.Types.Oid;
laninline: PgCatalog.Types.Oid;
lanvalidator: PgCatalog.Types.Oid;
lanacl: PgCatalog.Types.AclitemArray;
}

export type PgLanguageArray = 
     Array<PgCatalog.Types.PgLanguage>
    ;

export type PgLargeobjectMetadata = {
oid: PgCatalog.Types.Oid;
lomowner: PgCatalog.Types.Oid;
lomacl: PgCatalog.Types.AclitemArray;
}

export type PgLargeobjectMetadataArray = 
     Array<PgCatalog.Types.PgLargeobjectMetadata>
    ;

export type PgLargeobject = {
loid: PgCatalog.Types.Oid;
pageno: PgCatalog.Types.Int4;
data: PgCatalog.Types.Bytea;
}

export type PgLargeobjectArray = 
     Array<PgCatalog.Types.PgLargeobject>
    ;

export type PgAggregate = {
aggfnoid: PgCatalog.Types.Regproc;
aggkind: PgCatalog.Types.Char;
aggnumdirectargs: PgCatalog.Types.Int2;
aggtransfn: PgCatalog.Types.Regproc;
aggfinalfn: PgCatalog.Types.Regproc;
aggcombinefn: PgCatalog.Types.Regproc;
aggserialfn: PgCatalog.Types.Regproc;
aggdeserialfn: PgCatalog.Types.Regproc;
aggmtransfn: PgCatalog.Types.Regproc;
aggminvtransfn: PgCatalog.Types.Regproc;
aggmfinalfn: PgCatalog.Types.Regproc;
aggfinalextra: PgCatalog.Types.Bool;
aggmfinalextra: PgCatalog.Types.Bool;
aggfinalmodify: PgCatalog.Types.Char;
aggmfinalmodify: PgCatalog.Types.Char;
aggsortop: PgCatalog.Types.Oid;
aggtranstype: PgCatalog.Types.Oid;
aggtransspace: PgCatalog.Types.Int4;
aggmtranstype: PgCatalog.Types.Oid;
aggmtransspace: PgCatalog.Types.Int4;
agginitval: Nullable<PgCatalog.Types.Text>;
aggminitval: Nullable<PgCatalog.Types.Text>;
}

export type PgAggregateArray = 
     Array<PgCatalog.Types.PgAggregate>
    ;

export type PgStatistic = {
starelid: PgCatalog.Types.Oid;
staattnum: PgCatalog.Types.Int2;
stainherit: PgCatalog.Types.Bool;
stanullfrac: PgCatalog.Types.Float4;
stawidth: PgCatalog.Types.Int4;
stadistinct: PgCatalog.Types.Float4;
stakind1: PgCatalog.Types.Int2;
stakind2: PgCatalog.Types.Int2;
stakind3: PgCatalog.Types.Int2;
stakind4: PgCatalog.Types.Int2;
stakind5: PgCatalog.Types.Int2;
staop1: PgCatalog.Types.Oid;
staop2: PgCatalog.Types.Oid;
staop3: PgCatalog.Types.Oid;
staop4: PgCatalog.Types.Oid;
staop5: PgCatalog.Types.Oid;
stacoll1: PgCatalog.Types.Oid;
stacoll2: PgCatalog.Types.Oid;
stacoll3: PgCatalog.Types.Oid;
stacoll4: PgCatalog.Types.Oid;
stacoll5: PgCatalog.Types.Oid;
stanumbers1: PgCatalog.Types.Float4Array;
stanumbers2: PgCatalog.Types.Float4Array;
stanumbers3: PgCatalog.Types.Float4Array;
stanumbers4: PgCatalog.Types.Float4Array;
stanumbers5: PgCatalog.Types.Float4Array;
stavalues1: Nullable<PgCatalog.Types.Anyarray>;
stavalues2: Nullable<PgCatalog.Types.Anyarray>;
stavalues3: Nullable<PgCatalog.Types.Anyarray>;
stavalues4: Nullable<PgCatalog.Types.Anyarray>;
stavalues5: Nullable<PgCatalog.Types.Anyarray>;
}

export type PgStatisticArray = 
     Array<PgCatalog.Types.PgStatistic>
    ;

export type PgStatisticExt = {
oid: PgCatalog.Types.Oid;
stxrelid: PgCatalog.Types.Oid;
stxname: PgCatalog.Types.Name;
stxnamespace: PgCatalog.Types.Oid;
stxowner: PgCatalog.Types.Oid;
stxstattarget: PgCatalog.Types.Int4;
stxkeys: PgCatalog.Types.Int2vector;
stxkind: PgCatalog.Types.CharArray;
stxexprs: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgStatisticExtArray = 
     Array<PgCatalog.Types.PgStatisticExt>
    ;

export type PgStatisticExtData = {
stxoid: PgCatalog.Types.Oid;
stxdinherit: PgCatalog.Types.Bool;
stxdndistinct: Nullable<PgCatalog.Types.PgNdistinct>;
stxddependencies: Nullable<PgCatalog.Types.PgDependencies>;
stxdmcv: Nullable<PgCatalog.Types.PgMcvList>;
stxdexpr: PgCatalog.Types.PgStatisticArray;
}

export type PgStatisticExtDataArray = 
     Array<PgCatalog.Types.PgStatisticExtData>
    ;

export type PgRewrite = {
oid: PgCatalog.Types.Oid;
rulename: PgCatalog.Types.Name;
evClass: PgCatalog.Types.Oid;
evType: PgCatalog.Types.Char;
evEnabled: PgCatalog.Types.Char;
isInstead: PgCatalog.Types.Bool;
evQual: PgCatalog.Types.PgNodeTree;
evAction: PgCatalog.Types.PgNodeTree;
}

export type PgRewriteArray = 
     Array<PgCatalog.Types.PgRewrite>
    ;

export type PgTrigger = {
oid: PgCatalog.Types.Oid;
tgrelid: PgCatalog.Types.Oid;
tgparentid: PgCatalog.Types.Oid;
tgname: PgCatalog.Types.Name;
tgfoid: PgCatalog.Types.Oid;
tgtype: PgCatalog.Types.Int2;
tgenabled: PgCatalog.Types.Char;
tgisinternal: PgCatalog.Types.Bool;
tgconstrrelid: PgCatalog.Types.Oid;
tgconstrindid: PgCatalog.Types.Oid;
tgconstraint: PgCatalog.Types.Oid;
tgdeferrable: PgCatalog.Types.Bool;
tginitdeferred: PgCatalog.Types.Bool;
tgnargs: PgCatalog.Types.Int2;
tgattr: PgCatalog.Types.Int2vector;
tgargs: PgCatalog.Types.Bytea;
tgqual: Nullable<PgCatalog.Types.PgNodeTree>;
tgoldtable: Nullable<PgCatalog.Types.Name>;
tgnewtable: Nullable<PgCatalog.Types.Name>;
}

export type PgTriggerArray = 
     Array<PgCatalog.Types.PgTrigger>
    ;

export type PgEventTrigger = {
oid: PgCatalog.Types.Oid;
evtname: PgCatalog.Types.Name;
evtevent: PgCatalog.Types.Name;
evtowner: PgCatalog.Types.Oid;
evtfoid: PgCatalog.Types.Oid;
evtenabled: PgCatalog.Types.Char;
evttags: PgCatalog.Types.TextArray;
}

export type PgEventTriggerArray = 
     Array<PgCatalog.Types.PgEventTrigger>
    ;

export type PgDescription = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
description: PgCatalog.Types.Text;
}

export type PgDescriptionArray = 
     Array<PgCatalog.Types.PgDescription>
    ;

export type PgCast = {
oid: PgCatalog.Types.Oid;
castsource: PgCatalog.Types.Oid;
casttarget: PgCatalog.Types.Oid;
castfunc: PgCatalog.Types.Oid;
castcontext: PgCatalog.Types.Char;
castmethod: PgCatalog.Types.Char;
}

export type PgCastArray = 
     Array<PgCatalog.Types.PgCast>
    ;

export type PgEnum = {
oid: PgCatalog.Types.Oid;
enumtypid: PgCatalog.Types.Oid;
enumsortorder: PgCatalog.Types.Float4;
enumlabel: PgCatalog.Types.Name;
}

export type PgEnumArray = 
     Array<PgCatalog.Types.PgEnum>
    ;

export type PgNamespace = {
oid: PgCatalog.Types.Oid;
nspname: PgCatalog.Types.Name;
nspowner: PgCatalog.Types.Oid;
nspacl: PgCatalog.Types.AclitemArray;
}

export type PgNamespaceArray = 
     Array<PgCatalog.Types.PgNamespace>
    ;

export type PgConversion = {
oid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
conowner: PgCatalog.Types.Oid;
conforencoding: PgCatalog.Types.Int4;
contoencoding: PgCatalog.Types.Int4;
conproc: PgCatalog.Types.Regproc;
condefault: PgCatalog.Types.Bool;
}

export type PgConversionArray = 
     Array<PgCatalog.Types.PgConversion>
    ;

export type PgDepend = {
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
refobjsubid: PgCatalog.Types.Int4;
deptype: PgCatalog.Types.Char;
}

export type PgDependArray = 
     Array<PgCatalog.Types.PgDepend>
    ;

export type PgDatabase = {
oid: PgCatalog.Types.Oid;
datname: PgCatalog.Types.Name;
datdba: PgCatalog.Types.Oid;
encoding: PgCatalog.Types.Int4;
datlocprovider: PgCatalog.Types.Char;
datistemplate: PgCatalog.Types.Bool;
datallowconn: PgCatalog.Types.Bool;
datconnlimit: PgCatalog.Types.Int4;
datfrozenxid: PgCatalog.Types.Xid;
datminmxid: PgCatalog.Types.Xid;
dattablespace: PgCatalog.Types.Oid;
datcollate: PgCatalog.Types.Text;
datctype: PgCatalog.Types.Text;
daticulocale: Nullable<PgCatalog.Types.Text>;
daticurules: Nullable<PgCatalog.Types.Text>;
datcollversion: Nullable<PgCatalog.Types.Text>;
datacl: PgCatalog.Types.AclitemArray;
}

export type PgDatabaseArray = 
     Array<PgCatalog.Types.PgDatabase>
    ;

export type PgDbRoleSetting = {
setdatabase: PgCatalog.Types.Oid;
setrole: PgCatalog.Types.Oid;
setconfig: PgCatalog.Types.TextArray;
}

export type PgDbRoleSettingArray = 
     Array<PgCatalog.Types.PgDbRoleSetting>
    ;

export type PgTablespace = {
oid: PgCatalog.Types.Oid;
spcname: PgCatalog.Types.Name;
spcowner: PgCatalog.Types.Oid;
spcacl: PgCatalog.Types.AclitemArray;
spcoptions: PgCatalog.Types.TextArray;
}

export type PgTablespaceArray = 
     Array<PgCatalog.Types.PgTablespace>
    ;

export type PgAuthid = {
oid: PgCatalog.Types.Oid;
rolname: PgCatalog.Types.Name;
rolsuper: PgCatalog.Types.Bool;
rolinherit: PgCatalog.Types.Bool;
rolcreaterole: PgCatalog.Types.Bool;
rolcreatedb: PgCatalog.Types.Bool;
rolcanlogin: PgCatalog.Types.Bool;
rolreplication: PgCatalog.Types.Bool;
rolbypassrls: PgCatalog.Types.Bool;
rolconnlimit: PgCatalog.Types.Int4;
rolpassword: Nullable<PgCatalog.Types.Text>;
rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgAuthidArray = 
     Array<PgCatalog.Types.PgAuthid>
    ;

export type PgAuthMembers = {
oid: PgCatalog.Types.Oid;
roleid: PgCatalog.Types.Oid;
member: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
adminOption: PgCatalog.Types.Bool;
inheritOption: PgCatalog.Types.Bool;
setOption: PgCatalog.Types.Bool;
}

export type PgAuthMembersArray = 
     Array<PgCatalog.Types.PgAuthMembers>
    ;

export type PgShdepend = {
dbid: PgCatalog.Types.Oid;
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
deptype: PgCatalog.Types.Char;
}

export type PgShdependArray = 
     Array<PgCatalog.Types.PgShdepend>
    ;

export type PgShdescription = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
description: PgCatalog.Types.Text;
}

export type PgShdescriptionArray = 
     Array<PgCatalog.Types.PgShdescription>
    ;

export type PgTsConfig = {
oid: PgCatalog.Types.Oid;
cfgname: PgCatalog.Types.Name;
cfgnamespace: PgCatalog.Types.Oid;
cfgowner: PgCatalog.Types.Oid;
cfgparser: PgCatalog.Types.Oid;
}

export type PgTsConfigArray = 
     Array<PgCatalog.Types.PgTsConfig>
    ;

export type PgTsConfigMap = {
mapcfg: PgCatalog.Types.Oid;
maptokentype: PgCatalog.Types.Int4;
mapseqno: PgCatalog.Types.Int4;
mapdict: PgCatalog.Types.Oid;
}

export type PgTsConfigMapArray = 
     Array<PgCatalog.Types.PgTsConfigMap>
    ;

export type PgTsDict = {
oid: PgCatalog.Types.Oid;
dictname: PgCatalog.Types.Name;
dictnamespace: PgCatalog.Types.Oid;
dictowner: PgCatalog.Types.Oid;
dicttemplate: PgCatalog.Types.Oid;
dictinitoption: Nullable<PgCatalog.Types.Text>;
}

export type PgTsDictArray = 
     Array<PgCatalog.Types.PgTsDict>
    ;

export type PgTsParser = {
oid: PgCatalog.Types.Oid;
prsname: PgCatalog.Types.Name;
prsnamespace: PgCatalog.Types.Oid;
prsstart: PgCatalog.Types.Regproc;
prstoken: PgCatalog.Types.Regproc;
prsend: PgCatalog.Types.Regproc;
prsheadline: PgCatalog.Types.Regproc;
prslextype: PgCatalog.Types.Regproc;
}

export type PgTsParserArray = 
     Array<PgCatalog.Types.PgTsParser>
    ;

export type PgTsTemplate = {
oid: PgCatalog.Types.Oid;
tmplname: PgCatalog.Types.Name;
tmplnamespace: PgCatalog.Types.Oid;
tmplinit: PgCatalog.Types.Regproc;
tmpllexize: PgCatalog.Types.Regproc;
}

export type PgTsTemplateArray = 
     Array<PgCatalog.Types.PgTsTemplate>
    ;

export type PgExtension = {
oid: PgCatalog.Types.Oid;
extname: PgCatalog.Types.Name;
extowner: PgCatalog.Types.Oid;
extnamespace: PgCatalog.Types.Oid;
extrelocatable: PgCatalog.Types.Bool;
extversion: PgCatalog.Types.Text;
extconfig: PgCatalog.Types.OidArray;
extcondition: PgCatalog.Types.TextArray;
}

export type PgExtensionArray = 
     Array<PgCatalog.Types.PgExtension>
    ;

export type PgForeignDataWrapper = {
oid: PgCatalog.Types.Oid;
fdwname: PgCatalog.Types.Name;
fdwowner: PgCatalog.Types.Oid;
fdwhandler: PgCatalog.Types.Oid;
fdwvalidator: PgCatalog.Types.Oid;
fdwacl: PgCatalog.Types.AclitemArray;
fdwoptions: PgCatalog.Types.TextArray;
}

export type PgForeignDataWrapperArray = 
     Array<PgCatalog.Types.PgForeignDataWrapper>
    ;

export type PgForeignServer = {
oid: PgCatalog.Types.Oid;
srvname: PgCatalog.Types.Name;
srvowner: PgCatalog.Types.Oid;
srvfdw: PgCatalog.Types.Oid;
srvtype: Nullable<PgCatalog.Types.Text>;
srvversion: Nullable<PgCatalog.Types.Text>;
srvacl: PgCatalog.Types.AclitemArray;
srvoptions: PgCatalog.Types.TextArray;
}

export type PgForeignServerArray = 
     Array<PgCatalog.Types.PgForeignServer>
    ;

export type PgUserMapping = {
oid: PgCatalog.Types.Oid;
umuser: PgCatalog.Types.Oid;
umserver: PgCatalog.Types.Oid;
umoptions: PgCatalog.Types.TextArray;
}

export type PgUserMappingArray = 
     Array<PgCatalog.Types.PgUserMapping>
    ;

export type PgForeignTable = {
ftrelid: PgCatalog.Types.Oid;
ftserver: PgCatalog.Types.Oid;
ftoptions: PgCatalog.Types.TextArray;
}

export type PgForeignTableArray = 
     Array<PgCatalog.Types.PgForeignTable>
    ;

export type PgPolicy = {
oid: PgCatalog.Types.Oid;
polname: PgCatalog.Types.Name;
polrelid: PgCatalog.Types.Oid;
polcmd: PgCatalog.Types.Char;
polpermissive: PgCatalog.Types.Bool;
polroles: PgCatalog.Types.OidArray;
polqual: Nullable<PgCatalog.Types.PgNodeTree>;
polwithcheck: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgPolicyArray = 
     Array<PgCatalog.Types.PgPolicy>
    ;

export type PgReplicationOrigin = {
roident: PgCatalog.Types.Oid;
roname: PgCatalog.Types.Text;
}

export type PgReplicationOriginArray = 
     Array<PgCatalog.Types.PgReplicationOrigin>
    ;

export type PgDefaultAcl = {
oid: PgCatalog.Types.Oid;
defaclrole: PgCatalog.Types.Oid;
defaclnamespace: PgCatalog.Types.Oid;
defaclobjtype: PgCatalog.Types.Char;
defaclacl: PgCatalog.Types.AclitemArray;
}

export type PgDefaultAclArray = 
     Array<PgCatalog.Types.PgDefaultAcl>
    ;

export type PgInitPrivs = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
privtype: PgCatalog.Types.Char;
initprivs: PgCatalog.Types.AclitemArray;
}

export type PgInitPrivsArray = 
     Array<PgCatalog.Types.PgInitPrivs>
    ;

export type PgSeclabel = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
provider: PgCatalog.Types.Text;
label: PgCatalog.Types.Text;
}

export type PgSeclabelArray = 
     Array<PgCatalog.Types.PgSeclabel>
    ;

export type PgShseclabel = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
provider: PgCatalog.Types.Text;
label: PgCatalog.Types.Text;
}

export type PgShseclabelArray = 
     Array<PgCatalog.Types.PgShseclabel>
    ;

export type PgCollation = {
oid: PgCatalog.Types.Oid;
collname: PgCatalog.Types.Name;
collnamespace: PgCatalog.Types.Oid;
collowner: PgCatalog.Types.Oid;
collprovider: PgCatalog.Types.Char;
collisdeterministic: PgCatalog.Types.Bool;
collencoding: PgCatalog.Types.Int4;
collcollate: Nullable<PgCatalog.Types.Text>;
collctype: Nullable<PgCatalog.Types.Text>;
colliculocale: Nullable<PgCatalog.Types.Text>;
collicurules: Nullable<PgCatalog.Types.Text>;
collversion: Nullable<PgCatalog.Types.Text>;
}

export type PgCollationArray = 
     Array<PgCatalog.Types.PgCollation>
    ;

export type PgParameterAcl = {
oid: PgCatalog.Types.Oid;
parname: PgCatalog.Types.Text;
paracl: PgCatalog.Types.AclitemArray;
}

export type PgParameterAclArray = 
     Array<PgCatalog.Types.PgParameterAcl>
    ;

export type PgPartitionedTable = {
partrelid: PgCatalog.Types.Oid;
partstrat: PgCatalog.Types.Char;
partnatts: PgCatalog.Types.Int2;
partdefid: PgCatalog.Types.Oid;
partattrs: PgCatalog.Types.Int2vector;
partclass: PgCatalog.Types.Oidvector;
partcollation: PgCatalog.Types.Oidvector;
partexprs: Nullable<PgCatalog.Types.PgNodeTree>;
}

export type PgPartitionedTableArray = 
     Array<PgCatalog.Types.PgPartitionedTable>
    ;

export type PgRange = {
rngtypid: PgCatalog.Types.Oid;
rngsubtype: PgCatalog.Types.Oid;
rngmultitypid: PgCatalog.Types.Oid;
rngcollation: PgCatalog.Types.Oid;
rngsubopc: PgCatalog.Types.Oid;
rngcanonical: PgCatalog.Types.Regproc;
rngsubdiff: PgCatalog.Types.Regproc;
}

export type PgRangeArray = 
     Array<PgCatalog.Types.PgRange>
    ;

export type PgTransform = {
oid: PgCatalog.Types.Oid;
trftype: PgCatalog.Types.Oid;
trflang: PgCatalog.Types.Oid;
trffromsql: PgCatalog.Types.Regproc;
trftosql: PgCatalog.Types.Regproc;
}

export type PgTransformArray = 
     Array<PgCatalog.Types.PgTransform>
    ;

export type PgSequence = {
seqrelid: PgCatalog.Types.Oid;
seqtypid: PgCatalog.Types.Oid;
seqstart: PgCatalog.Types.Int8;
seqincrement: PgCatalog.Types.Int8;
seqmax: PgCatalog.Types.Int8;
seqmin: PgCatalog.Types.Int8;
seqcache: PgCatalog.Types.Int8;
seqcycle: PgCatalog.Types.Bool;
}

export type PgSequenceArray = 
     Array<PgCatalog.Types.PgSequence>
    ;

export type PgPublication = {
oid: PgCatalog.Types.Oid;
pubname: PgCatalog.Types.Name;
pubowner: PgCatalog.Types.Oid;
puballtables: PgCatalog.Types.Bool;
pubinsert: PgCatalog.Types.Bool;
pubupdate: PgCatalog.Types.Bool;
pubdelete: PgCatalog.Types.Bool;
pubtruncate: PgCatalog.Types.Bool;
pubviaroot: PgCatalog.Types.Bool;
}

export type PgPublicationArray = 
     Array<PgCatalog.Types.PgPublication>
    ;

export type PgPublicationNamespace = {
oid: PgCatalog.Types.Oid;
pnpubid: PgCatalog.Types.Oid;
pnnspid: PgCatalog.Types.Oid;
}

export type PgPublicationNamespaceArray = 
     Array<PgCatalog.Types.PgPublicationNamespace>
    ;

export type PgPublicationRel = {
oid: PgCatalog.Types.Oid;
prpubid: PgCatalog.Types.Oid;
prrelid: PgCatalog.Types.Oid;
prqual: Nullable<PgCatalog.Types.PgNodeTree>;
prattrs: Nullable<PgCatalog.Types.Int2vector>;
}

export type PgPublicationRelArray = 
     Array<PgCatalog.Types.PgPublicationRel>
    ;

export type PgSubscription = {
oid: PgCatalog.Types.Oid;
subdbid: PgCatalog.Types.Oid;
subskiplsn: PgCatalog.Types.PgLsn;
subname: PgCatalog.Types.Name;
subowner: PgCatalog.Types.Oid;
subenabled: PgCatalog.Types.Bool;
subbinary: PgCatalog.Types.Bool;
substream: PgCatalog.Types.Char;
subtwophasestate: PgCatalog.Types.Char;
subdisableonerr: PgCatalog.Types.Bool;
subpasswordrequired: PgCatalog.Types.Bool;
subrunasowner: PgCatalog.Types.Bool;
subconninfo: PgCatalog.Types.Text;
subslotname: Nullable<PgCatalog.Types.Name>;
subsynccommit: PgCatalog.Types.Text;
subpublications: PgCatalog.Types.TextArray;
suborigin: Nullable<PgCatalog.Types.Text>;
}

export type PgSubscriptionArray = 
     Array<PgCatalog.Types.PgSubscription>
    ;

export type PgSubscriptionRel = {
srsubid: PgCatalog.Types.Oid;
srrelid: PgCatalog.Types.Oid;
srsubstate: PgCatalog.Types.Char;
srsublsn: Nullable<PgCatalog.Types.PgLsn>;
}

export type PgSubscriptionRelArray = 
     Array<PgCatalog.Types.PgSubscriptionRel>
    ;

export type PgRoles = {
rolname: Nullable<PgCatalog.Types.Name>;
rolsuper: Nullable<PgCatalog.Types.Bool>;
rolinherit: Nullable<PgCatalog.Types.Bool>;
rolcreaterole: Nullable<PgCatalog.Types.Bool>;
rolcreatedb: Nullable<PgCatalog.Types.Bool>;
rolcanlogin: Nullable<PgCatalog.Types.Bool>;
rolreplication: Nullable<PgCatalog.Types.Bool>;
rolconnlimit: Nullable<PgCatalog.Types.Int4>;
rolpassword: Nullable<PgCatalog.Types.Text>;
rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
rolbypassrls: Nullable<PgCatalog.Types.Bool>;
rolconfig: PgCatalog.Types.TextArray;
oid: Nullable<PgCatalog.Types.Oid>;
}

export type PgRolesArray = 
     Array<PgCatalog.Types.PgRoles>
    ;

export type PgShadow = {
usename: Nullable<PgCatalog.Types.Name>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usecreatedb: Nullable<PgCatalog.Types.Bool>;
usesuper: Nullable<PgCatalog.Types.Bool>;
userepl: Nullable<PgCatalog.Types.Bool>;
usebypassrls: Nullable<PgCatalog.Types.Bool>;
passwd: Nullable<PgCatalog.Types.Text>;
valuntil: Nullable<PgCatalog.Types.Timestamptz>;
useconfig: PgCatalog.Types.TextArray;
}

export type PgShadowArray = 
     Array<PgCatalog.Types.PgShadow>
    ;

export type PgGroup = {
groname: Nullable<PgCatalog.Types.Name>;
grosysid: Nullable<PgCatalog.Types.Oid>;
grolist: PgCatalog.Types.OidArray;
}

export type PgGroupArray = 
     Array<PgCatalog.Types.PgGroup>
    ;

export type PgUser = {
usename: Nullable<PgCatalog.Types.Name>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usecreatedb: Nullable<PgCatalog.Types.Bool>;
usesuper: Nullable<PgCatalog.Types.Bool>;
userepl: Nullable<PgCatalog.Types.Bool>;
usebypassrls: Nullable<PgCatalog.Types.Bool>;
passwd: Nullable<PgCatalog.Types.Text>;
valuntil: Nullable<PgCatalog.Types.Timestamptz>;
useconfig: PgCatalog.Types.TextArray;
}

export type PgUserArray = 
     Array<PgCatalog.Types.PgUser>
    ;

export type PgPolicies = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
policyname: Nullable<PgCatalog.Types.Name>;
permissive: Nullable<PgCatalog.Types.Text>;
roles: PgCatalog.Types.NameArray;
cmd: Nullable<PgCatalog.Types.Text>;
qual: Nullable<PgCatalog.Types.Text>;
withCheck: Nullable<PgCatalog.Types.Text>;
}

export type PgPoliciesArray = 
     Array<PgCatalog.Types.PgPolicies>
    ;

export type PgRules = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
rulename: Nullable<PgCatalog.Types.Name>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgRulesArray = 
     Array<PgCatalog.Types.PgRules>
    ;

export type PgViews = {
schemaname: Nullable<PgCatalog.Types.Name>;
viewname: Nullable<PgCatalog.Types.Name>;
viewowner: Nullable<PgCatalog.Types.Name>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgViewsArray = 
     Array<PgCatalog.Types.PgViews>
    ;

export type PgTables = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
tableowner: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
hasindexes: Nullable<PgCatalog.Types.Bool>;
hasrules: Nullable<PgCatalog.Types.Bool>;
hastriggers: Nullable<PgCatalog.Types.Bool>;
rowsecurity: Nullable<PgCatalog.Types.Bool>;
}

export type PgTablesArray = 
     Array<PgCatalog.Types.PgTables>
    ;

export type PgMatviews = {
schemaname: Nullable<PgCatalog.Types.Name>;
matviewname: Nullable<PgCatalog.Types.Name>;
matviewowner: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
hasindexes: Nullable<PgCatalog.Types.Bool>;
ispopulated: Nullable<PgCatalog.Types.Bool>;
definition: Nullable<PgCatalog.Types.Text>;
}

export type PgMatviewsArray = 
     Array<PgCatalog.Types.PgMatviews>
    ;

export type PgIndexes = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
indexname: Nullable<PgCatalog.Types.Name>;
tablespace: Nullable<PgCatalog.Types.Name>;
indexdef: Nullable<PgCatalog.Types.Text>;
}

export type PgIndexesArray = 
     Array<PgCatalog.Types.PgIndexes>
    ;

export type PgSequences = {
schemaname: Nullable<PgCatalog.Types.Name>;
sequencename: Nullable<PgCatalog.Types.Name>;
sequenceowner: Nullable<PgCatalog.Types.Name>;
dataType: Nullable<PgCatalog.Types.Regtype>;
startValue: Nullable<PgCatalog.Types.Int8>;
minValue: Nullable<PgCatalog.Types.Int8>;
maxValue: Nullable<PgCatalog.Types.Int8>;
incrementBy: Nullable<PgCatalog.Types.Int8>;
cycle: Nullable<PgCatalog.Types.Bool>;
cacheSize: Nullable<PgCatalog.Types.Int8>;
lastValue: Nullable<PgCatalog.Types.Int8>;
}

export type PgSequencesArray = 
     Array<PgCatalog.Types.PgSequences>
    ;

export type PgStats = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
attname: Nullable<PgCatalog.Types.Name>;
inherited: Nullable<PgCatalog.Types.Bool>;
nullFrac: Nullable<PgCatalog.Types.Float4>;
avgWidth: Nullable<PgCatalog.Types.Int4>;
nDistinct: Nullable<PgCatalog.Types.Float4>;
mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
mostCommonFreqs: PgCatalog.Types.Float4Array;
histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
correlation: Nullable<PgCatalog.Types.Float4>;
mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
mostCommonElemFreqs: PgCatalog.Types.Float4Array;
elemCountHistogram: PgCatalog.Types.Float4Array;
}

export type PgStatsArray = 
     Array<PgCatalog.Types.PgStats>
    ;

export type PgStatsExt = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
statisticsName: Nullable<PgCatalog.Types.Name>;
statisticsOwner: Nullable<PgCatalog.Types.Name>;
attnames: PgCatalog.Types.NameArray;
exprs: PgCatalog.Types.TextArray;
kinds: PgCatalog.Types.CharArray;
inherited: Nullable<PgCatalog.Types.Bool>;
nDistinct: Nullable<PgCatalog.Types.PgNdistinct>;
dependencies: Nullable<PgCatalog.Types.PgDependencies>;
mostCommonVals: PgCatalog.Types.TextArray;
mostCommonValNulls: PgCatalog.Types.BoolArray;
mostCommonFreqs: PgCatalog.Types.Float8Array;
mostCommonBaseFreqs: PgCatalog.Types.Float8Array;
}

export type PgStatsExtArray = 
     Array<PgCatalog.Types.PgStatsExt>
    ;

export type PgStatsExtExprs = {
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
statisticsName: Nullable<PgCatalog.Types.Name>;
statisticsOwner: Nullable<PgCatalog.Types.Name>;
expr: Nullable<PgCatalog.Types.Text>;
inherited: Nullable<PgCatalog.Types.Bool>;
nullFrac: Nullable<PgCatalog.Types.Float4>;
avgWidth: Nullable<PgCatalog.Types.Int4>;
nDistinct: Nullable<PgCatalog.Types.Float4>;
mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
mostCommonFreqs: PgCatalog.Types.Float4Array;
histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
correlation: Nullable<PgCatalog.Types.Float4>;
mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
mostCommonElemFreqs: PgCatalog.Types.Float4Array;
elemCountHistogram: PgCatalog.Types.Float4Array;
}

export type PgStatsExtExprsArray = 
     Array<PgCatalog.Types.PgStatsExtExprs>
    ;

export type PgPublicationTables = {
pubname: Nullable<PgCatalog.Types.Name>;
schemaname: Nullable<PgCatalog.Types.Name>;
tablename: Nullable<PgCatalog.Types.Name>;
attnames: PgCatalog.Types.NameArray;
rowfilter: Nullable<PgCatalog.Types.Text>;
}

export type PgPublicationTablesArray = 
     Array<PgCatalog.Types.PgPublicationTables>
    ;

export type PgLocks = {
locktype: Nullable<PgCatalog.Types.Text>;
database: Nullable<PgCatalog.Types.Oid>;
relation: Nullable<PgCatalog.Types.Oid>;
page: Nullable<PgCatalog.Types.Int4>;
tuple: Nullable<PgCatalog.Types.Int2>;
virtualxid: Nullable<PgCatalog.Types.Text>;
transactionid: Nullable<PgCatalog.Types.Xid>;
classid: Nullable<PgCatalog.Types.Oid>;
objid: Nullable<PgCatalog.Types.Oid>;
objsubid: Nullable<PgCatalog.Types.Int2>;
virtualtransaction: Nullable<PgCatalog.Types.Text>;
pid: Nullable<PgCatalog.Types.Int4>;
mode: Nullable<PgCatalog.Types.Text>;
granted: Nullable<PgCatalog.Types.Bool>;
fastpath: Nullable<PgCatalog.Types.Bool>;
waitstart: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgLocksArray = 
     Array<PgCatalog.Types.PgLocks>
    ;

export type PgCursors = {
name: Nullable<PgCatalog.Types.Text>;
statement: Nullable<PgCatalog.Types.Text>;
isHoldable: Nullable<PgCatalog.Types.Bool>;
isBinary: Nullable<PgCatalog.Types.Bool>;
isScrollable: Nullable<PgCatalog.Types.Bool>;
creationTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgCursorsArray = 
     Array<PgCatalog.Types.PgCursors>
    ;

export type PgAvailableExtensions = {
name: Nullable<PgCatalog.Types.Name>;
defaultVersion: Nullable<PgCatalog.Types.Text>;
installedVersion: Nullable<PgCatalog.Types.Text>;
comment: Nullable<PgCatalog.Types.Text>;
}

export type PgAvailableExtensionsArray = 
     Array<PgCatalog.Types.PgAvailableExtensions>
    ;

export type PgAvailableExtensionVersions = {
name: Nullable<PgCatalog.Types.Name>;
version: Nullable<PgCatalog.Types.Text>;
installed: Nullable<PgCatalog.Types.Bool>;
superuser: Nullable<PgCatalog.Types.Bool>;
trusted: Nullable<PgCatalog.Types.Bool>;
relocatable: Nullable<PgCatalog.Types.Bool>;
schema: Nullable<PgCatalog.Types.Name>;
requires: PgCatalog.Types.NameArray;
comment: Nullable<PgCatalog.Types.Text>;
}

export type PgAvailableExtensionVersionsArray = 
     Array<PgCatalog.Types.PgAvailableExtensionVersions>
    ;

export type PgPreparedXacts = {
transaction: Nullable<PgCatalog.Types.Xid>;
gid: Nullable<PgCatalog.Types.Text>;
prepared: Nullable<PgCatalog.Types.Timestamptz>;
owner: Nullable<PgCatalog.Types.Name>;
database: Nullable<PgCatalog.Types.Name>;
}

export type PgPreparedXactsArray = 
     Array<PgCatalog.Types.PgPreparedXacts>
    ;

export type PgPreparedStatements = {
name: Nullable<PgCatalog.Types.Text>;
statement: Nullable<PgCatalog.Types.Text>;
prepareTime: Nullable<PgCatalog.Types.Timestamptz>;
parameterTypes: PgCatalog.Types.RegtypeArray;
resultTypes: PgCatalog.Types.RegtypeArray;
fromSql: Nullable<PgCatalog.Types.Bool>;
genericPlans: Nullable<PgCatalog.Types.Int8>;
customPlans: Nullable<PgCatalog.Types.Int8>;
}

export type PgPreparedStatementsArray = 
     Array<PgCatalog.Types.PgPreparedStatements>
    ;

export type PgSeclabels = {
objoid: Nullable<PgCatalog.Types.Oid>;
classoid: Nullable<PgCatalog.Types.Oid>;
objsubid: Nullable<PgCatalog.Types.Int4>;
objtype: Nullable<PgCatalog.Types.Text>;
objnamespace: Nullable<PgCatalog.Types.Oid>;
objname: Nullable<PgCatalog.Types.Text>;
provider: Nullable<PgCatalog.Types.Text>;
label: Nullable<PgCatalog.Types.Text>;
}

export type PgSeclabelsArray = 
     Array<PgCatalog.Types.PgSeclabels>
    ;

export type PgSettings = {
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
unit: Nullable<PgCatalog.Types.Text>;
category: Nullable<PgCatalog.Types.Text>;
shortDesc: Nullable<PgCatalog.Types.Text>;
extraDesc: Nullable<PgCatalog.Types.Text>;
context: Nullable<PgCatalog.Types.Text>;
vartype: Nullable<PgCatalog.Types.Text>;
source: Nullable<PgCatalog.Types.Text>;
minVal: Nullable<PgCatalog.Types.Text>;
maxVal: Nullable<PgCatalog.Types.Text>;
enumvals: PgCatalog.Types.TextArray;
bootVal: Nullable<PgCatalog.Types.Text>;
resetVal: Nullable<PgCatalog.Types.Text>;
sourcefile: Nullable<PgCatalog.Types.Text>;
sourceline: Nullable<PgCatalog.Types.Int4>;
pendingRestart: Nullable<PgCatalog.Types.Bool>;
}

export type PgSettingsArray = 
     Array<PgCatalog.Types.PgSettings>
    ;

export type PgFileSettings = {
sourcefile: Nullable<PgCatalog.Types.Text>;
sourceline: Nullable<PgCatalog.Types.Int4>;
seqno: Nullable<PgCatalog.Types.Int4>;
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
applied: Nullable<PgCatalog.Types.Bool>;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgFileSettingsArray = 
     Array<PgCatalog.Types.PgFileSettings>
    ;

export type PgHbaFileRules = {
ruleNumber: Nullable<PgCatalog.Types.Int4>;
fileName: Nullable<PgCatalog.Types.Text>;
lineNumber: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Text>;
database: PgCatalog.Types.TextArray;
userName: PgCatalog.Types.TextArray;
address: Nullable<PgCatalog.Types.Text>;
netmask: Nullable<PgCatalog.Types.Text>;
authMethod: Nullable<PgCatalog.Types.Text>;
options: PgCatalog.Types.TextArray;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgHbaFileRulesArray = 
     Array<PgCatalog.Types.PgHbaFileRules>
    ;

export type PgIdentFileMappings = {
mapNumber: Nullable<PgCatalog.Types.Int4>;
fileName: Nullable<PgCatalog.Types.Text>;
lineNumber: Nullable<PgCatalog.Types.Int4>;
mapName: Nullable<PgCatalog.Types.Text>;
sysName: Nullable<PgCatalog.Types.Text>;
pgUsername: Nullable<PgCatalog.Types.Text>;
error: Nullable<PgCatalog.Types.Text>;
}

export type PgIdentFileMappingsArray = 
     Array<PgCatalog.Types.PgIdentFileMappings>
    ;

export type PgTimezoneAbbrevs = {
abbrev: Nullable<PgCatalog.Types.Text>;
utcOffset: Nullable<PgCatalog.Types.Interval>;
isDst: Nullable<PgCatalog.Types.Bool>;
}

export type PgTimezoneAbbrevsArray = 
     Array<PgCatalog.Types.PgTimezoneAbbrevs>
    ;

export type PgTimezoneNames = {
name: Nullable<PgCatalog.Types.Text>;
abbrev: Nullable<PgCatalog.Types.Text>;
utcOffset: Nullable<PgCatalog.Types.Interval>;
isDst: Nullable<PgCatalog.Types.Bool>;
}

export type PgTimezoneNamesArray = 
     Array<PgCatalog.Types.PgTimezoneNames>
    ;

export type PgConfig = {
name: Nullable<PgCatalog.Types.Text>;
setting: Nullable<PgCatalog.Types.Text>;
}

export type PgConfigArray = 
     Array<PgCatalog.Types.PgConfig>
    ;

export type PgShmemAllocations = {
name: Nullable<PgCatalog.Types.Text>;
off: Nullable<PgCatalog.Types.Int8>;
size: Nullable<PgCatalog.Types.Int8>;
allocatedSize: Nullable<PgCatalog.Types.Int8>;
}

export type PgShmemAllocationsArray = 
     Array<PgCatalog.Types.PgShmemAllocations>
    ;

export type PgBackendMemoryContexts = {
name: Nullable<PgCatalog.Types.Text>;
ident: Nullable<PgCatalog.Types.Text>;
parent: Nullable<PgCatalog.Types.Text>;
level: Nullable<PgCatalog.Types.Int4>;
totalBytes: Nullable<PgCatalog.Types.Int8>;
totalNblocks: Nullable<PgCatalog.Types.Int8>;
freeBytes: Nullable<PgCatalog.Types.Int8>;
freeChunks: Nullable<PgCatalog.Types.Int8>;
usedBytes: Nullable<PgCatalog.Types.Int8>;
}

export type PgBackendMemoryContextsArray = 
     Array<PgCatalog.Types.PgBackendMemoryContexts>
    ;

export type PgStatAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatAllTablesArray = 
     Array<PgCatalog.Types.PgStatAllTables>
    ;

export type PgStatXactAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactAllTablesArray = 
     Array<PgCatalog.Types.PgStatXactAllTables>
    ;

export type PgStatSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatSysTablesArray = 
     Array<PgCatalog.Types.PgStatSysTables>
    ;

export type PgStatXactSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactSysTablesArray = 
     Array<PgCatalog.Types.PgStatXactSysTables>
    ;

export type PgStatUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
nLiveTup: Nullable<PgCatalog.Types.Int8>;
nDeadTup: Nullable<PgCatalog.Types.Int8>;
nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
vacuumCount: Nullable<PgCatalog.Types.Int8>;
autovacuumCount: Nullable<PgCatalog.Types.Int8>;
analyzeCount: Nullable<PgCatalog.Types.Int8>;
autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatUserTablesArray = 
     Array<PgCatalog.Types.PgStatUserTables>
    ;

export type PgStatXactUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
seqScan: Nullable<PgCatalog.Types.Int8>;
seqTupRead: Nullable<PgCatalog.Types.Int8>;
idxScan: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
nTupIns: Nullable<PgCatalog.Types.Int8>;
nTupUpd: Nullable<PgCatalog.Types.Int8>;
nTupDel: Nullable<PgCatalog.Types.Int8>;
nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatXactUserTablesArray = 
     Array<PgCatalog.Types.PgStatXactUserTables>
    ;

export type PgStatioAllTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllTablesArray = 
     Array<PgCatalog.Types.PgStatioAllTables>
    ;

export type PgStatioSysTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysTablesArray = 
     Array<PgCatalog.Types.PgStatioSysTables>
    ;

export type PgStatioUserTables = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
heapBlksRead: Nullable<PgCatalog.Types.Int8>;
heapBlksHit: Nullable<PgCatalog.Types.Int8>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
toastBlksRead: Nullable<PgCatalog.Types.Int8>;
toastBlksHit: Nullable<PgCatalog.Types.Int8>;
tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserTablesArray = 
     Array<PgCatalog.Types.PgStatioUserTables>
    ;

export type PgStatAllIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatAllIndexesArray = 
     Array<PgCatalog.Types.PgStatAllIndexes>
    ;

export type PgStatSysIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatSysIndexesArray = 
     Array<PgCatalog.Types.PgStatSysIndexes>
    ;

export type PgStatUserIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxScan: Nullable<PgCatalog.Types.Int8>;
lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
idxTupRead: Nullable<PgCatalog.Types.Int8>;
idxTupFetch: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatUserIndexesArray = 
     Array<PgCatalog.Types.PgStatUserIndexes>
    ;

export type PgStatioAllIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllIndexesArray = 
     Array<PgCatalog.Types.PgStatioAllIndexes>
    ;

export type PgStatioSysIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysIndexesArray = 
     Array<PgCatalog.Types.PgStatioSysIndexes>
    ;

export type PgStatioUserIndexes = {
relid: Nullable<PgCatalog.Types.Oid>;
indexrelid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
indexrelname: Nullable<PgCatalog.Types.Name>;
idxBlksRead: Nullable<PgCatalog.Types.Int8>;
idxBlksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserIndexesArray = 
     Array<PgCatalog.Types.PgStatioUserIndexes>
    ;

export type PgStatioAllSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioAllSequencesArray = 
     Array<PgCatalog.Types.PgStatioAllSequences>
    ;

export type PgStatioSysSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioSysSequencesArray = 
     Array<PgCatalog.Types.PgStatioSysSequences>
    ;

export type PgStatioUserSequences = {
relid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatioUserSequencesArray = 
     Array<PgCatalog.Types.PgStatioUserSequences>
    ;

export type PgStatActivity = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
pid: Nullable<PgCatalog.Types.Int4>;
leaderPid: Nullable<PgCatalog.Types.Int4>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
applicationName: Nullable<PgCatalog.Types.Text>;
clientAddr: Nullable<PgCatalog.Types.Inet>;
clientHostname: Nullable<PgCatalog.Types.Text>;
clientPort: Nullable<PgCatalog.Types.Int4>;
backendStart: Nullable<PgCatalog.Types.Timestamptz>;
xactStart: Nullable<PgCatalog.Types.Timestamptz>;
queryStart: Nullable<PgCatalog.Types.Timestamptz>;
stateChange: Nullable<PgCatalog.Types.Timestamptz>;
waitEventType: Nullable<PgCatalog.Types.Text>;
waitEvent: Nullable<PgCatalog.Types.Text>;
state: Nullable<PgCatalog.Types.Text>;
backendXid: Nullable<PgCatalog.Types.Xid>;
backendXmin: Nullable<PgCatalog.Types.Xid>;
queryId: Nullable<PgCatalog.Types.Int8>;
query: Nullable<PgCatalog.Types.Text>;
backendType: Nullable<PgCatalog.Types.Text>;
}

export type PgStatActivityArray = 
     Array<PgCatalog.Types.PgStatActivity>
    ;

export type PgStatReplication = {
pid: Nullable<PgCatalog.Types.Int4>;
usesysid: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
applicationName: Nullable<PgCatalog.Types.Text>;
clientAddr: Nullable<PgCatalog.Types.Inet>;
clientHostname: Nullable<PgCatalog.Types.Text>;
clientPort: Nullable<PgCatalog.Types.Int4>;
backendStart: Nullable<PgCatalog.Types.Timestamptz>;
backendXmin: Nullable<PgCatalog.Types.Xid>;
state: Nullable<PgCatalog.Types.Text>;
sentLsn: Nullable<PgCatalog.Types.PgLsn>;
writeLsn: Nullable<PgCatalog.Types.PgLsn>;
flushLsn: Nullable<PgCatalog.Types.PgLsn>;
replayLsn: Nullable<PgCatalog.Types.PgLsn>;
writeLag: Nullable<PgCatalog.Types.Interval>;
flushLag: Nullable<PgCatalog.Types.Interval>;
replayLag: Nullable<PgCatalog.Types.Interval>;
syncPriority: Nullable<PgCatalog.Types.Int4>;
syncState: Nullable<PgCatalog.Types.Text>;
replyTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatReplicationArray = 
     Array<PgCatalog.Types.PgStatReplication>
    ;

export type PgStatSlru = {
name: Nullable<PgCatalog.Types.Text>;
blksZeroed: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksWritten: Nullable<PgCatalog.Types.Int8>;
blksExists: Nullable<PgCatalog.Types.Int8>;
flushes: Nullable<PgCatalog.Types.Int8>;
truncates: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSlruArray = 
     Array<PgCatalog.Types.PgStatSlru>
    ;

export type PgStatWalReceiver = {
pid: Nullable<PgCatalog.Types.Int4>;
status: Nullable<PgCatalog.Types.Text>;
receiveStartLsn: Nullable<PgCatalog.Types.PgLsn>;
receiveStartTli: Nullable<PgCatalog.Types.Int4>;
writtenLsn: Nullable<PgCatalog.Types.PgLsn>;
flushedLsn: Nullable<PgCatalog.Types.PgLsn>;
receivedTli: Nullable<PgCatalog.Types.Int4>;
lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
slotName: Nullable<PgCatalog.Types.Text>;
senderHost: Nullable<PgCatalog.Types.Text>;
senderPort: Nullable<PgCatalog.Types.Int4>;
conninfo: Nullable<PgCatalog.Types.Text>;
}

export type PgStatWalReceiverArray = 
     Array<PgCatalog.Types.PgStatWalReceiver>
    ;

export type PgStatRecoveryPrefetch = {
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
prefetch: Nullable<PgCatalog.Types.Int8>;
hit: Nullable<PgCatalog.Types.Int8>;
skipInit: Nullable<PgCatalog.Types.Int8>;
skipNew: Nullable<PgCatalog.Types.Int8>;
skipFpw: Nullable<PgCatalog.Types.Int8>;
skipRep: Nullable<PgCatalog.Types.Int8>;
walDistance: Nullable<PgCatalog.Types.Int4>;
blockDistance: Nullable<PgCatalog.Types.Int4>;
ioDepth: Nullable<PgCatalog.Types.Int4>;
}

export type PgStatRecoveryPrefetchArray = 
     Array<PgCatalog.Types.PgStatRecoveryPrefetch>
    ;

export type PgStatSubscription = {
subid: Nullable<PgCatalog.Types.Oid>;
subname: Nullable<PgCatalog.Types.Name>;
pid: Nullable<PgCatalog.Types.Int4>;
leaderPid: Nullable<PgCatalog.Types.Int4>;
relid: Nullable<PgCatalog.Types.Oid>;
receivedLsn: Nullable<PgCatalog.Types.PgLsn>;
lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSubscriptionArray = 
     Array<PgCatalog.Types.PgStatSubscription>
    ;

export type PgStatSsl = {
pid: Nullable<PgCatalog.Types.Int4>;
ssl: Nullable<PgCatalog.Types.Bool>;
version: Nullable<PgCatalog.Types.Text>;
cipher: Nullable<PgCatalog.Types.Text>;
bits: Nullable<PgCatalog.Types.Int4>;
clientDn: Nullable<PgCatalog.Types.Text>;
clientSerial: Nullable<PgCatalog.Types.Numeric>;
issuerDn: Nullable<PgCatalog.Types.Text>;
}

export type PgStatSslArray = 
     Array<PgCatalog.Types.PgStatSsl>
    ;

export type PgStatGssapi = {
pid: Nullable<PgCatalog.Types.Int4>;
gssAuthenticated: Nullable<PgCatalog.Types.Bool>;
principal: Nullable<PgCatalog.Types.Text>;
encrypted: Nullable<PgCatalog.Types.Bool>;
credentialsDelegated: Nullable<PgCatalog.Types.Bool>;
}

export type PgStatGssapiArray = 
     Array<PgCatalog.Types.PgStatGssapi>
    ;

export type PgReplicationSlots = {
slotName: Nullable<PgCatalog.Types.Name>;
plugin: Nullable<PgCatalog.Types.Name>;
slotType: Nullable<PgCatalog.Types.Text>;
datoid: Nullable<PgCatalog.Types.Oid>;
database: Nullable<PgCatalog.Types.Name>;
temporary: Nullable<PgCatalog.Types.Bool>;
active: Nullable<PgCatalog.Types.Bool>;
activePid: Nullable<PgCatalog.Types.Int4>;
xmin: Nullable<PgCatalog.Types.Xid>;
catalogXmin: Nullable<PgCatalog.Types.Xid>;
restartLsn: Nullable<PgCatalog.Types.PgLsn>;
confirmedFlushLsn: Nullable<PgCatalog.Types.PgLsn>;
walStatus: Nullable<PgCatalog.Types.Text>;
safeWalSize: Nullable<PgCatalog.Types.Int8>;
twoPhase: Nullable<PgCatalog.Types.Bool>;
conflicting: Nullable<PgCatalog.Types.Bool>;
}

export type PgReplicationSlotsArray = 
     Array<PgCatalog.Types.PgReplicationSlots>
    ;

export type PgStatReplicationSlots = {
slotName: Nullable<PgCatalog.Types.Text>;
spillTxns: Nullable<PgCatalog.Types.Int8>;
spillCount: Nullable<PgCatalog.Types.Int8>;
spillBytes: Nullable<PgCatalog.Types.Int8>;
streamTxns: Nullable<PgCatalog.Types.Int8>;
streamCount: Nullable<PgCatalog.Types.Int8>;
streamBytes: Nullable<PgCatalog.Types.Int8>;
totalTxns: Nullable<PgCatalog.Types.Int8>;
totalBytes: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatReplicationSlotsArray = 
     Array<PgCatalog.Types.PgStatReplicationSlots>
    ;

export type PgStatDatabase = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
numbackends: Nullable<PgCatalog.Types.Int4>;
xactCommit: Nullable<PgCatalog.Types.Int8>;
xactRollback: Nullable<PgCatalog.Types.Int8>;
blksRead: Nullable<PgCatalog.Types.Int8>;
blksHit: Nullable<PgCatalog.Types.Int8>;
tupReturned: Nullable<PgCatalog.Types.Int8>;
tupFetched: Nullable<PgCatalog.Types.Int8>;
tupInserted: Nullable<PgCatalog.Types.Int8>;
tupUpdated: Nullable<PgCatalog.Types.Int8>;
tupDeleted: Nullable<PgCatalog.Types.Int8>;
conflicts: Nullable<PgCatalog.Types.Int8>;
tempFiles: Nullable<PgCatalog.Types.Int8>;
tempBytes: Nullable<PgCatalog.Types.Int8>;
deadlocks: Nullable<PgCatalog.Types.Int8>;
checksumFailures: Nullable<PgCatalog.Types.Int8>;
checksumLastFailure: Nullable<PgCatalog.Types.Timestamptz>;
blkReadTime: Nullable<PgCatalog.Types.Float8>;
blkWriteTime: Nullable<PgCatalog.Types.Float8>;
sessionTime: Nullable<PgCatalog.Types.Float8>;
activeTime: Nullable<PgCatalog.Types.Float8>;
idleInTransactionTime: Nullable<PgCatalog.Types.Float8>;
sessions: Nullable<PgCatalog.Types.Int8>;
sessionsAbandoned: Nullable<PgCatalog.Types.Int8>;
sessionsFatal: Nullable<PgCatalog.Types.Int8>;
sessionsKilled: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatDatabaseArray = 
     Array<PgCatalog.Types.PgStatDatabase>
    ;

export type PgStatDatabaseConflicts = {
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
conflTablespace: Nullable<PgCatalog.Types.Int8>;
conflLock: Nullable<PgCatalog.Types.Int8>;
conflSnapshot: Nullable<PgCatalog.Types.Int8>;
conflBufferpin: Nullable<PgCatalog.Types.Int8>;
conflDeadlock: Nullable<PgCatalog.Types.Int8>;
conflActiveLogicalslot: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatDatabaseConflictsArray = 
     Array<PgCatalog.Types.PgStatDatabaseConflicts>
    ;

export type PgStatUserFunctions = {
funcid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
funcname: Nullable<PgCatalog.Types.Name>;
calls: Nullable<PgCatalog.Types.Int8>;
totalTime: Nullable<PgCatalog.Types.Float8>;
selfTime: Nullable<PgCatalog.Types.Float8>;
}

export type PgStatUserFunctionsArray = 
     Array<PgCatalog.Types.PgStatUserFunctions>
    ;

export type PgStatXactUserFunctions = {
funcid: Nullable<PgCatalog.Types.Oid>;
schemaname: Nullable<PgCatalog.Types.Name>;
funcname: Nullable<PgCatalog.Types.Name>;
calls: Nullable<PgCatalog.Types.Int8>;
totalTime: Nullable<PgCatalog.Types.Float8>;
selfTime: Nullable<PgCatalog.Types.Float8>;
}

export type PgStatXactUserFunctionsArray = 
     Array<PgCatalog.Types.PgStatXactUserFunctions>
    ;

export type PgStatArchiver = {
archivedCount: Nullable<PgCatalog.Types.Int8>;
lastArchivedWal: Nullable<PgCatalog.Types.Text>;
lastArchivedTime: Nullable<PgCatalog.Types.Timestamptz>;
failedCount: Nullable<PgCatalog.Types.Int8>;
lastFailedWal: Nullable<PgCatalog.Types.Text>;
lastFailedTime: Nullable<PgCatalog.Types.Timestamptz>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatArchiverArray = 
     Array<PgCatalog.Types.PgStatArchiver>
    ;

export type PgStatBgwriter = {
checkpointsTimed: Nullable<PgCatalog.Types.Int8>;
checkpointsReq: Nullable<PgCatalog.Types.Int8>;
checkpointWriteTime: Nullable<PgCatalog.Types.Float8>;
checkpointSyncTime: Nullable<PgCatalog.Types.Float8>;
buffersCheckpoint: Nullable<PgCatalog.Types.Int8>;
buffersClean: Nullable<PgCatalog.Types.Int8>;
maxwrittenClean: Nullable<PgCatalog.Types.Int8>;
buffersBackend: Nullable<PgCatalog.Types.Int8>;
buffersBackendFsync: Nullable<PgCatalog.Types.Int8>;
buffersAlloc: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatBgwriterArray = 
     Array<PgCatalog.Types.PgStatBgwriter>
    ;

export type PgStatIo = {
backendType: Nullable<PgCatalog.Types.Text>;
object: Nullable<PgCatalog.Types.Text>;
context: Nullable<PgCatalog.Types.Text>;
reads: Nullable<PgCatalog.Types.Int8>;
readTime: Nullable<PgCatalog.Types.Float8>;
writes: Nullable<PgCatalog.Types.Int8>;
writeTime: Nullable<PgCatalog.Types.Float8>;
writebacks: Nullable<PgCatalog.Types.Int8>;
writebackTime: Nullable<PgCatalog.Types.Float8>;
extends: Nullable<PgCatalog.Types.Int8>;
extendTime: Nullable<PgCatalog.Types.Float8>;
opBytes: Nullable<PgCatalog.Types.Int8>;
hits: Nullable<PgCatalog.Types.Int8>;
evictions: Nullable<PgCatalog.Types.Int8>;
reuses: Nullable<PgCatalog.Types.Int8>;
fsyncs: Nullable<PgCatalog.Types.Int8>;
fsyncTime: Nullable<PgCatalog.Types.Float8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatIoArray = 
     Array<PgCatalog.Types.PgStatIo>
    ;

export type PgStatWal = {
walRecords: Nullable<PgCatalog.Types.Int8>;
walFpi: Nullable<PgCatalog.Types.Int8>;
walBytes: Nullable<PgCatalog.Types.Numeric>;
walBuffersFull: Nullable<PgCatalog.Types.Int8>;
walWrite: Nullable<PgCatalog.Types.Int8>;
walSync: Nullable<PgCatalog.Types.Int8>;
walWriteTime: Nullable<PgCatalog.Types.Float8>;
walSyncTime: Nullable<PgCatalog.Types.Float8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatWalArray = 
     Array<PgCatalog.Types.PgStatWal>
    ;

export type PgStatProgressAnalyze = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
phase: Nullable<PgCatalog.Types.Text>;
sampleBlksTotal: Nullable<PgCatalog.Types.Int8>;
sampleBlksScanned: Nullable<PgCatalog.Types.Int8>;
extStatsTotal: Nullable<PgCatalog.Types.Int8>;
extStatsComputed: Nullable<PgCatalog.Types.Int8>;
childTablesTotal: Nullable<PgCatalog.Types.Int8>;
childTablesDone: Nullable<PgCatalog.Types.Int8>;
currentChildTableRelid: Nullable<PgCatalog.Types.Oid>;
}

export type PgStatProgressAnalyzeArray = 
     Array<PgCatalog.Types.PgStatProgressAnalyze>
    ;

export type PgStatProgressVacuum = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
phase: Nullable<PgCatalog.Types.Text>;
heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
heapBlksVacuumed: Nullable<PgCatalog.Types.Int8>;
indexVacuumCount: Nullable<PgCatalog.Types.Int8>;
maxDeadTuples: Nullable<PgCatalog.Types.Int8>;
numDeadTuples: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressVacuumArray = 
     Array<PgCatalog.Types.PgStatProgressVacuum>
    ;

export type PgStatProgressCluster = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
phase: Nullable<PgCatalog.Types.Text>;
clusterIndexRelid: Nullable<PgCatalog.Types.Oid>;
heapTuplesScanned: Nullable<PgCatalog.Types.Int8>;
heapTuplesWritten: Nullable<PgCatalog.Types.Int8>;
heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
indexRebuildCount: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressClusterArray = 
     Array<PgCatalog.Types.PgStatProgressCluster>
    ;

export type PgStatProgressCreateIndex = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
indexRelid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
phase: Nullable<PgCatalog.Types.Text>;
lockersTotal: Nullable<PgCatalog.Types.Int8>;
lockersDone: Nullable<PgCatalog.Types.Int8>;
currentLockerPid: Nullable<PgCatalog.Types.Int8>;
blocksTotal: Nullable<PgCatalog.Types.Int8>;
blocksDone: Nullable<PgCatalog.Types.Int8>;
tuplesTotal: Nullable<PgCatalog.Types.Int8>;
tuplesDone: Nullable<PgCatalog.Types.Int8>;
partitionsTotal: Nullable<PgCatalog.Types.Int8>;
partitionsDone: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressCreateIndexArray = 
     Array<PgCatalog.Types.PgStatProgressCreateIndex>
    ;

export type PgStatProgressBasebackup = {
pid: Nullable<PgCatalog.Types.Int4>;
phase: Nullable<PgCatalog.Types.Text>;
backupTotal: Nullable<PgCatalog.Types.Int8>;
backupStreamed: Nullable<PgCatalog.Types.Int8>;
tablespacesTotal: Nullable<PgCatalog.Types.Int8>;
tablespacesStreamed: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressBasebackupArray = 
     Array<PgCatalog.Types.PgStatProgressBasebackup>
    ;

export type PgStatProgressCopy = {
pid: Nullable<PgCatalog.Types.Int4>;
datid: Nullable<PgCatalog.Types.Oid>;
datname: Nullable<PgCatalog.Types.Name>;
relid: Nullable<PgCatalog.Types.Oid>;
command: Nullable<PgCatalog.Types.Text>;
type: Nullable<PgCatalog.Types.Text>;
bytesProcessed: Nullable<PgCatalog.Types.Int8>;
bytesTotal: Nullable<PgCatalog.Types.Int8>;
tuplesProcessed: Nullable<PgCatalog.Types.Int8>;
tuplesExcluded: Nullable<PgCatalog.Types.Int8>;
}

export type PgStatProgressCopyArray = 
     Array<PgCatalog.Types.PgStatProgressCopy>
    ;

export type PgUserMappings = {
umid: Nullable<PgCatalog.Types.Oid>;
srvid: Nullable<PgCatalog.Types.Oid>;
srvname: Nullable<PgCatalog.Types.Name>;
umuser: Nullable<PgCatalog.Types.Oid>;
usename: Nullable<PgCatalog.Types.Name>;
umoptions: PgCatalog.Types.TextArray;
}

export type PgUserMappingsArray = 
     Array<PgCatalog.Types.PgUserMappings>
    ;

export type PgReplicationOriginStatus = {
localId: Nullable<PgCatalog.Types.Oid>;
externalId: Nullable<PgCatalog.Types.Text>;
remoteLsn: Nullable<PgCatalog.Types.PgLsn>;
localLsn: Nullable<PgCatalog.Types.PgLsn>;
}

export type PgReplicationOriginStatusArray = 
     Array<PgCatalog.Types.PgReplicationOriginStatus>
    ;

export type PgStatSubscriptionStats = {
subid: Nullable<PgCatalog.Types.Oid>;
subname: Nullable<PgCatalog.Types.Name>;
applyErrorCount: Nullable<PgCatalog.Types.Int8>;
syncErrorCount: Nullable<PgCatalog.Types.Int8>;
statsReset: Nullable<PgCatalog.Types.Timestamptz>;
}

export type PgStatSubscriptionStatsArray = 
     Array<PgCatalog.Types.PgStatSubscriptionStats>
    ;

export type PgProcOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgProcPronameArgsNspIndex = {
proname: PgCatalog.Types.Name;
proargtypes: PgCatalog.Types.Oidvector;
pronamespace: PgCatalog.Types.Oid;
}

export type PgTypeOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTypeTypnameNspIndex = {
typname: PgCatalog.Types.Name;
typnamespace: PgCatalog.Types.Oid;
}

export type PgAttributeRelidAttnamIndex = {
attrelid: PgCatalog.Types.Oid;
attname: PgCatalog.Types.Name;
}

export type PgAttributeRelidAttnumIndex = {
attrelid: PgCatalog.Types.Oid;
attnum: PgCatalog.Types.Int2;
}

export type PgClassOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgClassRelnameNspIndex = {
relname: PgCatalog.Types.Name;
relnamespace: PgCatalog.Types.Oid;
}

export type PgClassTblspcRelfilenodeIndex = {
reltablespace: PgCatalog.Types.Oid;
relfilenode: PgCatalog.Types.Oid;
}

export type PgAttrdefAdrelidAdnumIndex = {
adrelid: PgCatalog.Types.Oid;
adnum: PgCatalog.Types.Int2;
}

export type PgAttrdefOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConstraintConnameNspIndex = {
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
}

export type PgConstraintConrelidContypidConnameIndex = {
conrelid: PgCatalog.Types.Oid;
contypid: PgCatalog.Types.Oid;
conname: PgCatalog.Types.Name;
}

export type PgConstraintContypidIndex = {
contypid: PgCatalog.Types.Oid;
}

export type PgConstraintOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConstraintConparentidIndex = {
conparentid: PgCatalog.Types.Oid;
}

export type PgInheritsRelidSeqnoIndex = {
inhrelid: PgCatalog.Types.Oid;
inhseqno: PgCatalog.Types.Int4;
}

export type PgInheritsParentIndex = {
inhparent: PgCatalog.Types.Oid;
}

export type PgIndexIndrelidIndex = {
indrelid: PgCatalog.Types.Oid;
}

export type PgIndexIndexrelidIndex = {
indexrelid: PgCatalog.Types.Oid;
}

export type PgOperatorOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgOperatorOprnameLRNIndex = {
oprname: PgCatalog.Types.Name;
oprleft: PgCatalog.Types.Oid;
oprright: PgCatalog.Types.Oid;
oprnamespace: PgCatalog.Types.Oid;
}

export type PgOpfamilyAmNameNspIndex = {
opfmethod: PgCatalog.Types.Oid;
opfname: PgCatalog.Types.Name;
opfnamespace: PgCatalog.Types.Oid;
}

export type PgOpfamilyOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgOpclassAmNameNspIndex = {
opcmethod: PgCatalog.Types.Oid;
opcname: PgCatalog.Types.Name;
opcnamespace: PgCatalog.Types.Oid;
}

export type PgOpclassOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmNameIndex = {
amname: PgCatalog.Types.Name;
}

export type PgAmOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmopFamStratIndex = {
amopfamily: PgCatalog.Types.Oid;
amoplefttype: PgCatalog.Types.Oid;
amoprighttype: PgCatalog.Types.Oid;
amopstrategy: PgCatalog.Types.Int2;
}

export type PgAmopOprFamIndex = {
amopopr: PgCatalog.Types.Oid;
amoppurpose: PgCatalog.Types.Char;
amopfamily: PgCatalog.Types.Oid;
}

export type PgAmopOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAmprocFamProcIndex = {
amprocfamily: PgCatalog.Types.Oid;
amproclefttype: PgCatalog.Types.Oid;
amprocrighttype: PgCatalog.Types.Oid;
amprocnum: PgCatalog.Types.Int2;
}

export type PgAmprocOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLanguageNameIndex = {
lanname: PgCatalog.Types.Name;
}

export type PgLanguageOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLargeobjectMetadataOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgLargeobjectLoidPnIndex = {
loid: PgCatalog.Types.Oid;
pageno: PgCatalog.Types.Int4;
}

export type PgAggregateFnoidIndex = {
aggfnoid: PgCatalog.Types.Regproc;
}

export type PgStatisticRelidAttInhIndex = {
starelid: PgCatalog.Types.Oid;
staattnum: PgCatalog.Types.Int2;
stainherit: PgCatalog.Types.Bool;
}

export type PgStatisticExtOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgStatisticExtNameIndex = {
stxname: PgCatalog.Types.Name;
stxnamespace: PgCatalog.Types.Oid;
}

export type PgStatisticExtRelidIndex = {
stxrelid: PgCatalog.Types.Oid;
}

export type PgStatisticExtDataStxoidInhIndex = {
stxoid: PgCatalog.Types.Oid;
stxdinherit: PgCatalog.Types.Bool;
}

export type PgRewriteOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgRewriteRelRulenameIndex = {
evClass: PgCatalog.Types.Oid;
rulename: PgCatalog.Types.Name;
}

export type PgTriggerTgconstraintIndex = {
tgconstraint: PgCatalog.Types.Oid;
}

export type PgTriggerTgrelidTgnameIndex = {
tgrelid: PgCatalog.Types.Oid;
tgname: PgCatalog.Types.Name;
}

export type PgTriggerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgEventTriggerEvtnameIndex = {
evtname: PgCatalog.Types.Name;
}

export type PgEventTriggerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDescriptionOCOIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgCastOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgCastSourceTargetIndex = {
castsource: PgCatalog.Types.Oid;
casttarget: PgCatalog.Types.Oid;
}

export type PgEnumOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgEnumTypidLabelIndex = {
enumtypid: PgCatalog.Types.Oid;
enumlabel: PgCatalog.Types.Name;
}

export type PgEnumTypidSortorderIndex = {
enumtypid: PgCatalog.Types.Oid;
enumsortorder: PgCatalog.Types.Float4;
}

export type PgNamespaceNspnameIndex = {
nspname: PgCatalog.Types.Name;
}

export type PgNamespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgConversionDefaultIndex = {
connamespace: PgCatalog.Types.Oid;
conforencoding: PgCatalog.Types.Int4;
contoencoding: PgCatalog.Types.Int4;
oid: PgCatalog.Types.Oid;
}

export type PgConversionNameNspIndex = {
conname: PgCatalog.Types.Name;
connamespace: PgCatalog.Types.Oid;
}

export type PgConversionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDependDependerIndex = {
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgDependReferenceIndex = {
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
refobjsubid: PgCatalog.Types.Int4;
}

export type PgDatabaseDatnameIndex = {
datname: PgCatalog.Types.Name;
}

export type PgDatabaseOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgDbRoleSettingDatabaseidRolIndex = {
setdatabase: PgCatalog.Types.Oid;
setrole: PgCatalog.Types.Oid;
}

export type PgTablespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTablespaceSpcnameIndex = {
spcname: PgCatalog.Types.Name;
}

export type PgAuthidRolnameIndex = {
rolname: PgCatalog.Types.Name;
}

export type PgAuthidOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAuthMembersOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgAuthMembersRoleMemberIndex = {
roleid: PgCatalog.Types.Oid;
member: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
}

export type PgAuthMembersMemberRoleIndex = {
member: PgCatalog.Types.Oid;
roleid: PgCatalog.Types.Oid;
grantor: PgCatalog.Types.Oid;
}

export type PgAuthMembersGrantorIndex = {
grantor: PgCatalog.Types.Oid;
}

export type PgShdependDependerIndex = {
dbid: PgCatalog.Types.Oid;
classid: PgCatalog.Types.Oid;
objid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgShdependReferenceIndex = {
refclassid: PgCatalog.Types.Oid;
refobjid: PgCatalog.Types.Oid;
}

export type PgShdescriptionOCIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
}

export type PgTsConfigCfgnameIndex = {
cfgname: PgCatalog.Types.Name;
cfgnamespace: PgCatalog.Types.Oid;
}

export type PgTsConfigOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsConfigMapIndex = {
mapcfg: PgCatalog.Types.Oid;
maptokentype: PgCatalog.Types.Int4;
mapseqno: PgCatalog.Types.Int4;
}

export type PgTsDictDictnameIndex = {
dictname: PgCatalog.Types.Name;
dictnamespace: PgCatalog.Types.Oid;
}

export type PgTsDictOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsParserPrsnameIndex = {
prsname: PgCatalog.Types.Name;
prsnamespace: PgCatalog.Types.Oid;
}

export type PgTsParserOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTsTemplateTmplnameIndex = {
tmplname: PgCatalog.Types.Name;
tmplnamespace: PgCatalog.Types.Oid;
}

export type PgTsTemplateOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgExtensionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgExtensionNameIndex = {
extname: PgCatalog.Types.Name;
}

export type PgForeignDataWrapperOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgForeignDataWrapperNameIndex = {
fdwname: PgCatalog.Types.Name;
}

export type PgForeignServerOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgForeignServerNameIndex = {
srvname: PgCatalog.Types.Name;
}

export type PgUserMappingOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgUserMappingUserServerIndex = {
umuser: PgCatalog.Types.Oid;
umserver: PgCatalog.Types.Oid;
}

export type PgForeignTableRelidIndex = {
ftrelid: PgCatalog.Types.Oid;
}

export type PgPolicyOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPolicyPolrelidPolnameIndex = {
polrelid: PgCatalog.Types.Oid;
polname: PgCatalog.Types.Name;
}

export type PgReplicationOriginRoiidentIndex = {
roident: PgCatalog.Types.Oid;
}

export type PgReplicationOriginRonameIndex = {
roname: PgCatalog.Types.Text;
}

export type PgDefaultAclRoleNspObjIndex = {
defaclrole: PgCatalog.Types.Oid;
defaclnamespace: PgCatalog.Types.Oid;
defaclobjtype: PgCatalog.Types.Char;
}

export type PgDefaultAclOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgInitPrivsOCOIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
}

export type PgSeclabelObjectIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
objsubid: PgCatalog.Types.Int4;
provider: PgCatalog.Types.Text;
}

export type PgShseclabelObjectIndex = {
objoid: PgCatalog.Types.Oid;
classoid: PgCatalog.Types.Oid;
provider: PgCatalog.Types.Text;
}

export type PgCollationNameEncNspIndex = {
collname: PgCatalog.Types.Name;
collencoding: PgCatalog.Types.Int4;
collnamespace: PgCatalog.Types.Oid;
}

export type PgCollationOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgParameterAclParnameIndex = {
parname: PgCatalog.Types.Text;
}

export type PgParameterAclOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPartitionedTablePartrelidIndex = {
partrelid: PgCatalog.Types.Oid;
}

export type PgRangeRngtypidIndex = {
rngtypid: PgCatalog.Types.Oid;
}

export type PgRangeRngmultitypidIndex = {
rngmultitypid: PgCatalog.Types.Oid;
}

export type PgTransformOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgTransformTypeLangIndex = {
trftype: PgCatalog.Types.Oid;
trflang: PgCatalog.Types.Oid;
}

export type PgSequenceSeqrelidIndex = {
seqrelid: PgCatalog.Types.Oid;
}

export type PgPublicationOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationPubnameIndex = {
pubname: PgCatalog.Types.Name;
}

export type PgPublicationNamespaceOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationNamespacePnnspidPnpubidIndex = {
pnnspid: PgCatalog.Types.Oid;
pnpubid: PgCatalog.Types.Oid;
}

export type PgPublicationRelOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgPublicationRelPrrelidPrpubidIndex = {
prrelid: PgCatalog.Types.Oid;
prpubid: PgCatalog.Types.Oid;
}

export type PgPublicationRelPrpubidIndex = {
prpubid: PgCatalog.Types.Oid;
}

export type PgSubscriptionOidIndex = {
oid: PgCatalog.Types.Oid;
}

export type PgSubscriptionSubnameIndex = {
subdbid: PgCatalog.Types.Oid;
subname: PgCatalog.Types.Name;
}

export type PgSubscriptionRelSrrelidSrsubidIndex = {
srrelid: PgCatalog.Types.Oid;
srsubid: PgCatalog.Types.Oid;
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatistic> {
 return { starelid: undefined,staattnum: undefined,stainherit: undefined,stanullfrac: undefined,stawidth: undefined,stadistinct: undefined,stakind1: undefined,stakind2: undefined,stakind3: undefined,stakind4: undefined,stakind5: undefined,staop1: undefined,staop2: undefined,staop3: undefined,staop4: undefined,staop5: undefined,stacoll1: undefined,stacoll2: undefined,stacoll3: undefined,stacoll4: undefined,stacoll5: undefined,stanumbers1: undefined,stanumbers2: undefined,stanumbers3: undefined,stanumbers4: undefined,stanumbers5: undefined,stavalues1: undefined,stavalues2: undefined,stavalues3: undefined,stavalues4: undefined,stavalues5: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatistic,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatistic,  PrimaryKey>
export enum SortOptions  {
starelidAscending = "starelid ASC",
staattnumAscending = "staattnum ASC",
stainheritAscending = "stainherit ASC",
stanullfracAscending = "stanullfrac ASC",
stawidthAscending = "stawidth ASC",
stadistinctAscending = "stadistinct ASC",
stakind1Ascending = "stakind1 ASC",
stakind2Ascending = "stakind2 ASC",
stakind3Ascending = "stakind3 ASC",
stakind4Ascending = "stakind4 ASC",
stakind5Ascending = "stakind5 ASC",
staop1Ascending = "staop1 ASC",
staop2Ascending = "staop2 ASC",
staop3Ascending = "staop3 ASC",
staop4Ascending = "staop4 ASC",
staop5Ascending = "staop5 ASC",
stacoll1Ascending = "stacoll1 ASC",
stacoll2Ascending = "stacoll2 ASC",
stacoll3Ascending = "stacoll3 ASC",
stacoll4Ascending = "stacoll4 ASC",
stacoll5Ascending = "stacoll5 ASC",
stanumbers1Ascending = "stanumbers1 ASC",
stanumbers2Ascending = "stanumbers2 ASC",
stanumbers3Ascending = "stanumbers3 ASC",
stanumbers4Ascending = "stanumbers4 ASC",
stanumbers5Ascending = "stanumbers5 ASC",
stavalues1Ascending = "stavalues1 ASC",
stavalues2Ascending = "stavalues2 ASC",
stavalues3Ascending = "stavalues3 ASC",
stavalues4Ascending = "stavalues4 ASC",
stavalues5Ascending = "stavalues5 ASC",
starelidDescending = "starelid DESC",
staattnumDescending = "staattnum DESC",
stainheritDescending = "stainherit DESC",
stanullfracDescending = "stanullfrac DESC",
stawidthDescending = "stawidth DESC",
stadistinctDescending = "stadistinct DESC",
stakind1Descending = "stakind1 DESC",
stakind2Descending = "stakind2 DESC",
stakind3Descending = "stakind3 DESC",
stakind4Descending = "stakind4 DESC",
stakind5Descending = "stakind5 DESC",
staop1Descending = "staop1 DESC",
staop2Descending = "staop2 DESC",
staop3Descending = "staop3 DESC",
staop4Descending = "staop4 DESC",
staop5Descending = "staop5 DESC",
stacoll1Descending = "stacoll1 DESC",
stacoll2Descending = "stacoll2 DESC",
stacoll3Descending = "stacoll3 DESC",
stacoll4Descending = "stacoll4 DESC",
stacoll5Descending = "stacoll5 DESC",
stanumbers1Descending = "stanumbers1 DESC",
stanumbers2Descending = "stanumbers2 DESC",
stanumbers3Descending = "stanumbers3 DESC",
stanumbers4Descending = "stanumbers4 DESC",
stanumbers5Descending = "stanumbers5 DESC",
stavalues1Descending = "stavalues1 DESC",
stavalues2Descending = "stavalues2 DESC",
stavalues3Descending = "stavalues3 DESC",
stavalues4Descending = "stavalues4 DESC",
stavalues5Descending = "stavalues5 DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Starelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "starelid" as FieldNamesType,
},
Staattnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "staattnum" as FieldNamesType,
},
Stainherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "stainherit" as FieldNamesType,
},
Stanullfrac: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "stanullfrac" as FieldNamesType,
},
Stawidth: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "stawidth" as FieldNamesType,
},
Stadistinct: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "stadistinct" as FieldNamesType,
},
Stakind1: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind1" as FieldNamesType,
},
Stakind2: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind2" as FieldNamesType,
},
Stakind3: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind3" as FieldNamesType,
},
Stakind4: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind4" as FieldNamesType,
},
Stakind5: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "stakind5" as FieldNamesType,
},
Staop1: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop1" as FieldNamesType,
},
Staop2: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop2" as FieldNamesType,
},
Staop3: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop3" as FieldNamesType,
},
Staop4: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop4" as FieldNamesType,
},
Staop5: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "staop5" as FieldNamesType,
},
Stacoll1: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll1" as FieldNamesType,
},
Stacoll2: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll2" as FieldNamesType,
},
Stacoll3: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll3" as FieldNamesType,
},
Stacoll4: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll4" as FieldNamesType,
},
Stacoll5: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stacoll5" as FieldNamesType,
},
Stanumbers1: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers1" as FieldNamesType,
},
Stanumbers2: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers2" as FieldNamesType,
},
Stanumbers3: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers3" as FieldNamesType,
},
Stanumbers4: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers4" as FieldNamesType,
},
Stanumbers5: {
 typeName: "PgCatalog.Types.Float4Array",
 fieldName: "stanumbers5" as FieldNamesType,
},
Stavalues1: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues1" as FieldNamesType,
},
Stavalues2: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues2" as FieldNamesType,
},
Stavalues3: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues3" as FieldNamesType,
},
Stavalues4: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues4" as FieldNamesType,
},
Stavalues5: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "stavalues5" as FieldNamesType,
},
}
export const ColumnNames = ["Starelid","Staattnum","Stainherit","Stanullfrac","Stawidth","Stadistinct","Stakind1","Stakind2","Stakind3","Stakind4","Stakind5","Staop1","Staop2","Staop3","Staop4","Staop5","Stacoll1","Stacoll2","Stacoll3","Stacoll4","Stacoll5","Stanumbers1","Stanumbers2","Stanumbers3","Stanumbers4","Stanumbers5","Stavalues1","Stavalues2","Stavalues3","Stavalues4","Stavalues5"] as const;
export const FieldNames = ["starelid","staattnum","stainherit","stanullfrac","stawidth","stadistinct","stakind1","stakind2","stakind3","stakind4","stakind5","staop1","staop2","staop3","staop4","staop5","stacoll1","stacoll2","stacoll3","stacoll4","stacoll5","stanumbers1","stanumbers2","stanumbers3","stanumbers4","stanumbers5","stavalues1","stavalues2","stavalues3","stavalues4","stavalues5"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticRelidAttInhIndex;
}
export namespace PgType {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgType> {
 return { oid: undefined,typname: undefined,typnamespace: undefined,typowner: undefined,typlen: undefined,typbyval: undefined,typtype: undefined,typcategory: undefined,typispreferred: undefined,typisdefined: undefined,typdelim: undefined,typrelid: undefined,typsubscript: undefined,typelem: undefined,typarray: undefined,typinput: undefined,typoutput: undefined,typreceive: undefined,typsend: undefined,typmodin: undefined,typmodout: undefined,typanalyze: undefined,typalign: undefined,typstorage: undefined,typnotnull: undefined,typbasetype: undefined,typtypmod: undefined,typndims: undefined,typcollation: undefined,typdefaultbin: undefined,typdefault: undefined,typacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgType,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgType,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
typnameAscending = "typname ASC",
typnamespaceAscending = "typnamespace ASC",
typownerAscending = "typowner ASC",
typlenAscending = "typlen ASC",
typbyvalAscending = "typbyval ASC",
typtypeAscending = "typtype ASC",
typcategoryAscending = "typcategory ASC",
typispreferredAscending = "typispreferred ASC",
typisdefinedAscending = "typisdefined ASC",
typdelimAscending = "typdelim ASC",
typrelidAscending = "typrelid ASC",
typsubscriptAscending = "typsubscript ASC",
typelemAscending = "typelem ASC",
typarrayAscending = "typarray ASC",
typinputAscending = "typinput ASC",
typoutputAscending = "typoutput ASC",
typreceiveAscending = "typreceive ASC",
typsendAscending = "typsend ASC",
typmodinAscending = "typmodin ASC",
typmodoutAscending = "typmodout ASC",
typanalyzeAscending = "typanalyze ASC",
typalignAscending = "typalign ASC",
typstorageAscending = "typstorage ASC",
typnotnullAscending = "typnotnull ASC",
typbasetypeAscending = "typbasetype ASC",
typtypmodAscending = "typtypmod ASC",
typndimsAscending = "typndims ASC",
typcollationAscending = "typcollation ASC",
typdefaultbinAscending = "typdefaultbin ASC",
typdefaultAscending = "typdefault ASC",
typaclAscending = "typacl ASC",
oidDescending = "oid DESC",
typnameDescending = "typname DESC",
typnamespaceDescending = "typnamespace DESC",
typownerDescending = "typowner DESC",
typlenDescending = "typlen DESC",
typbyvalDescending = "typbyval DESC",
typtypeDescending = "typtype DESC",
typcategoryDescending = "typcategory DESC",
typispreferredDescending = "typispreferred DESC",
typisdefinedDescending = "typisdefined DESC",
typdelimDescending = "typdelim DESC",
typrelidDescending = "typrelid DESC",
typsubscriptDescending = "typsubscript DESC",
typelemDescending = "typelem DESC",
typarrayDescending = "typarray DESC",
typinputDescending = "typinput DESC",
typoutputDescending = "typoutput DESC",
typreceiveDescending = "typreceive DESC",
typsendDescending = "typsend DESC",
typmodinDescending = "typmodin DESC",
typmodoutDescending = "typmodout DESC",
typanalyzeDescending = "typanalyze DESC",
typalignDescending = "typalign DESC",
typstorageDescending = "typstorage DESC",
typnotnullDescending = "typnotnull DESC",
typbasetypeDescending = "typbasetype DESC",
typtypmodDescending = "typtypmod DESC",
typndimsDescending = "typndims DESC",
typcollationDescending = "typcollation DESC",
typdefaultbinDescending = "typdefaultbin DESC",
typdefaultDescending = "typdefault DESC",
typaclDescending = "typacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Typname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "typname" as FieldNamesType,
},
Typnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typnamespace" as FieldNamesType,
},
Typowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typowner" as FieldNamesType,
},
Typlen: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "typlen" as FieldNamesType,
},
Typbyval: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typbyval" as FieldNamesType,
},
Typtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typtype" as FieldNamesType,
},
Typcategory: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typcategory" as FieldNamesType,
},
Typispreferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typispreferred" as FieldNamesType,
},
Typisdefined: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typisdefined" as FieldNamesType,
},
Typdelim: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typdelim" as FieldNamesType,
},
Typrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typrelid" as FieldNamesType,
},
Typsubscript: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typsubscript" as FieldNamesType,
},
Typelem: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typelem" as FieldNamesType,
},
Typarray: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typarray" as FieldNamesType,
},
Typinput: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typinput" as FieldNamesType,
},
Typoutput: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typoutput" as FieldNamesType,
},
Typreceive: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typreceive" as FieldNamesType,
},
Typsend: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typsend" as FieldNamesType,
},
Typmodin: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typmodin" as FieldNamesType,
},
Typmodout: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typmodout" as FieldNamesType,
},
Typanalyze: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "typanalyze" as FieldNamesType,
},
Typalign: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typalign" as FieldNamesType,
},
Typstorage: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "typstorage" as FieldNamesType,
},
Typnotnull: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "typnotnull" as FieldNamesType,
},
Typbasetype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typbasetype" as FieldNamesType,
},
Typtypmod: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "typtypmod" as FieldNamesType,
},
Typndims: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "typndims" as FieldNamesType,
},
Typcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "typcollation" as FieldNamesType,
},
Typdefaultbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "typdefaultbin" as FieldNamesType,
},
Typdefault: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "typdefault" as FieldNamesType,
},
Typacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "typacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Typname","Typnamespace","Typowner","Typlen","Typbyval","Typtype","Typcategory","Typispreferred","Typisdefined","Typdelim","Typrelid","Typsubscript","Typelem","Typarray","Typinput","Typoutput","Typreceive","Typsend","Typmodin","Typmodout","Typanalyze","Typalign","Typstorage","Typnotnull","Typbasetype","Typtypmod","Typndims","Typcollation","Typdefaultbin","Typdefault","Typacl"] as const;
export const FieldNames = ["oid","typname","typnamespace","typowner","typlen","typbyval","typtype","typcategory","typispreferred","typisdefined","typdelim","typrelid","typsubscript","typelem","typarray","typinput","typoutput","typreceive","typsend","typmodin","typmodout","typanalyze","typalign","typstorage","typnotnull","typbasetype","typtypmod","typndims","typcollation","typdefaultbin","typdefault","typacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTypeOidIndex;
}
export namespace PgForeignTable {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignTable> {
 return { ftrelid: undefined,ftserver: undefined,ftoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignTable,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignTable,  PrimaryKey>
export enum SortOptions  {
ftrelidAscending = "ftrelid ASC",
ftserverAscending = "ftserver ASC",
ftoptionsAscending = "ftoptions ASC",
ftrelidDescending = "ftrelid DESC",
ftserverDescending = "ftserver DESC",
ftoptionsDescending = "ftoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Ftrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "ftrelid" as FieldNamesType,
},
Ftserver: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "ftserver" as FieldNamesType,
},
Ftoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "ftoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Ftrelid","Ftserver","Ftoptions"] as const;
export const FieldNames = ["ftrelid","ftserver","ftoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignTableRelidIndex;
}
export namespace PgAuthid {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAuthid> {
 return { oid: undefined,rolname: undefined,rolsuper: undefined,rolinherit: undefined,rolcreaterole: undefined,rolcreatedb: undefined,rolcanlogin: undefined,rolreplication: undefined,rolbypassrls: undefined,rolconnlimit: undefined,rolpassword: undefined,rolvaliduntil: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAuthid,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAuthid,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
rolnameAscending = "rolname ASC",
rolsuperAscending = "rolsuper ASC",
rolinheritAscending = "rolinherit ASC",
rolcreateroleAscending = "rolcreaterole ASC",
rolcreatedbAscending = "rolcreatedb ASC",
rolcanloginAscending = "rolcanlogin ASC",
rolreplicationAscending = "rolreplication ASC",
rolbypassrlsAscending = "rolbypassrls ASC",
rolconnlimitAscending = "rolconnlimit ASC",
rolpasswordAscending = "rolpassword ASC",
rolvaliduntilAscending = "rolvaliduntil ASC",
oidDescending = "oid DESC",
rolnameDescending = "rolname DESC",
rolsuperDescending = "rolsuper DESC",
rolinheritDescending = "rolinherit DESC",
rolcreateroleDescending = "rolcreaterole DESC",
rolcreatedbDescending = "rolcreatedb DESC",
rolcanloginDescending = "rolcanlogin DESC",
rolreplicationDescending = "rolreplication DESC",
rolbypassrlsDescending = "rolbypassrls DESC",
rolconnlimitDescending = "rolconnlimit DESC",
rolpasswordDescending = "rolpassword DESC",
rolvaliduntilDescending = "rolvaliduntil DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Rolname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "rolname" as FieldNamesType,
},
Rolsuper: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolsuper" as FieldNamesType,
},
Rolinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolinherit" as FieldNamesType,
},
Rolcreaterole: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcreaterole" as FieldNamesType,
},
Rolcreatedb: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcreatedb" as FieldNamesType,
},
Rolcanlogin: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolcanlogin" as FieldNamesType,
},
Rolreplication: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolreplication" as FieldNamesType,
},
Rolbypassrls: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "rolbypassrls" as FieldNamesType,
},
Rolconnlimit: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "rolconnlimit" as FieldNamesType,
},
Rolpassword: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "rolpassword" as FieldNamesType,
},
Rolvaliduntil: {
 typeName: "PgCatalog.Types.Timestamptz",
 fieldName: "rolvaliduntil" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Rolname","Rolsuper","Rolinherit","Rolcreaterole","Rolcreatedb","Rolcanlogin","Rolreplication","Rolbypassrls","Rolconnlimit","Rolpassword","Rolvaliduntil"] as const;
export const FieldNames = ["oid","rolname","rolsuper","rolinherit","rolcreaterole","rolcreatedb","rolcanlogin","rolreplication","rolbypassrls","rolconnlimit","rolpassword","rolvaliduntil"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAuthidOidIndex;
}
export namespace PgStatisticExtData {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatisticExtData> {
 return { stxoid: undefined,stxdinherit: undefined,stxdndistinct: undefined,stxddependencies: undefined,stxdmcv: undefined,stxdexpr: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatisticExtData,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatisticExtData,  PrimaryKey>
export enum SortOptions  {
stxoidAscending = "stxoid ASC",
stxdinheritAscending = "stxdinherit ASC",
stxdndistinctAscending = "stxdndistinct ASC",
stxddependenciesAscending = "stxddependencies ASC",
stxdmcvAscending = "stxdmcv ASC",
stxdexprAscending = "stxdexpr ASC",
stxoidDescending = "stxoid DESC",
stxdinheritDescending = "stxdinherit DESC",
stxdndistinctDescending = "stxdndistinct DESC",
stxddependenciesDescending = "stxddependencies DESC",
stxdmcvDescending = "stxdmcv DESC",
stxdexprDescending = "stxdexpr DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Stxoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxoid" as FieldNamesType,
},
Stxdinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "stxdinherit" as FieldNamesType,
},
Stxdndistinct: {
 typeName: "PgCatalog.Types.PgNdistinct",
 fieldName: "stxdndistinct" as FieldNamesType,
},
Stxddependencies: {
 typeName: "PgCatalog.Types.PgDependencies",
 fieldName: "stxddependencies" as FieldNamesType,
},
Stxdmcv: {
 typeName: "PgCatalog.Types.PgMcvList",
 fieldName: "stxdmcv" as FieldNamesType,
},
Stxdexpr: {
 typeName: "PgCatalog.Types.PgStatisticArray",
 fieldName: "stxdexpr" as FieldNamesType,
},
}
export const ColumnNames = ["Stxoid","Stxdinherit","Stxdndistinct","Stxddependencies","Stxdmcv","Stxdexpr"] as const;
export const FieldNames = ["stxoid","stxdinherit","stxdndistinct","stxddependencies","stxdmcv","stxdexpr"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticExtDataStxoidInhIndex;
}
export namespace PgUserMapping {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgUserMapping> {
 return { oid: undefined,umuser: undefined,umserver: undefined,umoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgUserMapping,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgUserMapping,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
umuserAscending = "umuser ASC",
umserverAscending = "umserver ASC",
umoptionsAscending = "umoptions ASC",
oidDescending = "oid DESC",
umuserDescending = "umuser DESC",
umserverDescending = "umserver DESC",
umoptionsDescending = "umoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Umuser: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "umuser" as FieldNamesType,
},
Umserver: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "umserver" as FieldNamesType,
},
Umoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "umoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Umuser","Umserver","Umoptions"] as const;
export const FieldNames = ["oid","umuser","umserver","umoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgUserMappingOidIndex;
}
export namespace PgSubscription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSubscription> {
 return { oid: undefined,subdbid: undefined,subskiplsn: undefined,subname: undefined,subowner: undefined,subenabled: undefined,subbinary: undefined,substream: undefined,subtwophasestate: undefined,subdisableonerr: undefined,subpasswordrequired: undefined,subrunasowner: undefined,subconninfo: undefined,subslotname: undefined,subsynccommit: undefined,subpublications: undefined,suborigin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSubscription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSubscription,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
subdbidAscending = "subdbid ASC",
subskiplsnAscending = "subskiplsn ASC",
subnameAscending = "subname ASC",
subownerAscending = "subowner ASC",
subenabledAscending = "subenabled ASC",
subbinaryAscending = "subbinary ASC",
substreamAscending = "substream ASC",
subtwophasestateAscending = "subtwophasestate ASC",
subdisableonerrAscending = "subdisableonerr ASC",
subpasswordrequiredAscending = "subpasswordrequired ASC",
subrunasownerAscending = "subrunasowner ASC",
subconninfoAscending = "subconninfo ASC",
subslotnameAscending = "subslotname ASC",
subsynccommitAscending = "subsynccommit ASC",
subpublicationsAscending = "subpublications ASC",
suboriginAscending = "suborigin ASC",
oidDescending = "oid DESC",
subdbidDescending = "subdbid DESC",
subskiplsnDescending = "subskiplsn DESC",
subnameDescending = "subname DESC",
subownerDescending = "subowner DESC",
subenabledDescending = "subenabled DESC",
subbinaryDescending = "subbinary DESC",
substreamDescending = "substream DESC",
subtwophasestateDescending = "subtwophasestate DESC",
subdisableonerrDescending = "subdisableonerr DESC",
subpasswordrequiredDescending = "subpasswordrequired DESC",
subrunasownerDescending = "subrunasowner DESC",
subconninfoDescending = "subconninfo DESC",
subslotnameDescending = "subslotname DESC",
subsynccommitDescending = "subsynccommit DESC",
subpublicationsDescending = "subpublications DESC",
suboriginDescending = "suborigin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Subdbid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "subdbid" as FieldNamesType,
},
Subskiplsn: {
 typeName: "PgCatalog.Types.PgLsn",
 fieldName: "subskiplsn" as FieldNamesType,
},
Subname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "subname" as FieldNamesType,
},
Subowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "subowner" as FieldNamesType,
},
Subenabled: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subenabled" as FieldNamesType,
},
Subbinary: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subbinary" as FieldNamesType,
},
Substream: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "substream" as FieldNamesType,
},
Subtwophasestate: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "subtwophasestate" as FieldNamesType,
},
Subdisableonerr: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subdisableonerr" as FieldNamesType,
},
Subpasswordrequired: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subpasswordrequired" as FieldNamesType,
},
Subrunasowner: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "subrunasowner" as FieldNamesType,
},
Subconninfo: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "subconninfo" as FieldNamesType,
},
Subslotname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "subslotname" as FieldNamesType,
},
Subsynccommit: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "subsynccommit" as FieldNamesType,
},
Subpublications: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "subpublications" as FieldNamesType,
},
Suborigin: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "suborigin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Subdbid","Subskiplsn","Subname","Subowner","Subenabled","Subbinary","Substream","Subtwophasestate","Subdisableonerr","Subpasswordrequired","Subrunasowner","Subconninfo","Subslotname","Subsynccommit","Subpublications","Suborigin"] as const;
export const FieldNames = ["oid","subdbid","subskiplsn","subname","subowner","subenabled","subbinary","substream","subtwophasestate","subdisableonerr","subpasswordrequired","subrunasowner","subconninfo","subslotname","subsynccommit","subpublications","suborigin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSubscriptionOidIndex;
}
export namespace PgAttribute {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAttribute> {
 return { attrelid: undefined,attname: undefined,atttypid: undefined,attlen: undefined,attnum: undefined,attcacheoff: undefined,atttypmod: undefined,attndims: undefined,attbyval: undefined,attalign: undefined,attstorage: undefined,attcompression: undefined,attnotnull: undefined,atthasdef: undefined,atthasmissing: undefined,attidentity: undefined,attgenerated: undefined,attisdropped: undefined,attislocal: undefined,attinhcount: undefined,attstattarget: undefined,attcollation: undefined,attacl: undefined,attoptions: undefined,attfdwoptions: undefined,attmissingval: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAttribute,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAttribute,  PrimaryKey>
export enum SortOptions  {
attrelidAscending = "attrelid ASC",
attnameAscending = "attname ASC",
atttypidAscending = "atttypid ASC",
attlenAscending = "attlen ASC",
attnumAscending = "attnum ASC",
attcacheoffAscending = "attcacheoff ASC",
atttypmodAscending = "atttypmod ASC",
attndimsAscending = "attndims ASC",
attbyvalAscending = "attbyval ASC",
attalignAscending = "attalign ASC",
attstorageAscending = "attstorage ASC",
attcompressionAscending = "attcompression ASC",
attnotnullAscending = "attnotnull ASC",
atthasdefAscending = "atthasdef ASC",
atthasmissingAscending = "atthasmissing ASC",
attidentityAscending = "attidentity ASC",
attgeneratedAscending = "attgenerated ASC",
attisdroppedAscending = "attisdropped ASC",
attislocalAscending = "attislocal ASC",
attinhcountAscending = "attinhcount ASC",
attstattargetAscending = "attstattarget ASC",
attcollationAscending = "attcollation ASC",
attaclAscending = "attacl ASC",
attoptionsAscending = "attoptions ASC",
attfdwoptionsAscending = "attfdwoptions ASC",
attmissingvalAscending = "attmissingval ASC",
attrelidDescending = "attrelid DESC",
attnameDescending = "attname DESC",
atttypidDescending = "atttypid DESC",
attlenDescending = "attlen DESC",
attnumDescending = "attnum DESC",
attcacheoffDescending = "attcacheoff DESC",
atttypmodDescending = "atttypmod DESC",
attndimsDescending = "attndims DESC",
attbyvalDescending = "attbyval DESC",
attalignDescending = "attalign DESC",
attstorageDescending = "attstorage DESC",
attcompressionDescending = "attcompression DESC",
attnotnullDescending = "attnotnull DESC",
atthasdefDescending = "atthasdef DESC",
atthasmissingDescending = "atthasmissing DESC",
attidentityDescending = "attidentity DESC",
attgeneratedDescending = "attgenerated DESC",
attisdroppedDescending = "attisdropped DESC",
attislocalDescending = "attislocal DESC",
attinhcountDescending = "attinhcount DESC",
attstattargetDescending = "attstattarget DESC",
attcollationDescending = "attcollation DESC",
attaclDescending = "attacl DESC",
attoptionsDescending = "attoptions DESC",
attfdwoptionsDescending = "attfdwoptions DESC",
attmissingvalDescending = "attmissingval DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Attrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "attrelid" as FieldNamesType,
},
Attname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "attname" as FieldNamesType,
},
Atttypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "atttypid" as FieldNamesType,
},
Attlen: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attlen" as FieldNamesType,
},
Attnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attnum" as FieldNamesType,
},
Attcacheoff: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "attcacheoff" as FieldNamesType,
},
Atttypmod: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "atttypmod" as FieldNamesType,
},
Attndims: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attndims" as FieldNamesType,
},
Attbyval: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attbyval" as FieldNamesType,
},
Attalign: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attalign" as FieldNamesType,
},
Attstorage: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attstorage" as FieldNamesType,
},
Attcompression: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attcompression" as FieldNamesType,
},
Attnotnull: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attnotnull" as FieldNamesType,
},
Atthasdef: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "atthasdef" as FieldNamesType,
},
Atthasmissing: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "atthasmissing" as FieldNamesType,
},
Attidentity: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attidentity" as FieldNamesType,
},
Attgenerated: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "attgenerated" as FieldNamesType,
},
Attisdropped: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attisdropped" as FieldNamesType,
},
Attislocal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "attislocal" as FieldNamesType,
},
Attinhcount: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attinhcount" as FieldNamesType,
},
Attstattarget: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "attstattarget" as FieldNamesType,
},
Attcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "attcollation" as FieldNamesType,
},
Attacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "attacl" as FieldNamesType,
},
Attoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "attoptions" as FieldNamesType,
},
Attfdwoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "attfdwoptions" as FieldNamesType,
},
Attmissingval: {
 typeName: "PgCatalog.Types.Anyarray",
 fieldName: "attmissingval" as FieldNamesType,
},
}
export const ColumnNames = ["Attrelid","Attname","Atttypid","Attlen","Attnum","Attcacheoff","Atttypmod","Attndims","Attbyval","Attalign","Attstorage","Attcompression","Attnotnull","Atthasdef","Atthasmissing","Attidentity","Attgenerated","Attisdropped","Attislocal","Attinhcount","Attstattarget","Attcollation","Attacl","Attoptions","Attfdwoptions","Attmissingval"] as const;
export const FieldNames = ["attrelid","attname","atttypid","attlen","attnum","attcacheoff","atttypmod","attndims","attbyval","attalign","attstorage","attcompression","attnotnull","atthasdef","atthasmissing","attidentity","attgenerated","attisdropped","attislocal","attinhcount","attstattarget","attcollation","attacl","attoptions","attfdwoptions","attmissingval"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAttributeRelidAttnumIndex;
}
export namespace PgProc {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgProc> {
 return { oid: undefined,proname: undefined,pronamespace: undefined,proowner: undefined,prolang: undefined,procost: undefined,prorows: undefined,provariadic: undefined,prosupport: undefined,prokind: undefined,prosecdef: undefined,proleakproof: undefined,proisstrict: undefined,proretset: undefined,provolatile: undefined,proparallel: undefined,pronargs: undefined,pronargdefaults: undefined,prorettype: undefined,proargtypes: undefined,proallargtypes: undefined,proargmodes: undefined,proargnames: undefined,proargdefaults: undefined,protrftypes: undefined,prosrc: undefined,probin: undefined,prosqlbody: undefined,proconfig: undefined,proacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgProc,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgProc,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pronameAscending = "proname ASC",
pronamespaceAscending = "pronamespace ASC",
proownerAscending = "proowner ASC",
prolangAscending = "prolang ASC",
procostAscending = "procost ASC",
prorowsAscending = "prorows ASC",
provariadicAscending = "provariadic ASC",
prosupportAscending = "prosupport ASC",
prokindAscending = "prokind ASC",
prosecdefAscending = "prosecdef ASC",
proleakproofAscending = "proleakproof ASC",
proisstrictAscending = "proisstrict ASC",
proretsetAscending = "proretset ASC",
provolatileAscending = "provolatile ASC",
proparallelAscending = "proparallel ASC",
pronargsAscending = "pronargs ASC",
pronargdefaultsAscending = "pronargdefaults ASC",
prorettypeAscending = "prorettype ASC",
proargtypesAscending = "proargtypes ASC",
proallargtypesAscending = "proallargtypes ASC",
proargmodesAscending = "proargmodes ASC",
proargnamesAscending = "proargnames ASC",
proargdefaultsAscending = "proargdefaults ASC",
protrftypesAscending = "protrftypes ASC",
prosrcAscending = "prosrc ASC",
probinAscending = "probin ASC",
prosqlbodyAscending = "prosqlbody ASC",
proconfigAscending = "proconfig ASC",
proaclAscending = "proacl ASC",
oidDescending = "oid DESC",
pronameDescending = "proname DESC",
pronamespaceDescending = "pronamespace DESC",
proownerDescending = "proowner DESC",
prolangDescending = "prolang DESC",
procostDescending = "procost DESC",
prorowsDescending = "prorows DESC",
provariadicDescending = "provariadic DESC",
prosupportDescending = "prosupport DESC",
prokindDescending = "prokind DESC",
prosecdefDescending = "prosecdef DESC",
proleakproofDescending = "proleakproof DESC",
proisstrictDescending = "proisstrict DESC",
proretsetDescending = "proretset DESC",
provolatileDescending = "provolatile DESC",
proparallelDescending = "proparallel DESC",
pronargsDescending = "pronargs DESC",
pronargdefaultsDescending = "pronargdefaults DESC",
prorettypeDescending = "prorettype DESC",
proargtypesDescending = "proargtypes DESC",
proallargtypesDescending = "proallargtypes DESC",
proargmodesDescending = "proargmodes DESC",
proargnamesDescending = "proargnames DESC",
proargdefaultsDescending = "proargdefaults DESC",
protrftypesDescending = "protrftypes DESC",
prosrcDescending = "prosrc DESC",
probinDescending = "probin DESC",
prosqlbodyDescending = "prosqlbody DESC",
proconfigDescending = "proconfig DESC",
proaclDescending = "proacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Proname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "proname" as FieldNamesType,
},
Pronamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pronamespace" as FieldNamesType,
},
Proowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "proowner" as FieldNamesType,
},
Prolang: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prolang" as FieldNamesType,
},
Procost: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "procost" as FieldNamesType,
},
Prorows: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "prorows" as FieldNamesType,
},
Provariadic: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "provariadic" as FieldNamesType,
},
Prosupport: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prosupport" as FieldNamesType,
},
Prokind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "prokind" as FieldNamesType,
},
Prosecdef: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "prosecdef" as FieldNamesType,
},
Proleakproof: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proleakproof" as FieldNamesType,
},
Proisstrict: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proisstrict" as FieldNamesType,
},
Proretset: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "proretset" as FieldNamesType,
},
Provolatile: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "provolatile" as FieldNamesType,
},
Proparallel: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "proparallel" as FieldNamesType,
},
Pronargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "pronargs" as FieldNamesType,
},
Pronargdefaults: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "pronargdefaults" as FieldNamesType,
},
Prorettype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prorettype" as FieldNamesType,
},
Proargtypes: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "proargtypes" as FieldNamesType,
},
Proallargtypes: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "proallargtypes" as FieldNamesType,
},
Proargmodes: {
 typeName: "PgCatalog.Types.CharArray",
 fieldName: "proargmodes" as FieldNamesType,
},
Proargnames: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "proargnames" as FieldNamesType,
},
Proargdefaults: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "proargdefaults" as FieldNamesType,
},
Protrftypes: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "protrftypes" as FieldNamesType,
},
Prosrc: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "prosrc" as FieldNamesType,
},
Probin: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "probin" as FieldNamesType,
},
Prosqlbody: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "prosqlbody" as FieldNamesType,
},
Proconfig: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "proconfig" as FieldNamesType,
},
Proacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "proacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Proname","Pronamespace","Proowner","Prolang","Procost","Prorows","Provariadic","Prosupport","Prokind","Prosecdef","Proleakproof","Proisstrict","Proretset","Provolatile","Proparallel","Pronargs","Pronargdefaults","Prorettype","Proargtypes","Proallargtypes","Proargmodes","Proargnames","Proargdefaults","Protrftypes","Prosrc","Probin","Prosqlbody","Proconfig","Proacl"] as const;
export const FieldNames = ["oid","proname","pronamespace","proowner","prolang","procost","prorows","provariadic","prosupport","prokind","prosecdef","proleakproof","proisstrict","proretset","provolatile","proparallel","pronargs","pronargdefaults","prorettype","proargtypes","proallargtypes","proargmodes","proargnames","proargdefaults","protrftypes","prosrc","probin","prosqlbody","proconfig","proacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgProcOidIndex;
}
export namespace PgClass {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgClass> {
 return { oid: undefined,relname: undefined,relnamespace: undefined,reltype: undefined,reloftype: undefined,relowner: undefined,relam: undefined,relfilenode: undefined,reltablespace: undefined,relpages: undefined,reltuples: undefined,relallvisible: undefined,reltoastrelid: undefined,relhasindex: undefined,relisshared: undefined,relpersistence: undefined,relkind: undefined,relnatts: undefined,relchecks: undefined,relhasrules: undefined,relhastriggers: undefined,relhassubclass: undefined,relrowsecurity: undefined,relforcerowsecurity: undefined,relispopulated: undefined,relreplident: undefined,relispartition: undefined,relrewrite: undefined,relfrozenxid: undefined,relminmxid: undefined,relacl: undefined,reloptions: undefined,relpartbound: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgClass,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgClass,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
relnameAscending = "relname ASC",
relnamespaceAscending = "relnamespace ASC",
reltypeAscending = "reltype ASC",
reloftypeAscending = "reloftype ASC",
relownerAscending = "relowner ASC",
relamAscending = "relam ASC",
relfilenodeAscending = "relfilenode ASC",
reltablespaceAscending = "reltablespace ASC",
relpagesAscending = "relpages ASC",
reltuplesAscending = "reltuples ASC",
relallvisibleAscending = "relallvisible ASC",
reltoastrelidAscending = "reltoastrelid ASC",
relhasindexAscending = "relhasindex ASC",
relissharedAscending = "relisshared ASC",
relpersistenceAscending = "relpersistence ASC",
relkindAscending = "relkind ASC",
relnattsAscending = "relnatts ASC",
relchecksAscending = "relchecks ASC",
relhasrulesAscending = "relhasrules ASC",
relhastriggersAscending = "relhastriggers ASC",
relhassubclassAscending = "relhassubclass ASC",
relrowsecurityAscending = "relrowsecurity ASC",
relforcerowsecurityAscending = "relforcerowsecurity ASC",
relispopulatedAscending = "relispopulated ASC",
relreplidentAscending = "relreplident ASC",
relispartitionAscending = "relispartition ASC",
relrewriteAscending = "relrewrite ASC",
relfrozenxidAscending = "relfrozenxid ASC",
relminmxidAscending = "relminmxid ASC",
relaclAscending = "relacl ASC",
reloptionsAscending = "reloptions ASC",
relpartboundAscending = "relpartbound ASC",
oidDescending = "oid DESC",
relnameDescending = "relname DESC",
relnamespaceDescending = "relnamespace DESC",
reltypeDescending = "reltype DESC",
reloftypeDescending = "reloftype DESC",
relownerDescending = "relowner DESC",
relamDescending = "relam DESC",
relfilenodeDescending = "relfilenode DESC",
reltablespaceDescending = "reltablespace DESC",
relpagesDescending = "relpages DESC",
reltuplesDescending = "reltuples DESC",
relallvisibleDescending = "relallvisible DESC",
reltoastrelidDescending = "reltoastrelid DESC",
relhasindexDescending = "relhasindex DESC",
relissharedDescending = "relisshared DESC",
relpersistenceDescending = "relpersistence DESC",
relkindDescending = "relkind DESC",
relnattsDescending = "relnatts DESC",
relchecksDescending = "relchecks DESC",
relhasrulesDescending = "relhasrules DESC",
relhastriggersDescending = "relhastriggers DESC",
relhassubclassDescending = "relhassubclass DESC",
relrowsecurityDescending = "relrowsecurity DESC",
relforcerowsecurityDescending = "relforcerowsecurity DESC",
relispopulatedDescending = "relispopulated DESC",
relreplidentDescending = "relreplident DESC",
relispartitionDescending = "relispartition DESC",
relrewriteDescending = "relrewrite DESC",
relfrozenxidDescending = "relfrozenxid DESC",
relminmxidDescending = "relminmxid DESC",
relaclDescending = "relacl DESC",
reloptionsDescending = "reloptions DESC",
relpartboundDescending = "relpartbound DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Relname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "relname" as FieldNamesType,
},
Relnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relnamespace" as FieldNamesType,
},
Reltype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltype" as FieldNamesType,
},
Reloftype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reloftype" as FieldNamesType,
},
Relowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relowner" as FieldNamesType,
},
Relam: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relam" as FieldNamesType,
},
Relfilenode: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relfilenode" as FieldNamesType,
},
Reltablespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltablespace" as FieldNamesType,
},
Relpages: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "relpages" as FieldNamesType,
},
Reltuples: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "reltuples" as FieldNamesType,
},
Relallvisible: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "relallvisible" as FieldNamesType,
},
Reltoastrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "reltoastrelid" as FieldNamesType,
},
Relhasindex: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhasindex" as FieldNamesType,
},
Relisshared: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relisshared" as FieldNamesType,
},
Relpersistence: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relpersistence" as FieldNamesType,
},
Relkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relkind" as FieldNamesType,
},
Relnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "relnatts" as FieldNamesType,
},
Relchecks: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "relchecks" as FieldNamesType,
},
Relhasrules: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhasrules" as FieldNamesType,
},
Relhastriggers: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhastriggers" as FieldNamesType,
},
Relhassubclass: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relhassubclass" as FieldNamesType,
},
Relrowsecurity: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relrowsecurity" as FieldNamesType,
},
Relforcerowsecurity: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relforcerowsecurity" as FieldNamesType,
},
Relispopulated: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relispopulated" as FieldNamesType,
},
Relreplident: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "relreplident" as FieldNamesType,
},
Relispartition: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "relispartition" as FieldNamesType,
},
Relrewrite: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "relrewrite" as FieldNamesType,
},
Relfrozenxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "relfrozenxid" as FieldNamesType,
},
Relminmxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "relminmxid" as FieldNamesType,
},
Relacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "relacl" as FieldNamesType,
},
Reloptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "reloptions" as FieldNamesType,
},
Relpartbound: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "relpartbound" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Relname","Relnamespace","Reltype","Reloftype","Relowner","Relam","Relfilenode","Reltablespace","Relpages","Reltuples","Relallvisible","Reltoastrelid","Relhasindex","Relisshared","Relpersistence","Relkind","Relnatts","Relchecks","Relhasrules","Relhastriggers","Relhassubclass","Relrowsecurity","Relforcerowsecurity","Relispopulated","Relreplident","Relispartition","Relrewrite","Relfrozenxid","Relminmxid","Relacl","Reloptions","Relpartbound"] as const;
export const FieldNames = ["oid","relname","relnamespace","reltype","reloftype","relowner","relam","relfilenode","reltablespace","relpages","reltuples","relallvisible","reltoastrelid","relhasindex","relisshared","relpersistence","relkind","relnatts","relchecks","relhasrules","relhastriggers","relhassubclass","relrowsecurity","relforcerowsecurity","relispopulated","relreplident","relispartition","relrewrite","relfrozenxid","relminmxid","relacl","reloptions","relpartbound"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgClassOidIndex;
}
export namespace PgAttrdef {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAttrdef> {
 return { oid: undefined,adrelid: undefined,adnum: undefined,adbin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAttrdef,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAttrdef,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
adrelidAscending = "adrelid ASC",
adnumAscending = "adnum ASC",
adbinAscending = "adbin ASC",
oidDescending = "oid DESC",
adrelidDescending = "adrelid DESC",
adnumDescending = "adnum DESC",
adbinDescending = "adbin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Adrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "adrelid" as FieldNamesType,
},
Adnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "adnum" as FieldNamesType,
},
Adbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "adbin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Adrelid","Adnum","Adbin"] as const;
export const FieldNames = ["oid","adrelid","adnum","adbin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAttrdefOidIndex;
}
export namespace PgConstraint {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgConstraint> {
 return { oid: undefined,conname: undefined,connamespace: undefined,contype: undefined,condeferrable: undefined,condeferred: undefined,convalidated: undefined,conrelid: undefined,contypid: undefined,conindid: undefined,conparentid: undefined,confrelid: undefined,confupdtype: undefined,confdeltype: undefined,confmatchtype: undefined,conislocal: undefined,coninhcount: undefined,connoinherit: undefined,conkey: undefined,confkey: undefined,conpfeqop: undefined,conppeqop: undefined,conffeqop: undefined,confdelsetcols: undefined,conexclop: undefined,conbin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgConstraint,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgConstraint,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
connameAscending = "conname ASC",
connamespaceAscending = "connamespace ASC",
contypeAscending = "contype ASC",
condeferrableAscending = "condeferrable ASC",
condeferredAscending = "condeferred ASC",
convalidatedAscending = "convalidated ASC",
conrelidAscending = "conrelid ASC",
contypidAscending = "contypid ASC",
conindidAscending = "conindid ASC",
conparentidAscending = "conparentid ASC",
confrelidAscending = "confrelid ASC",
confupdtypeAscending = "confupdtype ASC",
confdeltypeAscending = "confdeltype ASC",
confmatchtypeAscending = "confmatchtype ASC",
conislocalAscending = "conislocal ASC",
coninhcountAscending = "coninhcount ASC",
connoinheritAscending = "connoinherit ASC",
conkeyAscending = "conkey ASC",
confkeyAscending = "confkey ASC",
conpfeqopAscending = "conpfeqop ASC",
conppeqopAscending = "conppeqop ASC",
conffeqopAscending = "conffeqop ASC",
confdelsetcolsAscending = "confdelsetcols ASC",
conexclopAscending = "conexclop ASC",
conbinAscending = "conbin ASC",
oidDescending = "oid DESC",
connameDescending = "conname DESC",
connamespaceDescending = "connamespace DESC",
contypeDescending = "contype DESC",
condeferrableDescending = "condeferrable DESC",
condeferredDescending = "condeferred DESC",
convalidatedDescending = "convalidated DESC",
conrelidDescending = "conrelid DESC",
contypidDescending = "contypid DESC",
conindidDescending = "conindid DESC",
conparentidDescending = "conparentid DESC",
confrelidDescending = "confrelid DESC",
confupdtypeDescending = "confupdtype DESC",
confdeltypeDescending = "confdeltype DESC",
confmatchtypeDescending = "confmatchtype DESC",
conislocalDescending = "conislocal DESC",
coninhcountDescending = "coninhcount DESC",
connoinheritDescending = "connoinherit DESC",
conkeyDescending = "conkey DESC",
confkeyDescending = "confkey DESC",
conpfeqopDescending = "conpfeqop DESC",
conppeqopDescending = "conppeqop DESC",
conffeqopDescending = "conffeqop DESC",
confdelsetcolsDescending = "confdelsetcols DESC",
conexclopDescending = "conexclop DESC",
conbinDescending = "conbin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Conname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "conname" as FieldNamesType,
},
Connamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "connamespace" as FieldNamesType,
},
Contype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "contype" as FieldNamesType,
},
Condeferrable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condeferrable" as FieldNamesType,
},
Condeferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condeferred" as FieldNamesType,
},
Convalidated: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "convalidated" as FieldNamesType,
},
Conrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conrelid" as FieldNamesType,
},
Contypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "contypid" as FieldNamesType,
},
Conindid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conindid" as FieldNamesType,
},
Conparentid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conparentid" as FieldNamesType,
},
Confrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "confrelid" as FieldNamesType,
},
Confupdtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confupdtype" as FieldNamesType,
},
Confdeltype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confdeltype" as FieldNamesType,
},
Confmatchtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "confmatchtype" as FieldNamesType,
},
Conislocal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "conislocal" as FieldNamesType,
},
Coninhcount: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "coninhcount" as FieldNamesType,
},
Connoinherit: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "connoinherit" as FieldNamesType,
},
Conkey: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "conkey" as FieldNamesType,
},
Confkey: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "confkey" as FieldNamesType,
},
Conpfeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conpfeqop" as FieldNamesType,
},
Conppeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conppeqop" as FieldNamesType,
},
Conffeqop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conffeqop" as FieldNamesType,
},
Confdelsetcols: {
 typeName: "PgCatalog.Types.Int2Array",
 fieldName: "confdelsetcols" as FieldNamesType,
},
Conexclop: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "conexclop" as FieldNamesType,
},
Conbin: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "conbin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Conname","Connamespace","Contype","Condeferrable","Condeferred","Convalidated","Conrelid","Contypid","Conindid","Conparentid","Confrelid","Confupdtype","Confdeltype","Confmatchtype","Conislocal","Coninhcount","Connoinherit","Conkey","Confkey","Conpfeqop","Conppeqop","Conffeqop","Confdelsetcols","Conexclop","Conbin"] as const;
export const FieldNames = ["oid","conname","connamespace","contype","condeferrable","condeferred","convalidated","conrelid","contypid","conindid","conparentid","confrelid","confupdtype","confdeltype","confmatchtype","conislocal","coninhcount","connoinherit","conkey","confkey","conpfeqop","conppeqop","conffeqop","confdelsetcols","conexclop","conbin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgConstraintOidIndex;
}
export namespace PgInherits {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgInherits> {
 return { inhrelid: undefined,inhparent: undefined,inhseqno: undefined,inhdetachpending: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgInherits,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgInherits,  PrimaryKey>
export enum SortOptions  {
inhrelidAscending = "inhrelid ASC",
inhparentAscending = "inhparent ASC",
inhseqnoAscending = "inhseqno ASC",
inhdetachpendingAscending = "inhdetachpending ASC",
inhrelidDescending = "inhrelid DESC",
inhparentDescending = "inhparent DESC",
inhseqnoDescending = "inhseqno DESC",
inhdetachpendingDescending = "inhdetachpending DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Inhrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "inhrelid" as FieldNamesType,
},
Inhparent: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "inhparent" as FieldNamesType,
},
Inhseqno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "inhseqno" as FieldNamesType,
},
Inhdetachpending: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "inhdetachpending" as FieldNamesType,
},
}
export const ColumnNames = ["Inhrelid","Inhparent","Inhseqno","Inhdetachpending"] as const;
export const FieldNames = ["inhrelid","inhparent","inhseqno","inhdetachpending"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgInheritsRelidSeqnoIndex;
}
export namespace PgIndex {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgIndex> {
 return { indexrelid: undefined,indrelid: undefined,indnatts: undefined,indnkeyatts: undefined,indisunique: undefined,indnullsnotdistinct: undefined,indisprimary: undefined,indisexclusion: undefined,indimmediate: undefined,indisclustered: undefined,indisvalid: undefined,indcheckxmin: undefined,indisready: undefined,indislive: undefined,indisreplident: undefined,indkey: undefined,indcollation: undefined,indclass: undefined,indoption: undefined,indexprs: undefined,indpred: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgIndex,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgIndex,  PrimaryKey>
export enum SortOptions  {
indexrelidAscending = "indexrelid ASC",
indrelidAscending = "indrelid ASC",
indnattsAscending = "indnatts ASC",
indnkeyattsAscending = "indnkeyatts ASC",
indisuniqueAscending = "indisunique ASC",
indnullsnotdistinctAscending = "indnullsnotdistinct ASC",
indisprimaryAscending = "indisprimary ASC",
indisexclusionAscending = "indisexclusion ASC",
indimmediateAscending = "indimmediate ASC",
indisclusteredAscending = "indisclustered ASC",
indisvalidAscending = "indisvalid ASC",
indcheckxminAscending = "indcheckxmin ASC",
indisreadyAscending = "indisready ASC",
indisliveAscending = "indislive ASC",
indisreplidentAscending = "indisreplident ASC",
indkeyAscending = "indkey ASC",
indcollationAscending = "indcollation ASC",
indclassAscending = "indclass ASC",
indoptionAscending = "indoption ASC",
indexprsAscending = "indexprs ASC",
indpredAscending = "indpred ASC",
indexrelidDescending = "indexrelid DESC",
indrelidDescending = "indrelid DESC",
indnattsDescending = "indnatts DESC",
indnkeyattsDescending = "indnkeyatts DESC",
indisuniqueDescending = "indisunique DESC",
indnullsnotdistinctDescending = "indnullsnotdistinct DESC",
indisprimaryDescending = "indisprimary DESC",
indisexclusionDescending = "indisexclusion DESC",
indimmediateDescending = "indimmediate DESC",
indisclusteredDescending = "indisclustered DESC",
indisvalidDescending = "indisvalid DESC",
indcheckxminDescending = "indcheckxmin DESC",
indisreadyDescending = "indisready DESC",
indisliveDescending = "indislive DESC",
indisreplidentDescending = "indisreplident DESC",
indkeyDescending = "indkey DESC",
indcollationDescending = "indcollation DESC",
indclassDescending = "indclass DESC",
indoptionDescending = "indoption DESC",
indexprsDescending = "indexprs DESC",
indpredDescending = "indpred DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Indexrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "indexrelid" as FieldNamesType,
},
Indrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "indrelid" as FieldNamesType,
},
Indnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "indnatts" as FieldNamesType,
},
Indnkeyatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "indnkeyatts" as FieldNamesType,
},
Indisunique: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisunique" as FieldNamesType,
},
Indnullsnotdistinct: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indnullsnotdistinct" as FieldNamesType,
},
Indisprimary: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisprimary" as FieldNamesType,
},
Indisexclusion: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisexclusion" as FieldNamesType,
},
Indimmediate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indimmediate" as FieldNamesType,
},
Indisclustered: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisclustered" as FieldNamesType,
},
Indisvalid: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisvalid" as FieldNamesType,
},
Indcheckxmin: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indcheckxmin" as FieldNamesType,
},
Indisready: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisready" as FieldNamesType,
},
Indislive: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indislive" as FieldNamesType,
},
Indisreplident: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "indisreplident" as FieldNamesType,
},
Indkey: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "indkey" as FieldNamesType,
},
Indcollation: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "indcollation" as FieldNamesType,
},
Indclass: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "indclass" as FieldNamesType,
},
Indoption: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "indoption" as FieldNamesType,
},
Indexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "indexprs" as FieldNamesType,
},
Indpred: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "indpred" as FieldNamesType,
},
}
export const ColumnNames = ["Indexrelid","Indrelid","Indnatts","Indnkeyatts","Indisunique","Indnullsnotdistinct","Indisprimary","Indisexclusion","Indimmediate","Indisclustered","Indisvalid","Indcheckxmin","Indisready","Indislive","Indisreplident","Indkey","Indcollation","Indclass","Indoption","Indexprs","Indpred"] as const;
export const FieldNames = ["indexrelid","indrelid","indnatts","indnkeyatts","indisunique","indnullsnotdistinct","indisprimary","indisexclusion","indimmediate","indisclustered","indisvalid","indcheckxmin","indisready","indislive","indisreplident","indkey","indcollation","indclass","indoption","indexprs","indpred"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgIndexIndexrelidIndex;
}
export namespace PgOperator {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOperator> {
 return { oid: undefined,oprname: undefined,oprnamespace: undefined,oprowner: undefined,oprkind: undefined,oprcanmerge: undefined,oprcanhash: undefined,oprleft: undefined,oprright: undefined,oprresult: undefined,oprcom: undefined,oprnegate: undefined,oprcode: undefined,oprrest: undefined,oprjoin: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOperator,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOperator,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
oprnameAscending = "oprname ASC",
oprnamespaceAscending = "oprnamespace ASC",
oprownerAscending = "oprowner ASC",
oprkindAscending = "oprkind ASC",
oprcanmergeAscending = "oprcanmerge ASC",
oprcanhashAscending = "oprcanhash ASC",
oprleftAscending = "oprleft ASC",
oprrightAscending = "oprright ASC",
oprresultAscending = "oprresult ASC",
oprcomAscending = "oprcom ASC",
oprnegateAscending = "oprnegate ASC",
oprcodeAscending = "oprcode ASC",
oprrestAscending = "oprrest ASC",
oprjoinAscending = "oprjoin ASC",
oidDescending = "oid DESC",
oprnameDescending = "oprname DESC",
oprnamespaceDescending = "oprnamespace DESC",
oprownerDescending = "oprowner DESC",
oprkindDescending = "oprkind DESC",
oprcanmergeDescending = "oprcanmerge DESC",
oprcanhashDescending = "oprcanhash DESC",
oprleftDescending = "oprleft DESC",
oprrightDescending = "oprright DESC",
oprresultDescending = "oprresult DESC",
oprcomDescending = "oprcom DESC",
oprnegateDescending = "oprnegate DESC",
oprcodeDescending = "oprcode DESC",
oprrestDescending = "oprrest DESC",
oprjoinDescending = "oprjoin DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Oprname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "oprname" as FieldNamesType,
},
Oprnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprnamespace" as FieldNamesType,
},
Oprowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprowner" as FieldNamesType,
},
Oprkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "oprkind" as FieldNamesType,
},
Oprcanmerge: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "oprcanmerge" as FieldNamesType,
},
Oprcanhash: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "oprcanhash" as FieldNamesType,
},
Oprleft: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprleft" as FieldNamesType,
},
Oprright: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprright" as FieldNamesType,
},
Oprresult: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprresult" as FieldNamesType,
},
Oprcom: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprcom" as FieldNamesType,
},
Oprnegate: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oprnegate" as FieldNamesType,
},
Oprcode: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprcode" as FieldNamesType,
},
Oprrest: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprrest" as FieldNamesType,
},
Oprjoin: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "oprjoin" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Oprname","Oprnamespace","Oprowner","Oprkind","Oprcanmerge","Oprcanhash","Oprleft","Oprright","Oprresult","Oprcom","Oprnegate","Oprcode","Oprrest","Oprjoin"] as const;
export const FieldNames = ["oid","oprname","oprnamespace","oprowner","oprkind","oprcanmerge","oprcanhash","oprleft","oprright","oprresult","oprcom","oprnegate","oprcode","oprrest","oprjoin"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOperatorOidIndex;
}
export namespace PgOpfamily {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOpfamily> {
 return { oid: undefined,opfmethod: undefined,opfname: undefined,opfnamespace: undefined,opfowner: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOpfamily,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOpfamily,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
opfmethodAscending = "opfmethod ASC",
opfnameAscending = "opfname ASC",
opfnamespaceAscending = "opfnamespace ASC",
opfownerAscending = "opfowner ASC",
oidDescending = "oid DESC",
opfmethodDescending = "opfmethod DESC",
opfnameDescending = "opfname DESC",
opfnamespaceDescending = "opfnamespace DESC",
opfownerDescending = "opfowner DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Opfmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfmethod" as FieldNamesType,
},
Opfname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "opfname" as FieldNamesType,
},
Opfnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfnamespace" as FieldNamesType,
},
Opfowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opfowner" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Opfmethod","Opfname","Opfnamespace","Opfowner"] as const;
export const FieldNames = ["oid","opfmethod","opfname","opfnamespace","opfowner"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOpfamilyOidIndex;
}
export namespace PgOpclass {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgOpclass> {
 return { oid: undefined,opcmethod: undefined,opcname: undefined,opcnamespace: undefined,opcowner: undefined,opcfamily: undefined,opcintype: undefined,opcdefault: undefined,opckeytype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgOpclass,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgOpclass,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
opcmethodAscending = "opcmethod ASC",
opcnameAscending = "opcname ASC",
opcnamespaceAscending = "opcnamespace ASC",
opcownerAscending = "opcowner ASC",
opcfamilyAscending = "opcfamily ASC",
opcintypeAscending = "opcintype ASC",
opcdefaultAscending = "opcdefault ASC",
opckeytypeAscending = "opckeytype ASC",
oidDescending = "oid DESC",
opcmethodDescending = "opcmethod DESC",
opcnameDescending = "opcname DESC",
opcnamespaceDescending = "opcnamespace DESC",
opcownerDescending = "opcowner DESC",
opcfamilyDescending = "opcfamily DESC",
opcintypeDescending = "opcintype DESC",
opcdefaultDescending = "opcdefault DESC",
opckeytypeDescending = "opckeytype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Opcmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcmethod" as FieldNamesType,
},
Opcname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "opcname" as FieldNamesType,
},
Opcnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcnamespace" as FieldNamesType,
},
Opcowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcowner" as FieldNamesType,
},
Opcfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcfamily" as FieldNamesType,
},
Opcintype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opcintype" as FieldNamesType,
},
Opcdefault: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "opcdefault" as FieldNamesType,
},
Opckeytype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "opckeytype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Opcmethod","Opcname","Opcnamespace","Opcowner","Opcfamily","Opcintype","Opcdefault","Opckeytype"] as const;
export const FieldNames = ["oid","opcmethod","opcname","opcnamespace","opcowner","opcfamily","opcintype","opcdefault","opckeytype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgOpclassOidIndex;
}
export namespace PgAm {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAm> {
 return { oid: undefined,amname: undefined,amhandler: undefined,amtype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAm,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAm,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amnameAscending = "amname ASC",
amhandlerAscending = "amhandler ASC",
amtypeAscending = "amtype ASC",
oidDescending = "oid DESC",
amnameDescending = "amname DESC",
amhandlerDescending = "amhandler DESC",
amtypeDescending = "amtype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "amname" as FieldNamesType,
},
Amhandler: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "amhandler" as FieldNamesType,
},
Amtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "amtype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amname","Amhandler","Amtype"] as const;
export const FieldNames = ["oid","amname","amhandler","amtype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmOidIndex;
}
export namespace PgAmop {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAmop> {
 return { oid: undefined,amopfamily: undefined,amoplefttype: undefined,amoprighttype: undefined,amopstrategy: undefined,amoppurpose: undefined,amopopr: undefined,amopmethod: undefined,amopsortfamily: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAmop,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAmop,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amopfamilyAscending = "amopfamily ASC",
amoplefttypeAscending = "amoplefttype ASC",
amoprighttypeAscending = "amoprighttype ASC",
amopstrategyAscending = "amopstrategy ASC",
amoppurposeAscending = "amoppurpose ASC",
amopoprAscending = "amopopr ASC",
amopmethodAscending = "amopmethod ASC",
amopsortfamilyAscending = "amopsortfamily ASC",
oidDescending = "oid DESC",
amopfamilyDescending = "amopfamily DESC",
amoplefttypeDescending = "amoplefttype DESC",
amoprighttypeDescending = "amoprighttype DESC",
amopstrategyDescending = "amopstrategy DESC",
amoppurposeDescending = "amoppurpose DESC",
amopoprDescending = "amopopr DESC",
amopmethodDescending = "amopmethod DESC",
amopsortfamilyDescending = "amopsortfamily DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amopfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopfamily" as FieldNamesType,
},
Amoplefttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amoplefttype" as FieldNamesType,
},
Amoprighttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amoprighttype" as FieldNamesType,
},
Amopstrategy: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "amopstrategy" as FieldNamesType,
},
Amoppurpose: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "amoppurpose" as FieldNamesType,
},
Amopopr: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopopr" as FieldNamesType,
},
Amopmethod: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopmethod" as FieldNamesType,
},
Amopsortfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amopsortfamily" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amopfamily","Amoplefttype","Amoprighttype","Amopstrategy","Amoppurpose","Amopopr","Amopmethod","Amopsortfamily"] as const;
export const FieldNames = ["oid","amopfamily","amoplefttype","amoprighttype","amopstrategy","amoppurpose","amopopr","amopmethod","amopsortfamily"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmopOidIndex;
}
export namespace PgAmproc {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAmproc> {
 return { oid: undefined,amprocfamily: undefined,amproclefttype: undefined,amprocrighttype: undefined,amprocnum: undefined,amproc: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAmproc,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAmproc,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
amprocfamilyAscending = "amprocfamily ASC",
amproclefttypeAscending = "amproclefttype ASC",
amprocrighttypeAscending = "amprocrighttype ASC",
amprocnumAscending = "amprocnum ASC",
amprocAscending = "amproc ASC",
oidDescending = "oid DESC",
amprocfamilyDescending = "amprocfamily DESC",
amproclefttypeDescending = "amproclefttype DESC",
amprocrighttypeDescending = "amprocrighttype DESC",
amprocnumDescending = "amprocnum DESC",
amprocDescending = "amproc DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Amprocfamily: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amprocfamily" as FieldNamesType,
},
Amproclefttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amproclefttype" as FieldNamesType,
},
Amprocrighttype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "amprocrighttype" as FieldNamesType,
},
Amprocnum: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "amprocnum" as FieldNamesType,
},
Amproc: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "amproc" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Amprocfamily","Amproclefttype","Amprocrighttype","Amprocnum","Amproc"] as const;
export const FieldNames = ["oid","amprocfamily","amproclefttype","amprocrighttype","amprocnum","amproc"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAmprocOidIndex;
}
export namespace PgLanguage {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLanguage> {
 return { oid: undefined,lanname: undefined,lanowner: undefined,lanispl: undefined,lanpltrusted: undefined,lanplcallfoid: undefined,laninline: undefined,lanvalidator: undefined,lanacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLanguage,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLanguage,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
lannameAscending = "lanname ASC",
lanownerAscending = "lanowner ASC",
lanisplAscending = "lanispl ASC",
lanpltrustedAscending = "lanpltrusted ASC",
lanplcallfoidAscending = "lanplcallfoid ASC",
laninlineAscending = "laninline ASC",
lanvalidatorAscending = "lanvalidator ASC",
lanaclAscending = "lanacl ASC",
oidDescending = "oid DESC",
lannameDescending = "lanname DESC",
lanownerDescending = "lanowner DESC",
lanisplDescending = "lanispl DESC",
lanpltrustedDescending = "lanpltrusted DESC",
lanplcallfoidDescending = "lanplcallfoid DESC",
laninlineDescending = "laninline DESC",
lanvalidatorDescending = "lanvalidator DESC",
lanaclDescending = "lanacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Lanname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "lanname" as FieldNamesType,
},
Lanowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanowner" as FieldNamesType,
},
Lanispl: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "lanispl" as FieldNamesType,
},
Lanpltrusted: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "lanpltrusted" as FieldNamesType,
},
Lanplcallfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanplcallfoid" as FieldNamesType,
},
Laninline: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "laninline" as FieldNamesType,
},
Lanvalidator: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lanvalidator" as FieldNamesType,
},
Lanacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "lanacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Lanname","Lanowner","Lanispl","Lanpltrusted","Lanplcallfoid","Laninline","Lanvalidator","Lanacl"] as const;
export const FieldNames = ["oid","lanname","lanowner","lanispl","lanpltrusted","lanplcallfoid","laninline","lanvalidator","lanacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLanguageOidIndex;
}
export namespace PgLargeobjectMetadata {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLargeobjectMetadata> {
 return { oid: undefined,lomowner: undefined,lomacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLargeobjectMetadata,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLargeobjectMetadata,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
lomownerAscending = "lomowner ASC",
lomaclAscending = "lomacl ASC",
oidDescending = "oid DESC",
lomownerDescending = "lomowner DESC",
lomaclDescending = "lomacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Lomowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "lomowner" as FieldNamesType,
},
Lomacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "lomacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Lomowner","Lomacl"] as const;
export const FieldNames = ["oid","lomowner","lomacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLargeobjectMetadataOidIndex;
}
export namespace PgAggregate {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAggregate> {
 return { aggfnoid: undefined,aggkind: undefined,aggnumdirectargs: undefined,aggtransfn: undefined,aggfinalfn: undefined,aggcombinefn: undefined,aggserialfn: undefined,aggdeserialfn: undefined,aggmtransfn: undefined,aggminvtransfn: undefined,aggmfinalfn: undefined,aggfinalextra: undefined,aggmfinalextra: undefined,aggfinalmodify: undefined,aggmfinalmodify: undefined,aggsortop: undefined,aggtranstype: undefined,aggtransspace: undefined,aggmtranstype: undefined,aggmtransspace: undefined,agginitval: undefined,aggminitval: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAggregate,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAggregate,  PrimaryKey>
export enum SortOptions  {
aggfnoidAscending = "aggfnoid ASC",
aggkindAscending = "aggkind ASC",
aggnumdirectargsAscending = "aggnumdirectargs ASC",
aggtransfnAscending = "aggtransfn ASC",
aggfinalfnAscending = "aggfinalfn ASC",
aggcombinefnAscending = "aggcombinefn ASC",
aggserialfnAscending = "aggserialfn ASC",
aggdeserialfnAscending = "aggdeserialfn ASC",
aggmtransfnAscending = "aggmtransfn ASC",
aggminvtransfnAscending = "aggminvtransfn ASC",
aggmfinalfnAscending = "aggmfinalfn ASC",
aggfinalextraAscending = "aggfinalextra ASC",
aggmfinalextraAscending = "aggmfinalextra ASC",
aggfinalmodifyAscending = "aggfinalmodify ASC",
aggmfinalmodifyAscending = "aggmfinalmodify ASC",
aggsortopAscending = "aggsortop ASC",
aggtranstypeAscending = "aggtranstype ASC",
aggtransspaceAscending = "aggtransspace ASC",
aggmtranstypeAscending = "aggmtranstype ASC",
aggmtransspaceAscending = "aggmtransspace ASC",
agginitvalAscending = "agginitval ASC",
aggminitvalAscending = "aggminitval ASC",
aggfnoidDescending = "aggfnoid DESC",
aggkindDescending = "aggkind DESC",
aggnumdirectargsDescending = "aggnumdirectargs DESC",
aggtransfnDescending = "aggtransfn DESC",
aggfinalfnDescending = "aggfinalfn DESC",
aggcombinefnDescending = "aggcombinefn DESC",
aggserialfnDescending = "aggserialfn DESC",
aggdeserialfnDescending = "aggdeserialfn DESC",
aggmtransfnDescending = "aggmtransfn DESC",
aggminvtransfnDescending = "aggminvtransfn DESC",
aggmfinalfnDescending = "aggmfinalfn DESC",
aggfinalextraDescending = "aggfinalextra DESC",
aggmfinalextraDescending = "aggmfinalextra DESC",
aggfinalmodifyDescending = "aggfinalmodify DESC",
aggmfinalmodifyDescending = "aggmfinalmodify DESC",
aggsortopDescending = "aggsortop DESC",
aggtranstypeDescending = "aggtranstype DESC",
aggtransspaceDescending = "aggtransspace DESC",
aggmtranstypeDescending = "aggmtranstype DESC",
aggmtransspaceDescending = "aggmtransspace DESC",
agginitvalDescending = "agginitval DESC",
aggminitvalDescending = "aggminitval DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Aggfnoid: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggfnoid" as FieldNamesType,
},
Aggkind: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggkind" as FieldNamesType,
},
Aggnumdirectargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "aggnumdirectargs" as FieldNamesType,
},
Aggtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggtransfn" as FieldNamesType,
},
Aggfinalfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggfinalfn" as FieldNamesType,
},
Aggcombinefn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggcombinefn" as FieldNamesType,
},
Aggserialfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggserialfn" as FieldNamesType,
},
Aggdeserialfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggdeserialfn" as FieldNamesType,
},
Aggmtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggmtransfn" as FieldNamesType,
},
Aggminvtransfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggminvtransfn" as FieldNamesType,
},
Aggmfinalfn: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "aggmfinalfn" as FieldNamesType,
},
Aggfinalextra: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "aggfinalextra" as FieldNamesType,
},
Aggmfinalextra: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "aggmfinalextra" as FieldNamesType,
},
Aggfinalmodify: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggfinalmodify" as FieldNamesType,
},
Aggmfinalmodify: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "aggmfinalmodify" as FieldNamesType,
},
Aggsortop: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggsortop" as FieldNamesType,
},
Aggtranstype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggtranstype" as FieldNamesType,
},
Aggtransspace: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "aggtransspace" as FieldNamesType,
},
Aggmtranstype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "aggmtranstype" as FieldNamesType,
},
Aggmtransspace: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "aggmtransspace" as FieldNamesType,
},
Agginitval: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "agginitval" as FieldNamesType,
},
Aggminitval: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "aggminitval" as FieldNamesType,
},
}
export const ColumnNames = ["Aggfnoid","Aggkind","Aggnumdirectargs","Aggtransfn","Aggfinalfn","Aggcombinefn","Aggserialfn","Aggdeserialfn","Aggmtransfn","Aggminvtransfn","Aggmfinalfn","Aggfinalextra","Aggmfinalextra","Aggfinalmodify","Aggmfinalmodify","Aggsortop","Aggtranstype","Aggtransspace","Aggmtranstype","Aggmtransspace","Agginitval","Aggminitval"] as const;
export const FieldNames = ["aggfnoid","aggkind","aggnumdirectargs","aggtransfn","aggfinalfn","aggcombinefn","aggserialfn","aggdeserialfn","aggmtransfn","aggminvtransfn","aggmfinalfn","aggfinalextra","aggmfinalextra","aggfinalmodify","aggmfinalmodify","aggsortop","aggtranstype","aggtransspace","aggmtranstype","aggmtransspace","agginitval","aggminitval"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAggregateFnoidIndex;
}
export namespace PgStatisticExt {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgStatisticExt> {
 return { oid: undefined,stxrelid: undefined,stxname: undefined,stxnamespace: undefined,stxowner: undefined,stxstattarget: undefined,stxkeys: undefined,stxkind: undefined,stxexprs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgStatisticExt,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgStatisticExt,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
stxrelidAscending = "stxrelid ASC",
stxnameAscending = "stxname ASC",
stxnamespaceAscending = "stxnamespace ASC",
stxownerAscending = "stxowner ASC",
stxstattargetAscending = "stxstattarget ASC",
stxkeysAscending = "stxkeys ASC",
stxkindAscending = "stxkind ASC",
stxexprsAscending = "stxexprs ASC",
oidDescending = "oid DESC",
stxrelidDescending = "stxrelid DESC",
stxnameDescending = "stxname DESC",
stxnamespaceDescending = "stxnamespace DESC",
stxownerDescending = "stxowner DESC",
stxstattargetDescending = "stxstattarget DESC",
stxkeysDescending = "stxkeys DESC",
stxkindDescending = "stxkind DESC",
stxexprsDescending = "stxexprs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Stxrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxrelid" as FieldNamesType,
},
Stxname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "stxname" as FieldNamesType,
},
Stxnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxnamespace" as FieldNamesType,
},
Stxowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "stxowner" as FieldNamesType,
},
Stxstattarget: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "stxstattarget" as FieldNamesType,
},
Stxkeys: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "stxkeys" as FieldNamesType,
},
Stxkind: {
 typeName: "PgCatalog.Types.CharArray",
 fieldName: "stxkind" as FieldNamesType,
},
Stxexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "stxexprs" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Stxrelid","Stxname","Stxnamespace","Stxowner","Stxstattarget","Stxkeys","Stxkind","Stxexprs"] as const;
export const FieldNames = ["oid","stxrelid","stxname","stxnamespace","stxowner","stxstattarget","stxkeys","stxkind","stxexprs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgStatisticExtOidIndex;
}
export namespace PgRewrite {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgRewrite> {
 return { oid: undefined,rulename: undefined,evClass: undefined,evType: undefined,evEnabled: undefined,isInstead: undefined,evQual: undefined,evAction: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgRewrite,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgRewrite,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
rulenameAscending = "rulename ASC",
evClassAscending = "ev_class ASC",
evTypeAscending = "ev_type ASC",
evEnabledAscending = "ev_enabled ASC",
isInsteadAscending = "is_instead ASC",
evQualAscending = "ev_qual ASC",
evActionAscending = "ev_action ASC",
oidDescending = "oid DESC",
rulenameDescending = "rulename DESC",
evClassDescending = "ev_class DESC",
evTypeDescending = "ev_type DESC",
evEnabledDescending = "ev_enabled DESC",
isInsteadDescending = "is_instead DESC",
evQualDescending = "ev_qual DESC",
evActionDescending = "ev_action DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Rulename: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "rulename" as FieldNamesType,
},
EvClass: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evClass" as FieldNamesType,
},
EvType: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evType" as FieldNamesType,
},
EvEnabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evEnabled" as FieldNamesType,
},
IsInstead: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "isInstead" as FieldNamesType,
},
EvQual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "evQual" as FieldNamesType,
},
EvAction: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "evAction" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Rulename","EvClass","EvType","EvEnabled","IsInstead","EvQual","EvAction"] as const;
export const FieldNames = ["oid","rulename","evClass","evType","evEnabled","isInstead","evQual","evAction"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgRewriteOidIndex;
}
export namespace PgTrigger {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTrigger> {
 return { oid: undefined,tgrelid: undefined,tgparentid: undefined,tgname: undefined,tgfoid: undefined,tgtype: undefined,tgenabled: undefined,tgisinternal: undefined,tgconstrrelid: undefined,tgconstrindid: undefined,tgconstraint: undefined,tgdeferrable: undefined,tginitdeferred: undefined,tgnargs: undefined,tgattr: undefined,tgargs: undefined,tgqual: undefined,tgoldtable: undefined,tgnewtable: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTrigger,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTrigger,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
tgrelidAscending = "tgrelid ASC",
tgparentidAscending = "tgparentid ASC",
tgnameAscending = "tgname ASC",
tgfoidAscending = "tgfoid ASC",
tgtypeAscending = "tgtype ASC",
tgenabledAscending = "tgenabled ASC",
tgisinternalAscending = "tgisinternal ASC",
tgconstrrelidAscending = "tgconstrrelid ASC",
tgconstrindidAscending = "tgconstrindid ASC",
tgconstraintAscending = "tgconstraint ASC",
tgdeferrableAscending = "tgdeferrable ASC",
tginitdeferredAscending = "tginitdeferred ASC",
tgnargsAscending = "tgnargs ASC",
tgattrAscending = "tgattr ASC",
tgargsAscending = "tgargs ASC",
tgqualAscending = "tgqual ASC",
tgoldtableAscending = "tgoldtable ASC",
tgnewtableAscending = "tgnewtable ASC",
oidDescending = "oid DESC",
tgrelidDescending = "tgrelid DESC",
tgparentidDescending = "tgparentid DESC",
tgnameDescending = "tgname DESC",
tgfoidDescending = "tgfoid DESC",
tgtypeDescending = "tgtype DESC",
tgenabledDescending = "tgenabled DESC",
tgisinternalDescending = "tgisinternal DESC",
tgconstrrelidDescending = "tgconstrrelid DESC",
tgconstrindidDescending = "tgconstrindid DESC",
tgconstraintDescending = "tgconstraint DESC",
tgdeferrableDescending = "tgdeferrable DESC",
tginitdeferredDescending = "tginitdeferred DESC",
tgnargsDescending = "tgnargs DESC",
tgattrDescending = "tgattr DESC",
tgargsDescending = "tgargs DESC",
tgqualDescending = "tgqual DESC",
tgoldtableDescending = "tgoldtable DESC",
tgnewtableDescending = "tgnewtable DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Tgrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgrelid" as FieldNamesType,
},
Tgparentid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgparentid" as FieldNamesType,
},
Tgname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgname" as FieldNamesType,
},
Tgfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgfoid" as FieldNamesType,
},
Tgtype: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "tgtype" as FieldNamesType,
},
Tgenabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "tgenabled" as FieldNamesType,
},
Tgisinternal: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tgisinternal" as FieldNamesType,
},
Tgconstrrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstrrelid" as FieldNamesType,
},
Tgconstrindid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstrindid" as FieldNamesType,
},
Tgconstraint: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tgconstraint" as FieldNamesType,
},
Tgdeferrable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tgdeferrable" as FieldNamesType,
},
Tginitdeferred: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "tginitdeferred" as FieldNamesType,
},
Tgnargs: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "tgnargs" as FieldNamesType,
},
Tgattr: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "tgattr" as FieldNamesType,
},
Tgargs: {
 typeName: "PgCatalog.Types.Bytea",
 fieldName: "tgargs" as FieldNamesType,
},
Tgqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "tgqual" as FieldNamesType,
},
Tgoldtable: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgoldtable" as FieldNamesType,
},
Tgnewtable: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tgnewtable" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Tgrelid","Tgparentid","Tgname","Tgfoid","Tgtype","Tgenabled","Tgisinternal","Tgconstrrelid","Tgconstrindid","Tgconstraint","Tgdeferrable","Tginitdeferred","Tgnargs","Tgattr","Tgargs","Tgqual","Tgoldtable","Tgnewtable"] as const;
export const FieldNames = ["oid","tgrelid","tgparentid","tgname","tgfoid","tgtype","tgenabled","tgisinternal","tgconstrrelid","tgconstrindid","tgconstraint","tgdeferrable","tginitdeferred","tgnargs","tgattr","tgargs","tgqual","tgoldtable","tgnewtable"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTriggerOidIndex;
}
export namespace PgEventTrigger {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgEventTrigger> {
 return { oid: undefined,evtname: undefined,evtevent: undefined,evtowner: undefined,evtfoid: undefined,evtenabled: undefined,evttags: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgEventTrigger,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgEventTrigger,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
evtnameAscending = "evtname ASC",
evteventAscending = "evtevent ASC",
evtownerAscending = "evtowner ASC",
evtfoidAscending = "evtfoid ASC",
evtenabledAscending = "evtenabled ASC",
evttagsAscending = "evttags ASC",
oidDescending = "oid DESC",
evtnameDescending = "evtname DESC",
evteventDescending = "evtevent DESC",
evtownerDescending = "evtowner DESC",
evtfoidDescending = "evtfoid DESC",
evtenabledDescending = "evtenabled DESC",
evttagsDescending = "evttags DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Evtname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "evtname" as FieldNamesType,
},
Evtevent: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "evtevent" as FieldNamesType,
},
Evtowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evtowner" as FieldNamesType,
},
Evtfoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "evtfoid" as FieldNamesType,
},
Evtenabled: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "evtenabled" as FieldNamesType,
},
Evttags: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "evttags" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Evtname","Evtevent","Evtowner","Evtfoid","Evtenabled","Evttags"] as const;
export const FieldNames = ["oid","evtname","evtevent","evtowner","evtfoid","evtenabled","evttags"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgEventTriggerOidIndex;
}
export namespace PgDescription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDescription> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,description: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDescription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDescription,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
descriptionAscending = "description ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
descriptionDescending = "description DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Description: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "description" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Description"] as const;
export const FieldNames = ["objoid","classoid","objsubid","description"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDescriptionOCOIndex;
}
export namespace PgCast {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgCast> {
 return { oid: undefined,castsource: undefined,casttarget: undefined,castfunc: undefined,castcontext: undefined,castmethod: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgCast,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgCast,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
castsourceAscending = "castsource ASC",
casttargetAscending = "casttarget ASC",
castfuncAscending = "castfunc ASC",
castcontextAscending = "castcontext ASC",
castmethodAscending = "castmethod ASC",
oidDescending = "oid DESC",
castsourceDescending = "castsource DESC",
casttargetDescending = "casttarget DESC",
castfuncDescending = "castfunc DESC",
castcontextDescending = "castcontext DESC",
castmethodDescending = "castmethod DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Castsource: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "castsource" as FieldNamesType,
},
Casttarget: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "casttarget" as FieldNamesType,
},
Castfunc: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "castfunc" as FieldNamesType,
},
Castcontext: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "castcontext" as FieldNamesType,
},
Castmethod: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "castmethod" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Castsource","Casttarget","Castfunc","Castcontext","Castmethod"] as const;
export const FieldNames = ["oid","castsource","casttarget","castfunc","castcontext","castmethod"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgCastOidIndex;
}
export namespace PgEnum {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgEnum> {
 return { oid: undefined,enumtypid: undefined,enumsortorder: undefined,enumlabel: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgEnum,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgEnum,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
enumtypidAscending = "enumtypid ASC",
enumsortorderAscending = "enumsortorder ASC",
enumlabelAscending = "enumlabel ASC",
oidDescending = "oid DESC",
enumtypidDescending = "enumtypid DESC",
enumsortorderDescending = "enumsortorder DESC",
enumlabelDescending = "enumlabel DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Enumtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "enumtypid" as FieldNamesType,
},
Enumsortorder: {
 typeName: "PgCatalog.Types.Float4",
 fieldName: "enumsortorder" as FieldNamesType,
},
Enumlabel: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "enumlabel" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Enumtypid","Enumsortorder","Enumlabel"] as const;
export const FieldNames = ["oid","enumtypid","enumsortorder","enumlabel"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgEnumOidIndex;
}
export namespace PgNamespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgNamespace> {
 return { oid: undefined,nspname: undefined,nspowner: undefined,nspacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgNamespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgNamespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
nspnameAscending = "nspname ASC",
nspownerAscending = "nspowner ASC",
nspaclAscending = "nspacl ASC",
oidDescending = "oid DESC",
nspnameDescending = "nspname DESC",
nspownerDescending = "nspowner DESC",
nspaclDescending = "nspacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Nspname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "nspname" as FieldNamesType,
},
Nspowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "nspowner" as FieldNamesType,
},
Nspacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "nspacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Nspname","Nspowner","Nspacl"] as const;
export const FieldNames = ["oid","nspname","nspowner","nspacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgNamespaceOidIndex;
}
export namespace PgConversion {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgConversion> {
 return { oid: undefined,conname: undefined,connamespace: undefined,conowner: undefined,conforencoding: undefined,contoencoding: undefined,conproc: undefined,condefault: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgConversion,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgConversion,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
connameAscending = "conname ASC",
connamespaceAscending = "connamespace ASC",
conownerAscending = "conowner ASC",
conforencodingAscending = "conforencoding ASC",
contoencodingAscending = "contoencoding ASC",
conprocAscending = "conproc ASC",
condefaultAscending = "condefault ASC",
oidDescending = "oid DESC",
connameDescending = "conname DESC",
connamespaceDescending = "connamespace DESC",
conownerDescending = "conowner DESC",
conforencodingDescending = "conforencoding DESC",
contoencodingDescending = "contoencoding DESC",
conprocDescending = "conproc DESC",
condefaultDescending = "condefault DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Conname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "conname" as FieldNamesType,
},
Connamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "connamespace" as FieldNamesType,
},
Conowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "conowner" as FieldNamesType,
},
Conforencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "conforencoding" as FieldNamesType,
},
Contoencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "contoencoding" as FieldNamesType,
},
Conproc: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "conproc" as FieldNamesType,
},
Condefault: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "condefault" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Conname","Connamespace","Conowner","Conforencoding","Contoencoding","Conproc","Condefault"] as const;
export const FieldNames = ["oid","conname","connamespace","conowner","conforencoding","contoencoding","conproc","condefault"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgConversionOidIndex;
}
export namespace PgDepend {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDepend> {
 return { classid: undefined,objid: undefined,objsubid: undefined,refclassid: undefined,refobjid: undefined,refobjsubid: undefined,deptype: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<PgCatalog.Types.PgDepend,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDepend,  PrimaryKey>
export enum SortOptions  {
classidAscending = "classid ASC",
objidAscending = "objid ASC",
objsubidAscending = "objsubid ASC",
refclassidAscending = "refclassid ASC",
refobjidAscending = "refobjid ASC",
refobjsubidAscending = "refobjsubid ASC",
deptypeAscending = "deptype ASC",
classidDescending = "classid DESC",
objidDescending = "objid DESC",
objsubidDescending = "objsubid DESC",
refclassidDescending = "refclassid DESC",
refobjidDescending = "refobjid DESC",
refobjsubidDescending = "refobjsubid DESC",
deptypeDescending = "deptype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Classid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classid" as FieldNamesType,
},
Objid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Refclassid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refclassid" as FieldNamesType,
},
Refobjid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refobjid" as FieldNamesType,
},
Refobjsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "refobjsubid" as FieldNamesType,
},
Deptype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "deptype" as FieldNamesType,
},
}
export const ColumnNames = ["Classid","Objid","Objsubid","Refclassid","Refobjid","Refobjsubid","Deptype"] as const;
export const FieldNames = ["classid","objid","objsubid","refclassid","refobjid","refobjsubid","deptype"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PgDatabase {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDatabase> {
 return { oid: undefined,datname: undefined,datdba: undefined,encoding: undefined,datlocprovider: undefined,datistemplate: undefined,datallowconn: undefined,datconnlimit: undefined,datfrozenxid: undefined,datminmxid: undefined,dattablespace: undefined,datcollate: undefined,datctype: undefined,daticulocale: undefined,daticurules: undefined,datcollversion: undefined,datacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDatabase,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDatabase,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
datnameAscending = "datname ASC",
datdbaAscending = "datdba ASC",
encodingAscending = "encoding ASC",
datlocproviderAscending = "datlocprovider ASC",
datistemplateAscending = "datistemplate ASC",
datallowconnAscending = "datallowconn ASC",
datconnlimitAscending = "datconnlimit ASC",
datfrozenxidAscending = "datfrozenxid ASC",
datminmxidAscending = "datminmxid ASC",
dattablespaceAscending = "dattablespace ASC",
datcollateAscending = "datcollate ASC",
datctypeAscending = "datctype ASC",
daticulocaleAscending = "daticulocale ASC",
daticurulesAscending = "daticurules ASC",
datcollversionAscending = "datcollversion ASC",
dataclAscending = "datacl ASC",
oidDescending = "oid DESC",
datnameDescending = "datname DESC",
datdbaDescending = "datdba DESC",
encodingDescending = "encoding DESC",
datlocproviderDescending = "datlocprovider DESC",
datistemplateDescending = "datistemplate DESC",
datallowconnDescending = "datallowconn DESC",
datconnlimitDescending = "datconnlimit DESC",
datfrozenxidDescending = "datfrozenxid DESC",
datminmxidDescending = "datminmxid DESC",
dattablespaceDescending = "dattablespace DESC",
datcollateDescending = "datcollate DESC",
datctypeDescending = "datctype DESC",
daticulocaleDescending = "daticulocale DESC",
daticurulesDescending = "daticurules DESC",
datcollversionDescending = "datcollversion DESC",
dataclDescending = "datacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Datname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "datname" as FieldNamesType,
},
Datdba: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "datdba" as FieldNamesType,
},
Encoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "encoding" as FieldNamesType,
},
Datlocprovider: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "datlocprovider" as FieldNamesType,
},
Datistemplate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "datistemplate" as FieldNamesType,
},
Datallowconn: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "datallowconn" as FieldNamesType,
},
Datconnlimit: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "datconnlimit" as FieldNamesType,
},
Datfrozenxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "datfrozenxid" as FieldNamesType,
},
Datminmxid: {
 typeName: "PgCatalog.Types.Xid",
 fieldName: "datminmxid" as FieldNamesType,
},
Dattablespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dattablespace" as FieldNamesType,
},
Datcollate: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datcollate" as FieldNamesType,
},
Datctype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datctype" as FieldNamesType,
},
Daticulocale: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "daticulocale" as FieldNamesType,
},
Daticurules: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "daticurules" as FieldNamesType,
},
Datcollversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "datcollversion" as FieldNamesType,
},
Datacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "datacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Datname","Datdba","Encoding","Datlocprovider","Datistemplate","Datallowconn","Datconnlimit","Datfrozenxid","Datminmxid","Dattablespace","Datcollate","Datctype","Daticulocale","Daticurules","Datcollversion","Datacl"] as const;
export const FieldNames = ["oid","datname","datdba","encoding","datlocprovider","datistemplate","datallowconn","datconnlimit","datfrozenxid","datminmxid","dattablespace","datcollate","datctype","daticulocale","daticurules","datcollversion","datacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDatabaseOidIndex;
}
export namespace PgDbRoleSetting {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDbRoleSetting> {
 return { setdatabase: undefined,setrole: undefined,setconfig: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDbRoleSetting,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDbRoleSetting,  PrimaryKey>
export enum SortOptions  {
setdatabaseAscending = "setdatabase ASC",
setroleAscending = "setrole ASC",
setconfigAscending = "setconfig ASC",
setdatabaseDescending = "setdatabase DESC",
setroleDescending = "setrole DESC",
setconfigDescending = "setconfig DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Setdatabase: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "setdatabase" as FieldNamesType,
},
Setrole: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "setrole" as FieldNamesType,
},
Setconfig: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "setconfig" as FieldNamesType,
},
}
export const ColumnNames = ["Setdatabase","Setrole","Setconfig"] as const;
export const FieldNames = ["setdatabase","setrole","setconfig"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex;
}
export namespace PgTablespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTablespace> {
 return { oid: undefined,spcname: undefined,spcowner: undefined,spcacl: undefined,spcoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTablespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTablespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
spcnameAscending = "spcname ASC",
spcownerAscending = "spcowner ASC",
spcaclAscending = "spcacl ASC",
spcoptionsAscending = "spcoptions ASC",
oidDescending = "oid DESC",
spcnameDescending = "spcname DESC",
spcownerDescending = "spcowner DESC",
spcaclDescending = "spcacl DESC",
spcoptionsDescending = "spcoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Spcname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "spcname" as FieldNamesType,
},
Spcowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "spcowner" as FieldNamesType,
},
Spcacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "spcacl" as FieldNamesType,
},
Spcoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "spcoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Spcname","Spcowner","Spcacl","Spcoptions"] as const;
export const FieldNames = ["oid","spcname","spcowner","spcacl","spcoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTablespaceOidIndex;
}
export namespace PgAuthMembers {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgAuthMembers> {
 return { oid: undefined,roleid: undefined,member: undefined,grantor: undefined,adminOption: undefined,inheritOption: undefined,setOption: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgAuthMembers,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgAuthMembers,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
roleidAscending = "roleid ASC",
memberAscending = "member ASC",
grantorAscending = "grantor ASC",
adminOptionAscending = "admin_option ASC",
inheritOptionAscending = "inherit_option ASC",
setOptionAscending = "set_option ASC",
oidDescending = "oid DESC",
roleidDescending = "roleid DESC",
memberDescending = "member DESC",
grantorDescending = "grantor DESC",
adminOptionDescending = "admin_option DESC",
inheritOptionDescending = "inherit_option DESC",
setOptionDescending = "set_option DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Roleid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "roleid" as FieldNamesType,
},
Member: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "member" as FieldNamesType,
},
Grantor: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "grantor" as FieldNamesType,
},
AdminOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "adminOption" as FieldNamesType,
},
InheritOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "inheritOption" as FieldNamesType,
},
SetOption: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "setOption" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Roleid","Member","Grantor","AdminOption","InheritOption","SetOption"] as const;
export const FieldNames = ["oid","roleid","member","grantor","adminOption","inheritOption","setOption"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgAuthMembersOidIndex;
}
export namespace PgShdepend {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShdepend> {
 return { dbid: undefined,classid: undefined,objid: undefined,objsubid: undefined,refclassid: undefined,refobjid: undefined,deptype: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<PgCatalog.Types.PgShdepend,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShdepend,  PrimaryKey>
export enum SortOptions  {
dbidAscending = "dbid ASC",
classidAscending = "classid ASC",
objidAscending = "objid ASC",
objsubidAscending = "objsubid ASC",
refclassidAscending = "refclassid ASC",
refobjidAscending = "refobjid ASC",
deptypeAscending = "deptype ASC",
dbidDescending = "dbid DESC",
classidDescending = "classid DESC",
objidDescending = "objid DESC",
objsubidDescending = "objsubid DESC",
refclassidDescending = "refclassid DESC",
refobjidDescending = "refobjid DESC",
deptypeDescending = "deptype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Dbid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dbid" as FieldNamesType,
},
Classid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classid" as FieldNamesType,
},
Objid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Refclassid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refclassid" as FieldNamesType,
},
Refobjid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "refobjid" as FieldNamesType,
},
Deptype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "deptype" as FieldNamesType,
},
}
export const ColumnNames = ["Dbid","Classid","Objid","Objsubid","Refclassid","Refobjid","Deptype"] as const;
export const FieldNames = ["dbid","classid","objid","objsubid","refclassid","refobjid","deptype"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PgShdescription {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShdescription> {
 return { objoid: undefined,classoid: undefined,description: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgShdescription,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShdescription,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
descriptionAscending = "description ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
descriptionDescending = "description DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Description: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "description" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Description"] as const;
export const FieldNames = ["objoid","classoid","description"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgShdescriptionOCIndex;
}
export namespace PgTsConfig {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsConfig> {
 return { oid: undefined,cfgname: undefined,cfgnamespace: undefined,cfgowner: undefined,cfgparser: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsConfig,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsConfig,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
cfgnameAscending = "cfgname ASC",
cfgnamespaceAscending = "cfgnamespace ASC",
cfgownerAscending = "cfgowner ASC",
cfgparserAscending = "cfgparser ASC",
oidDescending = "oid DESC",
cfgnameDescending = "cfgname DESC",
cfgnamespaceDescending = "cfgnamespace DESC",
cfgownerDescending = "cfgowner DESC",
cfgparserDescending = "cfgparser DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Cfgname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "cfgname" as FieldNamesType,
},
Cfgnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgnamespace" as FieldNamesType,
},
Cfgowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgowner" as FieldNamesType,
},
Cfgparser: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "cfgparser" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Cfgname","Cfgnamespace","Cfgowner","Cfgparser"] as const;
export const FieldNames = ["oid","cfgname","cfgnamespace","cfgowner","cfgparser"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsConfigOidIndex;
}
export namespace PgTsConfigMap {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsConfigMap> {
 return { mapcfg: undefined,maptokentype: undefined,mapseqno: undefined,mapdict: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsConfigMap,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsConfigMap,  PrimaryKey>
export enum SortOptions  {
mapcfgAscending = "mapcfg ASC",
maptokentypeAscending = "maptokentype ASC",
mapseqnoAscending = "mapseqno ASC",
mapdictAscending = "mapdict ASC",
mapcfgDescending = "mapcfg DESC",
maptokentypeDescending = "maptokentype DESC",
mapseqnoDescending = "mapseqno DESC",
mapdictDescending = "mapdict DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Mapcfg: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "mapcfg" as FieldNamesType,
},
Maptokentype: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "maptokentype" as FieldNamesType,
},
Mapseqno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "mapseqno" as FieldNamesType,
},
Mapdict: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "mapdict" as FieldNamesType,
},
}
export const ColumnNames = ["Mapcfg","Maptokentype","Mapseqno","Mapdict"] as const;
export const FieldNames = ["mapcfg","maptokentype","mapseqno","mapdict"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsConfigMapIndex;
}
export namespace PgTsDict {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsDict> {
 return { oid: undefined,dictname: undefined,dictnamespace: undefined,dictowner: undefined,dicttemplate: undefined,dictinitoption: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsDict,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsDict,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
dictnameAscending = "dictname ASC",
dictnamespaceAscending = "dictnamespace ASC",
dictownerAscending = "dictowner ASC",
dicttemplateAscending = "dicttemplate ASC",
dictinitoptionAscending = "dictinitoption ASC",
oidDescending = "oid DESC",
dictnameDescending = "dictname DESC",
dictnamespaceDescending = "dictnamespace DESC",
dictownerDescending = "dictowner DESC",
dicttemplateDescending = "dicttemplate DESC",
dictinitoptionDescending = "dictinitoption DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Dictname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "dictname" as FieldNamesType,
},
Dictnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dictnamespace" as FieldNamesType,
},
Dictowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dictowner" as FieldNamesType,
},
Dicttemplate: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "dicttemplate" as FieldNamesType,
},
Dictinitoption: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "dictinitoption" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Dictname","Dictnamespace","Dictowner","Dicttemplate","Dictinitoption"] as const;
export const FieldNames = ["oid","dictname","dictnamespace","dictowner","dicttemplate","dictinitoption"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsDictOidIndex;
}
export namespace PgTsParser {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsParser> {
 return { oid: undefined,prsname: undefined,prsnamespace: undefined,prsstart: undefined,prstoken: undefined,prsend: undefined,prsheadline: undefined,prslextype: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsParser,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsParser,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
prsnameAscending = "prsname ASC",
prsnamespaceAscending = "prsnamespace ASC",
prsstartAscending = "prsstart ASC",
prstokenAscending = "prstoken ASC",
prsendAscending = "prsend ASC",
prsheadlineAscending = "prsheadline ASC",
prslextypeAscending = "prslextype ASC",
oidDescending = "oid DESC",
prsnameDescending = "prsname DESC",
prsnamespaceDescending = "prsnamespace DESC",
prsstartDescending = "prsstart DESC",
prstokenDescending = "prstoken DESC",
prsendDescending = "prsend DESC",
prsheadlineDescending = "prsheadline DESC",
prslextypeDescending = "prslextype DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Prsname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "prsname" as FieldNamesType,
},
Prsnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prsnamespace" as FieldNamesType,
},
Prsstart: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsstart" as FieldNamesType,
},
Prstoken: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prstoken" as FieldNamesType,
},
Prsend: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsend" as FieldNamesType,
},
Prsheadline: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prsheadline" as FieldNamesType,
},
Prslextype: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "prslextype" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Prsname","Prsnamespace","Prsstart","Prstoken","Prsend","Prsheadline","Prslextype"] as const;
export const FieldNames = ["oid","prsname","prsnamespace","prsstart","prstoken","prsend","prsheadline","prslextype"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsParserOidIndex;
}
export namespace PgTsTemplate {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTsTemplate> {
 return { oid: undefined,tmplname: undefined,tmplnamespace: undefined,tmplinit: undefined,tmpllexize: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTsTemplate,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTsTemplate,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
tmplnameAscending = "tmplname ASC",
tmplnamespaceAscending = "tmplnamespace ASC",
tmplinitAscending = "tmplinit ASC",
tmpllexizeAscending = "tmpllexize ASC",
oidDescending = "oid DESC",
tmplnameDescending = "tmplname DESC",
tmplnamespaceDescending = "tmplnamespace DESC",
tmplinitDescending = "tmplinit DESC",
tmpllexizeDescending = "tmpllexize DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Tmplname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "tmplname" as FieldNamesType,
},
Tmplnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "tmplnamespace" as FieldNamesType,
},
Tmplinit: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "tmplinit" as FieldNamesType,
},
Tmpllexize: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "tmpllexize" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Tmplname","Tmplnamespace","Tmplinit","Tmpllexize"] as const;
export const FieldNames = ["oid","tmplname","tmplnamespace","tmplinit","tmpllexize"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTsTemplateOidIndex;
}
export namespace PgExtension {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgExtension> {
 return { oid: undefined,extname: undefined,extowner: undefined,extnamespace: undefined,extrelocatable: undefined,extversion: undefined,extconfig: undefined,extcondition: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgExtension,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgExtension,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
extnameAscending = "extname ASC",
extownerAscending = "extowner ASC",
extnamespaceAscending = "extnamespace ASC",
extrelocatableAscending = "extrelocatable ASC",
extversionAscending = "extversion ASC",
extconfigAscending = "extconfig ASC",
extconditionAscending = "extcondition ASC",
oidDescending = "oid DESC",
extnameDescending = "extname DESC",
extownerDescending = "extowner DESC",
extnamespaceDescending = "extnamespace DESC",
extrelocatableDescending = "extrelocatable DESC",
extversionDescending = "extversion DESC",
extconfigDescending = "extconfig DESC",
extconditionDescending = "extcondition DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Extname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "extname" as FieldNamesType,
},
Extowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "extowner" as FieldNamesType,
},
Extnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "extnamespace" as FieldNamesType,
},
Extrelocatable: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "extrelocatable" as FieldNamesType,
},
Extversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "extversion" as FieldNamesType,
},
Extconfig: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "extconfig" as FieldNamesType,
},
Extcondition: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "extcondition" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Extname","Extowner","Extnamespace","Extrelocatable","Extversion","Extconfig","Extcondition"] as const;
export const FieldNames = ["oid","extname","extowner","extnamespace","extrelocatable","extversion","extconfig","extcondition"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgExtensionOidIndex;
}
export namespace PgForeignDataWrapper {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignDataWrapper> {
 return { oid: undefined,fdwname: undefined,fdwowner: undefined,fdwhandler: undefined,fdwvalidator: undefined,fdwacl: undefined,fdwoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignDataWrapper,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignDataWrapper,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
fdwnameAscending = "fdwname ASC",
fdwownerAscending = "fdwowner ASC",
fdwhandlerAscending = "fdwhandler ASC",
fdwvalidatorAscending = "fdwvalidator ASC",
fdwaclAscending = "fdwacl ASC",
fdwoptionsAscending = "fdwoptions ASC",
oidDescending = "oid DESC",
fdwnameDescending = "fdwname DESC",
fdwownerDescending = "fdwowner DESC",
fdwhandlerDescending = "fdwhandler DESC",
fdwvalidatorDescending = "fdwvalidator DESC",
fdwaclDescending = "fdwacl DESC",
fdwoptionsDescending = "fdwoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Fdwname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "fdwname" as FieldNamesType,
},
Fdwowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwowner" as FieldNamesType,
},
Fdwhandler: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwhandler" as FieldNamesType,
},
Fdwvalidator: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "fdwvalidator" as FieldNamesType,
},
Fdwacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "fdwacl" as FieldNamesType,
},
Fdwoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "fdwoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Fdwname","Fdwowner","Fdwhandler","Fdwvalidator","Fdwacl","Fdwoptions"] as const;
export const FieldNames = ["oid","fdwname","fdwowner","fdwhandler","fdwvalidator","fdwacl","fdwoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignDataWrapperOidIndex;
}
export namespace PgForeignServer {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgForeignServer> {
 return { oid: undefined,srvname: undefined,srvowner: undefined,srvfdw: undefined,srvtype: undefined,srvversion: undefined,srvacl: undefined,srvoptions: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgForeignServer,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgForeignServer,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
srvnameAscending = "srvname ASC",
srvownerAscending = "srvowner ASC",
srvfdwAscending = "srvfdw ASC",
srvtypeAscending = "srvtype ASC",
srvversionAscending = "srvversion ASC",
srvaclAscending = "srvacl ASC",
srvoptionsAscending = "srvoptions ASC",
oidDescending = "oid DESC",
srvnameDescending = "srvname DESC",
srvownerDescending = "srvowner DESC",
srvfdwDescending = "srvfdw DESC",
srvtypeDescending = "srvtype DESC",
srvversionDescending = "srvversion DESC",
srvaclDescending = "srvacl DESC",
srvoptionsDescending = "srvoptions DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Srvname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "srvname" as FieldNamesType,
},
Srvowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srvowner" as FieldNamesType,
},
Srvfdw: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srvfdw" as FieldNamesType,
},
Srvtype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srvtype" as FieldNamesType,
},
Srvversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srvversion" as FieldNamesType,
},
Srvacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "srvacl" as FieldNamesType,
},
Srvoptions: {
 typeName: "PgCatalog.Types.TextArray",
 fieldName: "srvoptions" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Srvname","Srvowner","Srvfdw","Srvtype","Srvversion","Srvacl","Srvoptions"] as const;
export const FieldNames = ["oid","srvname","srvowner","srvfdw","srvtype","srvversion","srvacl","srvoptions"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgForeignServerOidIndex;
}
export namespace PgPolicy {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPolicy> {
 return { oid: undefined,polname: undefined,polrelid: undefined,polcmd: undefined,polpermissive: undefined,polroles: undefined,polqual: undefined,polwithcheck: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPolicy,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPolicy,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
polnameAscending = "polname ASC",
polrelidAscending = "polrelid ASC",
polcmdAscending = "polcmd ASC",
polpermissiveAscending = "polpermissive ASC",
polrolesAscending = "polroles ASC",
polqualAscending = "polqual ASC",
polwithcheckAscending = "polwithcheck ASC",
oidDescending = "oid DESC",
polnameDescending = "polname DESC",
polrelidDescending = "polrelid DESC",
polcmdDescending = "polcmd DESC",
polpermissiveDescending = "polpermissive DESC",
polrolesDescending = "polroles DESC",
polqualDescending = "polqual DESC",
polwithcheckDescending = "polwithcheck DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Polname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "polname" as FieldNamesType,
},
Polrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "polrelid" as FieldNamesType,
},
Polcmd: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "polcmd" as FieldNamesType,
},
Polpermissive: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "polpermissive" as FieldNamesType,
},
Polroles: {
 typeName: "PgCatalog.Types.OidArray",
 fieldName: "polroles" as FieldNamesType,
},
Polqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "polqual" as FieldNamesType,
},
Polwithcheck: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "polwithcheck" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Polname","Polrelid","Polcmd","Polpermissive","Polroles","Polqual","Polwithcheck"] as const;
export const FieldNames = ["oid","polname","polrelid","polcmd","polpermissive","polroles","polqual","polwithcheck"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPolicyOidIndex;
}
export namespace PgReplicationOrigin {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgReplicationOrigin> {
 return { roident: undefined,roname: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgReplicationOrigin,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgReplicationOrigin,  PrimaryKey>
export enum SortOptions  {
roidentAscending = "roident ASC",
ronameAscending = "roname ASC",
roidentDescending = "roident DESC",
ronameDescending = "roname DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Roident: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "roident" as FieldNamesType,
},
Roname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "roname" as FieldNamesType,
},
}
export const ColumnNames = ["Roident","Roname"] as const;
export const FieldNames = ["roident","roname"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgReplicationOriginRoiidentIndex;
}
export namespace PgDefaultAcl {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgDefaultAcl> {
 return { oid: undefined,defaclrole: undefined,defaclnamespace: undefined,defaclobjtype: undefined,defaclacl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgDefaultAcl,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgDefaultAcl,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
defaclroleAscending = "defaclrole ASC",
defaclnamespaceAscending = "defaclnamespace ASC",
defaclobjtypeAscending = "defaclobjtype ASC",
defaclaclAscending = "defaclacl ASC",
oidDescending = "oid DESC",
defaclroleDescending = "defaclrole DESC",
defaclnamespaceDescending = "defaclnamespace DESC",
defaclobjtypeDescending = "defaclobjtype DESC",
defaclaclDescending = "defaclacl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Defaclrole: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "defaclrole" as FieldNamesType,
},
Defaclnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "defaclnamespace" as FieldNamesType,
},
Defaclobjtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "defaclobjtype" as FieldNamesType,
},
Defaclacl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "defaclacl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Defaclrole","Defaclnamespace","Defaclobjtype","Defaclacl"] as const;
export const FieldNames = ["oid","defaclrole","defaclnamespace","defaclobjtype","defaclacl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgDefaultAclOidIndex;
}
export namespace PgInitPrivs {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgInitPrivs> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,privtype: undefined,initprivs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgInitPrivs,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgInitPrivs,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
privtypeAscending = "privtype ASC",
initprivsAscending = "initprivs ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
privtypeDescending = "privtype DESC",
initprivsDescending = "initprivs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Privtype: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "privtype" as FieldNamesType,
},
Initprivs: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "initprivs" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Privtype","Initprivs"] as const;
export const FieldNames = ["objoid","classoid","objsubid","privtype","initprivs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgInitPrivsOCOIndex;
}
export namespace PgSeclabel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSeclabel> {
 return { objoid: undefined,classoid: undefined,objsubid: undefined,provider: undefined,label: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSeclabel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSeclabel,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
objsubidAscending = "objsubid ASC",
providerAscending = "provider ASC",
labelAscending = "label ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
objsubidDescending = "objsubid DESC",
providerDescending = "provider DESC",
labelDescending = "label DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Objsubid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "objsubid" as FieldNamesType,
},
Provider: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "provider" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "label" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Objsubid","Provider","Label"] as const;
export const FieldNames = ["objoid","classoid","objsubid","provider","label"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSeclabelObjectIndex;
}
export namespace PgShseclabel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgShseclabel> {
 return { objoid: undefined,classoid: undefined,provider: undefined,label: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgShseclabel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgShseclabel,  PrimaryKey>
export enum SortOptions  {
objoidAscending = "objoid ASC",
classoidAscending = "classoid ASC",
providerAscending = "provider ASC",
labelAscending = "label ASC",
objoidDescending = "objoid DESC",
classoidDescending = "classoid DESC",
providerDescending = "provider DESC",
labelDescending = "label DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Objoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "objoid" as FieldNamesType,
},
Classoid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "classoid" as FieldNamesType,
},
Provider: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "provider" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "label" as FieldNamesType,
},
}
export const ColumnNames = ["Objoid","Classoid","Provider","Label"] as const;
export const FieldNames = ["objoid","classoid","provider","label"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgShseclabelObjectIndex;
}
export namespace PgCollation {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgCollation> {
 return { oid: undefined,collname: undefined,collnamespace: undefined,collowner: undefined,collprovider: undefined,collisdeterministic: undefined,collencoding: undefined,collcollate: undefined,collctype: undefined,colliculocale: undefined,collicurules: undefined,collversion: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgCollation,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgCollation,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
collnameAscending = "collname ASC",
collnamespaceAscending = "collnamespace ASC",
collownerAscending = "collowner ASC",
collproviderAscending = "collprovider ASC",
collisdeterministicAscending = "collisdeterministic ASC",
collencodingAscending = "collencoding ASC",
collcollateAscending = "collcollate ASC",
collctypeAscending = "collctype ASC",
colliculocaleAscending = "colliculocale ASC",
collicurulesAscending = "collicurules ASC",
collversionAscending = "collversion ASC",
oidDescending = "oid DESC",
collnameDescending = "collname DESC",
collnamespaceDescending = "collnamespace DESC",
collownerDescending = "collowner DESC",
collproviderDescending = "collprovider DESC",
collisdeterministicDescending = "collisdeterministic DESC",
collencodingDescending = "collencoding DESC",
collcollateDescending = "collcollate DESC",
collctypeDescending = "collctype DESC",
colliculocaleDescending = "colliculocale DESC",
collicurulesDescending = "collicurules DESC",
collversionDescending = "collversion DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Collname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "collname" as FieldNamesType,
},
Collnamespace: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "collnamespace" as FieldNamesType,
},
Collowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "collowner" as FieldNamesType,
},
Collprovider: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "collprovider" as FieldNamesType,
},
Collisdeterministic: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "collisdeterministic" as FieldNamesType,
},
Collencoding: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "collencoding" as FieldNamesType,
},
Collcollate: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collcollate" as FieldNamesType,
},
Collctype: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collctype" as FieldNamesType,
},
Colliculocale: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "colliculocale" as FieldNamesType,
},
Collicurules: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collicurules" as FieldNamesType,
},
Collversion: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "collversion" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Collname","Collnamespace","Collowner","Collprovider","Collisdeterministic","Collencoding","Collcollate","Collctype","Colliculocale","Collicurules","Collversion"] as const;
export const FieldNames = ["oid","collname","collnamespace","collowner","collprovider","collisdeterministic","collencoding","collcollate","collctype","colliculocale","collicurules","collversion"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgCollationOidIndex;
}
export namespace PgParameterAcl {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgParameterAcl> {
 return { oid: undefined,parname: undefined,paracl: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgParameterAcl,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgParameterAcl,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
parnameAscending = "parname ASC",
paraclAscending = "paracl ASC",
oidDescending = "oid DESC",
parnameDescending = "parname DESC",
paraclDescending = "paracl DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Parname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "parname" as FieldNamesType,
},
Paracl: {
 typeName: "PgCatalog.Types.AclitemArray",
 fieldName: "paracl" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Parname","Paracl"] as const;
export const FieldNames = ["oid","parname","paracl"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgParameterAclOidIndex;
}
export namespace PgPartitionedTable {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPartitionedTable> {
 return { partrelid: undefined,partstrat: undefined,partnatts: undefined,partdefid: undefined,partattrs: undefined,partclass: undefined,partcollation: undefined,partexprs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPartitionedTable,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPartitionedTable,  PrimaryKey>
export enum SortOptions  {
partrelidAscending = "partrelid ASC",
partstratAscending = "partstrat ASC",
partnattsAscending = "partnatts ASC",
partdefidAscending = "partdefid ASC",
partattrsAscending = "partattrs ASC",
partclassAscending = "partclass ASC",
partcollationAscending = "partcollation ASC",
partexprsAscending = "partexprs ASC",
partrelidDescending = "partrelid DESC",
partstratDescending = "partstrat DESC",
partnattsDescending = "partnatts DESC",
partdefidDescending = "partdefid DESC",
partattrsDescending = "partattrs DESC",
partclassDescending = "partclass DESC",
partcollationDescending = "partcollation DESC",
partexprsDescending = "partexprs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Partrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "partrelid" as FieldNamesType,
},
Partstrat: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "partstrat" as FieldNamesType,
},
Partnatts: {
 typeName: "PgCatalog.Types.Int2",
 fieldName: "partnatts" as FieldNamesType,
},
Partdefid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "partdefid" as FieldNamesType,
},
Partattrs: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "partattrs" as FieldNamesType,
},
Partclass: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "partclass" as FieldNamesType,
},
Partcollation: {
 typeName: "PgCatalog.Types.Oidvector",
 fieldName: "partcollation" as FieldNamesType,
},
Partexprs: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "partexprs" as FieldNamesType,
},
}
export const ColumnNames = ["Partrelid","Partstrat","Partnatts","Partdefid","Partattrs","Partclass","Partcollation","Partexprs"] as const;
export const FieldNames = ["partrelid","partstrat","partnatts","partdefid","partattrs","partclass","partcollation","partexprs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPartitionedTablePartrelidIndex;
}
export namespace PgRange {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgRange> {
 return { rngtypid: undefined,rngsubtype: undefined,rngmultitypid: undefined,rngcollation: undefined,rngsubopc: undefined,rngcanonical: undefined,rngsubdiff: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgRange,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgRange,  PrimaryKey>
export enum SortOptions  {
rngtypidAscending = "rngtypid ASC",
rngsubtypeAscending = "rngsubtype ASC",
rngmultitypidAscending = "rngmultitypid ASC",
rngcollationAscending = "rngcollation ASC",
rngsubopcAscending = "rngsubopc ASC",
rngcanonicalAscending = "rngcanonical ASC",
rngsubdiffAscending = "rngsubdiff ASC",
rngtypidDescending = "rngtypid DESC",
rngsubtypeDescending = "rngsubtype DESC",
rngmultitypidDescending = "rngmultitypid DESC",
rngcollationDescending = "rngcollation DESC",
rngsubopcDescending = "rngsubopc DESC",
rngcanonicalDescending = "rngcanonical DESC",
rngsubdiffDescending = "rngsubdiff DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Rngtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngtypid" as FieldNamesType,
},
Rngsubtype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngsubtype" as FieldNamesType,
},
Rngmultitypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngmultitypid" as FieldNamesType,
},
Rngcollation: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngcollation" as FieldNamesType,
},
Rngsubopc: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "rngsubopc" as FieldNamesType,
},
Rngcanonical: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "rngcanonical" as FieldNamesType,
},
Rngsubdiff: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "rngsubdiff" as FieldNamesType,
},
}
export const ColumnNames = ["Rngtypid","Rngsubtype","Rngmultitypid","Rngcollation","Rngsubopc","Rngcanonical","Rngsubdiff"] as const;
export const FieldNames = ["rngtypid","rngsubtype","rngmultitypid","rngcollation","rngsubopc","rngcanonical","rngsubdiff"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgRangeRngtypidIndex;
}
export namespace PgTransform {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgTransform> {
 return { oid: undefined,trftype: undefined,trflang: undefined,trffromsql: undefined,trftosql: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgTransform,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgTransform,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
trftypeAscending = "trftype ASC",
trflangAscending = "trflang ASC",
trffromsqlAscending = "trffromsql ASC",
trftosqlAscending = "trftosql ASC",
oidDescending = "oid DESC",
trftypeDescending = "trftype DESC",
trflangDescending = "trflang DESC",
trffromsqlDescending = "trffromsql DESC",
trftosqlDescending = "trftosql DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Trftype: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "trftype" as FieldNamesType,
},
Trflang: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "trflang" as FieldNamesType,
},
Trffromsql: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "trffromsql" as FieldNamesType,
},
Trftosql: {
 typeName: "PgCatalog.Types.Regproc",
 fieldName: "trftosql" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Trftype","Trflang","Trffromsql","Trftosql"] as const;
export const FieldNames = ["oid","trftype","trflang","trffromsql","trftosql"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgTransformOidIndex;
}
export namespace PgSequence {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSequence> {
 return { seqrelid: undefined,seqtypid: undefined,seqstart: undefined,seqincrement: undefined,seqmax: undefined,seqmin: undefined,seqcache: undefined,seqcycle: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSequence,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSequence,  PrimaryKey>
export enum SortOptions  {
seqrelidAscending = "seqrelid ASC",
seqtypidAscending = "seqtypid ASC",
seqstartAscending = "seqstart ASC",
seqincrementAscending = "seqincrement ASC",
seqmaxAscending = "seqmax ASC",
seqminAscending = "seqmin ASC",
seqcacheAscending = "seqcache ASC",
seqcycleAscending = "seqcycle ASC",
seqrelidDescending = "seqrelid DESC",
seqtypidDescending = "seqtypid DESC",
seqstartDescending = "seqstart DESC",
seqincrementDescending = "seqincrement DESC",
seqmaxDescending = "seqmax DESC",
seqminDescending = "seqmin DESC",
seqcacheDescending = "seqcache DESC",
seqcycleDescending = "seqcycle DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Seqrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "seqrelid" as FieldNamesType,
},
Seqtypid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "seqtypid" as FieldNamesType,
},
Seqstart: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqstart" as FieldNamesType,
},
Seqincrement: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqincrement" as FieldNamesType,
},
Seqmax: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqmax" as FieldNamesType,
},
Seqmin: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqmin" as FieldNamesType,
},
Seqcache: {
 typeName: "PgCatalog.Types.Int8",
 fieldName: "seqcache" as FieldNamesType,
},
Seqcycle: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "seqcycle" as FieldNamesType,
},
}
export const ColumnNames = ["Seqrelid","Seqtypid","Seqstart","Seqincrement","Seqmax","Seqmin","Seqcache","Seqcycle"] as const;
export const FieldNames = ["seqrelid","seqtypid","seqstart","seqincrement","seqmax","seqmin","seqcache","seqcycle"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSequenceSeqrelidIndex;
}
export namespace PgPublication {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublication> {
 return { oid: undefined,pubname: undefined,pubowner: undefined,puballtables: undefined,pubinsert: undefined,pubupdate: undefined,pubdelete: undefined,pubtruncate: undefined,pubviaroot: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublication,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublication,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pubnameAscending = "pubname ASC",
pubownerAscending = "pubowner ASC",
puballtablesAscending = "puballtables ASC",
pubinsertAscending = "pubinsert ASC",
pubupdateAscending = "pubupdate ASC",
pubdeleteAscending = "pubdelete ASC",
pubtruncateAscending = "pubtruncate ASC",
pubviarootAscending = "pubviaroot ASC",
oidDescending = "oid DESC",
pubnameDescending = "pubname DESC",
pubownerDescending = "pubowner DESC",
puballtablesDescending = "puballtables DESC",
pubinsertDescending = "pubinsert DESC",
pubupdateDescending = "pubupdate DESC",
pubdeleteDescending = "pubdelete DESC",
pubtruncateDescending = "pubtruncate DESC",
pubviarootDescending = "pubviaroot DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Pubname: {
 typeName: "PgCatalog.Types.Name",
 fieldName: "pubname" as FieldNamesType,
},
Pubowner: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pubowner" as FieldNamesType,
},
Puballtables: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "puballtables" as FieldNamesType,
},
Pubinsert: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubinsert" as FieldNamesType,
},
Pubupdate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubupdate" as FieldNamesType,
},
Pubdelete: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubdelete" as FieldNamesType,
},
Pubtruncate: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubtruncate" as FieldNamesType,
},
Pubviaroot: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "pubviaroot" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Pubname","Pubowner","Puballtables","Pubinsert","Pubupdate","Pubdelete","Pubtruncate","Pubviaroot"] as const;
export const FieldNames = ["oid","pubname","pubowner","puballtables","pubinsert","pubupdate","pubdelete","pubtruncate","pubviaroot"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationOidIndex;
}
export namespace PgPublicationNamespace {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublicationNamespace> {
 return { oid: undefined,pnpubid: undefined,pnnspid: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublicationNamespace,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublicationNamespace,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
pnpubidAscending = "pnpubid ASC",
pnnspidAscending = "pnnspid ASC",
oidDescending = "oid DESC",
pnpubidDescending = "pnpubid DESC",
pnnspidDescending = "pnnspid DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Pnpubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pnpubid" as FieldNamesType,
},
Pnnspid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "pnnspid" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Pnpubid","Pnnspid"] as const;
export const FieldNames = ["oid","pnpubid","pnnspid"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationNamespaceOidIndex;
}
export namespace PgPublicationRel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgPublicationRel> {
 return { oid: undefined,prpubid: undefined,prrelid: undefined,prqual: undefined,prattrs: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgPublicationRel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgPublicationRel,  PrimaryKey>
export enum SortOptions  {
oidAscending = "oid ASC",
prpubidAscending = "prpubid ASC",
prrelidAscending = "prrelid ASC",
prqualAscending = "prqual ASC",
prattrsAscending = "prattrs ASC",
oidDescending = "oid DESC",
prpubidDescending = "prpubid DESC",
prrelidDescending = "prrelid DESC",
prqualDescending = "prqual DESC",
prattrsDescending = "prattrs DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Oid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "oid" as FieldNamesType,
},
Prpubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prpubid" as FieldNamesType,
},
Prrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "prrelid" as FieldNamesType,
},
Prqual: {
 typeName: "PgCatalog.Types.PgNodeTree",
 fieldName: "prqual" as FieldNamesType,
},
Prattrs: {
 typeName: "PgCatalog.Types.Int2vector",
 fieldName: "prattrs" as FieldNamesType,
},
}
export const ColumnNames = ["Oid","Prpubid","Prrelid","Prqual","Prattrs"] as const;
export const FieldNames = ["oid","prpubid","prrelid","prqual","prattrs"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgPublicationRelOidIndex;
}
export namespace PgSubscriptionRel {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgSubscriptionRel> {
 return { srsubid: undefined,srrelid: undefined,srsubstate: undefined,srsublsn: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgSubscriptionRel,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgSubscriptionRel,  PrimaryKey>
export enum SortOptions  {
srsubidAscending = "srsubid ASC",
srrelidAscending = "srrelid ASC",
srsubstateAscending = "srsubstate ASC",
srsublsnAscending = "srsublsn ASC",
srsubidDescending = "srsubid DESC",
srrelidDescending = "srrelid DESC",
srsubstateDescending = "srsubstate DESC",
srsublsnDescending = "srsublsn DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Srsubid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srsubid" as FieldNamesType,
},
Srrelid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "srrelid" as FieldNamesType,
},
Srsubstate: {
 typeName: "PgCatalog.Types.Char",
 fieldName: "srsubstate" as FieldNamesType,
},
Srsublsn: {
 typeName: "PgCatalog.Types.PgLsn",
 fieldName: "srsublsn" as FieldNamesType,
},
}
export const ColumnNames = ["Srsubid","Srrelid","Srsubstate","Srsublsn"] as const;
export const FieldNames = ["srsubid","srrelid","srsubstate","srsublsn"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex;
}
export namespace PgLargeobject {
export function emptyRow() : PossiblyEmpty<PgCatalog.Types.PgLargeobject> {
 return { loid: undefined,pageno: undefined,data: undefined };
}

export type Optional = Pick<PgCatalog.Types.PgLargeobject,never>
export type Values = PartiallyOptional<PgCatalog.Types.PgLargeobject,  PrimaryKey>
export enum SortOptions  {
loidAscending = "loid ASC",
pagenoAscending = "pageno ASC",
dataAscending = "data ASC",
loidDescending = "loid DESC",
pagenoDescending = "pageno DESC",
dataDescending = "data DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Loid: {
 typeName: "PgCatalog.Types.Oid",
 fieldName: "loid" as FieldNamesType,
},
Pageno: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "pageno" as FieldNamesType,
},
Data: {
 typeName: "PgCatalog.Types.Bytea",
 fieldName: "data" as FieldNamesType,
},
}
export const ColumnNames = ["Loid","Pageno","Data"] as const;
export const FieldNames = ["loid","pageno","data"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = PgCatalog.Types.PgLargeobjectLoidPnIndex;
}
}
}
export namespace InformationSchema {
export namespace Types {

export type CardinalNumber = PgCatalog.Types.Int4;

export type CardinalNumberArray = 
     Array<InformationSchema.Types.CardinalNumber>
    ;

export type CharacterData = PgCatalog.Types.Varchar;

export type CharacterDataArray = 
     Array<InformationSchema.Types.CharacterData>
    ;

export type SqlIdentifier = PgCatalog.Types.Name;

export type SqlIdentifierArray = 
     Array<InformationSchema.Types.SqlIdentifier>
    ;

export type InformationSchemaCatalogName = {
catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type InformationSchemaCatalogNameArray = 
     Array<InformationSchema.Types.InformationSchemaCatalogName>
    ;

export type TimeStamp = PgCatalog.Types.Timestamptz;

export type TimeStampArray = 
     Array<InformationSchema.Types.TimeStamp>
    ;

export type YesOrNo = PgCatalog.Types.Varchar;

export type YesOrNoArray = 
     Array<InformationSchema.Types.YesOrNo>
    ;

export type ApplicableRoles = {
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ApplicableRolesArray = 
     Array<InformationSchema.Types.ApplicableRoles>
    ;

export type AdministrableRoleAuthorizations = {
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type AdministrableRoleAuthorizationsArray = 
     Array<InformationSchema.Types.AdministrableRoleAuthorizations>
    ;

export type Attributes = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
attributeDefault: Nullable<InformationSchema.Types.CharacterData>;
isNullable: Nullable<InformationSchema.Types.YesOrNo>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
attributeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
attributeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
isDerivedReferenceAttribute: Nullable<InformationSchema.Types.YesOrNo>;
}

export type AttributesArray = 
     Array<InformationSchema.Types.Attributes>
    ;

export type CharacterSets = {
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
characterRepertoire: Nullable<InformationSchema.Types.SqlIdentifier>;
formOfUse: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCollateName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CharacterSetsArray = 
     Array<InformationSchema.Types.CharacterSets>
    ;

export type CheckConstraintRoutineUsage = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CheckConstraintRoutineUsageArray = 
     Array<InformationSchema.Types.CheckConstraintRoutineUsage>
    ;

export type CheckConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
checkClause: Nullable<InformationSchema.Types.CharacterData>;
}

export type CheckConstraintsArray = 
     Array<InformationSchema.Types.CheckConstraints>
    ;

export type Collations = {
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
padAttribute: Nullable<InformationSchema.Types.CharacterData>;
}

export type CollationsArray = 
     Array<InformationSchema.Types.Collations>
    ;

export type CollationCharacterSetApplicability = {
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type CollationCharacterSetApplicabilityArray = 
     Array<InformationSchema.Types.CollationCharacterSetApplicability>
    ;

export type ColumnColumnUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
dependentColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnColumnUsageArray = 
     Array<InformationSchema.Types.ColumnColumnUsage>
    ;

export type ColumnDomainUsage = {
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnDomainUsageArray = 
     Array<InformationSchema.Types.ColumnDomainUsage>
    ;

export type ColumnPrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ColumnPrivilegesArray = 
     Array<InformationSchema.Types.ColumnPrivileges>
    ;

export type ColumnUdtUsage = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ColumnUdtUsageArray = 
     Array<InformationSchema.Types.ColumnUdtUsage>
    ;

export type Columns = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
columnDefault: Nullable<InformationSchema.Types.CharacterData>;
isNullable: Nullable<InformationSchema.Types.YesOrNo>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
isSelfReferencing: Nullable<InformationSchema.Types.YesOrNo>;
isIdentity: Nullable<InformationSchema.Types.YesOrNo>;
identityGeneration: Nullable<InformationSchema.Types.CharacterData>;
identityStart: Nullable<InformationSchema.Types.CharacterData>;
identityIncrement: Nullable<InformationSchema.Types.CharacterData>;
identityMaximum: Nullable<InformationSchema.Types.CharacterData>;
identityMinimum: Nullable<InformationSchema.Types.CharacterData>;
identityCycle: Nullable<InformationSchema.Types.YesOrNo>;
isGenerated: Nullable<InformationSchema.Types.CharacterData>;
generationExpression: Nullable<InformationSchema.Types.CharacterData>;
isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ColumnsArray = 
     Array<InformationSchema.Types.Columns>
    ;

export type ConstraintColumnUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ConstraintColumnUsageArray = 
     Array<InformationSchema.Types.ConstraintColumnUsage>
    ;

export type ConstraintTableUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ConstraintTableUsageArray = 
     Array<InformationSchema.Types.ConstraintTableUsage>
    ;

export type DomainConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
}

export type DomainConstraintsArray = 
     Array<InformationSchema.Types.DomainConstraints>
    ;

export type DomainUdtUsage = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DomainUdtUsageArray = 
     Array<InformationSchema.Types.DomainUdtUsage>
    ;

export type Domains = {
domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
domainDefault: Nullable<InformationSchema.Types.CharacterData>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DomainsArray = 
     Array<InformationSchema.Types.Domains>
    ;

export type EnabledRoles = {
roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type EnabledRolesArray = 
     Array<InformationSchema.Types.EnabledRoles>
    ;

export type KeyColumnUsage = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
positionInUniqueConstraint: Nullable<InformationSchema.Types.CardinalNumber>;
}

export type KeyColumnUsageArray = 
     Array<InformationSchema.Types.KeyColumnUsage>
    ;

export type Parameters = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
parameterMode: Nullable<InformationSchema.Types.CharacterData>;
isResult: Nullable<InformationSchema.Types.YesOrNo>;
asLocator: Nullable<InformationSchema.Types.YesOrNo>;
parameterName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
parameterDefault: Nullable<InformationSchema.Types.CharacterData>;
}

export type ParametersArray = 
     Array<InformationSchema.Types.Parameters>
    ;

export type ReferentialConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
uniqueConstraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
matchOption: Nullable<InformationSchema.Types.CharacterData>;
updateRule: Nullable<InformationSchema.Types.CharacterData>;
deleteRule: Nullable<InformationSchema.Types.CharacterData>;
}

export type ReferentialConstraintsArray = 
     Array<InformationSchema.Types.ReferentialConstraints>
    ;

export type RoleColumnGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleColumnGrantsArray = 
     Array<InformationSchema.Types.RoleColumnGrants>
    ;

export type RoutineColumnUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineColumnUsageArray = 
     Array<InformationSchema.Types.RoutineColumnUsage>
    ;

export type RoutinePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoutinePrivilegesArray = 
     Array<InformationSchema.Types.RoutinePrivileges>
    ;

export type RoleRoutineGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleRoutineGrantsArray = 
     Array<InformationSchema.Types.RoleRoutineGrants>
    ;

export type RoutineRoutineUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineRoutineUsageArray = 
     Array<InformationSchema.Types.RoutineRoutineUsage>
    ;

export type RoutineSequenceUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineSequenceUsageArray = 
     Array<InformationSchema.Types.RoutineSequenceUsage>
    ;

export type RoutineTableUsage = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutineTableUsageArray = 
     Array<InformationSchema.Types.RoutineTableUsage>
    ;

export type Routines = {
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
routineType: Nullable<InformationSchema.Types.CharacterData>;
moduleCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
moduleSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
moduleName: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
typeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
typeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
typeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
routineBody: Nullable<InformationSchema.Types.CharacterData>;
routineDefinition: Nullable<InformationSchema.Types.CharacterData>;
externalName: Nullable<InformationSchema.Types.CharacterData>;
externalLanguage: Nullable<InformationSchema.Types.CharacterData>;
parameterStyle: Nullable<InformationSchema.Types.CharacterData>;
isDeterministic: Nullable<InformationSchema.Types.YesOrNo>;
sqlDataAccess: Nullable<InformationSchema.Types.CharacterData>;
isNullCall: Nullable<InformationSchema.Types.YesOrNo>;
sqlPath: Nullable<InformationSchema.Types.CharacterData>;
schemaLevelRoutine: Nullable<InformationSchema.Types.YesOrNo>;
maxDynamicResultSets: Nullable<InformationSchema.Types.CardinalNumber>;
isUserDefinedCast: Nullable<InformationSchema.Types.YesOrNo>;
isImplicitlyInvocable: Nullable<InformationSchema.Types.YesOrNo>;
securityType: Nullable<InformationSchema.Types.CharacterData>;
toSqlSpecificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
toSqlSpecificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
toSqlSpecificName: Nullable<InformationSchema.Types.SqlIdentifier>;
asLocator: Nullable<InformationSchema.Types.YesOrNo>;
created: Nullable<InformationSchema.Types.TimeStamp>;
lastAltered: Nullable<InformationSchema.Types.TimeStamp>;
newSavepointLevel: Nullable<InformationSchema.Types.YesOrNo>;
isUdtDependent: Nullable<InformationSchema.Types.YesOrNo>;
resultCastFromDataType: Nullable<InformationSchema.Types.CharacterData>;
resultCastAsLocator: Nullable<InformationSchema.Types.YesOrNo>;
resultCastCharMaxLength: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastCharOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastCharSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCharSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCharSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastCollationName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastNumericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastNumericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastNumericScale: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastDatetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastIntervalType: Nullable<InformationSchema.Types.CharacterData>;
resultCastIntervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastTypeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastTypeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastTypeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastScopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
resultCastMaximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
resultCastDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type RoutinesArray = 
     Array<InformationSchema.Types.Routines>
    ;

export type Schemata = {
catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
schemaName: Nullable<InformationSchema.Types.SqlIdentifier>;
schemaOwner: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
defaultCharacterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
sqlPath: Nullable<InformationSchema.Types.CharacterData>;
}

export type SchemataArray = 
     Array<InformationSchema.Types.Schemata>
    ;

export type Sequences = {
sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
startValue: Nullable<InformationSchema.Types.CharacterData>;
minimumValue: Nullable<InformationSchema.Types.CharacterData>;
maximumValue: Nullable<InformationSchema.Types.CharacterData>;
increment: Nullable<InformationSchema.Types.CharacterData>;
cycleOption: Nullable<InformationSchema.Types.YesOrNo>;
}

export type SequencesArray = 
     Array<InformationSchema.Types.Sequences>
    ;

export type SqlFeatures = {
featureId: Nullable<InformationSchema.Types.CharacterData>;
featureName: Nullable<InformationSchema.Types.CharacterData>;
subFeatureId: Nullable<InformationSchema.Types.CharacterData>;
subFeatureName: Nullable<InformationSchema.Types.CharacterData>;
isSupported: Nullable<InformationSchema.Types.YesOrNo>;
isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlFeaturesArray = 
     Array<InformationSchema.Types.SqlFeatures>
    ;

export type SqlImplementationInfo = {
implementationInfoId: Nullable<InformationSchema.Types.CharacterData>;
implementationInfoName: Nullable<InformationSchema.Types.CharacterData>;
integerValue: Nullable<InformationSchema.Types.CardinalNumber>;
characterValue: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlImplementationInfoArray = 
     Array<InformationSchema.Types.SqlImplementationInfo>
    ;

export type SqlParts = {
featureId: Nullable<InformationSchema.Types.CharacterData>;
featureName: Nullable<InformationSchema.Types.CharacterData>;
isSupported: Nullable<InformationSchema.Types.YesOrNo>;
isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlPartsArray = 
     Array<InformationSchema.Types.SqlParts>
    ;

export type SqlSizing = {
sizingId: Nullable<InformationSchema.Types.CardinalNumber>;
sizingName: Nullable<InformationSchema.Types.CharacterData>;
supportedValue: Nullable<InformationSchema.Types.CardinalNumber>;
comments: Nullable<InformationSchema.Types.CharacterData>;
}

export type SqlSizingArray = 
     Array<InformationSchema.Types.SqlSizing>
    ;

export type TableConstraints = {
constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
constraintType: Nullable<InformationSchema.Types.CharacterData>;
isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
enforced: Nullable<InformationSchema.Types.YesOrNo>;
nullsDistinct: Nullable<InformationSchema.Types.YesOrNo>;
}

export type TableConstraintsArray = 
     Array<InformationSchema.Types.TableConstraints>
    ;

export type TablePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
}

export type TablePrivilegesArray = 
     Array<InformationSchema.Types.TablePrivileges>
    ;

export type RoleTableGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleTableGrantsArray = 
     Array<InformationSchema.Types.RoleTableGrants>
    ;

export type Tables = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableType: Nullable<InformationSchema.Types.CharacterData>;
selfReferencingColumnName: Nullable<InformationSchema.Types.SqlIdentifier>;
referenceGeneration: Nullable<InformationSchema.Types.CharacterData>;
userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
isTyped: Nullable<InformationSchema.Types.YesOrNo>;
commitAction: Nullable<InformationSchema.Types.CharacterData>;
}

export type TablesArray = 
     Array<InformationSchema.Types.Tables>
    ;

export type Transforms = {
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
groupName: Nullable<InformationSchema.Types.SqlIdentifier>;
transformType: Nullable<InformationSchema.Types.CharacterData>;
}

export type TransformsArray = 
     Array<InformationSchema.Types.Transforms>
    ;

export type TriggeredUpdateColumns = {
triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type TriggeredUpdateColumnsArray = 
     Array<InformationSchema.Types.TriggeredUpdateColumns>
    ;

export type Triggers = {
triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
eventManipulation: Nullable<InformationSchema.Types.CharacterData>;
eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionOrder: Nullable<InformationSchema.Types.CardinalNumber>;
actionCondition: Nullable<InformationSchema.Types.CharacterData>;
actionStatement: Nullable<InformationSchema.Types.CharacterData>;
actionOrientation: Nullable<InformationSchema.Types.CharacterData>;
actionTiming: Nullable<InformationSchema.Types.CharacterData>;
actionReferenceOldTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceNewTable: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceOldRow: Nullable<InformationSchema.Types.SqlIdentifier>;
actionReferenceNewRow: Nullable<InformationSchema.Types.SqlIdentifier>;
created: Nullable<InformationSchema.Types.TimeStamp>;
}

export type TriggersArray = 
     Array<InformationSchema.Types.Triggers>
    ;

export type UdtPrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type UdtPrivilegesArray = 
     Array<InformationSchema.Types.UdtPrivileges>
    ;

export type RoleUdtGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleUdtGrantsArray = 
     Array<InformationSchema.Types.RoleUdtGrants>
    ;

export type UsagePrivileges = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type UsagePrivilegesArray = 
     Array<InformationSchema.Types.UsagePrivileges>
    ;

export type RoleUsageGrants = {
grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
privilegeType: Nullable<InformationSchema.Types.CharacterData>;
isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
}

export type RoleUsageGrantsArray = 
     Array<InformationSchema.Types.RoleUsageGrants>
    ;

export type UserDefinedTypes = {
userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
userDefinedTypeCategory: Nullable<InformationSchema.Types.CharacterData>;
isInstantiable: Nullable<InformationSchema.Types.YesOrNo>;
isFinal: Nullable<InformationSchema.Types.YesOrNo>;
orderingForm: Nullable<InformationSchema.Types.CharacterData>;
orderingCategory: Nullable<InformationSchema.Types.CharacterData>;
orderingRoutineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
orderingRoutineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
orderingRoutineName: Nullable<InformationSchema.Types.SqlIdentifier>;
referenceType: Nullable<InformationSchema.Types.CharacterData>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
sourceDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
refDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserDefinedTypesArray = 
     Array<InformationSchema.Types.UserDefinedTypes>
    ;

export type ViewColumnUsage = {
viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewColumnUsageArray = 
     Array<InformationSchema.Types.ViewColumnUsage>
    ;

export type ViewRoutineUsage = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewRoutineUsageArray = 
     Array<InformationSchema.Types.ViewRoutineUsage>
    ;

export type ViewTableUsage = {
viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ViewTableUsageArray = 
     Array<InformationSchema.Types.ViewTableUsage>
    ;

export type Views = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
viewDefinition: Nullable<InformationSchema.Types.CharacterData>;
checkOption: Nullable<InformationSchema.Types.CharacterData>;
isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerDeletable: Nullable<InformationSchema.Types.YesOrNo>;
isTriggerInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
}

export type ViewsArray = 
     Array<InformationSchema.Types.Views>
    ;

export type DataTypePrivileges = {
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type DataTypePrivilegesArray = 
     Array<InformationSchema.Types.DataTypePrivileges>
    ;

export type ElementTypes = {
objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
objectType: Nullable<InformationSchema.Types.CharacterData>;
collectionTypeIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
dataType: Nullable<InformationSchema.Types.CharacterData>;
characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
intervalType: Nullable<InformationSchema.Types.CharacterData>;
intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
domainDefault: Nullable<InformationSchema.Types.CharacterData>;
udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ElementTypesArray = 
     Array<InformationSchema.Types.ElementTypes>
    ;

export type PgForeignTableColumns = {
nspname: Nullable<PgCatalog.Types.Name>;
relname: Nullable<PgCatalog.Types.Name>;
attname: Nullable<PgCatalog.Types.Name>;
attfdwoptions: PgCatalog.Types.TextArray;
}

export type ColumnOptions = {
tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ColumnOptionsArray = 
     Array<InformationSchema.Types.ColumnOptions>
    ;

export type PgForeignDataWrappers = {
oid: Nullable<PgCatalog.Types.Oid>;
fdwowner: Nullable<PgCatalog.Types.Oid>;
fdwoptions: PgCatalog.Types.TextArray;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrapperOptions = {
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrapperOptionsArray = 
     Array<InformationSchema.Types.ForeignDataWrapperOptions>
    ;

export type ForeignDataWrappers = {
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
libraryName: Nullable<InformationSchema.Types.CharacterData>;
foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignDataWrappersArray = 
     Array<InformationSchema.Types.ForeignDataWrappers>
    ;

export type PgForeignServers = {
oid: Nullable<PgCatalog.Types.Oid>;
srvoptions: PgCatalog.Types.TextArray;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignServerOptions = {
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignServerOptionsArray = 
     Array<InformationSchema.Types.ForeignServerOptions>
    ;

export type ForeignServers = {
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignServersArray = 
     Array<InformationSchema.Types.ForeignServers>
    ;

export type PgForeignTables = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
ftoptions: PgCatalog.Types.TextArray;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignTableOptions = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type ForeignTableOptionsArray = 
     Array<InformationSchema.Types.ForeignTableOptions>
    ;

export type ForeignTables = {
foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type ForeignTablesArray = 
     Array<InformationSchema.Types.ForeignTables>
    ;

export type PgUserMappings = {
oid: Nullable<PgCatalog.Types.Oid>;
umoptions: PgCatalog.Types.TextArray;
umuser: Nullable<PgCatalog.Types.Oid>;
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
srvowner: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserMappingOptions = {
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
optionValue: Nullable<InformationSchema.Types.CharacterData>;
}

export type UserMappingOptionsArray = 
     Array<InformationSchema.Types.UserMappingOptions>
    ;

export type UserMappings = {
authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
}

export type UserMappingsArray = 
     Array<InformationSchema.Types.UserMappings>
    ;
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlFeatures> {
 return { featureId: undefined,featureName: undefined,subFeatureId: undefined,subFeatureName: undefined,isSupported: undefined,isVerifiedBy: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlFeatures,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlFeatures,  PrimaryKey>
export enum SortOptions  {
featureIdAscending = "feature_id ASC",
featureNameAscending = "feature_name ASC",
subFeatureIdAscending = "sub_feature_id ASC",
subFeatureNameAscending = "sub_feature_name ASC",
isSupportedAscending = "is_supported ASC",
isVerifiedByAscending = "is_verified_by ASC",
commentsAscending = "comments ASC",
featureIdDescending = "feature_id DESC",
featureNameDescending = "feature_name DESC",
subFeatureIdDescending = "sub_feature_id DESC",
subFeatureNameDescending = "sub_feature_name DESC",
isSupportedDescending = "is_supported DESC",
isVerifiedByDescending = "is_verified_by DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
FeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureId" as FieldNamesType,
},
FeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureName" as FieldNamesType,
},
SubFeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "subFeatureId" as FieldNamesType,
},
SubFeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "subFeatureName" as FieldNamesType,
},
IsSupported: {
 typeName: "InformationSchema.Types.YesOrNo",
 fieldName: "isSupported" as FieldNamesType,
},
IsVerifiedBy: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "isVerifiedBy" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["FeatureId","FeatureName","SubFeatureId","SubFeatureName","IsSupported","IsVerifiedBy","Comments"] as const;
export const FieldNames = ["featureId","featureName","subFeatureId","subFeatureName","isSupported","isVerifiedBy","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlImplementationInfo {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlImplementationInfo> {
 return { implementationInfoId: undefined,implementationInfoName: undefined,integerValue: undefined,characterValue: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlImplementationInfo,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlImplementationInfo,  PrimaryKey>
export enum SortOptions  {
implementationInfoIdAscending = "implementation_info_id ASC",
implementationInfoNameAscending = "implementation_info_name ASC",
integerValueAscending = "integer_value ASC",
characterValueAscending = "character_value ASC",
commentsAscending = "comments ASC",
implementationInfoIdDescending = "implementation_info_id DESC",
implementationInfoNameDescending = "implementation_info_name DESC",
integerValueDescending = "integer_value DESC",
characterValueDescending = "character_value DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
ImplementationInfoId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "implementationInfoId" as FieldNamesType,
},
ImplementationInfoName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "implementationInfoName" as FieldNamesType,
},
IntegerValue: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "integerValue" as FieldNamesType,
},
CharacterValue: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "characterValue" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["ImplementationInfoId","ImplementationInfoName","IntegerValue","CharacterValue","Comments"] as const;
export const FieldNames = ["implementationInfoId","implementationInfoName","integerValue","characterValue","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlParts {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlParts> {
 return { featureId: undefined,featureName: undefined,isSupported: undefined,isVerifiedBy: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlParts,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlParts,  PrimaryKey>
export enum SortOptions  {
featureIdAscending = "feature_id ASC",
featureNameAscending = "feature_name ASC",
isSupportedAscending = "is_supported ASC",
isVerifiedByAscending = "is_verified_by ASC",
commentsAscending = "comments ASC",
featureIdDescending = "feature_id DESC",
featureNameDescending = "feature_name DESC",
isSupportedDescending = "is_supported DESC",
isVerifiedByDescending = "is_verified_by DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
FeatureId: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureId" as FieldNamesType,
},
FeatureName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "featureName" as FieldNamesType,
},
IsSupported: {
 typeName: "InformationSchema.Types.YesOrNo",
 fieldName: "isSupported" as FieldNamesType,
},
IsVerifiedBy: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "isVerifiedBy" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["FeatureId","FeatureName","IsSupported","IsVerifiedBy","Comments"] as const;
export const FieldNames = ["featureId","featureName","isSupported","isVerifiedBy","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace SqlSizing {
export function emptyRow() : PossiblyEmpty<InformationSchema.Types.SqlSizing> {
 return { sizingId: undefined,sizingName: undefined,supportedValue: undefined,comments: undefined };
}
export type PrimaryKey = never;
export type Optional = Pick<InformationSchema.Types.SqlSizing,never>
export type Values = PartiallyOptional<InformationSchema.Types.SqlSizing,  PrimaryKey>
export enum SortOptions  {
sizingIdAscending = "sizing_id ASC",
sizingNameAscending = "sizing_name ASC",
supportedValueAscending = "supported_value ASC",
commentsAscending = "comments ASC",
sizingIdDescending = "sizing_id DESC",
sizingNameDescending = "sizing_name DESC",
supportedValueDescending = "supported_value DESC",
commentsDescending = "comments DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
SizingId: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "sizingId" as FieldNamesType,
},
SizingName: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "sizingName" as FieldNamesType,
},
SupportedValue: {
 typeName: "InformationSchema.Types.CardinalNumber",
 fieldName: "supportedValue" as FieldNamesType,
},
Comments: {
 typeName: "InformationSchema.Types.CharacterData",
 fieldName: "comments" as FieldNamesType,
},
}
export const ColumnNames = ["SizingId","SizingName","SupportedValue","Comments"] as const;
export const FieldNames = ["sizingId","sizingName","supportedValue","comments"] as const;
type FieldNamesType = typeof FieldNames[number];
}
}
}
export namespace Public {
export namespace Types {

export type Spheroid = never;

export type SpheroidArray = 
     Array<Public.Types.Spheroid>
    ;

export type Geometry = never;

export type GeometryArray = 
     Array<Public.Types.Geometry>
    ;

export type Box3d = never;

export type Box3dArray = 
     Array<Public.Types.Box3d>
    ;

export type Box2d = never;

export type Box2dArray = 
     Array<Public.Types.Box2d>
    ;

export type Box2df = never;

export type Box2dfArray = 
     Array<Public.Types.Box2df>
    ;

export type Gidx = never;

export type GidxArray = 
     Array<Public.Types.Gidx>
    ;

export type GeometryDump = {
path: PgCatalog.Types.Int4Array;
geom: Nullable<Public.Types.Geometry>;
}

export type GeometryDumpArray = 
     Array<Public.Types.GeometryDump>
    ;

export type SpatialRefSys = {
srid: PgCatalog.Types.Int4;
authName: Nullable<PgCatalog.Types.Varchar>;
authSrid: Nullable<PgCatalog.Types.Int4>;
srtext: Nullable<PgCatalog.Types.Varchar>;
proj4text: Nullable<PgCatalog.Types.Varchar>;
}

export type SpatialRefSysArray = 
     Array<Public.Types.SpatialRefSys>
    ;

export type ValidDetail = {
valid: Nullable<PgCatalog.Types.Bool>;
reason: Nullable<PgCatalog.Types.Varchar>;
location: Nullable<Public.Types.Geometry>;
}

export type ValidDetailArray = 
     Array<Public.Types.ValidDetail>
    ;

export type Geography = never;

export type GeographyArray = 
     Array<Public.Types.Geography>
    ;

export type GeographyColumns = {
fTableCatalog: Nullable<PgCatalog.Types.Name>;
fTableSchema: Nullable<PgCatalog.Types.Name>;
fTableName: Nullable<PgCatalog.Types.Name>;
fGeographyColumn: Nullable<PgCatalog.Types.Name>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
srid: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Text>;
}

export type GeographyColumnsArray = 
     Array<Public.Types.GeographyColumns>
    ;

export type GeometryColumns = {
fTableCatalog: Nullable<PgCatalog.Types.Varchar>;
fTableSchema: Nullable<PgCatalog.Types.Name>;
fTableName: Nullable<PgCatalog.Types.Name>;
fGeometryColumn: Nullable<PgCatalog.Types.Name>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
srid: Nullable<PgCatalog.Types.Int4>;
type: Nullable<PgCatalog.Types.Varchar>;
}

export type GeometryColumnsArray = 
     Array<Public.Types.GeometryColumns>
    ;

export type NycCensusBlocks = {
gid: PgCatalog.Types.Int4;
blkid: Nullable<PgCatalog.Types.Varchar>;
popnTotal: Nullable<PgCatalog.Types.Float8>;
popnWhite: Nullable<PgCatalog.Types.Float8>;
popnBlack: Nullable<PgCatalog.Types.Float8>;
popnNativ: Nullable<PgCatalog.Types.Float8>;
popnAsian: Nullable<PgCatalog.Types.Float8>;
popnOther: Nullable<PgCatalog.Types.Float8>;
boroname: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycCensusBlocksArray = 
     Array<Public.Types.NycCensusBlocks>
    ;

export type NycHomicides = {
gid: PgCatalog.Types.Int4;
incidentD: Nullable<PgCatalog.Types.Date>;
boroname: Nullable<PgCatalog.Types.Varchar>;
numVictim: Nullable<PgCatalog.Types.Varchar>;
primaryMo: Nullable<PgCatalog.Types.Varchar>;
id: Nullable<PgCatalog.Types.Float8>;
weapon: Nullable<PgCatalog.Types.Varchar>;
lightDark: Nullable<PgCatalog.Types.Varchar>;
year: Nullable<PgCatalog.Types.Float8>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycHomicidesArray = 
     Array<Public.Types.NycHomicides>
    ;

export type NycNeighborhoods = {
gid: PgCatalog.Types.Int4;
boroname: Nullable<PgCatalog.Types.Varchar>;
name: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycNeighborhoodsArray = 
     Array<Public.Types.NycNeighborhoods>
    ;

export type NycStreets = {
gid: PgCatalog.Types.Int4;
id: Nullable<PgCatalog.Types.Float8>;
name: Nullable<PgCatalog.Types.Varchar>;
oneway: Nullable<PgCatalog.Types.Varchar>;
type: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycStreetsArray = 
     Array<Public.Types.NycStreets>
    ;

export type NycSubwayStations = {
gid: PgCatalog.Types.Int4;
objectid: Nullable<PgCatalog.Types.Numeric>;
id: Nullable<PgCatalog.Types.Numeric>;
name: Nullable<PgCatalog.Types.Varchar>;
altName: Nullable<PgCatalog.Types.Varchar>;
crossSt: Nullable<PgCatalog.Types.Varchar>;
longName: Nullable<PgCatalog.Types.Varchar>;
label: Nullable<PgCatalog.Types.Varchar>;
borough: Nullable<PgCatalog.Types.Varchar>;
nghbhd: Nullable<PgCatalog.Types.Varchar>;
routes: Nullable<PgCatalog.Types.Varchar>;
transfers: Nullable<PgCatalog.Types.Varchar>;
color: Nullable<PgCatalog.Types.Varchar>;
express: Nullable<PgCatalog.Types.Varchar>;
closed: Nullable<PgCatalog.Types.Varchar>;
geom: Nullable<Public.Types.Geometry>;
}

export type NycSubwayStationsArray = 
     Array<Public.Types.NycSubwayStations>
    ;

export type SpatialRefSysPkey = {
srid: PgCatalog.Types.Int4;
}

export type NycCensusBlocksPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycHomicidesPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycNeighborhoodsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycStreetsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycSubwayStationsPkey = {
gid: PgCatalog.Types.Int4;
}

export type NycCensusBlocksGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycHomicidesGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycNeighborhoodsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycStreetsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type NycSubwayStationsGeomIdx = {
geom: Nullable<Public.Types.Geometry>;
}

export type PostgisSrs = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type PostgisSrsAll = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type PostgisSrsSearch = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
srname: Nullable<PgCatalog.Types.Text>;
srtext: Nullable<PgCatalog.Types.Text>;
proj4text: Nullable<PgCatalog.Types.Text>;
pointSw: Nullable<Public.Types.Geometry>;
pointNe: Nullable<Public.Types.Geometry>;
}

export type StMinimumboundingradius = {
center: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StMaximuminscribedcircle = {
center: Nullable<Public.Types.Geometry>;
nearest: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StLargestemptycircle = {
center: Nullable<Public.Types.Geometry>;
nearest: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}

export type StHexagongrid = {
geom: Nullable<Public.Types.Geometry>;
i: Nullable<PgCatalog.Types.Int4>;
j: Nullable<PgCatalog.Types.Int4>;
}

export type StSquaregrid = {
geom: Nullable<Public.Types.Geometry>;
i: Nullable<PgCatalog.Types.Int4>;
j: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Procedures {
export namespace StForcepolygoncw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace SpheroidIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace SpheroidOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Spheroid>;
}
}
export namespace GeometryIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace GeometryOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryTypmodIn {


export type Parameters = {
argument_0: PgCatalog.Types.CstringArray;
}
}
export namespace GeometryTypmodOut {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryAnalyze {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryRecv {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySend {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Geometry_6564 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Geometry_8997 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Point>;
}
}
export namespace Point {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryB0d8 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Path>;
}
}
export namespace Path {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryF1be {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Polygon>;
}
}
export namespace Polygon {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StX {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StY {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StZ {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StM {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3dIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box3dOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Box2dIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box2dOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Box2dfIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace Box2dfOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
}
}
export namespace GidxIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace GidxOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
}
}
export namespace GeometryLt {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryLe {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGt {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGe {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryEq {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryCmp {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySortsupport {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryHash {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistDistance_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistCompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPenalty_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPicksplit_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistUnion_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSame_2d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistDecompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSortsupport_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StForcerhr {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisNoop {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcepolygonccw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace GserializedGistSel_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GserializedGistSelNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GserializedGistJoinsel_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int2>;
}
}
export namespace GserializedGistJoinselNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Int2>;
}
}
export namespace GeometryOverlaps {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySame {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCentroid {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceBox {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContains {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryWithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryLeft {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverleft {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryBelow {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverbelow {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverright {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryRight {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryOverabove {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryAbove {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeometryGistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPenaltyNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistUnionNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistSameNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryGistDecompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryOverlapsNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContainsNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryWithinNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySameNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCentroidNd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryDistanceCpa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryGistDistanceNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StShiftlongitude {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StWrapx {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
wrap: Nullable<PgCatalog.Types.Float8>;
move: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StXmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StYmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StZmin {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StXmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StYmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StZmax {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace StExpand_269a {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpand_96e3 {


export type Parameters = {
box: Nullable<Public.Types.Box2d>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PostgisGetbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakebox2d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StEstimatedextentD2f5 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StEstimatedextent_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StEstimatedextent_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StFindextent_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StFindextent_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisAddbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisDropbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisHasbbox {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StQuantizecoordinates {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
precX: Nullable<PgCatalog.Types.Int4>;
precY: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMemsize {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSummary_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNpoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNrings {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlength {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLength2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLength_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLengthspheroid {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Spheroid>;
}
}
export namespace StLength2dspheroid {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Spheroid>;
}
}
export namespace St_3dperimeter {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPerimeter2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPerimeter_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StArea2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StArea_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIspolygoncw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIspolygonccw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistancespheroidCd56 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<Public.Types.Spheroid>;
}
}
export namespace StDistancespheroid_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistance_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointinsidecircle {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAzimuth_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StProjectD5eb {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
azimuth: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StProject_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAngleE1dd {


export type Parameters = {
pt1: Nullable<Public.Types.Geometry>;
pt2: Nullable<Public.Types.Geometry>;
pt3: Nullable<Public.Types.Geometry>;
pt4: Nullable<Public.Types.Geometry>;
}
}
export namespace StLineextend {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
distanceForward: Nullable<PgCatalog.Types.Float8>;
distanceBackward: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce2d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForce3dz {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce3d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce3dm {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
mvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForce4d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
zvalue: Nullable<PgCatalog.Types.Float8>;
mvalue: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StForcecollection {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectionextract_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StCollectionextract_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectionhomogenize {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMulti {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcecurve {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcesfs_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StForcesfs_88bc {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
version: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StExpand_2074 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpand_704e {


export type Parameters = {
box: Nullable<Public.Types.Box3d>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
dz: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpand_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StExpand_5500 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
dx: Nullable<PgCatalog.Types.Float8>;
dy: Nullable<PgCatalog.Types.Float8>;
dz: Nullable<PgCatalog.Types.Float8>;
dm: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StEnvelope {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBoundingdiagonal {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fits: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StReverse {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StScroll {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisGeosNoop {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNormalize {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
}
}
export namespace StZmflag {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNdims {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsewkt_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsewkt_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAstwkb_652e {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
prec: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
withSizes: Nullable<PgCatalog.Types.Bool>;
withBoxes: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAstwkbF3fd {


export type Parameters = {
geom: Public.Types.GeometryArray;
ids: PgCatalog.Types.Int8Array;
prec: Nullable<PgCatalog.Types.Int4>;
precZ: Nullable<PgCatalog.Types.Int4>;
precM: Nullable<PgCatalog.Types.Int4>;
withSizes: Nullable<PgCatalog.Types.Bool>;
withBoxes: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAsewkb_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAshexewkb_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAshexewkb_88bc {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsewkb_88bc {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAslatlontext {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tmpl: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geomfromewkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromewkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromtwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Geomfromewkt {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromewkt {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisCacheBbox {

}
export namespace StMakepoint_0aec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepoint_81ec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepoint_570b {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepointm {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3dmakebox {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakelineA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StLinefrommultipoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakeline_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StAddpoint_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StScaleD5eb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAddpointAa17 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StRemovepoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSetpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakeenvelope {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTileenvelope {


export type Parameters = {
zoom: Nullable<PgCatalog.Types.Int4>;
x: Nullable<PgCatalog.Types.Int4>;
y: Nullable<PgCatalog.Types.Int4>;
bounds: Nullable<Public.Types.Geometry>;
margin: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakepolygonE2e3 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Public.Types.GeometryArray;
}
}
export namespace StMakepolygon_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBuildarea {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPolygonizeA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StClusterintersectingA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StClusterwithin_0e49 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinemerge_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLinemerge_4ba2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAffineE42d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
argument_6: Nullable<PgCatalog.Types.Float8>;
argument_7: Nullable<PgCatalog.Types.Float8>;
argument_8: Nullable<PgCatalog.Types.Float8>;
argument_9: Nullable<PgCatalog.Types.Float8>;
argument_10: Nullable<PgCatalog.Types.Float8>;
argument_11: Nullable<PgCatalog.Types.Float8>;
argument_12: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAffine_1962 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
argument_6: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotate_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotate_8b9f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotate_463e {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<Public.Types.Geometry>;
}
}
export namespace StRotatez {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotatex {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRotatey {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTranslate_8b9f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTranslateD5eb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StScale_3651 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StScale_1bee {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StScale_8b9f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTransscale {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDump {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumprings {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumppoints {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StDumpsegments {
export const Columns = {
Path: {
 typeName: "PgCatalog.Types.Int4Array",
 fieldName: "path" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Path","Geom"] as const;
export const FieldNames = ["path","geom"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PopulateGeometryColumns_23fc {


export type Parameters = {
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PopulateGeometryColumns_4174 {


export type Parameters = {
tblOid: Nullable<PgCatalog.Types.Oid>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_8fbb {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSridIn: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_4617 {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSrid: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Addgeometrycolumn_093c {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSrid: Nullable<PgCatalog.Types.Int4>;
newType: Nullable<PgCatalog.Types.Varchar>;
newDim: Nullable<PgCatalog.Types.Int4>;
useTypmod: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Dropgeometrycolumn_0412 {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace Dropgeometrycolumn_2253 {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace DropgeometrycolumnF11a {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace Dropgeometrytable_2253 {


export type Parameters = {
catalogName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace StSegmentize_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace DropgeometrytableF11a {


export type Parameters = {
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace DropgeometrytableBfde {


export type Parameters = {
tableName: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace UpdategeometrysridB2ee {


export type Parameters = {
catalognName: Nullable<PgCatalog.Types.Varchar>;
schemaName: Nullable<PgCatalog.Types.Varchar>;
tableName: Nullable<PgCatalog.Types.Varchar>;
columnName: Nullable<PgCatalog.Types.Varchar>;
newSridIn: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Updategeometrysrid_7b58 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Varchar>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Updategeometrysrid_11c8 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace FindSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Varchar>;
argument_1: Nullable<PgCatalog.Types.Varchar>;
argument_2: Nullable<PgCatalog.Types.Varchar>;
}
}
export namespace GetProj4FromSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSetsrid_6cbe {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSrid_0cdb {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisTransformGeometry {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisSrsCodes {


export type Parameters = {
authName: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisSrs {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
authName: Nullable<PgCatalog.Types.Text>;
authSrid: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisSrsAll {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];
}
export namespace PostgisSrsSearch {
export const Columns = {
AuthName: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "authSrid" as FieldNamesType,
},
Srname: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srname" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Text",
 fieldName: "proj4text" as FieldNamesType,
},
PointSw: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointSw" as FieldNamesType,
},
PointNe: {
 typeName: "Public.Types.Geometry",
 fieldName: "pointNe" as FieldNamesType,
},
}
export const ColumnNames = ["AuthName","AuthSrid","Srname","Srtext","Proj4text","PointSw","PointNe"] as const;
export const FieldNames = ["authName","authSrid","srname","srtext","proj4text","pointSw","pointNe"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
bounds: Nullable<Public.Types.Geometry>;
authname: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransform_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTransform_88bc {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
toProj: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransform_655c {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fromProj: Nullable<PgCatalog.Types.Text>;
toProj: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StTransform_5016 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
fromProj: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTransformPipelineGeometry {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
forward: Nullable<PgCatalog.Types.Bool>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTransformpipeline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StInversetransformpipeline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
pipeline: Nullable<PgCatalog.Types.Text>;
toSrid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisVersion {

}
export namespace PostgisLiblwgeomVersion {

}
export namespace PostgisProjVersion {

}
export namespace PostgisWagyuVersion {

}
export namespace PostgisScriptsInstalled {

}
export namespace PostgisLibVersion {

}
export namespace PostgisScriptsReleased {

}
export namespace PostgisGeosVersion {

}
export namespace PostgisGeosCompiledVersion {

}
export namespace PostgisLibRevision {

}
export namespace PostgisSvnVersion {

}
export namespace PostgisLibxmlVersion {

}
export namespace PostgisScriptsBuildDate {

}
export namespace PostgisLibBuildDate {

}
export namespace PostgisExtensionsUpgrade {


export type Parameters = {
targetVersion: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLineinterpolatepoint_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLineinterpolatepoints_8fda {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
repeat: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLinesubstringD5eb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinelocatepoint_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StAddmeasure {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StClosestpointofapproach {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisFullVersion {

}
export namespace Box2d_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3d_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box2d_07e9 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Box3dE505 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Box_07e9 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace Text {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Box3dtobox {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace GeometryE505 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
}
}
export namespace Geometry_07e9 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
}
}
export namespace GeometryE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geometry_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Bytea_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSimplify_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSimplify_8fda {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSimplifyvw {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSeteffectivearea {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StFilterbym {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StChaikinsmoothing {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSnaptogrid_5500 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogridD5eb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogrid_7163 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSnaptogrid_7f2e {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Float8>;
argument_4: Nullable<PgCatalog.Types.Float8>;
argument_5: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDistancecpa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCpawithin {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIsvalidtrajectory {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIntersection_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBufferBf44 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
options: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StBufferC33e {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
quadsegs: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMinimumboundingradius {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Radius"] as const;
export const FieldNames = ["center","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumboundingcircle {


export type Parameters = {
inputgeom: Nullable<Public.Types.Geometry>;
segsPerQuarter: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StOrientedenvelope {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StOffsetcurve {


export type Parameters = {
line: Nullable<Public.Types.Geometry>;
distance: Nullable<PgCatalog.Types.Float8>;
params: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeneratepoints_6cbe {


export type Parameters = {
area: Nullable<Public.Types.Geometry>;
npoints: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeneratepointsD341 {


export type Parameters = {
area: Nullable<Public.Types.Geometry>;
npoints: Nullable<PgCatalog.Types.Int4>;
seed: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StConvexhull {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSimplifypreservetopology {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIsvalidreason_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsvaliddetail {
export const Columns = {
Valid: {
 typeName: "PgCatalog.Types.Bool",
 fieldName: "valid" as FieldNamesType,
},
Reason: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "reason" as FieldNamesType,
},
Location: {
 typeName: "Public.Types.Geometry",
 fieldName: "location" as FieldNamesType,
},
}
export const ColumnNames = ["Valid","Reason","Location"] as const;
export const FieldNames = ["valid","reason","location"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StIsvalidreason_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StIsvalid_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StHausdorffdistance_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StHausdorffdistance_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StFrechetdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMaximuminscribedcircle {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Nearest: {
 typeName: "Public.Types.Geometry",
 fieldName: "nearest" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Nearest","Radius"] as const;
export const FieldNames = ["center","nearest","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StLargestemptycircle {
export const Columns = {
Center: {
 typeName: "Public.Types.Geometry",
 fieldName: "center" as FieldNamesType,
},
Nearest: {
 typeName: "Public.Types.Geometry",
 fieldName: "nearest" as FieldNamesType,
},
Radius: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "radius" as FieldNamesType,
},
}
export const ColumnNames = ["Center","Nearest","Radius"] as const;
export const FieldNames = ["center","nearest","radius"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
boundary: Nullable<Public.Types.Geometry>;
}
}
export namespace StDifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBoundary {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSymdifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StSymmetricdifference {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StUnion_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StUnion_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StUnaryunion {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRemoverepeatedpoints {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StClipbybox2d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
box: Nullable<Public.Types.Box2d>;
}
}
export namespace StSubdivide {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxvertices: Nullable<PgCatalog.Types.Int4>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StReduceprecision {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
gridsize: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StMakevalid_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMakevalid_88bc {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
params: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCleangeometry {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StSplit {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSharedpaths {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSnap {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StRelatematch {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StNode {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
}
}
export namespace StDelaunaytriangles {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StTriangulatepolygon {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
}
}
export namespace StVoronoipolygons {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
extendTo: Nullable<Public.Types.Geometry>;
}
}
export namespace StVoronoilines {


export type Parameters = {
g1: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
extendTo: Nullable<Public.Types.Geometry>;
}
}
export namespace StCombinebbox_1ee2 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCombinebbox_9d67 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box3d>;
argument_1: Nullable<Public.Types.Box3d>;
}
}
export namespace StCombinebbox_1a7e {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollect_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCollectA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace PgisGeometryAccumTransfn_43cf {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisGeometryAccumTransfn_7c68 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PgisGeometryAccumTransfn_0b93 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PgisGeometryCollectFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryPolygonizeFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryClusterintersectingFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryClusterwithinFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryMakelineFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryCoverageunionFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelTransfn_43cf {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisGeometryUnionParallelTransfn_7c68 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PgisGeometryUnionParallelCombinefn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelSerialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelDeserialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisGeometryUnionParallelFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StUnionA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StCoverageunionA4b6 {


export type Parameters = {
argument_0: Public.Types.GeometryArray;
}
}
export namespace StRelate_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StRelateAa17 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StRelateCaf9 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDisjoint {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace PostgisIndexSupportfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StLinecrossingdirection {


export type Parameters = {
line1: Nullable<Public.Types.Geometry>;
line2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDwithin_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StTouches {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StIntersects_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCrosses {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StContains {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StContainsproperly {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StWithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCovers_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCoveredby_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StOverlaps {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDfullywithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3ddwithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3ddfullywithin {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace St_3dintersects {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StOrderingequals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StEquals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsvalid_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumclearance {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StMinimumclearanceline {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StCentroid_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometricmedian {


export type Parameters = {
g: Nullable<Public.Types.Geometry>;
tolerance: Nullable<PgCatalog.Types.Float8>;
maxIter: Nullable<PgCatalog.Types.Int4>;
failIfNotConverged: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StIsring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointonsurface {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIssimple {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIscollection {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Equals {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeomfromgml_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromgmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGmltosqlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGmltosql_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromkml {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfrommarc21 {


export type Parameters = {
marc21xml: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsmarc21 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
format: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromgeojsonE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromgeojson_608f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Json>;
}
}
export namespace StGeomfromgeojson_3c9d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Jsonb>;
}
}
export namespace PostgisLibjsonVersion {

}
export namespace StLinefromencodedpolyline {


export type Parameters = {
txtin: Nullable<PgCatalog.Types.Text>;
nprecision: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsencodedpolyline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
nprecision: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAssvgD341 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
rel: Nullable<PgCatalog.Types.Int4>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgmlD341 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgml_32a0 {


export type Parameters = {
version: Nullable<PgCatalog.Types.Int4>;
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskmlCce7 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgeojsonD341 {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgeojsonF2c6 {


export type Parameters = {
r: Nullable<PgCatalog.Types.Record>;
geomColumn: Nullable<PgCatalog.Types.Text>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
prettyBool: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Json {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Jsonb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace PgisAsmvtTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsmvtTransfn_27f4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtTransfnF57f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PgisAsmvtTransfn_92c1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
argument_4: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtTransfnF5be {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Int4>;
argument_4: Nullable<PgCatalog.Types.Text>;
argument_5: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsmvtFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtCombinefn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtSerialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsmvtDeserialfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StAsmvtgeom {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
bounds: Nullable<Public.Types.Box2d>;
extent: Nullable<PgCatalog.Types.Int4>;
buffer: Nullable<PgCatalog.Types.Int4>;
clipGeom: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PostgisLibprotobufVersion {

}
export namespace PgisAsgeobufTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsgeobufTransfn_27f4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsgeobufFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace PgisAsflatgeobufTransfn_647f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
}
}
export namespace PgisAsflatgeobufTransfn_9633 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PgisAsflatgeobufTransfn_521f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Anyelement>;
argument_2: Nullable<PgCatalog.Types.Bool>;
argument_3: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PgisAsflatgeobufFinalfn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StFromflatgeobuftotable {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StFromflatgeobuf {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Anyelement>;
argument_1: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeohash_6cbe {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxchars: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBox2dfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromgeohash {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StNumpoints {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNumgeometries {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometryn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StDimension {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StExteriorring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNuminteriorrings {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StNuminteriorring {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StInteriorringn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Geometrytype_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StGeometrytype {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPointn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StNumpatches {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StPatchn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StStartpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StEndpoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsclosed {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StIsempty {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAsbinary_88bc {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsbinary_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAstext_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StAstext_6cbe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeometryfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeometryfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StWkttosql {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPointfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPointfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinefromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLinefromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolyfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StPolyfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMlinefromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMlinefromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultilinestringfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultilinestringfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultipointfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMpolyfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpolyfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StMultipolygonfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMultipolygonfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomcollfromtext_27e2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomcollfromtextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeomfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLinefromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinefromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLinestringfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StLinestringfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StPolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StPolygonfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygonfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMpointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultipointfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyAnalyze {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StMultipointfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultilinefromwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMlinefromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMlinefromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMpolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMpolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMultipolyfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StMultipolyfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StGeomcollfromwkbD8af {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StGeomcollfromwkb_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StMaxdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StClosestpoint_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StShortestline_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StLongestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StSwapordinates {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
ords: Nullable<PgCatalog.Types.Cstring>;
}
}
export namespace StFlipcoordinates {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace StBdpolyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBdmpolyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Unlockrows {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geography_28e9 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
argument_2: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace Geography_2d19 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace Bytea_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstext_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstext_3181 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace LockrowE9aa {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Text>;
argument_4: Nullable<PgCatalog.Types.Timestamp>;
}
}
export namespace Lockrow_02b4 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Lockrow_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Lockrow_9a8a {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
argument_3: Nullable<PgCatalog.Types.Timestamp>;
}
}
export namespace Addauth {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauth_27e1 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauth_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Checkauthtrigger {

}
export namespace Gettransactionid {

}
export namespace Enablelongtransactions {

}
export namespace Longtransactionsenabled {

}
export namespace Disablelongtransactions {

}
export namespace GeographyTypmodIn {


export type Parameters = {
argument_0: PgCatalog.Types.CstringArray;
}
}
export namespace GeographyTypmodOut {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyIn {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Cstring>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyOut {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyRecv {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Oid>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographySend {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAstextE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeographyfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeogfromtext {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StGeogfromwkb {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace PostgisTypmodDims {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTypmodSrid {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace PostgisTypmodType {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Geography_0cdb {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
}
}
export namespace Geometry_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGistConsistent {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geography>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace GeographyGistCompress {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistPenalty {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistPicksplit {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistUnion {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Bytea>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistSame {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2d>;
argument_1: Nullable<Public.Types.Box2d>;
argument_2: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyGistDecompress {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyOverlaps {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyDistanceKnn {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGistDistance {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<Public.Types.Geography>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace OverlapsGeog_52a8 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace OverlapsGeog_25ba {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace OverlapsGeog_8fd3 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace GeogBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographyLt {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyLe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGt {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyGe {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyEq {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace GeographyCmp {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace StAssvg_6ec5 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
rel: Nullable<PgCatalog.Types.Int4>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAssvgE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StProjectD4ec {


export type Parameters = {
geogFrom: Nullable<Public.Types.Geography>;
geogTo: Nullable<Public.Types.Geography>;
distance: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAzimuthE452 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StBuffer_49f7 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgmlE888 {


export type Parameters = {
version: Nullable<PgCatalog.Types.Int4>;
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgml_2160 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
id: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskmlF40a {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
nprefix: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAskmlE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsgeojson_6ec5 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsgeojsonE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDistance_8dcd {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StDistance_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAreaEcae {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAreaE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLengthEcae {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLengthE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StProjectEd46 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
distance: Nullable<PgCatalog.Types.Float8>;
azimuth: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StPerimeterEcae {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StSegmentizeCadf {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxSegmentLength: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StAsbinary_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAsbinary_734d {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StAsewkt_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StAsewkt_3181 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAsewktE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace Geometrytype_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StSummary_7902 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
}
}
export namespace StGeohash_3181 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
maxchars: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StSrid_7902 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
}
}
export namespace StSetsrid_3181 {


export type Parameters = {
geog: Nullable<Public.Types.Geography>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StCentroidEcae {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StCentroidE728 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCoversE452 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StDwithin_55df {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
tolerance: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StCoveredbyE452 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StIntersectsE452 {


export type Parameters = {
geog1: Nullable<Public.Types.Geography>;
geog2: Nullable<Public.Types.Geography>;
}
}
export namespace StBufferCadf {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBuffer_12e3 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StBuffer_3aaa {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StBufferC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StBufferF7c6 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StIntersectionE452 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
}
}
export namespace StIntersection_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCovers_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StCoveredby_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StDwithinEfc0 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StIntersects_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StClosestpoint_8dcd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StClosestpoint_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StShortestline_8dcd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StShortestline_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLinesubstringEd46 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinesubstringE586 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
argument_2: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLinelocatepoint_8dcd {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<Public.Types.Geography>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLinelocatepoint_2ec2 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Text>;
}
}
export namespace StLineinterpolatepoints_8796 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
repeat: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLineinterpolatepointsC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLineinterpolatepoint_612b {


export type Parameters = {
argument_0: Nullable<Public.Types.Geography>;
argument_1: Nullable<PgCatalog.Types.Float8>;
useSpheroid: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StLineinterpolatepointC349 {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Text>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StDistancesphere_3651 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StDistancesphere_6961 {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
radius: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace PostgisTypeName {


export type Parameters = {
geomname: Nullable<PgCatalog.Types.Varchar>;
coordDimension: Nullable<PgCatalog.Types.Int4>;
useNewName: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace PostgisConstraintSrid {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisConstraintDims {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace PostgisConstraintType {


export type Parameters = {
geomschema: Nullable<PgCatalog.Types.Text>;
geomtable: Nullable<PgCatalog.Types.Text>;
geomcolumn: Nullable<PgCatalog.Types.Text>;
}
}
export namespace St_3ddistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dmaxdistance {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dclosestpoint {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dshortestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlongestline {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace StCoorddim {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StCurvetoline {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
tol: Nullable<PgCatalog.Types.Float8>;
toltype: Nullable<PgCatalog.Types.Int4>;
flags: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StHasarc {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StLinetocurve {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
}
}
export namespace StPoint_0aec {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StPoint_0b7f {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Float8>;
argument_1: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointz {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
zcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointm {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
mcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPointzm {


export type Parameters = {
xcoordinate: Nullable<PgCatalog.Types.Float8>;
ycoordinate: Nullable<PgCatalog.Types.Float8>;
zcoordinate: Nullable<PgCatalog.Types.Float8>;
mcoordinate: Nullable<PgCatalog.Types.Float8>;
srid: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StPolygon {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StWkbtosql {


export type Parameters = {
wkb: Nullable<PgCatalog.Types.Bytea>;
}
}
export namespace StLocatebetween {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
frommeasure: Nullable<PgCatalog.Types.Float8>;
tomeasure: Nullable<PgCatalog.Types.Float8>;
leftrightoffset: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLocatealong {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
measure: Nullable<PgCatalog.Types.Float8>;
leftrightoffset: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StLocatebetweenelevations {


export type Parameters = {
geometry: Nullable<Public.Types.Geometry>;
fromelevation: Nullable<PgCatalog.Types.Float8>;
toelevation: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace StInterpolatepoint {


export type Parameters = {
line: Nullable<Public.Types.Geometry>;
point: Nullable<Public.Types.Geometry>;
}
}
export namespace StHexagon {


export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
cellI: Nullable<PgCatalog.Types.Int4>;
cellJ: Nullable<PgCatalog.Types.Int4>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StSquare {


export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
cellI: Nullable<PgCatalog.Types.Int4>;
cellJ: Nullable<PgCatalog.Types.Int4>;
origin: Nullable<Public.Types.Geometry>;
}
}
export namespace StHexagongrid {
export const Columns = {
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
I: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "i" as FieldNamesType,
},
J: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "j" as FieldNamesType,
},
}
export const ColumnNames = ["Geom","I","J"] as const;
export const FieldNames = ["geom","i","j"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
bounds: Nullable<Public.Types.Geometry>;
}
}
export namespace StSquaregrid {
export const Columns = {
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
I: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "i" as FieldNamesType,
},
J: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "j" as FieldNamesType,
},
}
export const ColumnNames = ["Geom","I","J"] as const;
export const FieldNames = ["geom","i","j"] as const;
type FieldNamesType = typeof FieldNames[number];

export type Parameters = {
size: Nullable<PgCatalog.Types.Float8>;
bounds: Nullable<Public.Types.Geometry>;
}
}
export namespace Contains_2d_3f2a {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace IsContained_2d_3f2a {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace Overlaps_2d_3f2a {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace Overlaps_2d_4f71 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Contains_2d_4f71 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace IsContained_2d_4f71 {


export type Parameters = {
argument_0: Nullable<Public.Types.Box2df>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Contains_2d_7d4f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace IsContained_2d_7d4f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace Overlaps_2d_7d4f {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Box2df>;
}
}
export namespace OverlapsNd_6173 {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Geometry>;
}
}
export namespace OverlapsNd_25ba {


export type Parameters = {
argument_0: Nullable<Public.Types.Gidx>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace OverlapsNd_40b7 {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<Public.Types.Gidx>;
}
}
export namespace Geom2dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace Geom3dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace Geom4dBrinInclusionAddValue {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
argument_2: Nullable<PgCatalog.Types.Internal>;
argument_3: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StSimplifypolygonhull {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
vertexFraction: Nullable<PgCatalog.Types.Float8>;
isOuter: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StConcavehull {


export type Parameters = {
paramGeom: Nullable<Public.Types.Geometry>;
paramPctconvex: Nullable<PgCatalog.Types.Float8>;
paramAllowHoles: Nullable<PgCatalog.Types.Bool>;
}
}
export namespace StAsx3d {


export type Parameters = {
geom: Nullable<Public.Types.Geometry>;
maxdecimaldigits: Nullable<PgCatalog.Types.Int4>;
options: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace StAngle_3651 {


export type Parameters = {
line1: Nullable<Public.Types.Geometry>;
line2: Nullable<Public.Types.Geometry>;
}
}
export namespace St_3dlineinterpolatepoint {


export type Parameters = {
argument_0: Nullable<Public.Types.Geometry>;
argument_1: Nullable<PgCatalog.Types.Float8>;
}
}
export namespace GeometrySpgistConfig_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChoose_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplit_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistent_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompress_2d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometryOverlaps_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContains_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometryContained_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySame_3d {


export type Parameters = {
geom1: Nullable<Public.Types.Geometry>;
geom2: Nullable<Public.Types.Geometry>;
}
}
export namespace GeometrySpgistConfig_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChoose_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplit_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistent_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistent_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompress_3d {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistConfigNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistChooseNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistInnerConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistLeafConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeometrySpgistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistConfigNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistChooseNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistPicksplitNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistInnerConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistLeafConsistentNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
argument_1: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace GeographySpgistCompressNd {


export type Parameters = {
argument_0: Nullable<PgCatalog.Types.Internal>;
}
}
export namespace StLetters {


export type Parameters = {
letters: Nullable<PgCatalog.Types.Text>;
font: Nullable<PgCatalog.Types.Json>;
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
export function emptyRow() : PossiblyEmpty<Public.Types.SpatialRefSys> {
 return { srid: undefined,authName: undefined,authSrid: undefined,srtext: undefined,proj4text: undefined };
}

export type Optional = Pick<Public.Types.SpatialRefSys,never>
export type Values = PartiallyOptional<Public.Types.SpatialRefSys,  PrimaryKey>
export enum SortOptions  {
sridAscending = "srid ASC",
authNameAscending = "auth_name ASC",
authSridAscending = "auth_srid ASC",
srtextAscending = "srtext ASC",
proj4textAscending = "proj4text ASC",
sridDescending = "srid DESC",
authNameDescending = "auth_name DESC",
authSridDescending = "auth_srid DESC",
srtextDescending = "srtext DESC",
proj4textDescending = "proj4text DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Srid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "srid" as FieldNamesType,
},
AuthName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "authName" as FieldNamesType,
},
AuthSrid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "authSrid" as FieldNamesType,
},
Srtext: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "srtext" as FieldNamesType,
},
Proj4text: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "proj4text" as FieldNamesType,
},
}
export const ColumnNames = ["Srid","AuthName","AuthSrid","Srtext","Proj4text"] as const;
export const FieldNames = ["srid","authName","authSrid","srtext","proj4text"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.SpatialRefSysPkey;
}
export namespace NycCensusBlocks {
export function emptyRow() : PossiblyEmpty<Public.Types.NycCensusBlocks> {
 return { gid: undefined,blkid: undefined,popnTotal: undefined,popnWhite: undefined,popnBlack: undefined,popnNativ: undefined,popnAsian: undefined,popnOther: undefined,boroname: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycCensusBlocks,"gid">
export type Values = PartiallyOptional<Public.Types.NycCensusBlocks, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
blkidAscending = "blkid ASC",
popnTotalAscending = "popn_total ASC",
popnWhiteAscending = "popn_white ASC",
popnBlackAscending = "popn_black ASC",
popnNativAscending = "popn_nativ ASC",
popnAsianAscending = "popn_asian ASC",
popnOtherAscending = "popn_other ASC",
boronameAscending = "boroname ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
blkidDescending = "blkid DESC",
popnTotalDescending = "popn_total DESC",
popnWhiteDescending = "popn_white DESC",
popnBlackDescending = "popn_black DESC",
popnNativDescending = "popn_nativ DESC",
popnAsianDescending = "popn_asian DESC",
popnOtherDescending = "popn_other DESC",
boronameDescending = "boroname DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Blkid: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "blkid" as FieldNamesType,
},
PopnTotal: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnTotal" as FieldNamesType,
},
PopnWhite: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnWhite" as FieldNamesType,
},
PopnBlack: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnBlack" as FieldNamesType,
},
PopnNativ: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnNativ" as FieldNamesType,
},
PopnAsian: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnAsian" as FieldNamesType,
},
PopnOther: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "popnOther" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Blkid","PopnTotal","PopnWhite","PopnBlack","PopnNativ","PopnAsian","PopnOther","Boroname","Geom"] as const;
export const FieldNames = ["gid","blkid","popnTotal","popnWhite","popnBlack","popnNativ","popnAsian","popnOther","boroname","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycCensusBlocksPkey;
}
export namespace NycHomicides {
export function emptyRow() : PossiblyEmpty<Public.Types.NycHomicides> {
 return { gid: undefined,incidentD: undefined,boroname: undefined,numVictim: undefined,primaryMo: undefined,id: undefined,weapon: undefined,lightDark: undefined,year: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycHomicides,"gid">
export type Values = PartiallyOptional<Public.Types.NycHomicides, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
incidentDAscending = "incident_d ASC",
boronameAscending = "boroname ASC",
numVictimAscending = "num_victim ASC",
primaryMoAscending = "primary_mo ASC",
idAscending = "id ASC",
weaponAscending = "weapon ASC",
lightDarkAscending = "light_dark ASC",
yearAscending = "year ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
incidentDDescending = "incident_d DESC",
boronameDescending = "boroname DESC",
numVictimDescending = "num_victim DESC",
primaryMoDescending = "primary_mo DESC",
idDescending = "id DESC",
weaponDescending = "weapon DESC",
lightDarkDescending = "light_dark DESC",
yearDescending = "year DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
IncidentD: {
 typeName: "PgCatalog.Types.Date",
 fieldName: "incidentD" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
NumVictim: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "numVictim" as FieldNamesType,
},
PrimaryMo: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "primaryMo" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "id" as FieldNamesType,
},
Weapon: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "weapon" as FieldNamesType,
},
LightDark: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "lightDark" as FieldNamesType,
},
Year: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "year" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","IncidentD","Boroname","NumVictim","PrimaryMo","Id","Weapon","LightDark","Year","Geom"] as const;
export const FieldNames = ["gid","incidentD","boroname","numVictim","primaryMo","id","weapon","lightDark","year","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycHomicidesPkey;
}
export namespace NycNeighborhoods {
export function emptyRow() : PossiblyEmpty<Public.Types.NycNeighborhoods> {
 return { gid: undefined,boroname: undefined,name: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycNeighborhoods,"gid">
export type Values = PartiallyOptional<Public.Types.NycNeighborhoods, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
boronameAscending = "boroname ASC",
nameAscending = "name ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
boronameDescending = "boroname DESC",
nameDescending = "name DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Boroname: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "boroname" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Boroname","Name","Geom"] as const;
export const FieldNames = ["gid","boroname","name","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycNeighborhoodsPkey;
}
export namespace NycStreets {
export function emptyRow() : PossiblyEmpty<Public.Types.NycStreets> {
 return { gid: undefined,id: undefined,name: undefined,oneway: undefined,type: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycStreets,"gid">
export type Values = PartiallyOptional<Public.Types.NycStreets, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
idAscending = "id ASC",
nameAscending = "name ASC",
onewayAscending = "oneway ASC",
typeAscending = "type ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
idDescending = "id DESC",
nameDescending = "name DESC",
onewayDescending = "oneway DESC",
typeDescending = "type DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Float8",
 fieldName: "id" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
Oneway: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "oneway" as FieldNamesType,
},
Type: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "type" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Id","Name","Oneway","Type","Geom"] as const;
export const FieldNames = ["gid","id","name","oneway","type","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycStreetsPkey;
}
export namespace NycSubwayStations {
export function emptyRow() : PossiblyEmpty<Public.Types.NycSubwayStations> {
 return { gid: undefined,objectid: undefined,id: undefined,name: undefined,altName: undefined,crossSt: undefined,longName: undefined,label: undefined,borough: undefined,nghbhd: undefined,routes: undefined,transfers: undefined,color: undefined,express: undefined,closed: undefined,geom: undefined };
}

export type Optional = Pick<Public.Types.NycSubwayStations,"gid">
export type Values = PartiallyOptional<Public.Types.NycSubwayStations, Optional & PrimaryKey>
export enum SortOptions  {
gidAscending = "gid ASC",
objectidAscending = "objectid ASC",
idAscending = "id ASC",
nameAscending = "name ASC",
altNameAscending = "alt_name ASC",
crossStAscending = "cross_st ASC",
longNameAscending = "long_name ASC",
labelAscending = "label ASC",
boroughAscending = "borough ASC",
nghbhdAscending = "nghbhd ASC",
routesAscending = "routes ASC",
transfersAscending = "transfers ASC",
colorAscending = "color ASC",
expressAscending = "express ASC",
closedAscending = "closed ASC",
geomAscending = "geom ASC",
gidDescending = "gid DESC",
objectidDescending = "objectid DESC",
idDescending = "id DESC",
nameDescending = "name DESC",
altNameDescending = "alt_name DESC",
crossStDescending = "cross_st DESC",
longNameDescending = "long_name DESC",
labelDescending = "label DESC",
boroughDescending = "borough DESC",
nghbhdDescending = "nghbhd DESC",
routesDescending = "routes DESC",
transfersDescending = "transfers DESC",
colorDescending = "color DESC",
expressDescending = "express DESC",
closedDescending = "closed DESC",
geomDescending = "geom DESC",
};
export type Options = ReadOptions & {
 sort?: SortOptions[],
};
export const Columns = {
Gid: {
 typeName: "PgCatalog.Types.Int4",
 fieldName: "gid" as FieldNamesType,
},
Objectid: {
 typeName: "PgCatalog.Types.Numeric",
 fieldName: "objectid" as FieldNamesType,
},
Id: {
 typeName: "PgCatalog.Types.Numeric",
 fieldName: "id" as FieldNamesType,
},
Name: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "name" as FieldNamesType,
},
AltName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "altName" as FieldNamesType,
},
CrossSt: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "crossSt" as FieldNamesType,
},
LongName: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "longName" as FieldNamesType,
},
Label: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "label" as FieldNamesType,
},
Borough: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "borough" as FieldNamesType,
},
Nghbhd: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "nghbhd" as FieldNamesType,
},
Routes: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "routes" as FieldNamesType,
},
Transfers: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "transfers" as FieldNamesType,
},
Color: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "color" as FieldNamesType,
},
Express: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "express" as FieldNamesType,
},
Closed: {
 typeName: "PgCatalog.Types.Varchar",
 fieldName: "closed" as FieldNamesType,
},
Geom: {
 typeName: "Public.Types.Geometry",
 fieldName: "geom" as FieldNamesType,
},
}
export const ColumnNames = ["Gid","Objectid","Id","Name","AltName","CrossSt","LongName","Label","Borough","Nghbhd","Routes","Transfers","Color","Express","Closed","Geom"] as const;
export const FieldNames = ["gid","objectid","id","name","altName","crossSt","longName","label","borough","nghbhd","routes","transfers","color","express","closed","geom"] as const;
type FieldNamesType = typeof FieldNames[number];
export type PrimaryKey = Public.Types.NycSubwayStationsPkey;
}
}
}
export namespace PgToast {
export namespace Types {

export type PgToast_47570Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_48328Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_48334Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1255Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1247Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2604Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2606Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2612Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2600Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2619Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3381Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3429Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2618Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2620Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3466Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2609Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_48340Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2615Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1262Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2964Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1213Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1260Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2396Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3600Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3079Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_2328Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1417Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_1418Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3118Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3256Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6000Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_826Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3394Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3596Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3592Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3456Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6243Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_3350Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6106Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_6100Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_48346Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_48352Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13658Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13663Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13668Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}

export type PgToast_13673Index = {
chunkId: Nullable<PgCatalog.Types.Oid>;
chunkSeq: Nullable<PgCatalog.Types.Int4>;
}
}
export namespace Procedures {
}
export namespace Tables {
}
}

export namespace PgCatalog {
export namespace Types {
export namespace Bool {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Bytea {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Char {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Name {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Int8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Int2 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Int2vector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return new Uint16Array(JSON.parse(from));
      }
      if (Array.isArray(from)) {
        return new Uint16Array(from);
      }
      return [];
    
}


}
export namespace Int4 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regproc {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Text {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Oid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Tid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Cid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Oidvector {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oid.parse(e));
    
}


}
export namespace PgType {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgType.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
typname: PgCatalog.Types.Name.parse(from.typname),
typnamespace: PgCatalog.Types.Oid.parse(from.typnamespace),
typowner: PgCatalog.Types.Oid.parse(from.typowner),
typlen: PgCatalog.Types.Int2.parse(from.typlen),
typbyval: PgCatalog.Types.Bool.parse(from.typbyval),
typtype: PgCatalog.Types.Char.parse(from.typtype),
typcategory: PgCatalog.Types.Char.parse(from.typcategory),
typispreferred: PgCatalog.Types.Bool.parse(from.typispreferred),
typisdefined: PgCatalog.Types.Bool.parse(from.typisdefined),
typdelim: PgCatalog.Types.Char.parse(from.typdelim),
typrelid: PgCatalog.Types.Oid.parse(from.typrelid),
typsubscript: PgCatalog.Types.Regproc.parse(from.typsubscript),
typelem: PgCatalog.Types.Oid.parse(from.typelem),
typarray: PgCatalog.Types.Oid.parse(from.typarray),
typinput: PgCatalog.Types.Regproc.parse(from.typinput),
typoutput: PgCatalog.Types.Regproc.parse(from.typoutput),
typreceive: PgCatalog.Types.Regproc.parse(from.typreceive),
typsend: PgCatalog.Types.Regproc.parse(from.typsend),
typmodin: PgCatalog.Types.Regproc.parse(from.typmodin),
typmodout: PgCatalog.Types.Regproc.parse(from.typmodout),
typanalyze: PgCatalog.Types.Regproc.parse(from.typanalyze),
typalign: PgCatalog.Types.Char.parse(from.typalign),
typstorage: PgCatalog.Types.Char.parse(from.typstorage),
typnotnull: PgCatalog.Types.Bool.parse(from.typnotnull),
typbasetype: PgCatalog.Types.Oid.parse(from.typbasetype),
typtypmod: PgCatalog.Types.Int4.parse(from.typtypmod),
typndims: PgCatalog.Types.Int4.parse(from.typndims),
typcollation: PgCatalog.Types.Oid.parse(from.typcollation),
typdefaultbin: PgCatalog.Types.PgNodeTree.parse(from.typdefaultbin),
typdefault: PgCatalog.Types.Text.parse(from.typdefault),
typacl: PgCatalog.Types.AclitemArray.parse(from.typacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttribute {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttribute.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attname: PgCatalog.Types.Name.parse(from.attname),
atttypid: PgCatalog.Types.Oid.parse(from.atttypid),
attlen: PgCatalog.Types.Int2.parse(from.attlen),
attnum: PgCatalog.Types.Int2.parse(from.attnum),
attcacheoff: PgCatalog.Types.Int4.parse(from.attcacheoff),
atttypmod: PgCatalog.Types.Int4.parse(from.atttypmod),
attndims: PgCatalog.Types.Int2.parse(from.attndims),
attbyval: PgCatalog.Types.Bool.parse(from.attbyval),
attalign: PgCatalog.Types.Char.parse(from.attalign),
attstorage: PgCatalog.Types.Char.parse(from.attstorage),
attcompression: PgCatalog.Types.Char.parse(from.attcompression),
attnotnull: PgCatalog.Types.Bool.parse(from.attnotnull),
atthasdef: PgCatalog.Types.Bool.parse(from.atthasdef),
atthasmissing: PgCatalog.Types.Bool.parse(from.atthasmissing),
attidentity: PgCatalog.Types.Char.parse(from.attidentity),
attgenerated: PgCatalog.Types.Char.parse(from.attgenerated),
attisdropped: PgCatalog.Types.Bool.parse(from.attisdropped),
attislocal: PgCatalog.Types.Bool.parse(from.attislocal),
attinhcount: PgCatalog.Types.Int2.parse(from.attinhcount),
attstattarget: PgCatalog.Types.Int2.parse(from.attstattarget),
attcollation: PgCatalog.Types.Oid.parse(from.attcollation),
attacl: PgCatalog.Types.AclitemArray.parse(from.attacl),
attoptions: PgCatalog.Types.TextArray.parse(from.attoptions),
attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
attmissingval: PgCatalog.Types.Anyarray.parse(from.attmissingval),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgProc {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProc.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
proname: PgCatalog.Types.Name.parse(from.proname),
pronamespace: PgCatalog.Types.Oid.parse(from.pronamespace),
proowner: PgCatalog.Types.Oid.parse(from.proowner),
prolang: PgCatalog.Types.Oid.parse(from.prolang),
procost: PgCatalog.Types.Float4.parse(from.procost),
prorows: PgCatalog.Types.Float4.parse(from.prorows),
provariadic: PgCatalog.Types.Oid.parse(from.provariadic),
prosupport: PgCatalog.Types.Regproc.parse(from.prosupport),
prokind: PgCatalog.Types.Char.parse(from.prokind),
prosecdef: PgCatalog.Types.Bool.parse(from.prosecdef),
proleakproof: PgCatalog.Types.Bool.parse(from.proleakproof),
proisstrict: PgCatalog.Types.Bool.parse(from.proisstrict),
proretset: PgCatalog.Types.Bool.parse(from.proretset),
provolatile: PgCatalog.Types.Char.parse(from.provolatile),
proparallel: PgCatalog.Types.Char.parse(from.proparallel),
pronargs: PgCatalog.Types.Int2.parse(from.pronargs),
pronargdefaults: PgCatalog.Types.Int2.parse(from.pronargdefaults),
prorettype: PgCatalog.Types.Oid.parse(from.prorettype),
proargtypes: PgCatalog.Types.Oidvector.parse(from.proargtypes),
proallargtypes: PgCatalog.Types.OidArray.parse(from.proallargtypes),
proargmodes: PgCatalog.Types.CharArray.parse(from.proargmodes),
proargnames: PgCatalog.Types.TextArray.parse(from.proargnames),
proargdefaults: PgCatalog.Types.PgNodeTree.parse(from.proargdefaults),
protrftypes: PgCatalog.Types.OidArray.parse(from.protrftypes),
prosrc: PgCatalog.Types.Text.parse(from.prosrc),
probin: PgCatalog.Types.Text.parse(from.probin),
prosqlbody: PgCatalog.Types.PgNodeTree.parse(from.prosqlbody),
proconfig: PgCatalog.Types.TextArray.parse(from.proconfig),
proacl: PgCatalog.Types.AclitemArray.parse(from.proacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClass {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClass.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
relname: PgCatalog.Types.Name.parse(from.relname),
relnamespace: PgCatalog.Types.Oid.parse(from.relnamespace),
reltype: PgCatalog.Types.Oid.parse(from.reltype),
reloftype: PgCatalog.Types.Oid.parse(from.reloftype),
relowner: PgCatalog.Types.Oid.parse(from.relowner),
relam: PgCatalog.Types.Oid.parse(from.relam),
relfilenode: PgCatalog.Types.Oid.parse(from.relfilenode),
reltablespace: PgCatalog.Types.Oid.parse(from.reltablespace),
relpages: PgCatalog.Types.Int4.parse(from.relpages),
reltuples: PgCatalog.Types.Float4.parse(from.reltuples),
relallvisible: PgCatalog.Types.Int4.parse(from.relallvisible),
reltoastrelid: PgCatalog.Types.Oid.parse(from.reltoastrelid),
relhasindex: PgCatalog.Types.Bool.parse(from.relhasindex),
relisshared: PgCatalog.Types.Bool.parse(from.relisshared),
relpersistence: PgCatalog.Types.Char.parse(from.relpersistence),
relkind: PgCatalog.Types.Char.parse(from.relkind),
relnatts: PgCatalog.Types.Int2.parse(from.relnatts),
relchecks: PgCatalog.Types.Int2.parse(from.relchecks),
relhasrules: PgCatalog.Types.Bool.parse(from.relhasrules),
relhastriggers: PgCatalog.Types.Bool.parse(from.relhastriggers),
relhassubclass: PgCatalog.Types.Bool.parse(from.relhassubclass),
relrowsecurity: PgCatalog.Types.Bool.parse(from.relrowsecurity),
relforcerowsecurity: PgCatalog.Types.Bool.parse(from.relforcerowsecurity),
relispopulated: PgCatalog.Types.Bool.parse(from.relispopulated),
relreplident: PgCatalog.Types.Char.parse(from.relreplident),
relispartition: PgCatalog.Types.Bool.parse(from.relispartition),
relrewrite: PgCatalog.Types.Oid.parse(from.relrewrite),
relfrozenxid: PgCatalog.Types.Xid.parse(from.relfrozenxid),
relminmxid: PgCatalog.Types.Xid.parse(from.relminmxid),
relacl: PgCatalog.Types.AclitemArray.parse(from.relacl),
reloptions: PgCatalog.Types.TextArray.parse(from.reloptions),
relpartbound: PgCatalog.Types.PgNodeTree.parse(from.relpartbound),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace Json {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xml {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace PgNodeTree {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgNdistinct {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgDependencies {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgMcvList {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgDdlCommand {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Xid8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Point {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parsePoint(from);
    
}


}
export namespace Lseg {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parseLineSegment(from);
    
}


}
export namespace Path {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parsePath(from);
    
}


}
export namespace Box {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parseBox(from);
    
}


}
export namespace Polygon {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parsePolygon(from);
    
}


}
export namespace Line {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parseLine(from);
    
}


}
export namespace Float4 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Float8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Unknown {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Circle {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return Geometry.parseCircle(from);
    
}


}
export namespace Money {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Macaddr {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Inet {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Cidr {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Macaddr8 {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return new Uint8Array(JSON.parse(from));
    }
    if (Array.isArray(from)) {
      return new Uint8Array(from);
    }
    return [];
    
}


}
export namespace Aclitem {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Bpchar {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Varchar {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Date {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Time {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Timestamp {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Timestamptz {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if ((from as unknown) instanceof JsDate) return from as Date;
      return new JsDate(from as string);
    
}


}
export namespace Interval {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Timetz {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Bit {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Varbit {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "boolean") {
        return from;
      }
      if (typeof from === "string") {
        if(['t', 'true', 'on', 'yes'].includes(from.toLowerCase())) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
      }
      if (typeof from === "number") {
        return from !== 0;
      }
      return false;
    
}


}
export namespace Numeric {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Refcursor {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Regprocedure {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regoper {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regoperator {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regclass {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regcollation {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regtype {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regrole {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regnamespace {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Uuid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return new UUID(from as string);
    
}


}
export namespace PgLsn {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "bigint") {
      return from;
    }
    if (typeof from === "number") {
      return BigInt(from);
    }
    if (typeof from === "string") {
      if (from === '') return null;
      return BigInt(from);
    }
    return null;
    
}


}
export namespace Tsvector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Gtsvector {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsquery {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace Regconfig {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Regdictionary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

    if (typeof from === "string"){
      return Number.parseFloat(from);
    }
    if (typeof from === "number") {
      return from;
    }
    return null;
    
}


}
export namespace Jsonb {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Jsonpath {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      if (typeof from === "string") {
        return from;
      }
      throw new Error(`from is not a string`, {cause: from});
    
}


}
export namespace TxidSnapshot {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgSnapshot {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int4range {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Numrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tstzrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Daterange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int8range {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int4multirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Nummultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tsmultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Tstzmultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Datemultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Int8multirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Record {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace RecordArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Record.parse(e));
    
}


}
export namespace Cstring {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Any {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Void {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Trigger {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace EventTrigger {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace LanguageHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Internal {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyelement {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      throw new Error("not implemented");
    
}


}
export namespace Anynonarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyenum {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace FdwHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace IndexAmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace TsmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace TableAmHandler {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anyrange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatible {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblearray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblenonarray {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblerange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anymultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Anycompatiblemultirange {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgBrinBloomSummary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace PgBrinMinmaxMultiSummary {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace BoolArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bool.parse(e));
    
}


}
export namespace ByteaArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bytea.parse(e));
    
}


}
export namespace CharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Char.parse(e));
    
}


}
export namespace NameArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Name.parse(e));
    
}


}
export namespace Int8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8.parse(e));
    
}


}
export namespace Int2Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int2.parse(e));
    
}


}
export namespace Int2vectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int2vector.parse(e));
    
}


}
export namespace Int4Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4.parse(e));
    
}


}
export namespace RegprocArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regproc.parse(e));
    
}


}
export namespace TextArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Text.parse(e));
    
}


}
export namespace OidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oid.parse(e));
    
}


}
export namespace TidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tid.parse(e));
    
}


}
export namespace XidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xid.parse(e));
    
}


}
export namespace CidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cid.parse(e));
    
}


}
export namespace OidvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Oidvector.parse(e));
    
}


}
export namespace PgTypeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgType.parse(e));
    
}


}
export namespace PgAttributeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAttribute.parse(e));
    
}


}
export namespace PgProcArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgProc.parse(e));
    
}


}
export namespace PgClassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgClass.parse(e));
    
}


}
export namespace JsonArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Json.parse(e));
    
}


}
export namespace XmlArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xml.parse(e));
    
}


}
export namespace Xid8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Xid8.parse(e));
    
}


}
export namespace PointArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Point.parse(e));
    
}


}
export namespace LsegArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Lseg.parse(e));
    
}


}
export namespace PathArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Path.parse(e));
    
}


}
export namespace BoxArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box.parse(e));
    
}


}
export namespace PolygonArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Polygon.parse(e));
    
}


}
export namespace LineArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Line.parse(e));
    
}


}
export namespace Float4Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Float4.parse(e));
    
}


}
export namespace Float8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Float8.parse(e));
    
}


}
export namespace CircleArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Circle.parse(e));
    
}


}
export namespace MoneyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Money.parse(e));
    
}


}
export namespace MacaddrArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Macaddr.parse(e));
    
}


}
export namespace InetArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Inet.parse(e));
    
}


}
export namespace CidrArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cidr.parse(e));
    
}


}
export namespace Macaddr8Array {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Macaddr8.parse(e));
    
}


}
export namespace AclitemArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Aclitem.parse(e));
    
}


}
export namespace BpcharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bpchar.parse(e));
    
}


}
export namespace VarcharArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Varchar.parse(e));
    
}


}
export namespace DateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Date.parse(e));
    
}


}
export namespace TimeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Time.parse(e));
    
}


}
export namespace TimestampArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timestamp.parse(e));
    
}


}
export namespace TimestamptzArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timestamptz.parse(e));
    
}


}
export namespace IntervalArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Interval.parse(e));
    
}


}
export namespace TimetzArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Timetz.parse(e));
    
}


}
export namespace BitArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Bit.parse(e));
    
}


}
export namespace VarbitArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Varbit.parse(e));
    
}


}
export namespace NumericArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Numeric.parse(e));
    
}


}
export namespace RefcursorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Refcursor.parse(e));
    
}


}
export namespace RegprocedureArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regprocedure.parse(e));
    
}


}
export namespace RegoperArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regoper.parse(e));
    
}


}
export namespace RegoperatorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regoperator.parse(e));
    
}


}
export namespace RegclassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regclass.parse(e));
    
}


}
export namespace RegcollationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regcollation.parse(e));
    
}


}
export namespace RegtypeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regtype.parse(e));
    
}


}
export namespace RegroleArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regrole.parse(e));
    
}


}
export namespace RegnamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regnamespace.parse(e));
    
}


}
export namespace UuidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Uuid.parse(e));
    
}


}
export namespace PgLsnArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLsn.parse(e));
    
}


}
export namespace TsvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsvector.parse(e));
    
}


}
export namespace GtsvectorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Gtsvector.parse(e));
    
}


}
export namespace TsqueryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsquery.parse(e));
    
}


}
export namespace RegconfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regconfig.parse(e));
    
}


}
export namespace RegdictionaryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Regdictionary.parse(e));
    
}


}
export namespace JsonbArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Jsonb.parse(e));
    
}


}
export namespace JsonpathArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Jsonpath.parse(e));
    
}


}
export namespace TxidSnapshotArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TxidSnapshot.parse(e));
    
}


}
export namespace PgSnapshotArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSnapshot.parse(e));
    
}


}
export namespace Int4rangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4range.parse(e));
    
}


}
export namespace NumrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Numrange.parse(e));
    
}


}
export namespace TsrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsrange.parse(e));
    
}


}
export namespace TstzrangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tstzrange.parse(e));
    
}


}
export namespace DaterangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Daterange.parse(e));
    
}


}
export namespace Int8rangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8range.parse(e));
    
}


}
export namespace Int4multirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int4multirange.parse(e));
    
}


}
export namespace NummultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Nummultirange.parse(e));
    
}


}
export namespace TsmultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tsmultirange.parse(e));
    
}


}
export namespace TstzmultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tstzmultirange.parse(e));
    
}


}
export namespace DatemultirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Datemultirange.parse(e));
    
}


}
export namespace Int8multirangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Int8multirange.parse(e));
    
}


}
export namespace CstringArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Cstring.parse(e));
    
}


}
export namespace PgAttrdef {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdef.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
adrelid: PgCatalog.Types.Oid.parse(from.adrelid),
adnum: PgCatalog.Types.Int2.parse(from.adnum),
adbin: PgCatalog.Types.PgNodeTree.parse(from.adbin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAttrdef.parse(e));
    
}


}
export namespace PgConstraint {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraint.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
contype: PgCatalog.Types.Char.parse(from.contype),
condeferrable: PgCatalog.Types.Bool.parse(from.condeferrable),
condeferred: PgCatalog.Types.Bool.parse(from.condeferred),
convalidated: PgCatalog.Types.Bool.parse(from.convalidated),
conrelid: PgCatalog.Types.Oid.parse(from.conrelid),
contypid: PgCatalog.Types.Oid.parse(from.contypid),
conindid: PgCatalog.Types.Oid.parse(from.conindid),
conparentid: PgCatalog.Types.Oid.parse(from.conparentid),
confrelid: PgCatalog.Types.Oid.parse(from.confrelid),
confupdtype: PgCatalog.Types.Char.parse(from.confupdtype),
confdeltype: PgCatalog.Types.Char.parse(from.confdeltype),
confmatchtype: PgCatalog.Types.Char.parse(from.confmatchtype),
conislocal: PgCatalog.Types.Bool.parse(from.conislocal),
coninhcount: PgCatalog.Types.Int2.parse(from.coninhcount),
connoinherit: PgCatalog.Types.Bool.parse(from.connoinherit),
conkey: PgCatalog.Types.Int2Array.parse(from.conkey),
confkey: PgCatalog.Types.Int2Array.parse(from.confkey),
conpfeqop: PgCatalog.Types.OidArray.parse(from.conpfeqop),
conppeqop: PgCatalog.Types.OidArray.parse(from.conppeqop),
conffeqop: PgCatalog.Types.OidArray.parse(from.conffeqop),
confdelsetcols: PgCatalog.Types.Int2Array.parse(from.confdelsetcols),
conexclop: PgCatalog.Types.OidArray.parse(from.conexclop),
conbin: PgCatalog.Types.PgNodeTree.parse(from.conbin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConstraint.parse(e));
    
}


}
export namespace PgInherits {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInherits.is(from)) {
  return {
inhrelid: PgCatalog.Types.Oid.parse(from.inhrelid),
inhparent: PgCatalog.Types.Oid.parse(from.inhparent),
inhseqno: PgCatalog.Types.Int4.parse(from.inhseqno),
inhdetachpending: PgCatalog.Types.Bool.parse(from.inhdetachpending),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgInherits.parse(e));
    
}


}
export namespace PgIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndex.is(from)) {
  return {
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
indrelid: PgCatalog.Types.Oid.parse(from.indrelid),
indnatts: PgCatalog.Types.Int2.parse(from.indnatts),
indnkeyatts: PgCatalog.Types.Int2.parse(from.indnkeyatts),
indisunique: PgCatalog.Types.Bool.parse(from.indisunique),
indnullsnotdistinct: PgCatalog.Types.Bool.parse(from.indnullsnotdistinct),
indisprimary: PgCatalog.Types.Bool.parse(from.indisprimary),
indisexclusion: PgCatalog.Types.Bool.parse(from.indisexclusion),
indimmediate: PgCatalog.Types.Bool.parse(from.indimmediate),
indisclustered: PgCatalog.Types.Bool.parse(from.indisclustered),
indisvalid: PgCatalog.Types.Bool.parse(from.indisvalid),
indcheckxmin: PgCatalog.Types.Bool.parse(from.indcheckxmin),
indisready: PgCatalog.Types.Bool.parse(from.indisready),
indislive: PgCatalog.Types.Bool.parse(from.indislive),
indisreplident: PgCatalog.Types.Bool.parse(from.indisreplident),
indkey: PgCatalog.Types.Int2vector.parse(from.indkey),
indcollation: PgCatalog.Types.Oidvector.parse(from.indcollation),
indclass: PgCatalog.Types.Oidvector.parse(from.indclass),
indoption: PgCatalog.Types.Int2vector.parse(from.indoption),
indexprs: PgCatalog.Types.PgNodeTree.parse(from.indexprs),
indpred: PgCatalog.Types.PgNodeTree.parse(from.indpred),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIndex.parse(e));
    
}


}
export namespace PgOperator {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperator.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
oprname: PgCatalog.Types.Name.parse(from.oprname),
oprnamespace: PgCatalog.Types.Oid.parse(from.oprnamespace),
oprowner: PgCatalog.Types.Oid.parse(from.oprowner),
oprkind: PgCatalog.Types.Char.parse(from.oprkind),
oprcanmerge: PgCatalog.Types.Bool.parse(from.oprcanmerge),
oprcanhash: PgCatalog.Types.Bool.parse(from.oprcanhash),
oprleft: PgCatalog.Types.Oid.parse(from.oprleft),
oprright: PgCatalog.Types.Oid.parse(from.oprright),
oprresult: PgCatalog.Types.Oid.parse(from.oprresult),
oprcom: PgCatalog.Types.Oid.parse(from.oprcom),
oprnegate: PgCatalog.Types.Oid.parse(from.oprnegate),
oprcode: PgCatalog.Types.Regproc.parse(from.oprcode),
oprrest: PgCatalog.Types.Regproc.parse(from.oprrest),
oprjoin: PgCatalog.Types.Regproc.parse(from.oprjoin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOperator.parse(e));
    
}


}
export namespace PgOpfamily {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamily.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
opfmethod: PgCatalog.Types.Oid.parse(from.opfmethod),
opfname: PgCatalog.Types.Name.parse(from.opfname),
opfnamespace: PgCatalog.Types.Oid.parse(from.opfnamespace),
opfowner: PgCatalog.Types.Oid.parse(from.opfowner),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOpfamily.parse(e));
    
}


}
export namespace PgOpclass {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclass.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
opcmethod: PgCatalog.Types.Oid.parse(from.opcmethod),
opcname: PgCatalog.Types.Name.parse(from.opcname),
opcnamespace: PgCatalog.Types.Oid.parse(from.opcnamespace),
opcowner: PgCatalog.Types.Oid.parse(from.opcowner),
opcfamily: PgCatalog.Types.Oid.parse(from.opcfamily),
opcintype: PgCatalog.Types.Oid.parse(from.opcintype),
opcdefault: PgCatalog.Types.Bool.parse(from.opcdefault),
opckeytype: PgCatalog.Types.Oid.parse(from.opckeytype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgOpclass.parse(e));
    
}


}
export namespace PgAm {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAm.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amname: PgCatalog.Types.Name.parse(from.amname),
amhandler: PgCatalog.Types.Regproc.parse(from.amhandler),
amtype: PgCatalog.Types.Char.parse(from.amtype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAm.parse(e));
    
}


}
export namespace PgAmop {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmop.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
amoplefttype: PgCatalog.Types.Oid.parse(from.amoplefttype),
amoprighttype: PgCatalog.Types.Oid.parse(from.amoprighttype),
amopstrategy: PgCatalog.Types.Int2.parse(from.amopstrategy),
amoppurpose: PgCatalog.Types.Char.parse(from.amoppurpose),
amopopr: PgCatalog.Types.Oid.parse(from.amopopr),
amopmethod: PgCatalog.Types.Oid.parse(from.amopmethod),
amopsortfamily: PgCatalog.Types.Oid.parse(from.amopsortfamily),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAmop.parse(e));
    
}


}
export namespace PgAmproc {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmproc.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
amprocfamily: PgCatalog.Types.Oid.parse(from.amprocfamily),
amproclefttype: PgCatalog.Types.Oid.parse(from.amproclefttype),
amprocrighttype: PgCatalog.Types.Oid.parse(from.amprocrighttype),
amprocnum: PgCatalog.Types.Int2.parse(from.amprocnum),
amproc: PgCatalog.Types.Regproc.parse(from.amproc),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAmproc.parse(e));
    
}


}
export namespace PgLanguage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguage.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
lanname: PgCatalog.Types.Name.parse(from.lanname),
lanowner: PgCatalog.Types.Oid.parse(from.lanowner),
lanispl: PgCatalog.Types.Bool.parse(from.lanispl),
lanpltrusted: PgCatalog.Types.Bool.parse(from.lanpltrusted),
lanplcallfoid: PgCatalog.Types.Oid.parse(from.lanplcallfoid),
laninline: PgCatalog.Types.Oid.parse(from.laninline),
lanvalidator: PgCatalog.Types.Oid.parse(from.lanvalidator),
lanacl: PgCatalog.Types.AclitemArray.parse(from.lanacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLanguage.parse(e));
    
}


}
export namespace PgLargeobjectMetadata {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectMetadata.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
lomowner: PgCatalog.Types.Oid.parse(from.lomowner),
lomacl: PgCatalog.Types.AclitemArray.parse(from.lomacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectMetadataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLargeobjectMetadata.parse(e));
    
}


}
export namespace PgLargeobject {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobject.is(from)) {
  return {
loid: PgCatalog.Types.Oid.parse(from.loid),
pageno: PgCatalog.Types.Int4.parse(from.pageno),
data: PgCatalog.Types.Bytea.parse(from.data),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLargeobject.parse(e));
    
}


}
export namespace PgAggregate {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAggregate.is(from)) {
  return {
aggfnoid: PgCatalog.Types.Regproc.parse(from.aggfnoid),
aggkind: PgCatalog.Types.Char.parse(from.aggkind),
aggnumdirectargs: PgCatalog.Types.Int2.parse(from.aggnumdirectargs),
aggtransfn: PgCatalog.Types.Regproc.parse(from.aggtransfn),
aggfinalfn: PgCatalog.Types.Regproc.parse(from.aggfinalfn),
aggcombinefn: PgCatalog.Types.Regproc.parse(from.aggcombinefn),
aggserialfn: PgCatalog.Types.Regproc.parse(from.aggserialfn),
aggdeserialfn: PgCatalog.Types.Regproc.parse(from.aggdeserialfn),
aggmtransfn: PgCatalog.Types.Regproc.parse(from.aggmtransfn),
aggminvtransfn: PgCatalog.Types.Regproc.parse(from.aggminvtransfn),
aggmfinalfn: PgCatalog.Types.Regproc.parse(from.aggmfinalfn),
aggfinalextra: PgCatalog.Types.Bool.parse(from.aggfinalextra),
aggmfinalextra: PgCatalog.Types.Bool.parse(from.aggmfinalextra),
aggfinalmodify: PgCatalog.Types.Char.parse(from.aggfinalmodify),
aggmfinalmodify: PgCatalog.Types.Char.parse(from.aggmfinalmodify),
aggsortop: PgCatalog.Types.Oid.parse(from.aggsortop),
aggtranstype: PgCatalog.Types.Oid.parse(from.aggtranstype),
aggtransspace: PgCatalog.Types.Int4.parse(from.aggtransspace),
aggmtranstype: PgCatalog.Types.Oid.parse(from.aggmtranstype),
aggmtransspace: PgCatalog.Types.Int4.parse(from.aggmtransspace),
agginitval: PgCatalog.Types.Text.parse(from.agginitval),
aggminitval: PgCatalog.Types.Text.parse(from.aggminitval),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAggregateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAggregate.parse(e));
    
}


}
export namespace PgStatistic {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatistic.is(from)) {
  return {
starelid: PgCatalog.Types.Oid.parse(from.starelid),
staattnum: PgCatalog.Types.Int2.parse(from.staattnum),
stainherit: PgCatalog.Types.Bool.parse(from.stainherit),
stanullfrac: PgCatalog.Types.Float4.parse(from.stanullfrac),
stawidth: PgCatalog.Types.Int4.parse(from.stawidth),
stadistinct: PgCatalog.Types.Float4.parse(from.stadistinct),
stakind1: PgCatalog.Types.Int2.parse(from.stakind1),
stakind2: PgCatalog.Types.Int2.parse(from.stakind2),
stakind3: PgCatalog.Types.Int2.parse(from.stakind3),
stakind4: PgCatalog.Types.Int2.parse(from.stakind4),
stakind5: PgCatalog.Types.Int2.parse(from.stakind5),
staop1: PgCatalog.Types.Oid.parse(from.staop1),
staop2: PgCatalog.Types.Oid.parse(from.staop2),
staop3: PgCatalog.Types.Oid.parse(from.staop3),
staop4: PgCatalog.Types.Oid.parse(from.staop4),
staop5: PgCatalog.Types.Oid.parse(from.staop5),
stacoll1: PgCatalog.Types.Oid.parse(from.stacoll1),
stacoll2: PgCatalog.Types.Oid.parse(from.stacoll2),
stacoll3: PgCatalog.Types.Oid.parse(from.stacoll3),
stacoll4: PgCatalog.Types.Oid.parse(from.stacoll4),
stacoll5: PgCatalog.Types.Oid.parse(from.stacoll5),
stanumbers1: PgCatalog.Types.Float4Array.parse(from.stanumbers1),
stanumbers2: PgCatalog.Types.Float4Array.parse(from.stanumbers2),
stanumbers3: PgCatalog.Types.Float4Array.parse(from.stanumbers3),
stanumbers4: PgCatalog.Types.Float4Array.parse(from.stanumbers4),
stanumbers5: PgCatalog.Types.Float4Array.parse(from.stanumbers5),
stavalues1: PgCatalog.Types.Anyarray.parse(from.stavalues1),
stavalues2: PgCatalog.Types.Anyarray.parse(from.stavalues2),
stavalues3: PgCatalog.Types.Anyarray.parse(from.stavalues3),
stavalues4: PgCatalog.Types.Anyarray.parse(from.stavalues4),
stavalues5: PgCatalog.Types.Anyarray.parse(from.stavalues5),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatistic.parse(e));
    
}


}
export namespace PgStatisticExt {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExt.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
stxrelid: PgCatalog.Types.Oid.parse(from.stxrelid),
stxname: PgCatalog.Types.Name.parse(from.stxname),
stxnamespace: PgCatalog.Types.Oid.parse(from.stxnamespace),
stxowner: PgCatalog.Types.Oid.parse(from.stxowner),
stxstattarget: PgCatalog.Types.Int4.parse(from.stxstattarget),
stxkeys: PgCatalog.Types.Int2vector.parse(from.stxkeys),
stxkind: PgCatalog.Types.CharArray.parse(from.stxkind),
stxexprs: PgCatalog.Types.PgNodeTree.parse(from.stxexprs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatisticExt.parse(e));
    
}


}
export namespace PgStatisticExtData {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtData.is(from)) {
  return {
stxoid: PgCatalog.Types.Oid.parse(from.stxoid),
stxdinherit: PgCatalog.Types.Bool.parse(from.stxdinherit),
stxdndistinct: PgCatalog.Types.PgNdistinct.parse(from.stxdndistinct),
stxddependencies: PgCatalog.Types.PgDependencies.parse(from.stxddependencies),
stxdmcv: PgCatalog.Types.PgMcvList.parse(from.stxdmcv),
stxdexpr: PgCatalog.Types.PgStatisticArray.parse(from.stxdexpr),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtDataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatisticExtData.parse(e));
    
}


}
export namespace PgRewrite {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewrite.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
rulename: PgCatalog.Types.Name.parse(from.rulename),
evClass: PgCatalog.Types.Oid.parse(from.evClass),
evType: PgCatalog.Types.Char.parse(from.evType),
evEnabled: PgCatalog.Types.Char.parse(from.evEnabled),
isInstead: PgCatalog.Types.Bool.parse(from.isInstead),
evQual: PgCatalog.Types.PgNodeTree.parse(from.evQual),
evAction: PgCatalog.Types.PgNodeTree.parse(from.evAction),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRewrite.parse(e));
    
}


}
export namespace PgTrigger {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTrigger.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
tgrelid: PgCatalog.Types.Oid.parse(from.tgrelid),
tgparentid: PgCatalog.Types.Oid.parse(from.tgparentid),
tgname: PgCatalog.Types.Name.parse(from.tgname),
tgfoid: PgCatalog.Types.Oid.parse(from.tgfoid),
tgtype: PgCatalog.Types.Int2.parse(from.tgtype),
tgenabled: PgCatalog.Types.Char.parse(from.tgenabled),
tgisinternal: PgCatalog.Types.Bool.parse(from.tgisinternal),
tgconstrrelid: PgCatalog.Types.Oid.parse(from.tgconstrrelid),
tgconstrindid: PgCatalog.Types.Oid.parse(from.tgconstrindid),
tgconstraint: PgCatalog.Types.Oid.parse(from.tgconstraint),
tgdeferrable: PgCatalog.Types.Bool.parse(from.tgdeferrable),
tginitdeferred: PgCatalog.Types.Bool.parse(from.tginitdeferred),
tgnargs: PgCatalog.Types.Int2.parse(from.tgnargs),
tgattr: PgCatalog.Types.Int2vector.parse(from.tgattr),
tgargs: PgCatalog.Types.Bytea.parse(from.tgargs),
tgqual: PgCatalog.Types.PgNodeTree.parse(from.tgqual),
tgoldtable: PgCatalog.Types.Name.parse(from.tgoldtable),
tgnewtable: PgCatalog.Types.Name.parse(from.tgnewtable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTrigger.parse(e));
    
}


}
export namespace PgEventTrigger {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTrigger.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
evtname: PgCatalog.Types.Name.parse(from.evtname),
evtevent: PgCatalog.Types.Name.parse(from.evtevent),
evtowner: PgCatalog.Types.Oid.parse(from.evtowner),
evtfoid: PgCatalog.Types.Oid.parse(from.evtfoid),
evtenabled: PgCatalog.Types.Char.parse(from.evtenabled),
evttags: PgCatalog.Types.TextArray.parse(from.evttags),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgEventTrigger.parse(e));
    
}


}
export namespace PgDescription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDescription.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
description: PgCatalog.Types.Text.parse(from.description),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDescriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDescription.parse(e));
    
}


}
export namespace PgCast {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCast.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
castsource: PgCatalog.Types.Oid.parse(from.castsource),
casttarget: PgCatalog.Types.Oid.parse(from.casttarget),
castfunc: PgCatalog.Types.Oid.parse(from.castfunc),
castcontext: PgCatalog.Types.Char.parse(from.castcontext),
castmethod: PgCatalog.Types.Char.parse(from.castmethod),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCast.parse(e));
    
}


}
export namespace PgEnum {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnum.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumsortorder: PgCatalog.Types.Float4.parse(from.enumsortorder),
enumlabel: PgCatalog.Types.Name.parse(from.enumlabel),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgEnum.parse(e));
    
}


}
export namespace PgNamespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
nspname: PgCatalog.Types.Name.parse(from.nspname),
nspowner: PgCatalog.Types.Oid.parse(from.nspowner),
nspacl: PgCatalog.Types.AclitemArray.parse(from.nspacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgNamespace.parse(e));
    
}


}
export namespace PgConversion {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversion.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
conowner: PgCatalog.Types.Oid.parse(from.conowner),
conforencoding: PgCatalog.Types.Int4.parse(from.conforencoding),
contoencoding: PgCatalog.Types.Int4.parse(from.contoencoding),
conproc: PgCatalog.Types.Regproc.parse(from.conproc),
condefault: PgCatalog.Types.Bool.parse(from.condefault),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConversion.parse(e));
    
}


}
export namespace PgDepend {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDepend.is(from)) {
  return {
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
refobjsubid: PgCatalog.Types.Int4.parse(from.refobjsubid),
deptype: PgCatalog.Types.Char.parse(from.deptype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDepend.parse(e));
    
}


}
export namespace PgDatabase {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabase.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
datname: PgCatalog.Types.Name.parse(from.datname),
datdba: PgCatalog.Types.Oid.parse(from.datdba),
encoding: PgCatalog.Types.Int4.parse(from.encoding),
datlocprovider: PgCatalog.Types.Char.parse(from.datlocprovider),
datistemplate: PgCatalog.Types.Bool.parse(from.datistemplate),
datallowconn: PgCatalog.Types.Bool.parse(from.datallowconn),
datconnlimit: PgCatalog.Types.Int4.parse(from.datconnlimit),
datfrozenxid: PgCatalog.Types.Xid.parse(from.datfrozenxid),
datminmxid: PgCatalog.Types.Xid.parse(from.datminmxid),
dattablespace: PgCatalog.Types.Oid.parse(from.dattablespace),
datcollate: PgCatalog.Types.Text.parse(from.datcollate),
datctype: PgCatalog.Types.Text.parse(from.datctype),
daticulocale: PgCatalog.Types.Text.parse(from.daticulocale),
daticurules: PgCatalog.Types.Text.parse(from.daticurules),
datcollversion: PgCatalog.Types.Text.parse(from.datcollversion),
datacl: PgCatalog.Types.AclitemArray.parse(from.datacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDatabase.parse(e));
    
}


}
export namespace PgDbRoleSetting {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDbRoleSetting.is(from)) {
  return {
setdatabase: PgCatalog.Types.Oid.parse(from.setdatabase),
setrole: PgCatalog.Types.Oid.parse(from.setrole),
setconfig: PgCatalog.Types.TextArray.parse(from.setconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDbRoleSettingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDbRoleSetting.parse(e));
    
}


}
export namespace PgTablespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
spcname: PgCatalog.Types.Name.parse(from.spcname),
spcowner: PgCatalog.Types.Oid.parse(from.spcowner),
spcacl: PgCatalog.Types.AclitemArray.parse(from.spcacl),
spcoptions: PgCatalog.Types.TextArray.parse(from.spcoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTablespace.parse(e));
    
}


}
export namespace PgAuthid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthid.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
rolname: PgCatalog.Types.Name.parse(from.rolname),
rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
rolvaliduntil: PgCatalog.Types.Timestamptz.parse(from.rolvaliduntil),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAuthid.parse(e));
    
}


}
export namespace PgAuthMembers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
roleid: PgCatalog.Types.Oid.parse(from.roleid),
member: PgCatalog.Types.Oid.parse(from.member),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
adminOption: PgCatalog.Types.Bool.parse(from.adminOption),
inheritOption: PgCatalog.Types.Bool.parse(from.inheritOption),
setOption: PgCatalog.Types.Bool.parse(from.setOption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAuthMembers.parse(e));
    
}


}
export namespace PgShdepend {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdepend.is(from)) {
  return {
dbid: PgCatalog.Types.Oid.parse(from.dbid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
deptype: PgCatalog.Types.Char.parse(from.deptype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShdepend.parse(e));
    
}


}
export namespace PgShdescription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdescription.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
description: PgCatalog.Types.Text.parse(from.description),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdescriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShdescription.parse(e));
    
}


}
export namespace PgTsConfig {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfig.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
cfgname: PgCatalog.Types.Name.parse(from.cfgname),
cfgnamespace: PgCatalog.Types.Oid.parse(from.cfgnamespace),
cfgowner: PgCatalog.Types.Oid.parse(from.cfgowner),
cfgparser: PgCatalog.Types.Oid.parse(from.cfgparser),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsConfig.parse(e));
    
}


}
export namespace PgTsConfigMap {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigMap.is(from)) {
  return {
mapcfg: PgCatalog.Types.Oid.parse(from.mapcfg),
maptokentype: PgCatalog.Types.Int4.parse(from.maptokentype),
mapseqno: PgCatalog.Types.Int4.parse(from.mapseqno),
mapdict: PgCatalog.Types.Oid.parse(from.mapdict),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigMapArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsConfigMap.parse(e));
    
}


}
export namespace PgTsDict {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDict.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
dictname: PgCatalog.Types.Name.parse(from.dictname),
dictnamespace: PgCatalog.Types.Oid.parse(from.dictnamespace),
dictowner: PgCatalog.Types.Oid.parse(from.dictowner),
dicttemplate: PgCatalog.Types.Oid.parse(from.dicttemplate),
dictinitoption: PgCatalog.Types.Text.parse(from.dictinitoption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsDict.parse(e));
    
}


}
export namespace PgTsParser {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParser.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
prsname: PgCatalog.Types.Name.parse(from.prsname),
prsnamespace: PgCatalog.Types.Oid.parse(from.prsnamespace),
prsstart: PgCatalog.Types.Regproc.parse(from.prsstart),
prstoken: PgCatalog.Types.Regproc.parse(from.prstoken),
prsend: PgCatalog.Types.Regproc.parse(from.prsend),
prsheadline: PgCatalog.Types.Regproc.parse(from.prsheadline),
prslextype: PgCatalog.Types.Regproc.parse(from.prslextype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsParser.parse(e));
    
}


}
export namespace PgTsTemplate {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplate.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
tmplname: PgCatalog.Types.Name.parse(from.tmplname),
tmplnamespace: PgCatalog.Types.Oid.parse(from.tmplnamespace),
tmplinit: PgCatalog.Types.Regproc.parse(from.tmplinit),
tmpllexize: PgCatalog.Types.Regproc.parse(from.tmpllexize),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTsTemplate.parse(e));
    
}


}
export namespace PgExtension {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtension.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
extname: PgCatalog.Types.Name.parse(from.extname),
extowner: PgCatalog.Types.Oid.parse(from.extowner),
extnamespace: PgCatalog.Types.Oid.parse(from.extnamespace),
extrelocatable: PgCatalog.Types.Bool.parse(from.extrelocatable),
extversion: PgCatalog.Types.Text.parse(from.extversion),
extconfig: PgCatalog.Types.OidArray.parse(from.extconfig),
extcondition: PgCatalog.Types.TextArray.parse(from.extcondition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgExtension.parse(e));
    
}


}
export namespace PgForeignDataWrapper {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapper.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
fdwname: PgCatalog.Types.Name.parse(from.fdwname),
fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
fdwhandler: PgCatalog.Types.Oid.parse(from.fdwhandler),
fdwvalidator: PgCatalog.Types.Oid.parse(from.fdwvalidator),
fdwacl: PgCatalog.Types.AclitemArray.parse(from.fdwacl),
fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignDataWrapper.parse(e));
    
}


}
export namespace PgForeignServer {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServer.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
srvname: PgCatalog.Types.Name.parse(from.srvname),
srvowner: PgCatalog.Types.Oid.parse(from.srvowner),
srvfdw: PgCatalog.Types.Oid.parse(from.srvfdw),
srvtype: PgCatalog.Types.Text.parse(from.srvtype),
srvversion: PgCatalog.Types.Text.parse(from.srvversion),
srvacl: PgCatalog.Types.AclitemArray.parse(from.srvacl),
srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignServer.parse(e));
    
}


}
export namespace PgUserMapping {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMapping.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
umserver: PgCatalog.Types.Oid.parse(from.umserver),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUserMapping.parse(e));
    
}


}
export namespace PgForeignTable {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignTable.is(from)) {
  return {
ftrelid: PgCatalog.Types.Oid.parse(from.ftrelid),
ftserver: PgCatalog.Types.Oid.parse(from.ftserver),
ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignTableArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgForeignTable.parse(e));
    
}


}
export namespace PgPolicy {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicy.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
polname: PgCatalog.Types.Name.parse(from.polname),
polrelid: PgCatalog.Types.Oid.parse(from.polrelid),
polcmd: PgCatalog.Types.Char.parse(from.polcmd),
polpermissive: PgCatalog.Types.Bool.parse(from.polpermissive),
polroles: PgCatalog.Types.OidArray.parse(from.polroles),
polqual: PgCatalog.Types.PgNodeTree.parse(from.polqual),
polwithcheck: PgCatalog.Types.PgNodeTree.parse(from.polwithcheck),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPolicy.parse(e));
    
}


}
export namespace PgReplicationOrigin {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOrigin.is(from)) {
  return {
roident: PgCatalog.Types.Oid.parse(from.roident),
roname: PgCatalog.Types.Text.parse(from.roname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationOrigin.parse(e));
    
}


}
export namespace PgDefaultAcl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAcl.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
defaclrole: PgCatalog.Types.Oid.parse(from.defaclrole),
defaclnamespace: PgCatalog.Types.Oid.parse(from.defaclnamespace),
defaclobjtype: PgCatalog.Types.Char.parse(from.defaclobjtype),
defaclacl: PgCatalog.Types.AclitemArray.parse(from.defaclacl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgDefaultAcl.parse(e));
    
}


}
export namespace PgInitPrivs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInitPrivs.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
privtype: PgCatalog.Types.Char.parse(from.privtype),
initprivs: PgCatalog.Types.AclitemArray.parse(from.initprivs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInitPrivsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgInitPrivs.parse(e));
    
}


}
export namespace PgSeclabel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabel.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSeclabel.parse(e));
    
}


}
export namespace PgShseclabel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShseclabel.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShseclabelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShseclabel.parse(e));
    
}


}
export namespace PgCollation {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollation.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
collname: PgCatalog.Types.Name.parse(from.collname),
collnamespace: PgCatalog.Types.Oid.parse(from.collnamespace),
collowner: PgCatalog.Types.Oid.parse(from.collowner),
collprovider: PgCatalog.Types.Char.parse(from.collprovider),
collisdeterministic: PgCatalog.Types.Bool.parse(from.collisdeterministic),
collencoding: PgCatalog.Types.Int4.parse(from.collencoding),
collcollate: PgCatalog.Types.Text.parse(from.collcollate),
collctype: PgCatalog.Types.Text.parse(from.collctype),
colliculocale: PgCatalog.Types.Text.parse(from.colliculocale),
collicurules: PgCatalog.Types.Text.parse(from.collicurules),
collversion: PgCatalog.Types.Text.parse(from.collversion),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCollation.parse(e));
    
}


}
export namespace PgParameterAcl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAcl.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
parname: PgCatalog.Types.Text.parse(from.parname),
paracl: PgCatalog.Types.AclitemArray.parse(from.paracl),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgParameterAcl.parse(e));
    
}


}
export namespace PgPartitionedTable {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPartitionedTable.is(from)) {
  return {
partrelid: PgCatalog.Types.Oid.parse(from.partrelid),
partstrat: PgCatalog.Types.Char.parse(from.partstrat),
partnatts: PgCatalog.Types.Int2.parse(from.partnatts),
partdefid: PgCatalog.Types.Oid.parse(from.partdefid),
partattrs: PgCatalog.Types.Int2vector.parse(from.partattrs),
partclass: PgCatalog.Types.Oidvector.parse(from.partclass),
partcollation: PgCatalog.Types.Oidvector.parse(from.partcollation),
partexprs: PgCatalog.Types.PgNodeTree.parse(from.partexprs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPartitionedTableArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPartitionedTable.parse(e));
    
}


}
export namespace PgRange {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRange.is(from)) {
  return {
rngtypid: PgCatalog.Types.Oid.parse(from.rngtypid),
rngsubtype: PgCatalog.Types.Oid.parse(from.rngsubtype),
rngmultitypid: PgCatalog.Types.Oid.parse(from.rngmultitypid),
rngcollation: PgCatalog.Types.Oid.parse(from.rngcollation),
rngsubopc: PgCatalog.Types.Oid.parse(from.rngsubopc),
rngcanonical: PgCatalog.Types.Regproc.parse(from.rngcanonical),
rngsubdiff: PgCatalog.Types.Regproc.parse(from.rngsubdiff),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRange.parse(e));
    
}


}
export namespace PgTransform {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransform.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
trftype: PgCatalog.Types.Oid.parse(from.trftype),
trflang: PgCatalog.Types.Oid.parse(from.trflang),
trffromsql: PgCatalog.Types.Regproc.parse(from.trffromsql),
trftosql: PgCatalog.Types.Regproc.parse(from.trftosql),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTransform.parse(e));
    
}


}
export namespace PgSequence {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequence.is(from)) {
  return {
seqrelid: PgCatalog.Types.Oid.parse(from.seqrelid),
seqtypid: PgCatalog.Types.Oid.parse(from.seqtypid),
seqstart: PgCatalog.Types.Int8.parse(from.seqstart),
seqincrement: PgCatalog.Types.Int8.parse(from.seqincrement),
seqmax: PgCatalog.Types.Int8.parse(from.seqmax),
seqmin: PgCatalog.Types.Int8.parse(from.seqmin),
seqcache: PgCatalog.Types.Int8.parse(from.seqcache),
seqcycle: PgCatalog.Types.Bool.parse(from.seqcycle),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequenceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSequence.parse(e));
    
}


}
export namespace PgPublication {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublication.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
pubname: PgCatalog.Types.Name.parse(from.pubname),
pubowner: PgCatalog.Types.Oid.parse(from.pubowner),
puballtables: PgCatalog.Types.Bool.parse(from.puballtables),
pubinsert: PgCatalog.Types.Bool.parse(from.pubinsert),
pubupdate: PgCatalog.Types.Bool.parse(from.pubupdate),
pubdelete: PgCatalog.Types.Bool.parse(from.pubdelete),
pubtruncate: PgCatalog.Types.Bool.parse(from.pubtruncate),
pubviaroot: PgCatalog.Types.Bool.parse(from.pubviaroot),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublication.parse(e));
    
}


}
export namespace PgPublicationNamespace {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespace.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
pnpubid: PgCatalog.Types.Oid.parse(from.pnpubid),
pnnspid: PgCatalog.Types.Oid.parse(from.pnnspid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespaceArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationNamespace.parse(e));
    
}


}
export namespace PgPublicationRel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRel.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
prrelid: PgCatalog.Types.Oid.parse(from.prrelid),
prqual: PgCatalog.Types.PgNodeTree.parse(from.prqual),
prattrs: PgCatalog.Types.Int2vector.parse(from.prattrs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationRel.parse(e));
    
}


}
export namespace PgSubscription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscription.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
subdbid: PgCatalog.Types.Oid.parse(from.subdbid),
subskiplsn: PgCatalog.Types.PgLsn.parse(from.subskiplsn),
subname: PgCatalog.Types.Name.parse(from.subname),
subowner: PgCatalog.Types.Oid.parse(from.subowner),
subenabled: PgCatalog.Types.Bool.parse(from.subenabled),
subbinary: PgCatalog.Types.Bool.parse(from.subbinary),
substream: PgCatalog.Types.Char.parse(from.substream),
subtwophasestate: PgCatalog.Types.Char.parse(from.subtwophasestate),
subdisableonerr: PgCatalog.Types.Bool.parse(from.subdisableonerr),
subpasswordrequired: PgCatalog.Types.Bool.parse(from.subpasswordrequired),
subrunasowner: PgCatalog.Types.Bool.parse(from.subrunasowner),
subconninfo: PgCatalog.Types.Text.parse(from.subconninfo),
subslotname: PgCatalog.Types.Name.parse(from.subslotname),
subsynccommit: PgCatalog.Types.Text.parse(from.subsynccommit),
subpublications: PgCatalog.Types.TextArray.parse(from.subpublications),
suborigin: PgCatalog.Types.Text.parse(from.suborigin),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSubscription.parse(e));
    
}


}
export namespace PgSubscriptionRel {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionRel.is(from)) {
  return {
srsubid: PgCatalog.Types.Oid.parse(from.srsubid),
srrelid: PgCatalog.Types.Oid.parse(from.srrelid),
srsubstate: PgCatalog.Types.Char.parse(from.srsubstate),
srsublsn: PgCatalog.Types.PgLsn.parse(from.srsublsn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionRelArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSubscriptionRel.parse(e));
    
}


}
export namespace PgRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRoles.is(from)) {
  return {
rolname: PgCatalog.Types.Name.parse(from.rolname),
rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
rolvaliduntil: PgCatalog.Types.Timestamptz.parse(from.rolvaliduntil),
rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
rolconfig: PgCatalog.Types.TextArray.parse(from.rolconfig),
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRoles.parse(e));
    
}


}
export namespace PgShadow {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShadow.is(from)) {
  return {
usename: PgCatalog.Types.Name.parse(from.usename),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
userepl: PgCatalog.Types.Bool.parse(from.userepl),
usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
passwd: PgCatalog.Types.Text.parse(from.passwd),
valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShadowArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShadow.parse(e));
    
}


}
export namespace PgGroup {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgGroup.is(from)) {
  return {
groname: PgCatalog.Types.Name.parse(from.groname),
grosysid: PgCatalog.Types.Oid.parse(from.grosysid),
grolist: PgCatalog.Types.OidArray.parse(from.grolist),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgGroupArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgGroup.parse(e));
    
}


}
export namespace PgUser {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUser.is(from)) {
  return {
usename: PgCatalog.Types.Name.parse(from.usename),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
userepl: PgCatalog.Types.Bool.parse(from.userepl),
usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
passwd: PgCatalog.Types.Text.parse(from.passwd),
valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUser.parse(e));
    
}


}
export namespace PgPolicies {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicies.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
policyname: PgCatalog.Types.Name.parse(from.policyname),
permissive: PgCatalog.Types.Text.parse(from.permissive),
roles: PgCatalog.Types.NameArray.parse(from.roles),
cmd: PgCatalog.Types.Text.parse(from.cmd),
qual: PgCatalog.Types.Text.parse(from.qual),
withCheck: PgCatalog.Types.Text.parse(from.withCheck),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPoliciesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPolicies.parse(e));
    
}


}
export namespace PgRules {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRules.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
rulename: PgCatalog.Types.Name.parse(from.rulename),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRulesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgRules.parse(e));
    
}


}
export namespace PgViews {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgViews.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
viewname: PgCatalog.Types.Name.parse(from.viewname),
viewowner: PgCatalog.Types.Name.parse(from.viewowner),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgViewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgViews.parse(e));
    
}


}
export namespace PgTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTables.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
tableowner: PgCatalog.Types.Name.parse(from.tableowner),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
hasrules: PgCatalog.Types.Bool.parse(from.hasrules),
hastriggers: PgCatalog.Types.Bool.parse(from.hastriggers),
rowsecurity: PgCatalog.Types.Bool.parse(from.rowsecurity),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTables.parse(e));
    
}


}
export namespace PgMatviews {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgMatviews.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
matviewname: PgCatalog.Types.Name.parse(from.matviewname),
matviewowner: PgCatalog.Types.Name.parse(from.matviewowner),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
ispopulated: PgCatalog.Types.Bool.parse(from.ispopulated),
definition: PgCatalog.Types.Text.parse(from.definition),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgMatviewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgMatviews.parse(e));
    
}


}
export namespace PgIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexes.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
indexname: PgCatalog.Types.Name.parse(from.indexname),
tablespace: PgCatalog.Types.Name.parse(from.tablespace),
indexdef: PgCatalog.Types.Text.parse(from.indexdef),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIndexes.parse(e));
    
}


}
export namespace PgSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequences.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
sequencename: PgCatalog.Types.Name.parse(from.sequencename),
sequenceowner: PgCatalog.Types.Name.parse(from.sequenceowner),
dataType: PgCatalog.Types.Regtype.parse(from.dataType),
startValue: PgCatalog.Types.Int8.parse(from.startValue),
minValue: PgCatalog.Types.Int8.parse(from.minValue),
maxValue: PgCatalog.Types.Int8.parse(from.maxValue),
incrementBy: PgCatalog.Types.Int8.parse(from.incrementBy),
cycle: PgCatalog.Types.Bool.parse(from.cycle),
cacheSize: PgCatalog.Types.Int8.parse(from.cacheSize),
lastValue: PgCatalog.Types.Int8.parse(from.lastValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSequences.parse(e));
    
}


}
export namespace PgStats {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStats.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
attname: PgCatalog.Types.Name.parse(from.attname),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
mostCommonFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonFreqs),
histogramBounds: PgCatalog.Types.Anyarray.parse(from.histogramBounds),
correlation: PgCatalog.Types.Float4.parse(from.correlation),
mostCommonElems: PgCatalog.Types.Anyarray.parse(from.mostCommonElems),
mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonElemFreqs),
elemCountHistogram: PgCatalog.Types.Float4Array.parse(from.elemCountHistogram),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStats.parse(e));
    
}


}
export namespace PgStatsExt {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatsExt.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
statisticsSchemaname: PgCatalog.Types.Name.parse(from.statisticsSchemaname),
statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
attnames: PgCatalog.Types.NameArray.parse(from.attnames),
exprs: PgCatalog.Types.TextArray.parse(from.exprs),
kinds: PgCatalog.Types.CharArray.parse(from.kinds),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nDistinct: PgCatalog.Types.PgNdistinct.parse(from.nDistinct),
dependencies: PgCatalog.Types.PgDependencies.parse(from.dependencies),
mostCommonVals: PgCatalog.Types.TextArray.parse(from.mostCommonVals),
mostCommonValNulls: PgCatalog.Types.BoolArray.parse(from.mostCommonValNulls),
mostCommonFreqs: PgCatalog.Types.Float8Array.parse(from.mostCommonFreqs),
mostCommonBaseFreqs: PgCatalog.Types.Float8Array.parse(from.mostCommonBaseFreqs),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsExtArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatsExt.parse(e));
    
}


}
export namespace PgStatsExtExprs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatsExtExprs.is(from)) {
  return {
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
statisticsSchemaname: PgCatalog.Types.Name.parse(from.statisticsSchemaname),
statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
expr: PgCatalog.Types.Text.parse(from.expr),
inherited: PgCatalog.Types.Bool.parse(from.inherited),
nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
mostCommonFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonFreqs),
histogramBounds: PgCatalog.Types.Anyarray.parse(from.histogramBounds),
correlation: PgCatalog.Types.Float4.parse(from.correlation),
mostCommonElems: PgCatalog.Types.Anyarray.parse(from.mostCommonElems),
mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(from.mostCommonElemFreqs),
elemCountHistogram: PgCatalog.Types.Float4Array.parse(from.elemCountHistogram),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatsExtExprsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatsExtExprs.parse(e));
    
}


}
export namespace PgPublicationTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationTables.is(from)) {
  return {
pubname: PgCatalog.Types.Name.parse(from.pubname),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
tablename: PgCatalog.Types.Name.parse(from.tablename),
attnames: PgCatalog.Types.NameArray.parse(from.attnames),
rowfilter: PgCatalog.Types.Text.parse(from.rowfilter),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPublicationTables.parse(e));
    
}


}
export namespace PgLocks {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLocks.is(from)) {
  return {
locktype: PgCatalog.Types.Text.parse(from.locktype),
database: PgCatalog.Types.Oid.parse(from.database),
relation: PgCatalog.Types.Oid.parse(from.relation),
page: PgCatalog.Types.Int4.parse(from.page),
tuple: PgCatalog.Types.Int2.parse(from.tuple),
virtualxid: PgCatalog.Types.Text.parse(from.virtualxid),
transactionid: PgCatalog.Types.Xid.parse(from.transactionid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int2.parse(from.objsubid),
virtualtransaction: PgCatalog.Types.Text.parse(from.virtualtransaction),
pid: PgCatalog.Types.Int4.parse(from.pid),
mode: PgCatalog.Types.Text.parse(from.mode),
granted: PgCatalog.Types.Bool.parse(from.granted),
fastpath: PgCatalog.Types.Bool.parse(from.fastpath),
waitstart: PgCatalog.Types.Timestamptz.parse(from.waitstart),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLocksArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgLocks.parse(e));
    
}


}
export namespace PgCursors {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCursors.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
statement: PgCatalog.Types.Text.parse(from.statement),
isHoldable: PgCatalog.Types.Bool.parse(from.isHoldable),
isBinary: PgCatalog.Types.Bool.parse(from.isBinary),
isScrollable: PgCatalog.Types.Bool.parse(from.isScrollable),
creationTime: PgCatalog.Types.Timestamptz.parse(from.creationTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCursorsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgCursors.parse(e));
    
}


}
export namespace PgAvailableExtensions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAvailableExtensions.is(from)) {
  return {
name: PgCatalog.Types.Name.parse(from.name),
defaultVersion: PgCatalog.Types.Text.parse(from.defaultVersion),
installedVersion: PgCatalog.Types.Text.parse(from.installedVersion),
comment: PgCatalog.Types.Text.parse(from.comment),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAvailableExtensionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAvailableExtensions.parse(e));
    
}


}
export namespace PgAvailableExtensionVersions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAvailableExtensionVersions.is(from)) {
  return {
name: PgCatalog.Types.Name.parse(from.name),
version: PgCatalog.Types.Text.parse(from.version),
installed: PgCatalog.Types.Bool.parse(from.installed),
superuser: PgCatalog.Types.Bool.parse(from.superuser),
trusted: PgCatalog.Types.Bool.parse(from.trusted),
relocatable: PgCatalog.Types.Bool.parse(from.relocatable),
schema: PgCatalog.Types.Name.parse(from.schema),
requires: PgCatalog.Types.NameArray.parse(from.requires),
comment: PgCatalog.Types.Text.parse(from.comment),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAvailableExtensionVersionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgAvailableExtensionVersions.parse(e));
    
}


}
export namespace PgPreparedXacts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPreparedXacts.is(from)) {
  return {
transaction: PgCatalog.Types.Xid.parse(from.transaction),
gid: PgCatalog.Types.Text.parse(from.gid),
prepared: PgCatalog.Types.Timestamptz.parse(from.prepared),
owner: PgCatalog.Types.Name.parse(from.owner),
database: PgCatalog.Types.Name.parse(from.database),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPreparedXactsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPreparedXacts.parse(e));
    
}


}
export namespace PgPreparedStatements {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPreparedStatements.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
statement: PgCatalog.Types.Text.parse(from.statement),
prepareTime: PgCatalog.Types.Timestamptz.parse(from.prepareTime),
parameterTypes: PgCatalog.Types.RegtypeArray.parse(from.parameterTypes),
resultTypes: PgCatalog.Types.RegtypeArray.parse(from.resultTypes),
fromSql: PgCatalog.Types.Bool.parse(from.fromSql),
genericPlans: PgCatalog.Types.Int8.parse(from.genericPlans),
customPlans: PgCatalog.Types.Int8.parse(from.customPlans),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPreparedStatementsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgPreparedStatements.parse(e));
    
}


}
export namespace PgSeclabels {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabels.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
objtype: PgCatalog.Types.Text.parse(from.objtype),
objnamespace: PgCatalog.Types.Oid.parse(from.objnamespace),
objname: PgCatalog.Types.Text.parse(from.objname),
provider: PgCatalog.Types.Text.parse(from.provider),
label: PgCatalog.Types.Text.parse(from.label),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSeclabels.parse(e));
    
}


}
export namespace PgSettings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSettings.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
unit: PgCatalog.Types.Text.parse(from.unit),
category: PgCatalog.Types.Text.parse(from.category),
shortDesc: PgCatalog.Types.Text.parse(from.shortDesc),
extraDesc: PgCatalog.Types.Text.parse(from.extraDesc),
context: PgCatalog.Types.Text.parse(from.context),
vartype: PgCatalog.Types.Text.parse(from.vartype),
source: PgCatalog.Types.Text.parse(from.source),
minVal: PgCatalog.Types.Text.parse(from.minVal),
maxVal: PgCatalog.Types.Text.parse(from.maxVal),
enumvals: PgCatalog.Types.TextArray.parse(from.enumvals),
bootVal: PgCatalog.Types.Text.parse(from.bootVal),
resetVal: PgCatalog.Types.Text.parse(from.resetVal),
sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
pendingRestart: PgCatalog.Types.Bool.parse(from.pendingRestart),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSettingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgSettings.parse(e));
    
}


}
export namespace PgFileSettings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgFileSettings.is(from)) {
  return {
sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
seqno: PgCatalog.Types.Int4.parse(from.seqno),
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
applied: PgCatalog.Types.Bool.parse(from.applied),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgFileSettingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgFileSettings.parse(e));
    
}


}
export namespace PgHbaFileRules {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgHbaFileRules.is(from)) {
  return {
ruleNumber: PgCatalog.Types.Int4.parse(from.ruleNumber),
fileName: PgCatalog.Types.Text.parse(from.fileName),
lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
type: PgCatalog.Types.Text.parse(from.type),
database: PgCatalog.Types.TextArray.parse(from.database),
userName: PgCatalog.Types.TextArray.parse(from.userName),
address: PgCatalog.Types.Text.parse(from.address),
netmask: PgCatalog.Types.Text.parse(from.netmask),
authMethod: PgCatalog.Types.Text.parse(from.authMethod),
options: PgCatalog.Types.TextArray.parse(from.options),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgHbaFileRulesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgHbaFileRules.parse(e));
    
}


}
export namespace PgIdentFileMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIdentFileMappings.is(from)) {
  return {
mapNumber: PgCatalog.Types.Int4.parse(from.mapNumber),
fileName: PgCatalog.Types.Text.parse(from.fileName),
lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
mapName: PgCatalog.Types.Text.parse(from.mapName),
sysName: PgCatalog.Types.Text.parse(from.sysName),
pgUsername: PgCatalog.Types.Text.parse(from.pgUsername),
error: PgCatalog.Types.Text.parse(from.error),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIdentFileMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgIdentFileMappings.parse(e));
    
}


}
export namespace PgTimezoneAbbrevs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTimezoneAbbrevs.is(from)) {
  return {
abbrev: PgCatalog.Types.Text.parse(from.abbrev),
utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
isDst: PgCatalog.Types.Bool.parse(from.isDst),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTimezoneAbbrevsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTimezoneAbbrevs.parse(e));
    
}


}
export namespace PgTimezoneNames {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTimezoneNames.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
abbrev: PgCatalog.Types.Text.parse(from.abbrev),
utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
isDst: PgCatalog.Types.Bool.parse(from.isDst),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTimezoneNamesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgTimezoneNames.parse(e));
    
}


}
export namespace PgConfig {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConfig.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
setting: PgCatalog.Types.Text.parse(from.setting),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConfigArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgConfig.parse(e));
    
}


}
export namespace PgShmemAllocations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShmemAllocations.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
off: PgCatalog.Types.Int8.parse(from.off),
size: PgCatalog.Types.Int8.parse(from.size),
allocatedSize: PgCatalog.Types.Int8.parse(from.allocatedSize),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShmemAllocationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgShmemAllocations.parse(e));
    
}


}
export namespace PgBackendMemoryContexts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgBackendMemoryContexts.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
ident: PgCatalog.Types.Text.parse(from.ident),
parent: PgCatalog.Types.Text.parse(from.parent),
level: PgCatalog.Types.Int4.parse(from.level),
totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
totalNblocks: PgCatalog.Types.Int8.parse(from.totalNblocks),
freeBytes: PgCatalog.Types.Int8.parse(from.freeBytes),
freeChunks: PgCatalog.Types.Int8.parse(from.freeChunks),
usedBytes: PgCatalog.Types.Int8.parse(from.usedBytes),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgBackendMemoryContextsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgBackendMemoryContexts.parse(e));
    
}


}
export namespace PgStatAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatAllTables.parse(e));
    
}


}
export namespace PgStatXactAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactAllTables.parse(e));
    
}


}
export namespace PgStatSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSysTables.parse(e));
    
}


}
export namespace PgStatXactSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactSysTables.parse(e));
    
}


}
export namespace PgStatUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
lastAutovacuum: PgCatalog.Types.Timestamptz.parse(from.lastAutovacuum),
lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(from.lastAutoanalyze),
vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserTables.parse(e));
    
}


}
export namespace PgStatXactUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactUserTables.parse(e));
    
}


}
export namespace PgStatioAllTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllTables.parse(e));
    
}


}
export namespace PgStatioSysTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysTables.parse(e));
    
}


}
export namespace PgStatioUserTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserTables.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserTables.parse(e));
    
}


}
export namespace PgStatAllIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatAllIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatAllIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatAllIndexes.parse(e));
    
}


}
export namespace PgStatSysIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSysIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSysIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSysIndexes.parse(e));
    
}


}
export namespace PgStatUserIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserIndexes.parse(e));
    
}


}
export namespace PgStatioAllIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllIndexes.parse(e));
    
}


}
export namespace PgStatioSysIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysIndexes.parse(e));
    
}


}
export namespace PgStatioUserIndexes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserIndexes.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserIndexesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserIndexes.parse(e));
    
}


}
export namespace PgStatioAllSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioAllSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioAllSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioAllSequences.parse(e));
    
}


}
export namespace PgStatioSysSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioSysSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioSysSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioSysSequences.parse(e));
    
}


}
export namespace PgStatioUserSequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatioUserSequences.is(from)) {
  return {
relid: PgCatalog.Types.Oid.parse(from.relid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
relname: PgCatalog.Types.Name.parse(from.relname),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatioUserSequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatioUserSequences.parse(e));
    
}


}
export namespace PgStatActivity {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatActivity.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
pid: PgCatalog.Types.Int4.parse(from.pid),
leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usename: PgCatalog.Types.Name.parse(from.usename),
applicationName: PgCatalog.Types.Text.parse(from.applicationName),
clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
xactStart: PgCatalog.Types.Timestamptz.parse(from.xactStart),
queryStart: PgCatalog.Types.Timestamptz.parse(from.queryStart),
stateChange: PgCatalog.Types.Timestamptz.parse(from.stateChange),
waitEventType: PgCatalog.Types.Text.parse(from.waitEventType),
waitEvent: PgCatalog.Types.Text.parse(from.waitEvent),
state: PgCatalog.Types.Text.parse(from.state),
backendXid: PgCatalog.Types.Xid.parse(from.backendXid),
backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
queryId: PgCatalog.Types.Int8.parse(from.queryId),
query: PgCatalog.Types.Text.parse(from.query),
backendType: PgCatalog.Types.Text.parse(from.backendType),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatActivityArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatActivity.parse(e));
    
}


}
export namespace PgStatReplication {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatReplication.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
usename: PgCatalog.Types.Name.parse(from.usename),
applicationName: PgCatalog.Types.Text.parse(from.applicationName),
clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
state: PgCatalog.Types.Text.parse(from.state),
sentLsn: PgCatalog.Types.PgLsn.parse(from.sentLsn),
writeLsn: PgCatalog.Types.PgLsn.parse(from.writeLsn),
flushLsn: PgCatalog.Types.PgLsn.parse(from.flushLsn),
replayLsn: PgCatalog.Types.PgLsn.parse(from.replayLsn),
writeLag: PgCatalog.Types.Interval.parse(from.writeLag),
flushLag: PgCatalog.Types.Interval.parse(from.flushLag),
replayLag: PgCatalog.Types.Interval.parse(from.replayLag),
syncPriority: PgCatalog.Types.Int4.parse(from.syncPriority),
syncState: PgCatalog.Types.Text.parse(from.syncState),
replyTime: PgCatalog.Types.Timestamptz.parse(from.replyTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatReplicationArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatReplication.parse(e));
    
}


}
export namespace PgStatSlru {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSlru.is(from)) {
  return {
name: PgCatalog.Types.Text.parse(from.name),
blksZeroed: PgCatalog.Types.Int8.parse(from.blksZeroed),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksWritten: PgCatalog.Types.Int8.parse(from.blksWritten),
blksExists: PgCatalog.Types.Int8.parse(from.blksExists),
flushes: PgCatalog.Types.Int8.parse(from.flushes),
truncates: PgCatalog.Types.Int8.parse(from.truncates),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSlruArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSlru.parse(e));
    
}


}
export namespace PgStatWalReceiver {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatWalReceiver.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
status: PgCatalog.Types.Text.parse(from.status),
receiveStartLsn: PgCatalog.Types.PgLsn.parse(from.receiveStartLsn),
receiveStartTli: PgCatalog.Types.Int4.parse(from.receiveStartTli),
writtenLsn: PgCatalog.Types.PgLsn.parse(from.writtenLsn),
flushedLsn: PgCatalog.Types.PgLsn.parse(from.flushedLsn),
receivedTli: PgCatalog.Types.Int4.parse(from.receivedTli),
lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgSendTime),
lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgReceiptTime),
latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
latestEndTime: PgCatalog.Types.Timestamptz.parse(from.latestEndTime),
slotName: PgCatalog.Types.Text.parse(from.slotName),
senderHost: PgCatalog.Types.Text.parse(from.senderHost),
senderPort: PgCatalog.Types.Int4.parse(from.senderPort),
conninfo: PgCatalog.Types.Text.parse(from.conninfo),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatWalReceiverArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatWalReceiver.parse(e));
    
}


}
export namespace PgStatRecoveryPrefetch {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatRecoveryPrefetch.is(from)) {
  return {
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
prefetch: PgCatalog.Types.Int8.parse(from.prefetch),
hit: PgCatalog.Types.Int8.parse(from.hit),
skipInit: PgCatalog.Types.Int8.parse(from.skipInit),
skipNew: PgCatalog.Types.Int8.parse(from.skipNew),
skipFpw: PgCatalog.Types.Int8.parse(from.skipFpw),
skipRep: PgCatalog.Types.Int8.parse(from.skipRep),
walDistance: PgCatalog.Types.Int4.parse(from.walDistance),
blockDistance: PgCatalog.Types.Int4.parse(from.blockDistance),
ioDepth: PgCatalog.Types.Int4.parse(from.ioDepth),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatRecoveryPrefetchArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatRecoveryPrefetch.parse(e));
    
}


}
export namespace PgStatSubscription {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSubscription.is(from)) {
  return {
subid: PgCatalog.Types.Oid.parse(from.subid),
subname: PgCatalog.Types.Name.parse(from.subname),
pid: PgCatalog.Types.Int4.parse(from.pid),
leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
relid: PgCatalog.Types.Oid.parse(from.relid),
receivedLsn: PgCatalog.Types.PgLsn.parse(from.receivedLsn),
lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgSendTime),
lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(from.lastMsgReceiptTime),
latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
latestEndTime: PgCatalog.Types.Timestamptz.parse(from.latestEndTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSubscriptionArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSubscription.parse(e));
    
}


}
export namespace PgStatSsl {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSsl.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
ssl: PgCatalog.Types.Bool.parse(from.ssl),
version: PgCatalog.Types.Text.parse(from.version),
cipher: PgCatalog.Types.Text.parse(from.cipher),
bits: PgCatalog.Types.Int4.parse(from.bits),
clientDn: PgCatalog.Types.Text.parse(from.clientDn),
clientSerial: PgCatalog.Types.Numeric.parse(from.clientSerial),
issuerDn: PgCatalog.Types.Text.parse(from.issuerDn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSslArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSsl.parse(e));
    
}


}
export namespace PgStatGssapi {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatGssapi.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
gssAuthenticated: PgCatalog.Types.Bool.parse(from.gssAuthenticated),
principal: PgCatalog.Types.Text.parse(from.principal),
encrypted: PgCatalog.Types.Bool.parse(from.encrypted),
credentialsDelegated: PgCatalog.Types.Bool.parse(from.credentialsDelegated),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatGssapiArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatGssapi.parse(e));
    
}


}
export namespace PgReplicationSlots {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationSlots.is(from)) {
  return {
slotName: PgCatalog.Types.Name.parse(from.slotName),
plugin: PgCatalog.Types.Name.parse(from.plugin),
slotType: PgCatalog.Types.Text.parse(from.slotType),
datoid: PgCatalog.Types.Oid.parse(from.datoid),
database: PgCatalog.Types.Name.parse(from.database),
temporary: PgCatalog.Types.Bool.parse(from.temporary),
active: PgCatalog.Types.Bool.parse(from.active),
activePid: PgCatalog.Types.Int4.parse(from.activePid),
xmin: PgCatalog.Types.Xid.parse(from.xmin),
catalogXmin: PgCatalog.Types.Xid.parse(from.catalogXmin),
restartLsn: PgCatalog.Types.PgLsn.parse(from.restartLsn),
confirmedFlushLsn: PgCatalog.Types.PgLsn.parse(from.confirmedFlushLsn),
walStatus: PgCatalog.Types.Text.parse(from.walStatus),
safeWalSize: PgCatalog.Types.Int8.parse(from.safeWalSize),
twoPhase: PgCatalog.Types.Bool.parse(from.twoPhase),
conflicting: PgCatalog.Types.Bool.parse(from.conflicting),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationSlotsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationSlots.parse(e));
    
}


}
export namespace PgStatReplicationSlots {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatReplicationSlots.is(from)) {
  return {
slotName: PgCatalog.Types.Text.parse(from.slotName),
spillTxns: PgCatalog.Types.Int8.parse(from.spillTxns),
spillCount: PgCatalog.Types.Int8.parse(from.spillCount),
spillBytes: PgCatalog.Types.Int8.parse(from.spillBytes),
streamTxns: PgCatalog.Types.Int8.parse(from.streamTxns),
streamCount: PgCatalog.Types.Int8.parse(from.streamCount),
streamBytes: PgCatalog.Types.Int8.parse(from.streamBytes),
totalTxns: PgCatalog.Types.Int8.parse(from.totalTxns),
totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatReplicationSlotsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatReplicationSlots.parse(e));
    
}


}
export namespace PgStatDatabase {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatDatabase.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
numbackends: PgCatalog.Types.Int4.parse(from.numbackends),
xactCommit: PgCatalog.Types.Int8.parse(from.xactCommit),
xactRollback: PgCatalog.Types.Int8.parse(from.xactRollback),
blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
tupReturned: PgCatalog.Types.Int8.parse(from.tupReturned),
tupFetched: PgCatalog.Types.Int8.parse(from.tupFetched),
tupInserted: PgCatalog.Types.Int8.parse(from.tupInserted),
tupUpdated: PgCatalog.Types.Int8.parse(from.tupUpdated),
tupDeleted: PgCatalog.Types.Int8.parse(from.tupDeleted),
conflicts: PgCatalog.Types.Int8.parse(from.conflicts),
tempFiles: PgCatalog.Types.Int8.parse(from.tempFiles),
tempBytes: PgCatalog.Types.Int8.parse(from.tempBytes),
deadlocks: PgCatalog.Types.Int8.parse(from.deadlocks),
checksumFailures: PgCatalog.Types.Int8.parse(from.checksumFailures),
checksumLastFailure: PgCatalog.Types.Timestamptz.parse(from.checksumLastFailure),
blkReadTime: PgCatalog.Types.Float8.parse(from.blkReadTime),
blkWriteTime: PgCatalog.Types.Float8.parse(from.blkWriteTime),
sessionTime: PgCatalog.Types.Float8.parse(from.sessionTime),
activeTime: PgCatalog.Types.Float8.parse(from.activeTime),
idleInTransactionTime: PgCatalog.Types.Float8.parse(from.idleInTransactionTime),
sessions: PgCatalog.Types.Int8.parse(from.sessions),
sessionsAbandoned: PgCatalog.Types.Int8.parse(from.sessionsAbandoned),
sessionsFatal: PgCatalog.Types.Int8.parse(from.sessionsFatal),
sessionsKilled: PgCatalog.Types.Int8.parse(from.sessionsKilled),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatDatabaseArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatDatabase.parse(e));
    
}


}
export namespace PgStatDatabaseConflicts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatDatabaseConflicts.is(from)) {
  return {
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
conflTablespace: PgCatalog.Types.Int8.parse(from.conflTablespace),
conflLock: PgCatalog.Types.Int8.parse(from.conflLock),
conflSnapshot: PgCatalog.Types.Int8.parse(from.conflSnapshot),
conflBufferpin: PgCatalog.Types.Int8.parse(from.conflBufferpin),
conflDeadlock: PgCatalog.Types.Int8.parse(from.conflDeadlock),
conflActiveLogicalslot: PgCatalog.Types.Int8.parse(from.conflActiveLogicalslot),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatDatabaseConflictsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatDatabaseConflicts.parse(e));
    
}


}
export namespace PgStatUserFunctions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatUserFunctions.is(from)) {
  return {
funcid: PgCatalog.Types.Oid.parse(from.funcid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
funcname: PgCatalog.Types.Name.parse(from.funcname),
calls: PgCatalog.Types.Int8.parse(from.calls),
totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatUserFunctionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatUserFunctions.parse(e));
    
}


}
export namespace PgStatXactUserFunctions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatXactUserFunctions.is(from)) {
  return {
funcid: PgCatalog.Types.Oid.parse(from.funcid),
schemaname: PgCatalog.Types.Name.parse(from.schemaname),
funcname: PgCatalog.Types.Name.parse(from.funcname),
calls: PgCatalog.Types.Int8.parse(from.calls),
totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatXactUserFunctionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatXactUserFunctions.parse(e));
    
}


}
export namespace PgStatArchiver {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatArchiver.is(from)) {
  return {
archivedCount: PgCatalog.Types.Int8.parse(from.archivedCount),
lastArchivedWal: PgCatalog.Types.Text.parse(from.lastArchivedWal),
lastArchivedTime: PgCatalog.Types.Timestamptz.parse(from.lastArchivedTime),
failedCount: PgCatalog.Types.Int8.parse(from.failedCount),
lastFailedWal: PgCatalog.Types.Text.parse(from.lastFailedWal),
lastFailedTime: PgCatalog.Types.Timestamptz.parse(from.lastFailedTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatArchiverArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatArchiver.parse(e));
    
}


}
export namespace PgStatBgwriter {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatBgwriter.is(from)) {
  return {
checkpointsTimed: PgCatalog.Types.Int8.parse(from.checkpointsTimed),
checkpointsReq: PgCatalog.Types.Int8.parse(from.checkpointsReq),
checkpointWriteTime: PgCatalog.Types.Float8.parse(from.checkpointWriteTime),
checkpointSyncTime: PgCatalog.Types.Float8.parse(from.checkpointSyncTime),
buffersCheckpoint: PgCatalog.Types.Int8.parse(from.buffersCheckpoint),
buffersClean: PgCatalog.Types.Int8.parse(from.buffersClean),
maxwrittenClean: PgCatalog.Types.Int8.parse(from.maxwrittenClean),
buffersBackend: PgCatalog.Types.Int8.parse(from.buffersBackend),
buffersBackendFsync: PgCatalog.Types.Int8.parse(from.buffersBackendFsync),
buffersAlloc: PgCatalog.Types.Int8.parse(from.buffersAlloc),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatBgwriterArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatBgwriter.parse(e));
    
}


}
export namespace PgStatIo {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatIo.is(from)) {
  return {
backendType: PgCatalog.Types.Text.parse(from.backendType),
object: PgCatalog.Types.Text.parse(from.object),
context: PgCatalog.Types.Text.parse(from.context),
reads: PgCatalog.Types.Int8.parse(from.reads),
readTime: PgCatalog.Types.Float8.parse(from.readTime),
writes: PgCatalog.Types.Int8.parse(from.writes),
writeTime: PgCatalog.Types.Float8.parse(from.writeTime),
writebacks: PgCatalog.Types.Int8.parse(from.writebacks),
writebackTime: PgCatalog.Types.Float8.parse(from.writebackTime),
extends: PgCatalog.Types.Int8.parse(from.extends),
extendTime: PgCatalog.Types.Float8.parse(from.extendTime),
opBytes: PgCatalog.Types.Int8.parse(from.opBytes),
hits: PgCatalog.Types.Int8.parse(from.hits),
evictions: PgCatalog.Types.Int8.parse(from.evictions),
reuses: PgCatalog.Types.Int8.parse(from.reuses),
fsyncs: PgCatalog.Types.Int8.parse(from.fsyncs),
fsyncTime: PgCatalog.Types.Float8.parse(from.fsyncTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatIoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatIo.parse(e));
    
}


}
export namespace PgStatWal {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatWal.is(from)) {
  return {
walRecords: PgCatalog.Types.Int8.parse(from.walRecords),
walFpi: PgCatalog.Types.Int8.parse(from.walFpi),
walBytes: PgCatalog.Types.Numeric.parse(from.walBytes),
walBuffersFull: PgCatalog.Types.Int8.parse(from.walBuffersFull),
walWrite: PgCatalog.Types.Int8.parse(from.walWrite),
walSync: PgCatalog.Types.Int8.parse(from.walSync),
walWriteTime: PgCatalog.Types.Float8.parse(from.walWriteTime),
walSyncTime: PgCatalog.Types.Float8.parse(from.walSyncTime),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatWalArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatWal.parse(e));
    
}


}
export namespace PgStatProgressAnalyze {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressAnalyze.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
phase: PgCatalog.Types.Text.parse(from.phase),
sampleBlksTotal: PgCatalog.Types.Int8.parse(from.sampleBlksTotal),
sampleBlksScanned: PgCatalog.Types.Int8.parse(from.sampleBlksScanned),
extStatsTotal: PgCatalog.Types.Int8.parse(from.extStatsTotal),
extStatsComputed: PgCatalog.Types.Int8.parse(from.extStatsComputed),
childTablesTotal: PgCatalog.Types.Int8.parse(from.childTablesTotal),
childTablesDone: PgCatalog.Types.Int8.parse(from.childTablesDone),
currentChildTableRelid: PgCatalog.Types.Oid.parse(from.currentChildTableRelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressAnalyzeArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressAnalyze.parse(e));
    
}


}
export namespace PgStatProgressVacuum {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressVacuum.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
phase: PgCatalog.Types.Text.parse(from.phase),
heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
heapBlksVacuumed: PgCatalog.Types.Int8.parse(from.heapBlksVacuumed),
indexVacuumCount: PgCatalog.Types.Int8.parse(from.indexVacuumCount),
maxDeadTuples: PgCatalog.Types.Int8.parse(from.maxDeadTuples),
numDeadTuples: PgCatalog.Types.Int8.parse(from.numDeadTuples),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressVacuumArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressVacuum.parse(e));
    
}


}
export namespace PgStatProgressCluster {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCluster.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
command: PgCatalog.Types.Text.parse(from.command),
phase: PgCatalog.Types.Text.parse(from.phase),
clusterIndexRelid: PgCatalog.Types.Oid.parse(from.clusterIndexRelid),
heapTuplesScanned: PgCatalog.Types.Int8.parse(from.heapTuplesScanned),
heapTuplesWritten: PgCatalog.Types.Int8.parse(from.heapTuplesWritten),
heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
indexRebuildCount: PgCatalog.Types.Int8.parse(from.indexRebuildCount),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressClusterArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCluster.parse(e));
    
}


}
export namespace PgStatProgressCreateIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCreateIndex.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
indexRelid: PgCatalog.Types.Oid.parse(from.indexRelid),
command: PgCatalog.Types.Text.parse(from.command),
phase: PgCatalog.Types.Text.parse(from.phase),
lockersTotal: PgCatalog.Types.Int8.parse(from.lockersTotal),
lockersDone: PgCatalog.Types.Int8.parse(from.lockersDone),
currentLockerPid: PgCatalog.Types.Int8.parse(from.currentLockerPid),
blocksTotal: PgCatalog.Types.Int8.parse(from.blocksTotal),
blocksDone: PgCatalog.Types.Int8.parse(from.blocksDone),
tuplesTotal: PgCatalog.Types.Int8.parse(from.tuplesTotal),
tuplesDone: PgCatalog.Types.Int8.parse(from.tuplesDone),
partitionsTotal: PgCatalog.Types.Int8.parse(from.partitionsTotal),
partitionsDone: PgCatalog.Types.Int8.parse(from.partitionsDone),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressCreateIndexArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCreateIndex.parse(e));
    
}


}
export namespace PgStatProgressBasebackup {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressBasebackup.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
phase: PgCatalog.Types.Text.parse(from.phase),
backupTotal: PgCatalog.Types.Int8.parse(from.backupTotal),
backupStreamed: PgCatalog.Types.Int8.parse(from.backupStreamed),
tablespacesTotal: PgCatalog.Types.Int8.parse(from.tablespacesTotal),
tablespacesStreamed: PgCatalog.Types.Int8.parse(from.tablespacesStreamed),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressBasebackupArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressBasebackup.parse(e));
    
}


}
export namespace PgStatProgressCopy {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatProgressCopy.is(from)) {
  return {
pid: PgCatalog.Types.Int4.parse(from.pid),
datid: PgCatalog.Types.Oid.parse(from.datid),
datname: PgCatalog.Types.Name.parse(from.datname),
relid: PgCatalog.Types.Oid.parse(from.relid),
command: PgCatalog.Types.Text.parse(from.command),
type: PgCatalog.Types.Text.parse(from.type),
bytesProcessed: PgCatalog.Types.Int8.parse(from.bytesProcessed),
bytesTotal: PgCatalog.Types.Int8.parse(from.bytesTotal),
tuplesProcessed: PgCatalog.Types.Int8.parse(from.tuplesProcessed),
tuplesExcluded: PgCatalog.Types.Int8.parse(from.tuplesExcluded),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatProgressCopyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatProgressCopy.parse(e));
    
}


}
export namespace PgUserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappings.is(from)) {
  return {
umid: PgCatalog.Types.Oid.parse(from.umid),
srvid: PgCatalog.Types.Oid.parse(from.srvid),
srvname: PgCatalog.Types.Name.parse(from.srvname),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
usename: PgCatalog.Types.Name.parse(from.usename),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgUserMappings.parse(e));
    
}


}
export namespace PgReplicationOriginStatus {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginStatus.is(from)) {
  return {
localId: PgCatalog.Types.Oid.parse(from.localId),
externalId: PgCatalog.Types.Text.parse(from.externalId),
remoteLsn: PgCatalog.Types.PgLsn.parse(from.remoteLsn),
localLsn: PgCatalog.Types.PgLsn.parse(from.localLsn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginStatusArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgReplicationOriginStatus.parse(e));
    
}


}
export namespace PgStatSubscriptionStats {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatSubscriptionStats.is(from)) {
  return {
subid: PgCatalog.Types.Oid.parse(from.subid),
subname: PgCatalog.Types.Name.parse(from.subname),
applyErrorCount: PgCatalog.Types.Int8.parse(from.applyErrorCount),
syncErrorCount: PgCatalog.Types.Int8.parse(from.syncErrorCount),
statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatSubscriptionStatsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => PgStatSubscriptionStats.parse(e));
    
}


}
export namespace PgProcOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProcOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgProcPronameArgsNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgProcPronameArgsNspIndex.is(from)) {
  return {
proname: PgCatalog.Types.Name.parse(from.proname),
proargtypes: PgCatalog.Types.Oidvector.parse(from.proargtypes),
pronamespace: PgCatalog.Types.Oid.parse(from.pronamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTypeOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTypeOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTypeTypnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTypeTypnameNspIndex.is(from)) {
  return {
typname: PgCatalog.Types.Name.parse(from.typname),
typnamespace: PgCatalog.Types.Oid.parse(from.typnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttributeRelidAttnamIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttributeRelidAttnamIndex.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attname: PgCatalog.Types.Name.parse(from.attname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttributeRelidAttnumIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttributeRelidAttnumIndex.is(from)) {
  return {
attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
attnum: PgCatalog.Types.Int2.parse(from.attnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassRelnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassRelnameNspIndex.is(from)) {
  return {
relname: PgCatalog.Types.Name.parse(from.relname),
relnamespace: PgCatalog.Types.Oid.parse(from.relnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgClassTblspcRelfilenodeIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgClassTblspcRelfilenodeIndex.is(from)) {
  return {
reltablespace: PgCatalog.Types.Oid.parse(from.reltablespace),
relfilenode: PgCatalog.Types.Oid.parse(from.relfilenode),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefAdrelidAdnumIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdefAdrelidAdnumIndex.is(from)) {
  return {
adrelid: PgCatalog.Types.Oid.parse(from.adrelid),
adnum: PgCatalog.Types.Int2.parse(from.adnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAttrdefOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAttrdefOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConnameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConnameNspIndex.is(from)) {
  return {
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConrelidContypidConnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConrelidContypidConnameIndex.is(from)) {
  return {
conrelid: PgCatalog.Types.Oid.parse(from.conrelid),
contypid: PgCatalog.Types.Oid.parse(from.contypid),
conname: PgCatalog.Types.Name.parse(from.conname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintContypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintContypidIndex.is(from)) {
  return {
contypid: PgCatalog.Types.Oid.parse(from.contypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConstraintConparentidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConstraintConparentidIndex.is(from)) {
  return {
conparentid: PgCatalog.Types.Oid.parse(from.conparentid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsRelidSeqnoIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInheritsRelidSeqnoIndex.is(from)) {
  return {
inhrelid: PgCatalog.Types.Oid.parse(from.inhrelid),
inhseqno: PgCatalog.Types.Int4.parse(from.inhseqno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInheritsParentIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInheritsParentIndex.is(from)) {
  return {
inhparent: PgCatalog.Types.Oid.parse(from.inhparent),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexIndrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexIndrelidIndex.is(from)) {
  return {
indrelid: PgCatalog.Types.Oid.parse(from.indrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgIndexIndexrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgIndexIndexrelidIndex.is(from)) {
  return {
indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperatorOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOperatorOprnameLRNIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOperatorOprnameLRNIndex.is(from)) {
  return {
oprname: PgCatalog.Types.Name.parse(from.oprname),
oprleft: PgCatalog.Types.Oid.parse(from.oprleft),
oprright: PgCatalog.Types.Oid.parse(from.oprright),
oprnamespace: PgCatalog.Types.Oid.parse(from.oprnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyAmNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamilyAmNameNspIndex.is(from)) {
  return {
opfmethod: PgCatalog.Types.Oid.parse(from.opfmethod),
opfname: PgCatalog.Types.Name.parse(from.opfname),
opfnamespace: PgCatalog.Types.Oid.parse(from.opfnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpfamilyOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpfamilyOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassAmNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclassAmNameNspIndex.is(from)) {
  return {
opcmethod: PgCatalog.Types.Oid.parse(from.opcmethod),
opcname: PgCatalog.Types.Name.parse(from.opcname),
opcnamespace: PgCatalog.Types.Oid.parse(from.opcnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgOpclassOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgOpclassOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmNameIndex.is(from)) {
  return {
amname: PgCatalog.Types.Name.parse(from.amname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopFamStratIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopFamStratIndex.is(from)) {
  return {
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
amoplefttype: PgCatalog.Types.Oid.parse(from.amoplefttype),
amoprighttype: PgCatalog.Types.Oid.parse(from.amoprighttype),
amopstrategy: PgCatalog.Types.Int2.parse(from.amopstrategy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopOprFamIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopOprFamIndex.is(from)) {
  return {
amopopr: PgCatalog.Types.Oid.parse(from.amopopr),
amoppurpose: PgCatalog.Types.Char.parse(from.amoppurpose),
amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmopOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmopOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocFamProcIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmprocFamProcIndex.is(from)) {
  return {
amprocfamily: PgCatalog.Types.Oid.parse(from.amprocfamily),
amproclefttype: PgCatalog.Types.Oid.parse(from.amproclefttype),
amprocrighttype: PgCatalog.Types.Oid.parse(from.amprocrighttype),
amprocnum: PgCatalog.Types.Int2.parse(from.amprocnum),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAmprocOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAmprocOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguageNameIndex.is(from)) {
  return {
lanname: PgCatalog.Types.Name.parse(from.lanname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLanguageOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLanguageOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectMetadataOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectMetadataOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgLargeobjectLoidPnIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgLargeobjectLoidPnIndex.is(from)) {
  return {
loid: PgCatalog.Types.Oid.parse(from.loid),
pageno: PgCatalog.Types.Int4.parse(from.pageno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAggregateFnoidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAggregateFnoidIndex.is(from)) {
  return {
aggfnoid: PgCatalog.Types.Regproc.parse(from.aggfnoid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticRelidAttInhIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticRelidAttInhIndex.is(from)) {
  return {
starelid: PgCatalog.Types.Oid.parse(from.starelid),
staattnum: PgCatalog.Types.Int2.parse(from.staattnum),
stainherit: PgCatalog.Types.Bool.parse(from.stainherit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtNameIndex.is(from)) {
  return {
stxname: PgCatalog.Types.Name.parse(from.stxname),
stxnamespace: PgCatalog.Types.Oid.parse(from.stxnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtRelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtRelidIndex.is(from)) {
  return {
stxrelid: PgCatalog.Types.Oid.parse(from.stxrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgStatisticExtDataStxoidInhIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgStatisticExtDataStxoidInhIndex.is(from)) {
  return {
stxoid: PgCatalog.Types.Oid.parse(from.stxoid),
stxdinherit: PgCatalog.Types.Bool.parse(from.stxdinherit),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewriteOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRewriteRelRulenameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRewriteRelRulenameIndex.is(from)) {
  return {
evClass: PgCatalog.Types.Oid.parse(from.evClass),
rulename: PgCatalog.Types.Name.parse(from.rulename),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerTgconstraintIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerTgconstraintIndex.is(from)) {
  return {
tgconstraint: PgCatalog.Types.Oid.parse(from.tgconstraint),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerTgrelidTgnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerTgrelidTgnameIndex.is(from)) {
  return {
tgrelid: PgCatalog.Types.Oid.parse(from.tgrelid),
tgname: PgCatalog.Types.Name.parse(from.tgname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTriggerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTriggerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerEvtnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTriggerEvtnameIndex.is(from)) {
  return {
evtname: PgCatalog.Types.Name.parse(from.evtname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEventTriggerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEventTriggerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDescriptionOCOIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDescriptionOCOIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCastOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCastSourceTargetIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCastSourceTargetIndex.is(from)) {
  return {
castsource: PgCatalog.Types.Oid.parse(from.castsource),
casttarget: PgCatalog.Types.Oid.parse(from.casttarget),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumTypidLabelIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumTypidLabelIndex.is(from)) {
  return {
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumlabel: PgCatalog.Types.Name.parse(from.enumlabel),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgEnumTypidSortorderIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgEnumTypidSortorderIndex.is(from)) {
  return {
enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
enumsortorder: PgCatalog.Types.Float4.parse(from.enumsortorder),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceNspnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespaceNspnameIndex.is(from)) {
  return {
nspname: PgCatalog.Types.Name.parse(from.nspname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgNamespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgNamespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionDefaultIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionDefaultIndex.is(from)) {
  return {
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
conforencoding: PgCatalog.Types.Int4.parse(from.conforencoding),
contoencoding: PgCatalog.Types.Int4.parse(from.contoencoding),
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionNameNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionNameNspIndex.is(from)) {
  return {
conname: PgCatalog.Types.Name.parse(from.conname),
connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgConversionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgConversionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependDependerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDependDependerIndex.is(from)) {
  return {
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDependReferenceIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDependReferenceIndex.is(from)) {
  return {
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
refobjsubid: PgCatalog.Types.Int4.parse(from.refobjsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseDatnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabaseDatnameIndex.is(from)) {
  return {
datname: PgCatalog.Types.Name.parse(from.datname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDatabaseOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDatabaseOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDbRoleSettingDatabaseidRolIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex.is(from)) {
  return {
setdatabase: PgCatalog.Types.Oid.parse(from.setdatabase),
setrole: PgCatalog.Types.Oid.parse(from.setrole),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTablespaceSpcnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTablespaceSpcnameIndex.is(from)) {
  return {
spcname: PgCatalog.Types.Name.parse(from.spcname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidRolnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthidRolnameIndex.is(from)) {
  return {
rolname: PgCatalog.Types.Name.parse(from.rolname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthidOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthidOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersRoleMemberIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersRoleMemberIndex.is(from)) {
  return {
roleid: PgCatalog.Types.Oid.parse(from.roleid),
member: PgCatalog.Types.Oid.parse(from.member),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersMemberRoleIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersMemberRoleIndex.is(from)) {
  return {
member: PgCatalog.Types.Oid.parse(from.member),
roleid: PgCatalog.Types.Oid.parse(from.roleid),
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgAuthMembersGrantorIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgAuthMembersGrantorIndex.is(from)) {
  return {
grantor: PgCatalog.Types.Oid.parse(from.grantor),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependDependerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdependDependerIndex.is(from)) {
  return {
dbid: PgCatalog.Types.Oid.parse(from.dbid),
classid: PgCatalog.Types.Oid.parse(from.classid),
objid: PgCatalog.Types.Oid.parse(from.objid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdependReferenceIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdependReferenceIndex.is(from)) {
  return {
refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShdescriptionOCIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShdescriptionOCIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigCfgnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigCfgnameIndex.is(from)) {
  return {
cfgname: PgCatalog.Types.Name.parse(from.cfgname),
cfgnamespace: PgCatalog.Types.Oid.parse(from.cfgnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsConfigMapIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsConfigMapIndex.is(from)) {
  return {
mapcfg: PgCatalog.Types.Oid.parse(from.mapcfg),
maptokentype: PgCatalog.Types.Int4.parse(from.maptokentype),
mapseqno: PgCatalog.Types.Int4.parse(from.mapseqno),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictDictnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDictDictnameIndex.is(from)) {
  return {
dictname: PgCatalog.Types.Name.parse(from.dictname),
dictnamespace: PgCatalog.Types.Oid.parse(from.dictnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsDictOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsDictOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserPrsnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParserPrsnameIndex.is(from)) {
  return {
prsname: PgCatalog.Types.Name.parse(from.prsname),
prsnamespace: PgCatalog.Types.Oid.parse(from.prsnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsParserOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsParserOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateTmplnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplateTmplnameIndex.is(from)) {
  return {
tmplname: PgCatalog.Types.Name.parse(from.tmplname),
tmplnamespace: PgCatalog.Types.Oid.parse(from.tmplnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTsTemplateOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTsTemplateOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtensionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgExtensionNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgExtensionNameIndex.is(from)) {
  return {
extname: PgCatalog.Types.Name.parse(from.extname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapperOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignDataWrapperNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignDataWrapperNameIndex.is(from)) {
  return {
fdwname: PgCatalog.Types.Name.parse(from.fdwname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServerOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignServerNameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignServerNameIndex.is(from)) {
  return {
srvname: PgCatalog.Types.Name.parse(from.srvname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappingOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgUserMappingUserServerIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgUserMappingUserServerIndex.is(from)) {
  return {
umuser: PgCatalog.Types.Oid.parse(from.umuser),
umserver: PgCatalog.Types.Oid.parse(from.umserver),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgForeignTableRelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgForeignTableRelidIndex.is(from)) {
  return {
ftrelid: PgCatalog.Types.Oid.parse(from.ftrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicyOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPolicyPolrelidPolnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPolicyPolrelidPolnameIndex.is(from)) {
  return {
polrelid: PgCatalog.Types.Oid.parse(from.polrelid),
polname: PgCatalog.Types.Name.parse(from.polname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginRoiidentIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginRoiidentIndex.is(from)) {
  return {
roident: PgCatalog.Types.Oid.parse(from.roident),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgReplicationOriginRonameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgReplicationOriginRonameIndex.is(from)) {
  return {
roname: PgCatalog.Types.Text.parse(from.roname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclRoleNspObjIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAclRoleNspObjIndex.is(from)) {
  return {
defaclrole: PgCatalog.Types.Oid.parse(from.defaclrole),
defaclnamespace: PgCatalog.Types.Oid.parse(from.defaclnamespace),
defaclobjtype: PgCatalog.Types.Char.parse(from.defaclobjtype),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgDefaultAclOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgDefaultAclOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgInitPrivsOCOIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgInitPrivsOCOIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSeclabelObjectIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSeclabelObjectIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
provider: PgCatalog.Types.Text.parse(from.provider),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgShseclabelObjectIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgShseclabelObjectIndex.is(from)) {
  return {
objoid: PgCatalog.Types.Oid.parse(from.objoid),
classoid: PgCatalog.Types.Oid.parse(from.classoid),
provider: PgCatalog.Types.Text.parse(from.provider),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationNameEncNspIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollationNameEncNspIndex.is(from)) {
  return {
collname: PgCatalog.Types.Name.parse(from.collname),
collencoding: PgCatalog.Types.Int4.parse(from.collencoding),
collnamespace: PgCatalog.Types.Oid.parse(from.collnamespace),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgCollationOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgCollationOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclParnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAclParnameIndex.is(from)) {
  return {
parname: PgCatalog.Types.Text.parse(from.parname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgParameterAclOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgParameterAclOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPartitionedTablePartrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPartitionedTablePartrelidIndex.is(from)) {
  return {
partrelid: PgCatalog.Types.Oid.parse(from.partrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeRngtypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRangeRngtypidIndex.is(from)) {
  return {
rngtypid: PgCatalog.Types.Oid.parse(from.rngtypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgRangeRngmultitypidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgRangeRngmultitypidIndex.is(from)) {
  return {
rngmultitypid: PgCatalog.Types.Oid.parse(from.rngmultitypid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransformOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgTransformTypeLangIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgTransformTypeLangIndex.is(from)) {
  return {
trftype: PgCatalog.Types.Oid.parse(from.trftype),
trflang: PgCatalog.Types.Oid.parse(from.trflang),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSequenceSeqrelidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSequenceSeqrelidIndex.is(from)) {
  return {
seqrelid: PgCatalog.Types.Oid.parse(from.seqrelid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationPubnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationPubnameIndex.is(from)) {
  return {
pubname: PgCatalog.Types.Name.parse(from.pubname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespaceOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespaceOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex.is(from)) {
  return {
pnnspid: PgCatalog.Types.Oid.parse(from.pnnspid),
pnpubid: PgCatalog.Types.Oid.parse(from.pnpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelPrrelidPrpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex.is(from)) {
  return {
prrelid: PgCatalog.Types.Oid.parse(from.prrelid),
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgPublicationRelPrpubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgPublicationRelPrpubidIndex.is(from)) {
  return {
prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionOidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionOidIndex.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionSubnameIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionSubnameIndex.is(from)) {
  return {
subdbid: PgCatalog.Types.Oid.parse(from.subdbid),
subname: PgCatalog.Types.Name.parse(from.subname),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex.is(from)) {
  return {
srrelid: PgCatalog.Types.Oid.parse(from.srrelid),
srsubid: PgCatalog.Types.Oid.parse(from.srsubid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgType {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignTable {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAuthid {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgStatisticExtData {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgUserMapping {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSubscription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAttribute {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgProc {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgClass {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAttrdef {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgConstraint {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgInherits {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgIndex {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOperator {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOpfamily {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgOpclass {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAm {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAmop {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAmproc {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLanguage {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLargeobjectMetadata {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAggregate {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgStatisticExt {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgRewrite {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTrigger {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgEventTrigger {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDescription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgCast {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgEnum {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgNamespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgConversion {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDepend {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDatabase {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDbRoleSetting {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTablespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgAuthMembers {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShdepend {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShdescription {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsConfig {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsConfigMap {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsDict {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsParser {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTsTemplate {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgExtension {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignDataWrapper {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgForeignServer {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPolicy {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgReplicationOrigin {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgDefaultAcl {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgInitPrivs {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSeclabel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgShseclabel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgCollation {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgParameterAcl {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPartitionedTable {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgRange {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgTransform {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSequence {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublication {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublicationNamespace {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgPublicationRel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgSubscriptionRel {
export namespace Results {
}
export namespace Create {
}
}
export namespace PgLargeobject {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace CardinalNumber {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Int4.parse(from);
}


}
export namespace CardinalNumberArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CardinalNumber.parse(e));
    
}


}
export namespace CharacterData {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Varchar.parse(from);
}


}
export namespace CharacterDataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CharacterData.parse(e));
    
}


}
export namespace SqlIdentifier {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Name.parse(from);
}


}
export namespace SqlIdentifierArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlIdentifier.parse(e));
    
}


}
export namespace InformationSchemaCatalogName {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.InformationSchemaCatalogName.is(from)) {
  return {
catalogName: InformationSchema.Types.SqlIdentifier.parse(from.catalogName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace InformationSchemaCatalogNameArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => InformationSchemaCatalogName.parse(e));
    
}


}
export namespace TimeStamp {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Timestamptz.parse(from);
}


}
export namespace TimeStampArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TimeStamp.parse(e));
    
}


}
export namespace YesOrNo {
export function parse(from: unknown) {
// DomainType
if (from === null || from === undefined) return null;
return PgCatalog.Types.Varchar.parse(from);
}


}
export namespace YesOrNoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => YesOrNo.parse(e));
    
}


}
export namespace ApplicableRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ApplicableRoles.is(from)) {
  return {
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ApplicableRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ApplicableRoles.parse(e));
    
}


}
export namespace AdministrableRoleAuthorizations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.AdministrableRoleAuthorizations.is(from)) {
  return {
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace AdministrableRoleAuthorizationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => AdministrableRoleAuthorizations.parse(e));
    
}


}
export namespace Attributes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Attributes.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
attributeName: InformationSchema.Types.SqlIdentifier.parse(from.attributeName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
attributeDefault: InformationSchema.Types.CharacterData.parse(from.attributeDefault),
isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
attributeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtCatalog),
attributeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtSchema),
attributeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.attributeUdtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
isDerivedReferenceAttribute: InformationSchema.Types.YesOrNo.parse(from.isDerivedReferenceAttribute),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace AttributesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Attributes.parse(e));
    
}


}
export namespace CharacterSets {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CharacterSets.is(from)) {
  return {
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
characterRepertoire: InformationSchema.Types.SqlIdentifier.parse(from.characterRepertoire),
formOfUse: InformationSchema.Types.SqlIdentifier.parse(from.formOfUse),
defaultCollateCatalog: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateCatalog),
defaultCollateSchema: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateSchema),
defaultCollateName: InformationSchema.Types.SqlIdentifier.parse(from.defaultCollateName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CharacterSetsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CharacterSets.parse(e));
    
}


}
export namespace CheckConstraintRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CheckConstraintRoutineUsage.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CheckConstraintRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CheckConstraintRoutineUsage.parse(e));
    
}


}
export namespace CheckConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CheckConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
checkClause: InformationSchema.Types.CharacterData.parse(from.checkClause),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CheckConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CheckConstraints.parse(e));
    
}


}
export namespace Collations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Collations.is(from)) {
  return {
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
padAttribute: InformationSchema.Types.CharacterData.parse(from.padAttribute),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CollationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Collations.parse(e));
    
}


}
export namespace CollationCharacterSetApplicability {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.CollationCharacterSetApplicability.is(from)) {
  return {
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace CollationCharacterSetApplicabilityArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => CollationCharacterSetApplicability.parse(e));
    
}


}
export namespace ColumnColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnColumnUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
dependentColumn: InformationSchema.Types.SqlIdentifier.parse(from.dependentColumn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnColumnUsage.parse(e));
    
}


}
export namespace ColumnDomainUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnDomainUsage.is(from)) {
  return {
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnDomainUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnDomainUsage.parse(e));
    
}


}
export namespace ColumnPrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnPrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnPrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnPrivileges.parse(e));
    
}


}
export namespace ColumnUdtUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnUdtUsage.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnUdtUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnUdtUsage.parse(e));
    
}


}
export namespace Columns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Columns.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
columnDefault: InformationSchema.Types.CharacterData.parse(from.columnDefault),
isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
isSelfReferencing: InformationSchema.Types.YesOrNo.parse(from.isSelfReferencing),
isIdentity: InformationSchema.Types.YesOrNo.parse(from.isIdentity),
identityGeneration: InformationSchema.Types.CharacterData.parse(from.identityGeneration),
identityStart: InformationSchema.Types.CharacterData.parse(from.identityStart),
identityIncrement: InformationSchema.Types.CharacterData.parse(from.identityIncrement),
identityMaximum: InformationSchema.Types.CharacterData.parse(from.identityMaximum),
identityMinimum: InformationSchema.Types.CharacterData.parse(from.identityMinimum),
identityCycle: InformationSchema.Types.YesOrNo.parse(from.identityCycle),
isGenerated: InformationSchema.Types.CharacterData.parse(from.isGenerated),
generationExpression: InformationSchema.Types.CharacterData.parse(from.generationExpression),
isUpdatable: InformationSchema.Types.YesOrNo.parse(from.isUpdatable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Columns.parse(e));
    
}


}
export namespace ConstraintColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ConstraintColumnUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ConstraintColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ConstraintColumnUsage.parse(e));
    
}


}
export namespace ConstraintTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ConstraintTableUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ConstraintTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ConstraintTableUsage.parse(e));
    
}


}
export namespace DomainConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DomainConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
isDeferrable: InformationSchema.Types.YesOrNo.parse(from.isDeferrable),
initiallyDeferred: InformationSchema.Types.YesOrNo.parse(from.initiallyDeferred),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DomainConstraints.parse(e));
    
}


}
export namespace DomainUdtUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DomainUdtUsage.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainUdtUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DomainUdtUsage.parse(e));
    
}


}
export namespace Domains {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Domains.is(from)) {
  return {
domainCatalog: InformationSchema.Types.SqlIdentifier.parse(from.domainCatalog),
domainSchema: InformationSchema.Types.SqlIdentifier.parse(from.domainSchema),
domainName: InformationSchema.Types.SqlIdentifier.parse(from.domainName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
domainDefault: InformationSchema.Types.CharacterData.parse(from.domainDefault),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DomainsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Domains.parse(e));
    
}


}
export namespace EnabledRoles {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.EnabledRoles.is(from)) {
  return {
roleName: InformationSchema.Types.SqlIdentifier.parse(from.roleName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace EnabledRolesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => EnabledRoles.parse(e));
    
}


}
export namespace KeyColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.KeyColumnUsage.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
positionInUniqueConstraint: InformationSchema.Types.CardinalNumber.parse(from.positionInUniqueConstraint),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace KeyColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => KeyColumnUsage.parse(e));
    
}


}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Parameters.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
ordinalPosition: InformationSchema.Types.CardinalNumber.parse(from.ordinalPosition),
parameterMode: InformationSchema.Types.CharacterData.parse(from.parameterMode),
isResult: InformationSchema.Types.YesOrNo.parse(from.isResult),
asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
parameterName: InformationSchema.Types.SqlIdentifier.parse(from.parameterName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
parameterDefault: InformationSchema.Types.CharacterData.parse(from.parameterDefault),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ParametersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Parameters.parse(e));
    
}


}
export namespace ReferentialConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ReferentialConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
uniqueConstraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintCatalog),
uniqueConstraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintSchema),
uniqueConstraintName: InformationSchema.Types.SqlIdentifier.parse(from.uniqueConstraintName),
matchOption: InformationSchema.Types.CharacterData.parse(from.matchOption),
updateRule: InformationSchema.Types.CharacterData.parse(from.updateRule),
deleteRule: InformationSchema.Types.CharacterData.parse(from.deleteRule),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ReferentialConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ReferentialConstraints.parse(e));
    
}


}
export namespace RoleColumnGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleColumnGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleColumnGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleColumnGrants.parse(e));
    
}


}
export namespace RoutineColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineColumnUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineColumnUsage.parse(e));
    
}


}
export namespace RoutinePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutinePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutinePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutinePrivileges.parse(e));
    
}


}
export namespace RoleRoutineGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleRoutineGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleRoutineGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleRoutineGrants.parse(e));
    
}


}
export namespace RoutineRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineRoutineUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineRoutineUsage.parse(e));
    
}


}
export namespace RoutineSequenceUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineSequenceUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(from.sequenceCatalog),
sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(from.sequenceSchema),
sequenceName: InformationSchema.Types.SqlIdentifier.parse(from.sequenceName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineSequenceUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineSequenceUsage.parse(e));
    
}


}
export namespace RoutineTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoutineTableUsage.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutineTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoutineTableUsage.parse(e));
    
}


}
export namespace Routines {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Routines.is(from)) {
  return {
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
routineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.routineCatalog),
routineSchema: InformationSchema.Types.SqlIdentifier.parse(from.routineSchema),
routineName: InformationSchema.Types.SqlIdentifier.parse(from.routineName),
routineType: InformationSchema.Types.CharacterData.parse(from.routineType),
moduleCatalog: InformationSchema.Types.SqlIdentifier.parse(from.moduleCatalog),
moduleSchema: InformationSchema.Types.SqlIdentifier.parse(from.moduleSchema),
moduleName: InformationSchema.Types.SqlIdentifier.parse(from.moduleName),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
typeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtCatalog),
typeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtSchema),
typeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.typeUdtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
routineBody: InformationSchema.Types.CharacterData.parse(from.routineBody),
routineDefinition: InformationSchema.Types.CharacterData.parse(from.routineDefinition),
externalName: InformationSchema.Types.CharacterData.parse(from.externalName),
externalLanguage: InformationSchema.Types.CharacterData.parse(from.externalLanguage),
parameterStyle: InformationSchema.Types.CharacterData.parse(from.parameterStyle),
isDeterministic: InformationSchema.Types.YesOrNo.parse(from.isDeterministic),
sqlDataAccess: InformationSchema.Types.CharacterData.parse(from.sqlDataAccess),
isNullCall: InformationSchema.Types.YesOrNo.parse(from.isNullCall),
sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
schemaLevelRoutine: InformationSchema.Types.YesOrNo.parse(from.schemaLevelRoutine),
maxDynamicResultSets: InformationSchema.Types.CardinalNumber.parse(from.maxDynamicResultSets),
isUserDefinedCast: InformationSchema.Types.YesOrNo.parse(from.isUserDefinedCast),
isImplicitlyInvocable: InformationSchema.Types.YesOrNo.parse(from.isImplicitlyInvocable),
securityType: InformationSchema.Types.CharacterData.parse(from.securityType),
toSqlSpecificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificCatalog),
toSqlSpecificSchema: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificSchema),
toSqlSpecificName: InformationSchema.Types.SqlIdentifier.parse(from.toSqlSpecificName),
asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
created: InformationSchema.Types.TimeStamp.parse(from.created),
lastAltered: InformationSchema.Types.TimeStamp.parse(from.lastAltered),
newSavepointLevel: InformationSchema.Types.YesOrNo.parse(from.newSavepointLevel),
isUdtDependent: InformationSchema.Types.YesOrNo.parse(from.isUdtDependent),
resultCastFromDataType: InformationSchema.Types.CharacterData.parse(from.resultCastFromDataType),
resultCastAsLocator: InformationSchema.Types.YesOrNo.parse(from.resultCastAsLocator),
resultCastCharMaxLength: InformationSchema.Types.CardinalNumber.parse(from.resultCastCharMaxLength),
resultCastCharOctetLength: InformationSchema.Types.CardinalNumber.parse(from.resultCastCharOctetLength),
resultCastCharSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetCatalog),
resultCastCharSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetSchema),
resultCastCharSetName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCharSetName),
resultCastCollationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationCatalog),
resultCastCollationSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationSchema),
resultCastCollationName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastCollationName),
resultCastNumericPrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericPrecision),
resultCastNumericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericPrecisionRadix),
resultCastNumericScale: InformationSchema.Types.CardinalNumber.parse(from.resultCastNumericScale),
resultCastDatetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastDatetimePrecision),
resultCastIntervalType: InformationSchema.Types.CharacterData.parse(from.resultCastIntervalType),
resultCastIntervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.resultCastIntervalPrecision),
resultCastTypeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtCatalog),
resultCastTypeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtSchema),
resultCastTypeUdtName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastTypeUdtName),
resultCastScopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeCatalog),
resultCastScopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeSchema),
resultCastScopeName: InformationSchema.Types.SqlIdentifier.parse(from.resultCastScopeName),
resultCastMaximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.resultCastMaximumCardinality),
resultCastDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.resultCastDtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoutinesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Routines.parse(e));
    
}


}
export namespace Schemata {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Schemata.is(from)) {
  return {
catalogName: InformationSchema.Types.SqlIdentifier.parse(from.catalogName),
schemaName: InformationSchema.Types.SqlIdentifier.parse(from.schemaName),
schemaOwner: InformationSchema.Types.SqlIdentifier.parse(from.schemaOwner),
defaultCharacterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetCatalog),
defaultCharacterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetSchema),
defaultCharacterSetName: InformationSchema.Types.SqlIdentifier.parse(from.defaultCharacterSetName),
sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SchemataArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Schemata.parse(e));
    
}


}
export namespace Sequences {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Sequences.is(from)) {
  return {
sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(from.sequenceCatalog),
sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(from.sequenceSchema),
sequenceName: InformationSchema.Types.SqlIdentifier.parse(from.sequenceName),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
startValue: InformationSchema.Types.CharacterData.parse(from.startValue),
minimumValue: InformationSchema.Types.CharacterData.parse(from.minimumValue),
maximumValue: InformationSchema.Types.CharacterData.parse(from.maximumValue),
increment: InformationSchema.Types.CharacterData.parse(from.increment),
cycleOption: InformationSchema.Types.YesOrNo.parse(from.cycleOption),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SequencesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Sequences.parse(e));
    
}


}
export namespace SqlFeatures {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlFeatures.is(from)) {
  return {
featureId: InformationSchema.Types.CharacterData.parse(from.featureId),
featureName: InformationSchema.Types.CharacterData.parse(from.featureName),
subFeatureId: InformationSchema.Types.CharacterData.parse(from.subFeatureId),
subFeatureName: InformationSchema.Types.CharacterData.parse(from.subFeatureName),
isSupported: InformationSchema.Types.YesOrNo.parse(from.isSupported),
isVerifiedBy: InformationSchema.Types.CharacterData.parse(from.isVerifiedBy),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlFeaturesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlFeatures.parse(e));
    
}


}
export namespace SqlImplementationInfo {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlImplementationInfo.is(from)) {
  return {
implementationInfoId: InformationSchema.Types.CharacterData.parse(from.implementationInfoId),
implementationInfoName: InformationSchema.Types.CharacterData.parse(from.implementationInfoName),
integerValue: InformationSchema.Types.CardinalNumber.parse(from.integerValue),
characterValue: InformationSchema.Types.CharacterData.parse(from.characterValue),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlImplementationInfoArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlImplementationInfo.parse(e));
    
}


}
export namespace SqlParts {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlParts.is(from)) {
  return {
featureId: InformationSchema.Types.CharacterData.parse(from.featureId),
featureName: InformationSchema.Types.CharacterData.parse(from.featureName),
isSupported: InformationSchema.Types.YesOrNo.parse(from.isSupported),
isVerifiedBy: InformationSchema.Types.CharacterData.parse(from.isVerifiedBy),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlPartsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlParts.parse(e));
    
}


}
export namespace SqlSizing {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.SqlSizing.is(from)) {
  return {
sizingId: InformationSchema.Types.CardinalNumber.parse(from.sizingId),
sizingName: InformationSchema.Types.CharacterData.parse(from.sizingName),
supportedValue: InformationSchema.Types.CardinalNumber.parse(from.supportedValue),
comments: InformationSchema.Types.CharacterData.parse(from.comments),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SqlSizingArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SqlSizing.parse(e));
    
}


}
export namespace TableConstraints {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TableConstraints.is(from)) {
  return {
constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(from.constraintCatalog),
constraintSchema: InformationSchema.Types.SqlIdentifier.parse(from.constraintSchema),
constraintName: InformationSchema.Types.SqlIdentifier.parse(from.constraintName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
constraintType: InformationSchema.Types.CharacterData.parse(from.constraintType),
isDeferrable: InformationSchema.Types.YesOrNo.parse(from.isDeferrable),
initiallyDeferred: InformationSchema.Types.YesOrNo.parse(from.initiallyDeferred),
enforced: InformationSchema.Types.YesOrNo.parse(from.enforced),
nullsDistinct: InformationSchema.Types.YesOrNo.parse(from.nullsDistinct),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TableConstraintsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TableConstraints.parse(e));
    
}


}
export namespace TablePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TablePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
withHierarchy: InformationSchema.Types.YesOrNo.parse(from.withHierarchy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TablePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TablePrivileges.parse(e));
    
}


}
export namespace RoleTableGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleTableGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
withHierarchy: InformationSchema.Types.YesOrNo.parse(from.withHierarchy),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleTableGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleTableGrants.parse(e));
    
}


}
export namespace Tables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Tables.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
tableType: InformationSchema.Types.CharacterData.parse(from.tableType),
selfReferencingColumnName: InformationSchema.Types.SqlIdentifier.parse(from.selfReferencingColumnName),
referenceGeneration: InformationSchema.Types.CharacterData.parse(from.referenceGeneration),
userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeCatalog),
userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeSchema),
userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeName),
isInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isInsertableInto),
isTyped: InformationSchema.Types.YesOrNo.parse(from.isTyped),
commitAction: InformationSchema.Types.CharacterData.parse(from.commitAction),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Tables.parse(e));
    
}


}
export namespace Transforms {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Transforms.is(from)) {
  return {
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
groupName: InformationSchema.Types.SqlIdentifier.parse(from.groupName),
transformType: InformationSchema.Types.CharacterData.parse(from.transformType),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TransformsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Transforms.parse(e));
    
}


}
export namespace TriggeredUpdateColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.TriggeredUpdateColumns.is(from)) {
  return {
triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.triggerCatalog),
triggerSchema: InformationSchema.Types.SqlIdentifier.parse(from.triggerSchema),
triggerName: InformationSchema.Types.SqlIdentifier.parse(from.triggerName),
eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectCatalog),
eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectSchema),
eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectTable),
eventObjectColumn: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectColumn),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TriggeredUpdateColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => TriggeredUpdateColumns.parse(e));
    
}


}
export namespace Triggers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Triggers.is(from)) {
  return {
triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.triggerCatalog),
triggerSchema: InformationSchema.Types.SqlIdentifier.parse(from.triggerSchema),
triggerName: InformationSchema.Types.SqlIdentifier.parse(from.triggerName),
eventManipulation: InformationSchema.Types.CharacterData.parse(from.eventManipulation),
eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectCatalog),
eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectSchema),
eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(from.eventObjectTable),
actionOrder: InformationSchema.Types.CardinalNumber.parse(from.actionOrder),
actionCondition: InformationSchema.Types.CharacterData.parse(from.actionCondition),
actionStatement: InformationSchema.Types.CharacterData.parse(from.actionStatement),
actionOrientation: InformationSchema.Types.CharacterData.parse(from.actionOrientation),
actionTiming: InformationSchema.Types.CharacterData.parse(from.actionTiming),
actionReferenceOldTable: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceOldTable),
actionReferenceNewTable: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceNewTable),
actionReferenceOldRow: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceOldRow),
actionReferenceNewRow: InformationSchema.Types.SqlIdentifier.parse(from.actionReferenceNewRow),
created: InformationSchema.Types.TimeStamp.parse(from.created),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace TriggersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Triggers.parse(e));
    
}


}
export namespace UdtPrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UdtPrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UdtPrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UdtPrivileges.parse(e));
    
}


}
export namespace RoleUdtGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleUdtGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleUdtGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleUdtGrants.parse(e));
    
}


}
export namespace UsagePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UsagePrivileges.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UsagePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UsagePrivileges.parse(e));
    
}


}
export namespace RoleUsageGrants {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.RoleUsageGrants.is(from)) {
  return {
grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
privilegeType: InformationSchema.Types.CharacterData.parse(from.privilegeType),
isGrantable: InformationSchema.Types.YesOrNo.parse(from.isGrantable),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace RoleUsageGrantsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => RoleUsageGrants.parse(e));
    
}


}
export namespace UserDefinedTypes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserDefinedTypes.is(from)) {
  return {
userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeCatalog),
userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeSchema),
userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(from.userDefinedTypeName),
userDefinedTypeCategory: InformationSchema.Types.CharacterData.parse(from.userDefinedTypeCategory),
isInstantiable: InformationSchema.Types.YesOrNo.parse(from.isInstantiable),
isFinal: InformationSchema.Types.YesOrNo.parse(from.isFinal),
orderingForm: InformationSchema.Types.CharacterData.parse(from.orderingForm),
orderingCategory: InformationSchema.Types.CharacterData.parse(from.orderingCategory),
orderingRoutineCatalog: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineCatalog),
orderingRoutineSchema: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineSchema),
orderingRoutineName: InformationSchema.Types.SqlIdentifier.parse(from.orderingRoutineName),
referenceType: InformationSchema.Types.CharacterData.parse(from.referenceType),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
sourceDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.sourceDtdIdentifier),
refDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.refDtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserDefinedTypesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserDefinedTypes.parse(e));
    
}


}
export namespace ViewColumnUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewColumnUsage.is(from)) {
  return {
viewCatalog: InformationSchema.Types.SqlIdentifier.parse(from.viewCatalog),
viewSchema: InformationSchema.Types.SqlIdentifier.parse(from.viewSchema),
viewName: InformationSchema.Types.SqlIdentifier.parse(from.viewName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewColumnUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewColumnUsage.parse(e));
    
}


}
export namespace ViewRoutineUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewRoutineUsage.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
specificCatalog: InformationSchema.Types.SqlIdentifier.parse(from.specificCatalog),
specificSchema: InformationSchema.Types.SqlIdentifier.parse(from.specificSchema),
specificName: InformationSchema.Types.SqlIdentifier.parse(from.specificName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewRoutineUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewRoutineUsage.parse(e));
    
}


}
export namespace ViewTableUsage {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ViewTableUsage.is(from)) {
  return {
viewCatalog: InformationSchema.Types.SqlIdentifier.parse(from.viewCatalog),
viewSchema: InformationSchema.Types.SqlIdentifier.parse(from.viewSchema),
viewName: InformationSchema.Types.SqlIdentifier.parse(from.viewName),
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewTableUsageArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ViewTableUsage.parse(e));
    
}


}
export namespace Views {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.Views.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
viewDefinition: InformationSchema.Types.CharacterData.parse(from.viewDefinition),
checkOption: InformationSchema.Types.CharacterData.parse(from.checkOption),
isUpdatable: InformationSchema.Types.YesOrNo.parse(from.isUpdatable),
isInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isInsertableInto),
isTriggerUpdatable: InformationSchema.Types.YesOrNo.parse(from.isTriggerUpdatable),
isTriggerDeletable: InformationSchema.Types.YesOrNo.parse(from.isTriggerDeletable),
isTriggerInsertableInto: InformationSchema.Types.YesOrNo.parse(from.isTriggerInsertableInto),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ViewsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Views.parse(e));
    
}


}
export namespace DataTypePrivileges {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.DataTypePrivileges.is(from)) {
  return {
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace DataTypePrivilegesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => DataTypePrivileges.parse(e));
    
}


}
export namespace ElementTypes {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ElementTypes.is(from)) {
  return {
objectCatalog: InformationSchema.Types.SqlIdentifier.parse(from.objectCatalog),
objectSchema: InformationSchema.Types.SqlIdentifier.parse(from.objectSchema),
objectName: InformationSchema.Types.SqlIdentifier.parse(from.objectName),
objectType: InformationSchema.Types.CharacterData.parse(from.objectType),
collectionTypeIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.collectionTypeIdentifier),
dataType: InformationSchema.Types.CharacterData.parse(from.dataType),
characterMaximumLength: InformationSchema.Types.CardinalNumber.parse(from.characterMaximumLength),
characterOctetLength: InformationSchema.Types.CardinalNumber.parse(from.characterOctetLength),
characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(from.characterSetCatalog),
characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(from.characterSetSchema),
characterSetName: InformationSchema.Types.SqlIdentifier.parse(from.characterSetName),
collationCatalog: InformationSchema.Types.SqlIdentifier.parse(from.collationCatalog),
collationSchema: InformationSchema.Types.SqlIdentifier.parse(from.collationSchema),
collationName: InformationSchema.Types.SqlIdentifier.parse(from.collationName),
numericPrecision: InformationSchema.Types.CardinalNumber.parse(from.numericPrecision),
numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(from.numericPrecisionRadix),
numericScale: InformationSchema.Types.CardinalNumber.parse(from.numericScale),
datetimePrecision: InformationSchema.Types.CardinalNumber.parse(from.datetimePrecision),
intervalType: InformationSchema.Types.CharacterData.parse(from.intervalType),
intervalPrecision: InformationSchema.Types.CardinalNumber.parse(from.intervalPrecision),
domainDefault: InformationSchema.Types.CharacterData.parse(from.domainDefault),
udtCatalog: InformationSchema.Types.SqlIdentifier.parse(from.udtCatalog),
udtSchema: InformationSchema.Types.SqlIdentifier.parse(from.udtSchema),
udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(from.scopeCatalog),
scopeSchema: InformationSchema.Types.SqlIdentifier.parse(from.scopeSchema),
scopeName: InformationSchema.Types.SqlIdentifier.parse(from.scopeName),
maximumCardinality: InformationSchema.Types.CardinalNumber.parse(from.maximumCardinality),
dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.dtdIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ElementTypesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ElementTypes.parse(e));
    
}


}
export namespace PgForeignTableColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignTableColumns.is(from)) {
  return {
nspname: PgCatalog.Types.Name.parse(from.nspname),
relname: PgCatalog.Types.Name.parse(from.relname),
attname: PgCatalog.Types.Name.parse(from.attname),
attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ColumnOptions.is(from)) {
  return {
tableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.tableCatalog),
tableSchema: InformationSchema.Types.SqlIdentifier.parse(from.tableSchema),
tableName: InformationSchema.Types.SqlIdentifier.parse(from.tableName),
columnName: InformationSchema.Types.SqlIdentifier.parse(from.columnName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ColumnOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ColumnOptions.parse(e));
    
}


}
export namespace PgForeignDataWrappers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignDataWrappers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignDataWrapperLanguage: InformationSchema.Types.CharacterData.parse(from.foreignDataWrapperLanguage),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrapperOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignDataWrapperOptions.is(from)) {
  return {
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrapperOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignDataWrapperOptions.parse(e));
    
}


}
export namespace ForeignDataWrappers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignDataWrappers.is(from)) {
  return {
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
libraryName: InformationSchema.Types.CharacterData.parse(from.libraryName),
foreignDataWrapperLanguage: InformationSchema.Types.CharacterData.parse(from.foreignDataWrapperLanguage),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignDataWrappersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignDataWrappers.parse(e));
    
}


}
export namespace PgForeignServers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignServers.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
foreignServerType: InformationSchema.Types.CharacterData.parse(from.foreignServerType),
foreignServerVersion: InformationSchema.Types.CharacterData.parse(from.foreignServerVersion),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServerOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignServerOptions.is(from)) {
  return {
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServerOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignServerOptions.parse(e));
    
}


}
export namespace ForeignServers {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignServers.is(from)) {
  return {
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
foreignDataWrapperCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperCatalog),
foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(from.foreignDataWrapperName),
foreignServerType: InformationSchema.Types.CharacterData.parse(from.foreignServerType),
foreignServerVersion: InformationSchema.Types.CharacterData.parse(from.foreignServerVersion),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignServersArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignServers.parse(e));
    
}


}
export namespace PgForeignTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgForeignTables.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTableOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignTableOptions.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTableOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignTableOptions.parse(e));
    
}


}
export namespace ForeignTables {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.ForeignTables.is(from)) {
  return {
foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableCatalog),
foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableSchema),
foreignTableName: InformationSchema.Types.SqlIdentifier.parse(from.foreignTableName),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ForeignTablesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ForeignTables.parse(e));
    
}


}
export namespace PgUserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.PgUserMappings.is(from)) {
  return {
oid: PgCatalog.Types.Oid.parse(from.oid),
umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
umuser: PgCatalog.Types.Oid.parse(from.umuser),
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
srvowner: InformationSchema.Types.SqlIdentifier.parse(from.srvowner),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingOptions {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserMappingOptions.is(from)) {
  return {
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
optionName: InformationSchema.Types.SqlIdentifier.parse(from.optionName),
optionValue: InformationSchema.Types.CharacterData.parse(from.optionValue),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingOptionsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserMappingOptions.parse(e));
    
}


}
export namespace UserMappings {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (InformationSchema.Types.UserMappings.is(from)) {
  return {
authorizationIdentifier: InformationSchema.Types.SqlIdentifier.parse(from.authorizationIdentifier),
foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerCatalog),
foreignServerName: InformationSchema.Types.SqlIdentifier.parse(from.foreignServerName),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace UserMappingsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => UserMappings.parse(e));
    
}


}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlImplementationInfo {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlParts {
export namespace Results {
}
export namespace Create {
}
}
export namespace SqlSizing {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace Public {
export namespace Types {
export namespace Spheroid {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace SpheroidArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Spheroid.parse(e));
    
}


}
export namespace Geometry {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace GeometryArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Geometry.parse(e));
    
}


}
export namespace Box3d {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Box3dArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box3d.parse(e));
    
}


}
export namespace Box2d {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Box2dArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box2d.parse(e));
    
}


}
export namespace Box2df {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace Box2dfArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Box2df.parse(e));
    
}


}
export namespace Gidx {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace GidxArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Gidx.parse(e));
    
}


}
export namespace GeometryDump {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeometryDump.is(from)) {
  return {
path: PgCatalog.Types.Int4Array.parse(from.path),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeometryDumpArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeometryDump.parse(e));
    
}


}
export namespace SpatialRefSys {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.SpatialRefSys.is(from)) {
  return {
srid: PgCatalog.Types.Int4.parse(from.srid),
authName: PgCatalog.Types.Varchar.parse(from.authName),
authSrid: PgCatalog.Types.Int4.parse(from.authSrid),
srtext: PgCatalog.Types.Varchar.parse(from.srtext),
proj4text: PgCatalog.Types.Varchar.parse(from.proj4text),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace SpatialRefSysArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => SpatialRefSys.parse(e));
    
}


}
export namespace ValidDetail {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.ValidDetail.is(from)) {
  return {
valid: PgCatalog.Types.Bool.parse(from.valid),
reason: PgCatalog.Types.Varchar.parse(from.reason),
location: Public.Types.Geometry.parse(from.location),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace ValidDetailArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => ValidDetail.parse(e));
    
}


}
export namespace Geography {
export function parse(from: unknown) {
// Type
if (from === null || from === undefined) return null;

      return from;
    
}


}
export namespace GeographyArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => Geography.parse(e));
    
}


}
export namespace GeographyColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeographyColumns.is(from)) {
  return {
fTableCatalog: PgCatalog.Types.Name.parse(from.fTableCatalog),
fTableSchema: PgCatalog.Types.Name.parse(from.fTableSchema),
fTableName: PgCatalog.Types.Name.parse(from.fTableName),
fGeographyColumn: PgCatalog.Types.Name.parse(from.fGeographyColumn),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
srid: PgCatalog.Types.Int4.parse(from.srid),
type: PgCatalog.Types.Text.parse(from.type),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeographyColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeographyColumns.parse(e));
    
}


}
export namespace GeometryColumns {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.GeometryColumns.is(from)) {
  return {
fTableCatalog: PgCatalog.Types.Varchar.parse(from.fTableCatalog),
fTableSchema: PgCatalog.Types.Name.parse(from.fTableSchema),
fTableName: PgCatalog.Types.Name.parse(from.fTableName),
fGeometryColumn: PgCatalog.Types.Name.parse(from.fGeometryColumn),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
srid: PgCatalog.Types.Int4.parse(from.srid),
type: PgCatalog.Types.Varchar.parse(from.type),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace GeometryColumnsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => GeometryColumns.parse(e));
    
}


}
export namespace NycCensusBlocks {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocks.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
blkid: PgCatalog.Types.Varchar.parse(from.blkid),
popnTotal: PgCatalog.Types.Float8.parse(from.popnTotal),
popnWhite: PgCatalog.Types.Float8.parse(from.popnWhite),
popnBlack: PgCatalog.Types.Float8.parse(from.popnBlack),
popnNativ: PgCatalog.Types.Float8.parse(from.popnNativ),
popnAsian: PgCatalog.Types.Float8.parse(from.popnAsian),
popnOther: PgCatalog.Types.Float8.parse(from.popnOther),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycCensusBlocks.parse(e));
    
}


}
export namespace NycHomicides {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicides.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
incidentD: PgCatalog.Types.Date.parse(from.incidentD),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
numVictim: PgCatalog.Types.Varchar.parse(from.numVictim),
primaryMo: PgCatalog.Types.Varchar.parse(from.primaryMo),
id: PgCatalog.Types.Float8.parse(from.id),
weapon: PgCatalog.Types.Varchar.parse(from.weapon),
lightDark: PgCatalog.Types.Varchar.parse(from.lightDark),
year: PgCatalog.Types.Float8.parse(from.year),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycHomicides.parse(e));
    
}


}
export namespace NycNeighborhoods {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoods.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
boroname: PgCatalog.Types.Varchar.parse(from.boroname),
name: PgCatalog.Types.Varchar.parse(from.name),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycNeighborhoods.parse(e));
    
}


}
export namespace NycStreets {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreets.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
id: PgCatalog.Types.Float8.parse(from.id),
name: PgCatalog.Types.Varchar.parse(from.name),
oneway: PgCatalog.Types.Varchar.parse(from.oneway),
type: PgCatalog.Types.Varchar.parse(from.type),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycStreets.parse(e));
    
}


}
export namespace NycSubwayStations {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStations.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
objectid: PgCatalog.Types.Numeric.parse(from.objectid),
id: PgCatalog.Types.Numeric.parse(from.id),
name: PgCatalog.Types.Varchar.parse(from.name),
altName: PgCatalog.Types.Varchar.parse(from.altName),
crossSt: PgCatalog.Types.Varchar.parse(from.crossSt),
longName: PgCatalog.Types.Varchar.parse(from.longName),
label: PgCatalog.Types.Varchar.parse(from.label),
borough: PgCatalog.Types.Varchar.parse(from.borough),
nghbhd: PgCatalog.Types.Varchar.parse(from.nghbhd),
routes: PgCatalog.Types.Varchar.parse(from.routes),
transfers: PgCatalog.Types.Varchar.parse(from.transfers),
color: PgCatalog.Types.Varchar.parse(from.color),
express: PgCatalog.Types.Varchar.parse(from.express),
closed: PgCatalog.Types.Varchar.parse(from.closed),
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsArray {
export function parse(from: unknown) {
// ArrayType
if (from === null || from === undefined) return [];

      const rawArray = Array.isArray(from) ? from : JSON.parse(from as string) as unknown[];
      return rawArray.map((e:unknown) => NycSubwayStations.parse(e));
    
}


}
export namespace SpatialRefSysPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.SpatialRefSysPkey.is(from)) {
  return {
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocksPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicidesPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoodsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreetsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsPkey {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStationsPkey.is(from)) {
  return {
gid: PgCatalog.Types.Int4.parse(from.gid),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycCensusBlocksGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycCensusBlocksGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycHomicidesGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycHomicidesGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycNeighborhoodsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycNeighborhoodsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycStreetsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycStreetsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace NycSubwayStationsGeomIdx {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.NycSubwayStationsGeomIdx.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrs {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrs.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrsAll {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrsAll.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PostgisSrsSearch {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.PostgisSrsSearch.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
srname: PgCatalog.Types.Text.parse(from.srname),
srtext: PgCatalog.Types.Text.parse(from.srtext),
proj4text: PgCatalog.Types.Text.parse(from.proj4text),
pointSw: Public.Types.Geometry.parse(from.pointSw),
pointNe: Public.Types.Geometry.parse(from.pointNe),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StMinimumboundingradius {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StMinimumboundingradius.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StMaximuminscribedcircle {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StMaximuminscribedcircle.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
nearest: Public.Types.Geometry.parse(from.nearest),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StLargestemptycircle {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StLargestemptycircle.is(from)) {
  return {
center: Public.Types.Geometry.parse(from.center),
nearest: Public.Types.Geometry.parse(from.nearest),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StHexagongrid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StHexagongrid.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
i: PgCatalog.Types.Int4.parse(from.i),
j: PgCatalog.Types.Int4.parse(from.j),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace StSquaregrid {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Types.StSquaregrid.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
i: PgCatalog.Types.Int4.parse(from.i),
j: PgCatalog.Types.Int4.parse(from.j),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcepolygoncw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace SpheroidIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.SpheroidIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace SpheroidOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.SpheroidOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Spheroid.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryTypmodIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryTypmodIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.CstringArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryTypmodOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryTypmodOut.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryAnalyze {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryAnalyze.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryRecv {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryRecv.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySend.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_6564 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_6564.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_8997 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_8997.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Point.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Point {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Point.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryB0d8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryB0d8.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Path.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Path {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Path.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryF1be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryF1be.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Polygon.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Polygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Polygon.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StX {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StX.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StY {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StY.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZ {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZ.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StM {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StM.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dfIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dfIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2dfOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2dfOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GidxIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GidxIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GidxOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GidxOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLt.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLe.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGt.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGe.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryEq {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryEq.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryCmp {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryCmp.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySortsupport {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySortsupport.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryHash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryHash.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDistance_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDistance_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistCompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistCompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPenalty_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPenalty_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPicksplit_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPicksplit_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistUnion_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistUnion_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSame_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSame_2d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDecompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDecompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSortsupport_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSortsupport_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcerhr {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcerhr.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisNoop {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisNoop.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcepolygonccw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcepolygonccw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistSel_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistSel_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistSelNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistSelNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistJoinsel_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistJoinsel_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int2.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GserializedGistJoinselNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GserializedGistJoinselNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Int2.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlaps.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySame {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySame.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCentroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCentroid.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceBox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceBox.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContains {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContains.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryWithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryWithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryLeft {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryLeft.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverleft {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverleft.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryBelow {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryBelow.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverbelow {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverbelow.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverright {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverright.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryRight {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryRight.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverabove {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverabove.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryAbove {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryAbove.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPenaltyNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPenaltyNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistUnionNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistUnionNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistSameNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistSameNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDecompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDecompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlapsNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlapsNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContainsNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContainsNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryWithinNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryWithinNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySameNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySameNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCentroidNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCentroidNd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryDistanceCpa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryDistanceCpa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryGistDistanceNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryGistDistanceNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShiftlongitude {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShiftlongitude.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWrapx {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWrapx.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
wrap: PgCatalog.Types.Float8.parse(from.wrap),
move: PgCatalog.Types.Float8.parse(from.move),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StXmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StXmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StYmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StYmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StXmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StXmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StYmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StYmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmax {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmax.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_269a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_269a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_96e3 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_96e3.Parameters.is(from)) {
  return {
box: Public.Types.Box2d.parse(from.box),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisGetbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisGetbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakebox2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakebox2d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextentD2f5 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextentD2f5.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Bool.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextent_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextent_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEstimatedextent_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEstimatedextent_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFindextent_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFindextent_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFindextent_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFindextent_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisAddbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisAddbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisDropbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisDropbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisHasbbox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisHasbbox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StQuantizecoordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StQuantizecoordinates.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
precX: PgCatalog.Types.Int4.parse(from.precX),
precY: PgCatalog.Types.Int4.parse(from.precY),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMemsize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMemsize.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSummary_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSummary_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNpoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNrings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNrings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlength {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlength.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthspheroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthspheroid.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Spheroid.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLength2dspheroid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLength2dspheroid.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Spheroid.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dperimeter {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dperimeter.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeter2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeter2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeter_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeter_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StArea2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StArea2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StArea_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StArea_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIspolygoncw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIspolygoncw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIspolygonccw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIspolygonccw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancespheroidCd56 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancespheroidCd56.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: Public.Types.Spheroid.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancespheroid_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancespheroid_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistance_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistance_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointinsidecircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointinsidecircle.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAzimuth_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAzimuth_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProjectD5eb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProjectD5eb.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
distance: PgCatalog.Types.Float8.parse(from.distance),
azimuth: PgCatalog.Types.Float8.parse(from.azimuth),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProject_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProject_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
distance: PgCatalog.Types.Float8.parse(from.distance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAngleE1dd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAngleE1dd.Parameters.is(from)) {
  return {
pt1: Public.Types.Geometry.parse(from.pt1),
pt2: Public.Types.Geometry.parse(from.pt2),
pt3: Public.Types.Geometry.parse(from.pt3),
pt4: Public.Types.Geometry.parse(from.pt4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineextend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineextend.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
distanceForward: PgCatalog.Types.Float8.parse(from.distanceForward),
distanceBackward: PgCatalog.Types.Float8.parse(from.distanceBackward),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce2d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3dz {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3dz.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce3dm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce3dm.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
mvalue: PgCatalog.Types.Float8.parse(from.mvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForce4d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForce4d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
zvalue: PgCatalog.Types.Float8.parse(from.zvalue),
mvalue: PgCatalog.Types.Float8.parse(from.mvalue),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcecollection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcecollection.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionextract_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionextract_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionextract_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionextract_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectionhomogenize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectionhomogenize.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMulti {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMulti.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcecurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcecurve.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcesfs_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcesfs_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StForcesfs_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StForcesfs_88bc.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
version: PgCatalog.Types.Text.parse(from.version),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_2074 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_2074.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_704e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_704e.Parameters.is(from)) {
  return {
box: Public.Types.Box3d.parse(from.box),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
dz: PgCatalog.Types.Float8.parse(from.dz),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExpand_5500 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExpand_5500.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
dx: PgCatalog.Types.Float8.parse(from.dx),
dy: PgCatalog.Types.Float8.parse(from.dy),
dz: PgCatalog.Types.Float8.parse(from.dz),
dm: PgCatalog.Types.Float8.parse(from.dm),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEnvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEnvelope.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBoundingdiagonal {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBoundingdiagonal.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fits: PgCatalog.Types.Bool.parse(from.fits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StReverse {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StReverse.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScroll {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScroll.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisGeosNoop {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisGeosNoop.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNormalize {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNormalize.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StZmflag {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StZmflag.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNdims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNdims.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstwkb_652e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstwkb_652e.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
prec: PgCatalog.Types.Int4.parse(from.prec),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
withSizes: PgCatalog.Types.Bool.parse(from.withSizes),
withBoxes: PgCatalog.Types.Bool.parse(from.withBoxes),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstwkbF3fd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstwkbF3fd.Parameters.is(from)) {
  return {
geom: Public.Types.GeometryArray.parse(from.geom),
ids: PgCatalog.Types.Int8Array.parse(from.ids),
prec: PgCatalog.Types.Int4.parse(from.prec),
precZ: PgCatalog.Types.Int4.parse(from.precZ),
precM: PgCatalog.Types.Int4.parse(from.precM),
withSizes: PgCatalog.Types.Bool.parse(from.withSizes),
withBoxes: PgCatalog.Types.Bool.parse(from.withBoxes),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkb_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkb_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAshexewkb_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAshexewkb_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAshexewkb_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAshexewkb_88bc.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkb_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkb_88bc.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAslatlontext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAslatlontext.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tmpl: PgCatalog.Types.Text.parse(from.tmpl),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geomfromewkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geomfromewkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromewkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromewkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geomfromewkt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geomfromewkt.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromewkt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromewkt.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisCacheBbox {
export namespace Results {
}
}
export namespace StMakepoint_0aec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_0aec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepoint_81ec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_81ec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepoint_570b {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepoint_570b.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepointm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepointm.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dmakebox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dmakebox.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakelineA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakelineA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefrommultipoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefrommultipoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakeline_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakeline_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddpoint_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddpoint_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScaleD5eb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScaleD5eb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddpointAa17 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddpointAa17.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRemovepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRemovepoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: Public.Types.Geometry.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakeenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakeenvelope.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Int4.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTileenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTileenvelope.Parameters.is(from)) {
  return {
zoom: PgCatalog.Types.Int4.parse(from.zoom),
x: PgCatalog.Types.Int4.parse(from.x),
y: PgCatalog.Types.Int4.parse(from.y),
bounds: Public.Types.Geometry.parse(from.bounds),
margin: PgCatalog.Types.Float8.parse(from.margin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepolygonE2e3 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepolygonE2e3.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.GeometryArray.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakepolygon_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakepolygon_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuildarea {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuildarea.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonizeA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonizeA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClusterintersectingA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClusterintersectingA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClusterwithin_0e49 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClusterwithin_0e49.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinemerge_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinemerge_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinemerge_4ba2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinemerge_4ba2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Bool.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAffineE42d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAffineE42d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
argument_6: PgCatalog.Types.Float8.parse(from.argument_6),
argument_7: PgCatalog.Types.Float8.parse(from.argument_7),
argument_8: PgCatalog.Types.Float8.parse(from.argument_8),
argument_9: PgCatalog.Types.Float8.parse(from.argument_9),
argument_10: PgCatalog.Types.Float8.parse(from.argument_10),
argument_11: PgCatalog.Types.Float8.parse(from.argument_11),
argument_12: PgCatalog.Types.Float8.parse(from.argument_12),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAffine_1962 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAffine_1962.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
argument_6: PgCatalog.Types.Float8.parse(from.argument_6),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotate_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotate_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotate_8b9f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotate_8b9f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotate_463e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotate_463e.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: Public.Types.Geometry.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatez {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatez.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatex {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatex.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRotatey {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRotatey.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTranslate_8b9f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTranslate_8b9f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTranslateD5eb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTranslateD5eb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_3651.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_1bee {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_1bee.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StScale_8b9f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StScale_8b9f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransscale {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransscale.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDump {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDump.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumprings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumprings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumppoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumppoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDumpsegments {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDumpsegments.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PopulateGeometryColumns_23fc.Parameters.is(from)) {
  return {
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PopulateGeometryColumns_4174.Parameters.is(from)) {
  return {
tblOid: PgCatalog.Types.Oid.parse(from.tblOid),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_8fbb.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSridIn: PgCatalog.Types.Int4.parse(from.newSridIn),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_4617 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_4617.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSrid: PgCatalog.Types.Int4.parse(from.newSrid),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addgeometrycolumn_093c {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addgeometrycolumn_093c.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSrid: PgCatalog.Types.Int4.parse(from.newSrid),
newType: PgCatalog.Types.Varchar.parse(from.newType),
newDim: PgCatalog.Types.Int4.parse(from.newDim),
useTypmod: PgCatalog.Types.Bool.parse(from.useTypmod),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrycolumn_0412.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrycolumn_2253.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrycolumnF11a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrycolumnF11a.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Dropgeometrytable_2253 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Dropgeometrytable_2253.Parameters.is(from)) {
  return {
catalogName: PgCatalog.Types.Varchar.parse(from.catalogName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSegmentize_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSegmentize_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrytableF11a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrytableF11a.Parameters.is(from)) {
  return {
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace DropgeometrytableBfde {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.DropgeometrytableBfde.Parameters.is(from)) {
  return {
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace UpdategeometrysridB2ee {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.UpdategeometrysridB2ee.Parameters.is(from)) {
  return {
catalognName: PgCatalog.Types.Varchar.parse(from.catalognName),
schemaName: PgCatalog.Types.Varchar.parse(from.schemaName),
tableName: PgCatalog.Types.Varchar.parse(from.tableName),
columnName: PgCatalog.Types.Varchar.parse(from.columnName),
newSridIn: PgCatalog.Types.Int4.parse(from.newSridIn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Updategeometrysrid_7b58 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Updategeometrysrid_7b58.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Varchar.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Updategeometrysrid_11c8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Updategeometrysrid_11c8.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace FindSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.FindSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Varchar.parse(from.argument_0),
argument_1: PgCatalog.Types.Varchar.parse(from.argument_1),
argument_2: PgCatalog.Types.Varchar.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GetProj4FromSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GetProj4FromSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetsrid_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetsrid_6cbe.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSrid_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSrid_0cdb.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTransformGeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTransformGeometry.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrsCodes {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrsCodes.Parameters.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrs {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrs.Parameters.is(from)) {
  return {
authName: PgCatalog.Types.Text.parse(from.authName),
authSrid: PgCatalog.Types.Text.parse(from.authSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisSrsAll {
export namespace Results {
}
}
export namespace PostgisSrsSearch {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisSrsSearch.Parameters.is(from)) {
  return {
bounds: Public.Types.Geometry.parse(from.bounds),
authname: PgCatalog.Types.Text.parse(from.authname),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransform_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransform_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransform_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransform_88bc.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
toProj: PgCatalog.Types.Text.parse(from.toProj),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransform_655c {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransform_655c.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fromProj: PgCatalog.Types.Text.parse(from.fromProj),
toProj: PgCatalog.Types.Text.parse(from.toProj),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransform_5016 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransform_5016.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
fromProj: PgCatalog.Types.Text.parse(from.fromProj),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTransformPipelineGeometry.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
forward: PgCatalog.Types.Bool.parse(from.forward),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTransformpipeline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTransformpipeline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInversetransformpipeline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInversetransformpipeline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
pipeline: PgCatalog.Types.Text.parse(from.pipeline),
toSrid: PgCatalog.Types.Int4.parse(from.toSrid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisVersion {
export namespace Results {
}
}
export namespace PostgisLiblwgeomVersion {
export namespace Results {
}
}
export namespace PostgisProjVersion {
export namespace Results {
}
}
export namespace PostgisWagyuVersion {
export namespace Results {
}
}
export namespace PostgisScriptsInstalled {
export namespace Results {
}
}
export namespace PostgisLibVersion {
export namespace Results {
}
}
export namespace PostgisScriptsReleased {
export namespace Results {
}
}
export namespace PostgisGeosVersion {
export namespace Results {
}
}
export namespace PostgisGeosCompiledVersion {
export namespace Results {
}
}
export namespace PostgisLibRevision {
export namespace Results {
}
}
export namespace PostgisSvnVersion {
export namespace Results {
}
}
export namespace PostgisLibxmlVersion {
export namespace Results {
}
}
export namespace PostgisScriptsBuildDate {
export namespace Results {
}
}
export namespace PostgisLibBuildDate {
export namespace Results {
}
}
export namespace PostgisExtensionsUpgrade {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisExtensionsUpgrade.Parameters.is(from)) {
  return {
targetVersion: PgCatalog.Types.Text.parse(from.targetVersion),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoint_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoint_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoints_8fda {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoints_8fda.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
repeat: PgCatalog.Types.Bool.parse(from.repeat),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstringD5eb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstringD5eb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepoint_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepoint_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAddmeasure {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAddmeasure.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpointofapproach {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpointofapproach.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisFullVersion {
export namespace Results {
}
}
export namespace Box2d_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2d_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3d_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3d_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box2d_07e9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box2d_07e9.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dE505 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dE505.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box_07e9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box_07e9.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Text {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Text.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Box3dtobox {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Box3dtobox.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryE505 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryE505.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_07e9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_07e9.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Bytea_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Bytea_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplify_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplify_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplify_8fda {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplify_8fda.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifyvw {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifyvw.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSeteffectivearea {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSeteffectivearea.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFilterbym {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFilterbym.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Bool.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StChaikinsmoothing {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StChaikinsmoothing.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogrid_5500 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogrid_5500.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogridD5eb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogridD5eb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogrid_7163 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogrid_7163.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnaptogrid_7f2e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnaptogrid_7f2e.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Float8.parse(from.argument_3),
argument_4: PgCatalog.Types.Float8.parse(from.argument_4),
argument_5: PgCatalog.Types.Float8.parse(from.argument_5),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancecpa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancecpa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCpawithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCpawithin.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidtrajectory {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidtrajectory.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersection_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersection_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferBf44 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferBf44.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
radius: PgCatalog.Types.Float8.parse(from.radius),
options: PgCatalog.Types.Text.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferC33e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferC33e.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
radius: PgCatalog.Types.Float8.parse(from.radius),
quadsegs: PgCatalog.Types.Int4.parse(from.quadsegs),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumboundingradius {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumboundingradius.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumboundingcircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumboundingcircle.Parameters.is(from)) {
  return {
inputgeom: Public.Types.Geometry.parse(from.inputgeom),
segsPerQuarter: PgCatalog.Types.Int4.parse(from.segsPerQuarter),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOrientedenvelope {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOrientedenvelope.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOffsetcurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOffsetcurve.Parameters.is(from)) {
  return {
line: Public.Types.Geometry.parse(from.line),
distance: PgCatalog.Types.Float8.parse(from.distance),
params: PgCatalog.Types.Text.parse(from.params),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeneratepoints_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeneratepoints_6cbe.Parameters.is(from)) {
  return {
area: Public.Types.Geometry.parse(from.area),
npoints: PgCatalog.Types.Int4.parse(from.npoints),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeneratepointsD341 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeneratepointsD341.Parameters.is(from)) {
  return {
area: Public.Types.Geometry.parse(from.area),
npoints: PgCatalog.Types.Int4.parse(from.npoints),
seed: PgCatalog.Types.Int4.parse(from.seed),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StConvexhull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StConvexhull.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifypreservetopology {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifypreservetopology.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidreason_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidreason_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvaliddetail {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvaliddetail.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalidreason_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalidreason_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalid_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalid_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHausdorffdistance_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHausdorffdistance_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHausdorffdistance_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHausdorffdistance_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFrechetdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFrechetdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMaximuminscribedcircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMaximuminscribedcircle.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLargestemptycircle {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLargestemptycircle.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
boundary: Public.Types.Geometry.parse(from.boundary),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBoundary {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBoundary.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSymdifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSymdifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSymmetricdifference {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSymmetricdifference.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnion_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnion_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnion_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnion_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnaryunion {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnaryunion.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRemoverepeatedpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRemoverepeatedpoints.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClipbybox2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClipbybox2d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
box: Public.Types.Box2d.parse(from.box),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSubdivide {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSubdivide.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxvertices: PgCatalog.Types.Int4.parse(from.maxvertices),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StReduceprecision {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StReduceprecision.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
gridsize: PgCatalog.Types.Float8.parse(from.gridsize),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakevalid_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakevalid_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMakevalid_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMakevalid_88bc.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
params: PgCatalog.Types.Text.parse(from.params),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCleangeometry {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCleangeometry.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSplit {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSplit.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSharedpaths {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSharedpaths.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSnap {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSnap.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelatematch {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelatematch.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNode {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNode.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDelaunaytriangles {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDelaunaytriangles.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTriangulatepolygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTriangulatepolygon.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StVoronoipolygons {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StVoronoipolygons.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
extendTo: Public.Types.Geometry.parse(from.extendTo),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StVoronoilines {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StVoronoilines.Parameters.is(from)) {
  return {
g1: Public.Types.Geometry.parse(from.g1),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
extendTo: Public.Types.Geometry.parse(from.extendTo),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebbox_1ee2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebbox_1ee2.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebbox_9d67 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebbox_9d67.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box3d.parse(from.argument_0),
argument_1: Public.Types.Box3d.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCombinebbox_1a7e {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCombinebbox_1a7e.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollect_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollect_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCollectA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCollectA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfn_43cf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfn_7c68 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryAccumTransfn_0b93 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryCollectFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryMakelineFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelTransfn_43cf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelTransfn_7c68 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StUnionA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StUnionA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoverageunionA4b6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoverageunionA4b6.Parameters.is(from)) {
  return {
argument_0: Public.Types.GeometryArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelate_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelate_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelateAa17 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelateAa17.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StRelateCaf9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StRelateCaf9.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDisjoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDisjoint.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisIndexSupportfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisIndexSupportfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinecrossingdirection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinecrossingdirection.Parameters.is(from)) {
  return {
line1: Public.Types.Geometry.parse(from.line1),
line2: Public.Types.Geometry.parse(from.line2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithin_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithin_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StTouches {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StTouches.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersects_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersects_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCrosses {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCrosses.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StContains {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StContains.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StContainsproperly {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StContainsproperly.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCovers_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCovers_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredby_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredby_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOverlaps.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDfullywithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDfullywithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddwithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddwithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddfullywithin {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddfullywithin.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dintersects {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dintersects.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StOrderingequals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StOrderingequals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEquals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEquals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsvalid_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsvalid_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumclearance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumclearance.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMinimumclearanceline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMinimumclearanceline.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroid_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroid_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometricmedian {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometricmedian.Parameters.is(from)) {
  return {
g: Public.Types.Geometry.parse(from.g),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
maxIter: PgCatalog.Types.Int4.parse(from.maxIter),
failIfNotConverged: PgCatalog.Types.Bool.parse(from.failIfNotConverged),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointonsurface {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointonsurface.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIssimple {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIssimple.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIscollection {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIscollection.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Equals {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Equals.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgml_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgml_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGmltosqlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGmltosqlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGmltosql_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGmltosql_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromkml {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromkml.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfrommarc21 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfrommarc21.Parameters.is(from)) {
  return {
marc21xml: PgCatalog.Types.Text.parse(from.marc21xml),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsmarc21 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsmarc21.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
format: PgCatalog.Types.Text.parse(from.format),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojsonE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojsonE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojson_608f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojson_608f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Json.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeojson_3c9d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Jsonb.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisLibjsonVersion {
export namespace Results {
}
}
export namespace StLinefromencodedpolyline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromencodedpolyline.Parameters.is(from)) {
  return {
txtin: PgCatalog.Types.Text.parse(from.txtin),
nprecision: PgCatalog.Types.Int4.parse(from.nprecision),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsencodedpolyline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsencodedpolyline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
nprecision: PgCatalog.Types.Int4.parse(from.nprecision),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvgD341 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvgD341.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
rel: PgCatalog.Types.Int4.parse(from.rel),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlD341 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlD341.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgml_32a0 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgml_32a0.Parameters.is(from)) {
  return {
version: PgCatalog.Types.Int4.parse(from.version),
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskmlCce7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskmlCce7.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonD341 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonD341.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonF2c6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonF2c6.Parameters.is(from)) {
  return {
r: PgCatalog.Types.Record.parse(from.r),
geomColumn: PgCatalog.Types.Text.parse(from.geomColumn),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
prettyBool: PgCatalog.Types.Bool.parse(from.prettyBool),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Json {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Json.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Jsonb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Jsonb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_27f4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfnF57f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfn_92c1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
argument_4: PgCatalog.Types.Text.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtTransfnF5be.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Int4.parse(from.argument_3),
argument_4: PgCatalog.Types.Text.parse(from.argument_4),
argument_5: PgCatalog.Types.Text.parse(from.argument_5),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtCombinefn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtCombinefn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtSerialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtSerialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsmvtDeserialfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsmvtDeserialfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsmvtgeom {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsmvtgeom.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
bounds: Public.Types.Box2d.parse(from.bounds),
extent: PgCatalog.Types.Int4.parse(from.extent),
buffer: PgCatalog.Types.Int4.parse(from.buffer),
clipGeom: PgCatalog.Types.Bool.parse(from.clipGeom),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisLibprotobufVersion {
export namespace Results {
}
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsgeobufFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsgeobufFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Anyelement.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PgisAsflatgeobufFinalfn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFromflatgeobuftotable {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFromflatgeobuftotable.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Bytea.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFromflatgeobuf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFromflatgeobuf.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Anyelement.parse(from.argument_0),
argument_1: PgCatalog.Types.Bytea.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeohash_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeohash_6cbe.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxchars: PgCatalog.Types.Int4.parse(from.maxchars),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBox2dfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBox2dfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromgeohash {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromgeohash.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumpoints {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumpoints.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumgeometries {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumgeometries.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDimension {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDimension.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StExteriorring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StExteriorring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNuminteriorrings {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNuminteriorrings.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNuminteriorring {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNuminteriorring.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInteriorringn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInteriorringn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometrytype_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometrytype_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometrytype {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometrytype.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StNumpatches {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StNumpatches.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPatchn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPatchn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StStartpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StStartpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StEndpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StEndpoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsclosed {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsclosed.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIsempty {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIsempty.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_88bc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_88bc.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_6cbe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_6cbe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeometryfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeometryfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWkttosql {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWkttosql.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinestringfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinestringfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinestringfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolygonfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolygonfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolygonfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromtext_27e2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromtextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromtextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinefromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinefromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinestringfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinestringfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinestringfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygonfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyAnalyze {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyAnalyze.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipointfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultilinefromwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultilinefromwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMlinefromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMlinefromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMpolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolyfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolyfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMultipolyfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromwkbD8af {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromwkbD8af.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeomcollfromwkb_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StMaxdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StMaxdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpoint_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpoint_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestline_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestline_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLongestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLongestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSwapordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSwapordinates.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
ords: PgCatalog.Types.Cstring.parse(from.ords),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StFlipcoordinates {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StFlipcoordinates.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBdpolyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBdpolyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBdmpolyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBdmpolyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Unlockrows {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Unlockrows.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_28e9 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_28e9.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
argument_2: PgCatalog.Types.Bool.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_2d19 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_2d19.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Bytea_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Bytea_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstext_3181 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstext_3181.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace LockrowE9aa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.LockrowE9aa.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
argument_4: PgCatalog.Types.Timestamp.parse(from.argument_4),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_02b4 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_02b4.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Text.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Lockrow_9a8a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Lockrow_9a8a.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
argument_3: PgCatalog.Types.Timestamp.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Addauth {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Addauth.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauth_27e1 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Checkauth_27e1.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauth_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Checkauth_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Checkauthtrigger {
export namespace Results {
}
}
export namespace Gettransactionid {
export namespace Results {
}
}
export namespace Enablelongtransactions {
export namespace Results {
}
}
export namespace Longtransactionsenabled {
export namespace Results {
}
}
export namespace Disablelongtransactions {
export namespace Results {
}
}
export namespace GeographyTypmodIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyTypmodIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.CstringArray.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyTypmodOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyTypmodOut.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyIn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyIn.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Cstring.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyOut {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyOut.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyRecv {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyRecv.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Oid.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySend {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySend.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAstextE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAstextE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeographyfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeographyfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeogfromtext {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeogfromtext.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeogfromwkb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeogfromwkb.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodDims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodDims.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodSrid.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypmodType {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypmodType.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Int4.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geography_0cdb {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geography_0cdb.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometry_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometry_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistConsistent {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistConsistent.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistCompress {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistCompress.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistPenalty {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistPenalty.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistPicksplit {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistPicksplit.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistUnion {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistUnion.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Bytea.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistSame {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistSame.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2d.parse(from.argument_0),
argument_1: Public.Types.Box2d.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistDecompress {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistDecompress.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyOverlaps {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyOverlaps.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyDistanceKnn {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyDistanceKnn.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGistDistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGistDistance.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeog_52a8 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeog_52a8.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeog_25ba {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeog_25ba.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsGeog_8fd3 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsGeog_8fd3.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeogBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeogBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyLt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyLt.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyLe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyLe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGt {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGt.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyGe {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyGe.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyEq {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyEq.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographyCmp {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographyCmp.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvg_6ec5 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvg_6ec5.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
rel: PgCatalog.Types.Int4.parse(from.rel),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAssvgE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAssvgE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProjectD4ec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProjectD4ec.Parameters.is(from)) {
  return {
geogFrom: Public.Types.Geography.parse(from.geogFrom),
geogTo: Public.Types.Geography.parse(from.geogTo),
distance: PgCatalog.Types.Float8.parse(from.distance),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAzimuthE452 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAzimuthE452.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_49f7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_49f7.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlE888 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlE888.Parameters.is(from)) {
  return {
version: PgCatalog.Types.Int4.parse(from.version),
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgml_2160 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgml_2160.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
id: PgCatalog.Types.Text.parse(from.id),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskmlF40a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskmlF40a.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
nprefix: PgCatalog.Types.Text.parse(from.nprefix),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAskmlE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAskmlE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojson_6ec5 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojson_6ec5.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsgeojsonE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsgeojsonE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistance_8dcd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistance_8dcd.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistance_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistance_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAreaEcae {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAreaEcae.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAreaE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAreaE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthEcae {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthEcae.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLengthE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLengthE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StProjectEd46 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StProjectEd46.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
distance: PgCatalog.Types.Float8.parse(from.distance),
azimuth: PgCatalog.Types.Float8.parse(from.azimuth),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPerimeterEcae {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPerimeterEcae.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSegmentizeCadf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSegmentizeCadf.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxSegmentLength: PgCatalog.Types.Float8.parse(from.maxSegmentLength),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsbinary_734d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsbinary_734d.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewkt_3181 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewkt_3181.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsewktE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsewktE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geometrytype_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geometrytype_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSummary_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSummary_7902.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StGeohash_3181 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StGeohash_3181.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
maxchars: PgCatalog.Types.Int4.parse(from.maxchars),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSrid_7902 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSrid_7902.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSetsrid_3181 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSetsrid_3181.Parameters.is(from)) {
  return {
geog: Public.Types.Geography.parse(from.geog),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroidEcae {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroidEcae.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCentroidE728 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCentroidE728.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoversE452 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoversE452.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithin_55df {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithin_55df.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
tolerance: PgCatalog.Types.Float8.parse(from.tolerance),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredbyE452 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredbyE452.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectsE452 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectsE452.Parameters.is(from)) {
  return {
geog1: Public.Types.Geography.parse(from.geog1),
geog2: Public.Types.Geography.parse(from.geog2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferCadf {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferCadf.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_12e3 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_12e3.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Int4.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBuffer_3aaa {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBuffer_3aaa.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StBufferF7c6 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StBufferF7c6.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Text.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersectionE452 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersectionE452.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersection_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersection_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCovers_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCovers_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoveredby_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoveredby_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDwithinEfc0 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDwithinEfc0.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StIntersects_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StIntersects_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpoint_8dcd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpoint_8dcd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StClosestpoint_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StClosestpoint_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestline_8dcd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestline_8dcd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StShortestline_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StShortestline_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstringEd46 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstringEd46.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinesubstringE586 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinesubstringE586.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
argument_2: PgCatalog.Types.Float8.parse(from.argument_2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepoint_8dcd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepoint_8dcd.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: Public.Types.Geography.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinelocatepoint_2ec2.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Text.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoints_8796 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoints_8796.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
repeat: PgCatalog.Types.Bool.parse(from.repeat),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointsC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointsC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepoint_612b {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepoint_612b.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geography.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
useSpheroid: PgCatalog.Types.Bool.parse(from.useSpheroid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLineinterpolatepointC349 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLineinterpolatepointC349.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Text.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancesphere_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancesphere_3651.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StDistancesphere_6961 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StDistancesphere_6961.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
radius: PgCatalog.Types.Float8.parse(from.radius),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisTypeName {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisTypeName.Parameters.is(from)) {
  return {
geomname: PgCatalog.Types.Varchar.parse(from.geomname),
coordDimension: PgCatalog.Types.Int4.parse(from.coordDimension),
useNewName: PgCatalog.Types.Bool.parse(from.useNewName),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintSrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintSrid.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintDims {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintDims.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace PostgisConstraintType {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.PostgisConstraintType.Parameters.is(from)) {
  return {
geomschema: PgCatalog.Types.Text.parse(from.geomschema),
geomtable: PgCatalog.Types.Text.parse(from.geomtable),
geomcolumn: PgCatalog.Types.Text.parse(from.geomcolumn),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3ddistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3ddistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dmaxdistance {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dmaxdistance.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dclosestpoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dclosestpoint.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dshortestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dshortestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlongestline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlongestline.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCoorddim {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCoorddim.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StCurvetoline {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StCurvetoline.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
tol: PgCatalog.Types.Float8.parse(from.tol),
toltype: PgCatalog.Types.Int4.parse(from.toltype),
flags: PgCatalog.Types.Int4.parse(from.flags),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHasarc {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHasarc.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLinetocurve {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLinetocurve.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoint_0aec {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoint_0aec.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPoint_0b7f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPoint_0b7f.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Float8.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointz {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointz.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
zcoordinate: PgCatalog.Types.Float8.parse(from.zcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointm.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
mcoordinate: PgCatalog.Types.Float8.parse(from.mcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPointzm {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPointzm.Parameters.is(from)) {
  return {
xcoordinate: PgCatalog.Types.Float8.parse(from.xcoordinate),
ycoordinate: PgCatalog.Types.Float8.parse(from.ycoordinate),
zcoordinate: PgCatalog.Types.Float8.parse(from.zcoordinate),
mcoordinate: PgCatalog.Types.Float8.parse(from.mcoordinate),
srid: PgCatalog.Types.Int4.parse(from.srid),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StPolygon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StPolygon.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Int4.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StWkbtosql {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StWkbtosql.Parameters.is(from)) {
  return {
wkb: PgCatalog.Types.Bytea.parse(from.wkb),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatebetween {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatebetween.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
frommeasure: PgCatalog.Types.Float8.parse(from.frommeasure),
tomeasure: PgCatalog.Types.Float8.parse(from.tomeasure),
leftrightoffset: PgCatalog.Types.Float8.parse(from.leftrightoffset),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatealong {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatealong.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
measure: PgCatalog.Types.Float8.parse(from.measure),
leftrightoffset: PgCatalog.Types.Float8.parse(from.leftrightoffset),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLocatebetweenelevations {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLocatebetweenelevations.Parameters.is(from)) {
  return {
geometry: Public.Types.Geometry.parse(from.geometry),
fromelevation: PgCatalog.Types.Float8.parse(from.fromelevation),
toelevation: PgCatalog.Types.Float8.parse(from.toelevation),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StInterpolatepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StInterpolatepoint.Parameters.is(from)) {
  return {
line: Public.Types.Geometry.parse(from.line),
point: Public.Types.Geometry.parse(from.point),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHexagon {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHexagon.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
cellI: PgCatalog.Types.Int4.parse(from.cellI),
cellJ: PgCatalog.Types.Int4.parse(from.cellJ),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSquare {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSquare.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
cellI: PgCatalog.Types.Int4.parse(from.cellI),
cellJ: PgCatalog.Types.Int4.parse(from.cellJ),
origin: Public.Types.Geometry.parse(from.origin),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StHexagongrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StHexagongrid.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
bounds: Public.Types.Geometry.parse(from.bounds),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSquaregrid {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSquaregrid.Parameters.is(from)) {
  return {
size: PgCatalog.Types.Float8.parse(from.size),
bounds: Public.Types.Geometry.parse(from.bounds),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2d_3f2a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2d_3f2a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2d_3f2a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2d_3f2a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2d_3f2a {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2d_3f2a.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2d_4f71 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2d_4f71.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2d_4f71 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2d_4f71.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2d_4f71 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2d_4f71.Parameters.is(from)) {
  return {
argument_0: Public.Types.Box2df.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Contains_2d_7d4f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Contains_2d_7d4f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace IsContained_2d_7d4f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.IsContained_2d_7d4f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Overlaps_2d_7d4f {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Overlaps_2d_7d4f.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Box2df.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNd_6173 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNd_6173.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Geometry.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNd_25ba {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNd_25ba.Parameters.is(from)) {
  return {
argument_0: Public.Types.Gidx.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace OverlapsNd_40b7 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.OverlapsNd_40b7.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: Public.Types.Gidx.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom2dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom3dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.Geom4dBrinInclusionAddValue.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
argument_2: PgCatalog.Types.Internal.parse(from.argument_2),
argument_3: PgCatalog.Types.Internal.parse(from.argument_3),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StSimplifypolygonhull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StSimplifypolygonhull.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
vertexFraction: PgCatalog.Types.Float8.parse(from.vertexFraction),
isOuter: PgCatalog.Types.Bool.parse(from.isOuter),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StConcavehull {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StConcavehull.Parameters.is(from)) {
  return {
paramGeom: Public.Types.Geometry.parse(from.paramGeom),
paramPctconvex: PgCatalog.Types.Float8.parse(from.paramPctconvex),
paramAllowHoles: PgCatalog.Types.Bool.parse(from.paramAllowHoles),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAsx3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAsx3d.Parameters.is(from)) {
  return {
geom: Public.Types.Geometry.parse(from.geom),
maxdecimaldigits: PgCatalog.Types.Int4.parse(from.maxdecimaldigits),
options: PgCatalog.Types.Int4.parse(from.options),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StAngle_3651 {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StAngle_3651.Parameters.is(from)) {
  return {
line1: Public.Types.Geometry.parse(from.line1),
line2: Public.Types.Geometry.parse(from.line2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace St_3dlineinterpolatepoint {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.St_3dlineinterpolatepoint.Parameters.is(from)) {
  return {
argument_0: Public.Types.Geometry.parse(from.argument_0),
argument_1: PgCatalog.Types.Float8.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfig_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfig_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChoose_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChoose_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplit_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompress_2d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompress_2d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryOverlaps_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryOverlaps_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContains_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContains_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometryContained_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometryContained_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySame_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySame_3d.Parameters.is(from)) {
  return {
geom1: Public.Types.Geometry.parse(from.geom1),
geom2: Public.Types.Geometry.parse(from.geom2),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfig_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfig_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChoose_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChoose_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplit_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompress_3d {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompress_3d.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistConfigNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistConfigNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistChooseNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistChooseNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeometrySpgistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeometrySpgistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistConfigNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistConfigNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistChooseNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistChooseNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistPicksplitNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistPicksplitNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistInnerConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistLeafConsistentNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
argument_1: PgCatalog.Types.Internal.parse(from.argument_1),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace GeographySpgistCompressNd {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.GeographySpgistCompressNd.Parameters.is(from)) {
  return {
argument_0: PgCatalog.Types.Internal.parse(from.argument_0),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace StLetters {
export namespace Results {
}
export namespace Parameters {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (Public.Procedures.StLetters.Parameters.is(from)) {
  return {
letters: PgCatalog.Types.Text.parse(from.letters),
font: PgCatalog.Types.Json.parse(from.font),
};
}
throw new Error(JSON.stringify(from))
}


}
}
}
export namespace Tables {
export namespace SpatialRefSys {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycCensusBlocks {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycHomicides {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycNeighborhoods {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycStreets {
export namespace Results {
}
export namespace Create {
}
}
export namespace NycSubwayStations {
export namespace Results {
}
export namespace Create {
}
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_47570Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_47570Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_48328Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_48328Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_48334Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_48334Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1255Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1255Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1247Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1247Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2604Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2604Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2606Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2606Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2612Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2612Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2600Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2600Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2619Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2619Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3381Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3381Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3429Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3429Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2618Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2618Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2620Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2620Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3466Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3466Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2609Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2609Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_48340Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_48340Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2615Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2615Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1262Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1262Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2964Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2964Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1213Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1213Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1260Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1260Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2396Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2396Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3600Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3600Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3079Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3079Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_2328Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_2328Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1417Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1417Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_1418Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_1418Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3118Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3118Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3256Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3256Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6000Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6000Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_826Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_826Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3394Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3394Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3596Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3596Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3592Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3592Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3456Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3456Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6243Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6243Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_3350Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_3350Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6106Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6106Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_6100Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_6100Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_48346Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_48346Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_48352Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_48352Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13658Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13658Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13663Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13663Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13668Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13668Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
export namespace PgToast_13673Index {
export function parse(from: unknown) {
// CompositeType
if (from === null || from === undefined) return null;
if (PgToast.Types.PgToast_13673Index.is(from)) {
  return {
chunkId: PgCatalog.Types.Oid.parse(from.chunkId),
chunkSeq: PgCatalog.Types.Int4.parse(from.chunkSeq),
};
}
throw new Error(JSON.stringify(from))
}


}
}
export namespace Procedures {
}
export namespace Tables {
}
}
// begin table column parser mapping
export namespace PgCatalog {
export namespace Tables {
export namespace PgStatistic {
export namespace Starelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staattnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stainherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Stanullfrac {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Stawidth {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Stadistinct {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Stakind1 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind2 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind3 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind4 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Stakind5 {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Staop1 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop2 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop3 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop4 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Staop5 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll1 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll2 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll3 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll4 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stacoll5 {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stanumbers1 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers2 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers3 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers4 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stanumbers5 {
export const parse = PgCatalog.Types.Float4Array.parse;
}
export namespace Stavalues1 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues2 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues3 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues4 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
export namespace Stavalues5 {
export const parse = PgCatalog.Types.Anyarray.parse;
}
}
export namespace PgType {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Typnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typlen {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Typbyval {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typcategory {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typispreferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typisdefined {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typdelim {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typsubscript {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typelem {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typarray {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typinput {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typoutput {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typreceive {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typsend {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typmodin {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typmodout {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typanalyze {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Typalign {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typstorage {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Typnotnull {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Typbasetype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typtypmod {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Typndims {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Typcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Typdefaultbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Typdefault {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Typacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgForeignTable {
export namespace Ftrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Ftserver {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Ftoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgAuthid {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rolname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Rolsuper {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcreaterole {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcreatedb {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolcanlogin {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolreplication {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolbypassrls {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Rolconnlimit {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Rolpassword {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Rolvaliduntil {
export const parse = PgCatalog.Types.Timestamptz.parse;
}
}
export namespace PgStatisticExtData {
export namespace Stxoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxdinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Stxdndistinct {
export const parse = PgCatalog.Types.PgNdistinct.parse;
}
export namespace Stxddependencies {
export const parse = PgCatalog.Types.PgDependencies.parse;
}
export namespace Stxdmcv {
export const parse = PgCatalog.Types.PgMcvList.parse;
}
export namespace Stxdexpr {
export const parse = PgCatalog.Types.PgStatisticArray.parse;
}
}
export namespace PgUserMapping {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umuser {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umserver {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Umoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgSubscription {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subdbid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subskiplsn {
export const parse = PgCatalog.Types.PgLsn.parse;
}
export namespace Subname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Subowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Subenabled {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subbinary {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Substream {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Subtwophasestate {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Subdisableonerr {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subpasswordrequired {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subrunasowner {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Subconninfo {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Subslotname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Subsynccommit {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Subpublications {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Suborigin {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgAttribute {
export namespace Attrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Atttypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attlen {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attcacheoff {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Atttypmod {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Attndims {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attbyval {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attalign {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attstorage {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attcompression {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attnotnull {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Atthasdef {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Atthasmissing {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attidentity {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attgenerated {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Attisdropped {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attislocal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Attinhcount {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attstattarget {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Attcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Attacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Attoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Attfdwoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Attmissingval {
export const parse = PgCatalog.Types.Anyarray.parse;
}
}
export namespace PgProc {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Pronamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prolang {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Procost {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Prorows {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Provariadic {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prosupport {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prokind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Prosecdef {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proleakproof {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proisstrict {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Proretset {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Provolatile {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Proparallel {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Pronargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Pronargdefaults {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Prorettype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Proargtypes {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Proallargtypes {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Proargmodes {
export const parse = PgCatalog.Types.CharArray.parse;
}
export namespace Proargnames {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Proargdefaults {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Protrftypes {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Prosrc {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Probin {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Prosqlbody {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Proconfig {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Proacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgClass {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Relnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reltype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reloftype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relam {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relfilenode {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Reltablespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relpages {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Reltuples {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Relallvisible {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Reltoastrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relhasindex {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relisshared {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relpersistence {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Relchecks {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Relhasrules {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relhastriggers {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relhassubclass {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relrowsecurity {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relforcerowsecurity {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relispopulated {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relreplident {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Relispartition {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Relrewrite {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Relfrozenxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Relminmxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Relacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Reloptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
export namespace Relpartbound {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgAttrdef {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Adrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Adnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Adbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgConstraint {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Connamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Contype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Condeferrable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Condeferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Convalidated {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Conrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Contypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conindid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conparentid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Confrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Confupdtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Confdeltype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Confmatchtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Conislocal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Coninhcount {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Connoinherit {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Conkey {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Confkey {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Conpfeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conppeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conffeqop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Confdelsetcols {
export const parse = PgCatalog.Types.Int2Array.parse;
}
export namespace Conexclop {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Conbin {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgInherits {
export namespace Inhrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Inhparent {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Inhseqno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Inhdetachpending {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgIndex {
export namespace Indexrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Indrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Indnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Indnkeyatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Indisunique {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indnullsnotdistinct {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisprimary {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisexclusion {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indimmediate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisclustered {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisvalid {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indcheckxmin {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisready {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indislive {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indisreplident {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Indkey {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Indcollation {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Indclass {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Indoption {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Indexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Indpred {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgOperator {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Oprnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Oprcanmerge {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Oprcanhash {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Oprleft {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprright {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprresult {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprcom {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprnegate {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Oprcode {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Oprrest {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Oprjoin {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgOpfamily {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Opfnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opfowner {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgOpclass {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Opcnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcintype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Opcdefault {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Opckeytype {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgAm {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Amhandler {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Amtype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgAmop {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amoplefttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amoprighttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopstrategy {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Amoppurpose {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Amopopr {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopmethod {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amopsortfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgAmproc {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocfamily {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amproclefttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocrighttype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Amprocnum {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Amproc {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgLanguage {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Lanowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanispl {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Lanpltrusted {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Lanplcallfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Laninline {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanvalidator {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lanacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgLargeobjectMetadata {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lomowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Lomacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgAggregate {
export namespace Aggfnoid {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggkind {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggnumdirectargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Aggtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggfinalfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggcombinefn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggserialfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggdeserialfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggmtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggminvtransfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggmfinalfn {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Aggfinalextra {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Aggmfinalextra {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Aggfinalmodify {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggmfinalmodify {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Aggsortop {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggtranstype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggtransspace {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Aggmtranstype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Aggmtransspace {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Agginitval {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Aggminitval {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgStatisticExt {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Stxnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Stxstattarget {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Stxkeys {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Stxkind {
export const parse = PgCatalog.Types.CharArray.parse;
}
export namespace Stxexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgRewrite {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rulename {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace EvClass {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace EvType {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace EvEnabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace IsInstead {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace EvQual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace EvAction {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgTrigger {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgparentid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tgfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgtype {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Tgenabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Tgisinternal {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tgconstrrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgconstrindid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgconstraint {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tgdeferrable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tginitdeferred {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Tgnargs {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Tgattr {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Tgargs {
export const parse = PgCatalog.Types.Bytea.parse;
}
export namespace Tgqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Tgoldtable {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tgnewtable {
export const parse = PgCatalog.Types.Name.parse;
}
}
export namespace PgEventTrigger {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Evtevent {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Evtowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtfoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Evtenabled {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Evttags {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgDescription {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Description {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgCast {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castsource {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Casttarget {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castfunc {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Castcontext {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Castmethod {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgEnum {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Enumtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Enumsortorder {
export const parse = PgCatalog.Types.Float4.parse;
}
export namespace Enumlabel {
export const parse = PgCatalog.Types.Name.parse;
}
}
export namespace PgNamespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Nspname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Nspowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Nspacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgConversion {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Connamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Conforencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Contoencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Conproc {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Condefault {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgDepend {
export namespace Classid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Refclassid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Deptype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgDatabase {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Datname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Datdba {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Encoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Datlocprovider {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Datistemplate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Datallowconn {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Datconnlimit {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Datfrozenxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Datminmxid {
export const parse = PgCatalog.Types.Xid.parse;
}
export namespace Dattablespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Datcollate {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datctype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Daticulocale {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Daticurules {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datcollversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Datacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgDbRoleSetting {
export namespace Setdatabase {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Setrole {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Setconfig {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgTablespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Spcname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Spcowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Spcacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Spcoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgAuthMembers {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Roleid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Member {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Grantor {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace AdminOption {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace InheritOption {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace SetOption {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgShdepend {
export namespace Dbid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Refclassid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Refobjid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Deptype {
export const parse = PgCatalog.Types.Char.parse;
}
}
export namespace PgShdescription {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Description {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgTsConfig {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Cfgnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Cfgparser {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgTsConfigMap {
export namespace Mapcfg {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Maptokentype {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Mapseqno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Mapdict {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgTsDict {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Dictnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dicttemplate {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Dictinitoption {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgTsParser {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prsname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Prsnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prsstart {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prstoken {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prsend {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prsheadline {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Prslextype {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgTsTemplate {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tmplname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Tmplnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Tmplinit {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Tmpllexize {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgExtension {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Extowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Extrelocatable {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Extversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Extconfig {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Extcondition {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgForeignDataWrapper {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Fdwowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwhandler {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwvalidator {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Fdwacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Fdwoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgForeignServer {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Srvowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvfdw {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srvtype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Srvversion {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Srvacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
export namespace Srvoptions {
export const parse = PgCatalog.Types.TextArray.parse;
}
}
export namespace PgPolicy {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Polname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Polrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Polcmd {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Polpermissive {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Polroles {
export const parse = PgCatalog.Types.OidArray.parse;
}
export namespace Polqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Polwithcheck {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgReplicationOrigin {
export namespace Roident {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Roname {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgDefaultAcl {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclrole {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Defaclobjtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Defaclacl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgInitPrivs {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Privtype {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Initprivs {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgSeclabel {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Objsubid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Provider {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgShseclabel {
export namespace Objoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Classoid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Provider {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgCollation {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Collnamespace {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Collprovider {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Collisdeterministic {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Collencoding {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Collcollate {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collctype {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Colliculocale {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collicurules {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Collversion {
export const parse = PgCatalog.Types.Text.parse;
}
}
export namespace PgParameterAcl {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Parname {
export const parse = PgCatalog.Types.Text.parse;
}
export namespace Paracl {
export const parse = PgCatalog.Types.AclitemArray.parse;
}
}
export namespace PgPartitionedTable {
export namespace Partrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Partstrat {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Partnatts {
export const parse = PgCatalog.Types.Int2.parse;
}
export namespace Partdefid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Partattrs {
export const parse = PgCatalog.Types.Int2vector.parse;
}
export namespace Partclass {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Partcollation {
export const parse = PgCatalog.Types.Oidvector.parse;
}
export namespace Partexprs {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
}
export namespace PgRange {
export namespace Rngtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngsubtype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngmultitypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngcollation {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngsubopc {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Rngcanonical {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Rngsubdiff {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgTransform {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trftype {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trflang {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Trffromsql {
export const parse = PgCatalog.Types.Regproc.parse;
}
export namespace Trftosql {
export const parse = PgCatalog.Types.Regproc.parse;
}
}
export namespace PgSequence {
export namespace Seqrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Seqtypid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Seqstart {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqincrement {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqmax {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqmin {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqcache {
export const parse = PgCatalog.Types.Int8.parse;
}
export namespace Seqcycle {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgPublication {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pubname {
export const parse = PgCatalog.Types.Name.parse;
}
export namespace Pubowner {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Puballtables {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubinsert {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubupdate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubdelete {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubtruncate {
export const parse = PgCatalog.Types.Bool.parse;
}
export namespace Pubviaroot {
export const parse = PgCatalog.Types.Bool.parse;
}
}
export namespace PgPublicationNamespace {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pnpubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pnnspid {
export const parse = PgCatalog.Types.Oid.parse;
}
}
export namespace PgPublicationRel {
export namespace Oid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prpubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Prqual {
export const parse = PgCatalog.Types.PgNodeTree.parse;
}
export namespace Prattrs {
export const parse = PgCatalog.Types.Int2vector.parse;
}
}
export namespace PgSubscriptionRel {
export namespace Srsubid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srrelid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Srsubstate {
export const parse = PgCatalog.Types.Char.parse;
}
export namespace Srsublsn {
export const parse = PgCatalog.Types.PgLsn.parse;
}
}
export namespace PgLargeobject {
export namespace Loid {
export const parse = PgCatalog.Types.Oid.parse;
}
export namespace Pageno {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Data {
export const parse = PgCatalog.Types.Bytea.parse;
}
}
}
}
export namespace InformationSchema {
export namespace Tables {
export namespace SqlFeatures {
export namespace FeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace FeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SubFeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SubFeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IsSupported {
export const parse = InformationSchema.Types.YesOrNo.parse;
}
export namespace IsVerifiedBy {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlImplementationInfo {
export namespace ImplementationInfoId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace ImplementationInfoName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IntegerValue {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace CharacterValue {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlParts {
export namespace FeatureId {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace FeatureName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace IsSupported {
export const parse = InformationSchema.Types.YesOrNo.parse;
}
export namespace IsVerifiedBy {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
export namespace SqlSizing {
export namespace SizingId {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace SizingName {
export const parse = InformationSchema.Types.CharacterData.parse;
}
export namespace SupportedValue {
export const parse = InformationSchema.Types.CardinalNumber.parse;
}
export namespace Comments {
export const parse = InformationSchema.Types.CharacterData.parse;
}
}
}
}
export namespace Public {
export namespace Tables {
export namespace SpatialRefSys {
export namespace Srid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace AuthName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace AuthSrid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Srtext {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Proj4text {
export const parse = PgCatalog.Types.Varchar.parse;
}
}
export namespace NycCensusBlocks {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Blkid {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace PopnTotal {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnWhite {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnBlack {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnNativ {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnAsian {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace PopnOther {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycHomicides {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace IncidentD {
export const parse = PgCatalog.Types.Date.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace NumVictim {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace PrimaryMo {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Weapon {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace LightDark {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Year {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycNeighborhoods {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Boroname {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycStreets {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Float8.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Oneway {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Type {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
export namespace NycSubwayStations {
export namespace Gid {
export const parse = PgCatalog.Types.Int4.parse;
}
export namespace Objectid {
export const parse = PgCatalog.Types.Numeric.parse;
}
export namespace Id {
export const parse = PgCatalog.Types.Numeric.parse;
}
export namespace Name {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace AltName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace CrossSt {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace LongName {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Label {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Borough {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Nghbhd {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Routes {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Transfers {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Color {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Express {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Closed {
export const parse = PgCatalog.Types.Varchar.parse;
}
export namespace Geom {
export const parse = Public.Types.Geometry.parse;
}
}
}
}
export namespace PgToast {
export namespace Tables {
}
}

// begin primary key pickers
export namespace Public {
export namespace Tables {
export namespace SpatialRefSys {
export function primaryKeyFrom(value: Public.Types.SpatialRefSys) : string {
return JSON.stringify({
srid: value.srid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.SpatialRefSys>){
        return value.srid !== undefined
      }
      
}
export namespace NycCensusBlocks {
export function primaryKeyFrom(value: Public.Types.NycCensusBlocks) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycCensusBlocks>){
        return value.gid !== undefined
      }
      
}
export namespace NycHomicides {
export function primaryKeyFrom(value: Public.Types.NycHomicides) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycHomicides>){
        return value.gid !== undefined
      }
      
}
export namespace NycNeighborhoods {
export function primaryKeyFrom(value: Public.Types.NycNeighborhoods) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycNeighborhoods>){
        return value.gid !== undefined
      }
      
}
export namespace NycStreets {
export function primaryKeyFrom(value: Public.Types.NycStreets) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycStreets>){
        return value.gid !== undefined
      }
      
}
export namespace NycSubwayStations {
export function primaryKeyFrom(value: Public.Types.NycSubwayStations) : string {
return JSON.stringify({
gid: value.gid,
});
}

      export function includesPrimaryKey(value: Partial<Public.Types.NycSubwayStations>){
        return value.gid !== undefined
      }
      
}
}
}

export namespace PgCatalog {
export namespace Types {
export namespace PgType {
export function is(value: any) : value is PgCatalog.Types.PgType {
if (
(value.oid !== undefined) && (value.typname !== undefined) && (value.typnamespace !== undefined) && (value.typowner !== undefined) && (value.typlen !== undefined) && (value.typbyval !== undefined) && (value.typtype !== undefined) && (value.typcategory !== undefined) && (value.typispreferred !== undefined) && (value.typisdefined !== undefined) && (value.typdelim !== undefined) && (value.typrelid !== undefined) && (value.typsubscript !== undefined) && (value.typelem !== undefined) && (value.typarray !== undefined) && (value.typinput !== undefined) && (value.typoutput !== undefined) && (value.typreceive !== undefined) && (value.typsend !== undefined) && (value.typmodin !== undefined) && (value.typmodout !== undefined) && (value.typanalyze !== undefined) && (value.typalign !== undefined) && (value.typstorage !== undefined) && (value.typnotnull !== undefined) && (value.typbasetype !== undefined) && (value.typtypmod !== undefined) && (value.typndims !== undefined) && (value.typcollation !== undefined) && (value.typdefaultbin !== undefined) && (value.typdefault !== undefined) && (value.typacl !== undefined)
) return true;
return false;
}
}
export namespace PgAttribute {
export function is(value: any) : value is PgCatalog.Types.PgAttribute {
if (
(value.attrelid !== undefined) && (value.attname !== undefined) && (value.atttypid !== undefined) && (value.attlen !== undefined) && (value.attnum !== undefined) && (value.attcacheoff !== undefined) && (value.atttypmod !== undefined) && (value.attndims !== undefined) && (value.attbyval !== undefined) && (value.attalign !== undefined) && (value.attstorage !== undefined) && (value.attcompression !== undefined) && (value.attnotnull !== undefined) && (value.atthasdef !== undefined) && (value.atthasmissing !== undefined) && (value.attidentity !== undefined) && (value.attgenerated !== undefined) && (value.attisdropped !== undefined) && (value.attislocal !== undefined) && (value.attinhcount !== undefined) && (value.attstattarget !== undefined) && (value.attcollation !== undefined) && (value.attacl !== undefined) && (value.attoptions !== undefined) && (value.attfdwoptions !== undefined) && (value.attmissingval !== undefined)
) return true;
return false;
}
}
export namespace PgProc {
export function is(value: any) : value is PgCatalog.Types.PgProc {
if (
(value.oid !== undefined) && (value.proname !== undefined) && (value.pronamespace !== undefined) && (value.proowner !== undefined) && (value.prolang !== undefined) && (value.procost !== undefined) && (value.prorows !== undefined) && (value.provariadic !== undefined) && (value.prosupport !== undefined) && (value.prokind !== undefined) && (value.prosecdef !== undefined) && (value.proleakproof !== undefined) && (value.proisstrict !== undefined) && (value.proretset !== undefined) && (value.provolatile !== undefined) && (value.proparallel !== undefined) && (value.pronargs !== undefined) && (value.pronargdefaults !== undefined) && (value.prorettype !== undefined) && (value.proargtypes !== undefined) && (value.proallargtypes !== undefined) && (value.proargmodes !== undefined) && (value.proargnames !== undefined) && (value.proargdefaults !== undefined) && (value.protrftypes !== undefined) && (value.prosrc !== undefined) && (value.probin !== undefined) && (value.prosqlbody !== undefined) && (value.proconfig !== undefined) && (value.proacl !== undefined)
) return true;
return false;
}
}
export namespace PgClass {
export function is(value: any) : value is PgCatalog.Types.PgClass {
if (
(value.oid !== undefined) && (value.relname !== undefined) && (value.relnamespace !== undefined) && (value.reltype !== undefined) && (value.reloftype !== undefined) && (value.relowner !== undefined) && (value.relam !== undefined) && (value.relfilenode !== undefined) && (value.reltablespace !== undefined) && (value.relpages !== undefined) && (value.reltuples !== undefined) && (value.relallvisible !== undefined) && (value.reltoastrelid !== undefined) && (value.relhasindex !== undefined) && (value.relisshared !== undefined) && (value.relpersistence !== undefined) && (value.relkind !== undefined) && (value.relnatts !== undefined) && (value.relchecks !== undefined) && (value.relhasrules !== undefined) && (value.relhastriggers !== undefined) && (value.relhassubclass !== undefined) && (value.relrowsecurity !== undefined) && (value.relforcerowsecurity !== undefined) && (value.relispopulated !== undefined) && (value.relreplident !== undefined) && (value.relispartition !== undefined) && (value.relrewrite !== undefined) && (value.relfrozenxid !== undefined) && (value.relminmxid !== undefined) && (value.relacl !== undefined) && (value.reloptions !== undefined) && (value.relpartbound !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdef {
export function is(value: any) : value is PgCatalog.Types.PgAttrdef {
if (
(value.oid !== undefined) && (value.adrelid !== undefined) && (value.adnum !== undefined) && (value.adbin !== undefined)
) return true;
return false;
}
}
export namespace PgConstraint {
export function is(value: any) : value is PgCatalog.Types.PgConstraint {
if (
(value.oid !== undefined) && (value.conname !== undefined) && (value.connamespace !== undefined) && (value.contype !== undefined) && (value.condeferrable !== undefined) && (value.condeferred !== undefined) && (value.convalidated !== undefined) && (value.conrelid !== undefined) && (value.contypid !== undefined) && (value.conindid !== undefined) && (value.conparentid !== undefined) && (value.confrelid !== undefined) && (value.confupdtype !== undefined) && (value.confdeltype !== undefined) && (value.confmatchtype !== undefined) && (value.conislocal !== undefined) && (value.coninhcount !== undefined) && (value.connoinherit !== undefined) && (value.conkey !== undefined) && (value.confkey !== undefined) && (value.conpfeqop !== undefined) && (value.conppeqop !== undefined) && (value.conffeqop !== undefined) && (value.confdelsetcols !== undefined) && (value.conexclop !== undefined) && (value.conbin !== undefined)
) return true;
return false;
}
}
export namespace PgInherits {
export function is(value: any) : value is PgCatalog.Types.PgInherits {
if (
(value.inhrelid !== undefined) && (value.inhparent !== undefined) && (value.inhseqno !== undefined) && (value.inhdetachpending !== undefined)
) return true;
return false;
}
}
export namespace PgIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndex {
if (
(value.indexrelid !== undefined) && (value.indrelid !== undefined) && (value.indnatts !== undefined) && (value.indnkeyatts !== undefined) && (value.indisunique !== undefined) && (value.indnullsnotdistinct !== undefined) && (value.indisprimary !== undefined) && (value.indisexclusion !== undefined) && (value.indimmediate !== undefined) && (value.indisclustered !== undefined) && (value.indisvalid !== undefined) && (value.indcheckxmin !== undefined) && (value.indisready !== undefined) && (value.indislive !== undefined) && (value.indisreplident !== undefined) && (value.indkey !== undefined) && (value.indcollation !== undefined) && (value.indclass !== undefined) && (value.indoption !== undefined) && (value.indexprs !== undefined) && (value.indpred !== undefined)
) return true;
return false;
}
}
export namespace PgOperator {
export function is(value: any) : value is PgCatalog.Types.PgOperator {
if (
(value.oid !== undefined) && (value.oprname !== undefined) && (value.oprnamespace !== undefined) && (value.oprowner !== undefined) && (value.oprkind !== undefined) && (value.oprcanmerge !== undefined) && (value.oprcanhash !== undefined) && (value.oprleft !== undefined) && (value.oprright !== undefined) && (value.oprresult !== undefined) && (value.oprcom !== undefined) && (value.oprnegate !== undefined) && (value.oprcode !== undefined) && (value.oprrest !== undefined) && (value.oprjoin !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamily {
export function is(value: any) : value is PgCatalog.Types.PgOpfamily {
if (
(value.oid !== undefined) && (value.opfmethod !== undefined) && (value.opfname !== undefined) && (value.opfnamespace !== undefined) && (value.opfowner !== undefined)
) return true;
return false;
}
}
export namespace PgOpclass {
export function is(value: any) : value is PgCatalog.Types.PgOpclass {
if (
(value.oid !== undefined) && (value.opcmethod !== undefined) && (value.opcname !== undefined) && (value.opcnamespace !== undefined) && (value.opcowner !== undefined) && (value.opcfamily !== undefined) && (value.opcintype !== undefined) && (value.opcdefault !== undefined) && (value.opckeytype !== undefined)
) return true;
return false;
}
}
export namespace PgAm {
export function is(value: any) : value is PgCatalog.Types.PgAm {
if (
(value.oid !== undefined) && (value.amname !== undefined) && (value.amhandler !== undefined) && (value.amtype !== undefined)
) return true;
return false;
}
}
export namespace PgAmop {
export function is(value: any) : value is PgCatalog.Types.PgAmop {
if (
(value.oid !== undefined) && (value.amopfamily !== undefined) && (value.amoplefttype !== undefined) && (value.amoprighttype !== undefined) && (value.amopstrategy !== undefined) && (value.amoppurpose !== undefined) && (value.amopopr !== undefined) && (value.amopmethod !== undefined) && (value.amopsortfamily !== undefined)
) return true;
return false;
}
}
export namespace PgAmproc {
export function is(value: any) : value is PgCatalog.Types.PgAmproc {
if (
(value.oid !== undefined) && (value.amprocfamily !== undefined) && (value.amproclefttype !== undefined) && (value.amprocrighttype !== undefined) && (value.amprocnum !== undefined) && (value.amproc !== undefined)
) return true;
return false;
}
}
export namespace PgLanguage {
export function is(value: any) : value is PgCatalog.Types.PgLanguage {
if (
(value.oid !== undefined) && (value.lanname !== undefined) && (value.lanowner !== undefined) && (value.lanispl !== undefined) && (value.lanpltrusted !== undefined) && (value.lanplcallfoid !== undefined) && (value.laninline !== undefined) && (value.lanvalidator !== undefined) && (value.lanacl !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectMetadata {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectMetadata {
if (
(value.oid !== undefined) && (value.lomowner !== undefined) && (value.lomacl !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobject {
export function is(value: any) : value is PgCatalog.Types.PgLargeobject {
if (
(value.loid !== undefined) && (value.pageno !== undefined) && (value.data !== undefined)
) return true;
return false;
}
}
export namespace PgAggregate {
export function is(value: any) : value is PgCatalog.Types.PgAggregate {
if (
(value.aggfnoid !== undefined) && (value.aggkind !== undefined) && (value.aggnumdirectargs !== undefined) && (value.aggtransfn !== undefined) && (value.aggfinalfn !== undefined) && (value.aggcombinefn !== undefined) && (value.aggserialfn !== undefined) && (value.aggdeserialfn !== undefined) && (value.aggmtransfn !== undefined) && (value.aggminvtransfn !== undefined) && (value.aggmfinalfn !== undefined) && (value.aggfinalextra !== undefined) && (value.aggmfinalextra !== undefined) && (value.aggfinalmodify !== undefined) && (value.aggmfinalmodify !== undefined) && (value.aggsortop !== undefined) && (value.aggtranstype !== undefined) && (value.aggtransspace !== undefined) && (value.aggmtranstype !== undefined) && (value.aggmtransspace !== undefined) && (value.agginitval !== undefined) && (value.aggminitval !== undefined)
) return true;
return false;
}
}
export namespace PgStatistic {
export function is(value: any) : value is PgCatalog.Types.PgStatistic {
if (
(value.starelid !== undefined) && (value.staattnum !== undefined) && (value.stainherit !== undefined) && (value.stanullfrac !== undefined) && (value.stawidth !== undefined) && (value.stadistinct !== undefined) && (value.stakind1 !== undefined) && (value.stakind2 !== undefined) && (value.stakind3 !== undefined) && (value.stakind4 !== undefined) && (value.stakind5 !== undefined) && (value.staop1 !== undefined) && (value.staop2 !== undefined) && (value.staop3 !== undefined) && (value.staop4 !== undefined) && (value.staop5 !== undefined) && (value.stacoll1 !== undefined) && (value.stacoll2 !== undefined) && (value.stacoll3 !== undefined) && (value.stacoll4 !== undefined) && (value.stacoll5 !== undefined) && (value.stanumbers1 !== undefined) && (value.stanumbers2 !== undefined) && (value.stanumbers3 !== undefined) && (value.stanumbers4 !== undefined) && (value.stanumbers5 !== undefined) && (value.stavalues1 !== undefined) && (value.stavalues2 !== undefined) && (value.stavalues3 !== undefined) && (value.stavalues4 !== undefined) && (value.stavalues5 !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExt {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExt {
if (
(value.oid !== undefined) && (value.stxrelid !== undefined) && (value.stxname !== undefined) && (value.stxnamespace !== undefined) && (value.stxowner !== undefined) && (value.stxstattarget !== undefined) && (value.stxkeys !== undefined) && (value.stxkind !== undefined) && (value.stxexprs !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtData {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtData {
if (
(value.stxoid !== undefined) && (value.stxdinherit !== undefined) && (value.stxdndistinct !== undefined) && (value.stxddependencies !== undefined) && (value.stxdmcv !== undefined) && (value.stxdexpr !== undefined)
) return true;
return false;
}
}
export namespace PgRewrite {
export function is(value: any) : value is PgCatalog.Types.PgRewrite {
if (
(value.oid !== undefined) && (value.rulename !== undefined) && (value.evClass !== undefined) && (value.evType !== undefined) && (value.evEnabled !== undefined) && (value.isInstead !== undefined) && (value.evQual !== undefined) && (value.evAction !== undefined)
) return true;
return false;
}
}
export namespace PgTrigger {
export function is(value: any) : value is PgCatalog.Types.PgTrigger {
if (
(value.oid !== undefined) && (value.tgrelid !== undefined) && (value.tgparentid !== undefined) && (value.tgname !== undefined) && (value.tgfoid !== undefined) && (value.tgtype !== undefined) && (value.tgenabled !== undefined) && (value.tgisinternal !== undefined) && (value.tgconstrrelid !== undefined) && (value.tgconstrindid !== undefined) && (value.tgconstraint !== undefined) && (value.tgdeferrable !== undefined) && (value.tginitdeferred !== undefined) && (value.tgnargs !== undefined) && (value.tgattr !== undefined) && (value.tgargs !== undefined) && (value.tgqual !== undefined) && (value.tgoldtable !== undefined) && (value.tgnewtable !== undefined)
) return true;
return false;
}
}
export namespace PgEventTrigger {
export function is(value: any) : value is PgCatalog.Types.PgEventTrigger {
if (
(value.oid !== undefined) && (value.evtname !== undefined) && (value.evtevent !== undefined) && (value.evtowner !== undefined) && (value.evtfoid !== undefined) && (value.evtenabled !== undefined) && (value.evttags !== undefined)
) return true;
return false;
}
}
export namespace PgDescription {
export function is(value: any) : value is PgCatalog.Types.PgDescription {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.description !== undefined)
) return true;
return false;
}
}
export namespace PgCast {
export function is(value: any) : value is PgCatalog.Types.PgCast {
if (
(value.oid !== undefined) && (value.castsource !== undefined) && (value.casttarget !== undefined) && (value.castfunc !== undefined) && (value.castcontext !== undefined) && (value.castmethod !== undefined)
) return true;
return false;
}
}
export namespace PgEnum {
export function is(value: any) : value is PgCatalog.Types.PgEnum {
if (
(value.oid !== undefined) && (value.enumtypid !== undefined) && (value.enumsortorder !== undefined) && (value.enumlabel !== undefined)
) return true;
return false;
}
}
export namespace PgNamespace {
export function is(value: any) : value is PgCatalog.Types.PgNamespace {
if (
(value.oid !== undefined) && (value.nspname !== undefined) && (value.nspowner !== undefined) && (value.nspacl !== undefined)
) return true;
return false;
}
}
export namespace PgConversion {
export function is(value: any) : value is PgCatalog.Types.PgConversion {
if (
(value.oid !== undefined) && (value.conname !== undefined) && (value.connamespace !== undefined) && (value.conowner !== undefined) && (value.conforencoding !== undefined) && (value.contoencoding !== undefined) && (value.conproc !== undefined) && (value.condefault !== undefined)
) return true;
return false;
}
}
export namespace PgDepend {
export function is(value: any) : value is PgCatalog.Types.PgDepend {
if (
(value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.refobjsubid !== undefined) && (value.deptype !== undefined)
) return true;
return false;
}
}
export namespace PgDatabase {
export function is(value: any) : value is PgCatalog.Types.PgDatabase {
if (
(value.oid !== undefined) && (value.datname !== undefined) && (value.datdba !== undefined) && (value.encoding !== undefined) && (value.datlocprovider !== undefined) && (value.datistemplate !== undefined) && (value.datallowconn !== undefined) && (value.datconnlimit !== undefined) && (value.datfrozenxid !== undefined) && (value.datminmxid !== undefined) && (value.dattablespace !== undefined) && (value.datcollate !== undefined) && (value.datctype !== undefined) && (value.daticulocale !== undefined) && (value.daticurules !== undefined) && (value.datcollversion !== undefined) && (value.datacl !== undefined)
) return true;
return false;
}
}
export namespace PgDbRoleSetting {
export function is(value: any) : value is PgCatalog.Types.PgDbRoleSetting {
if (
(value.setdatabase !== undefined) && (value.setrole !== undefined) && (value.setconfig !== undefined)
) return true;
return false;
}
}
export namespace PgTablespace {
export function is(value: any) : value is PgCatalog.Types.PgTablespace {
if (
(value.oid !== undefined) && (value.spcname !== undefined) && (value.spcowner !== undefined) && (value.spcacl !== undefined) && (value.spcoptions !== undefined)
) return true;
return false;
}
}
export namespace PgAuthid {
export function is(value: any) : value is PgCatalog.Types.PgAuthid {
if (
(value.oid !== undefined) && (value.rolname !== undefined) && (value.rolsuper !== undefined) && (value.rolinherit !== undefined) && (value.rolcreaterole !== undefined) && (value.rolcreatedb !== undefined) && (value.rolcanlogin !== undefined) && (value.rolreplication !== undefined) && (value.rolbypassrls !== undefined) && (value.rolconnlimit !== undefined) && (value.rolpassword !== undefined) && (value.rolvaliduntil !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembers {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembers {
if (
(value.oid !== undefined) && (value.roleid !== undefined) && (value.member !== undefined) && (value.grantor !== undefined) && (value.adminOption !== undefined) && (value.inheritOption !== undefined) && (value.setOption !== undefined)
) return true;
return false;
}
}
export namespace PgShdepend {
export function is(value: any) : value is PgCatalog.Types.PgShdepend {
if (
(value.dbid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.deptype !== undefined)
) return true;
return false;
}
}
export namespace PgShdescription {
export function is(value: any) : value is PgCatalog.Types.PgShdescription {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.description !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfig {
export function is(value: any) : value is PgCatalog.Types.PgTsConfig {
if (
(value.oid !== undefined) && (value.cfgname !== undefined) && (value.cfgnamespace !== undefined) && (value.cfgowner !== undefined) && (value.cfgparser !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigMap {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigMap {
if (
(value.mapcfg !== undefined) && (value.maptokentype !== undefined) && (value.mapseqno !== undefined) && (value.mapdict !== undefined)
) return true;
return false;
}
}
export namespace PgTsDict {
export function is(value: any) : value is PgCatalog.Types.PgTsDict {
if (
(value.oid !== undefined) && (value.dictname !== undefined) && (value.dictnamespace !== undefined) && (value.dictowner !== undefined) && (value.dicttemplate !== undefined) && (value.dictinitoption !== undefined)
) return true;
return false;
}
}
export namespace PgTsParser {
export function is(value: any) : value is PgCatalog.Types.PgTsParser {
if (
(value.oid !== undefined) && (value.prsname !== undefined) && (value.prsnamespace !== undefined) && (value.prsstart !== undefined) && (value.prstoken !== undefined) && (value.prsend !== undefined) && (value.prsheadline !== undefined) && (value.prslextype !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplate {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplate {
if (
(value.oid !== undefined) && (value.tmplname !== undefined) && (value.tmplnamespace !== undefined) && (value.tmplinit !== undefined) && (value.tmpllexize !== undefined)
) return true;
return false;
}
}
export namespace PgExtension {
export function is(value: any) : value is PgCatalog.Types.PgExtension {
if (
(value.oid !== undefined) && (value.extname !== undefined) && (value.extowner !== undefined) && (value.extnamespace !== undefined) && (value.extrelocatable !== undefined) && (value.extversion !== undefined) && (value.extconfig !== undefined) && (value.extcondition !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapper {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapper {
if (
(value.oid !== undefined) && (value.fdwname !== undefined) && (value.fdwowner !== undefined) && (value.fdwhandler !== undefined) && (value.fdwvalidator !== undefined) && (value.fdwacl !== undefined) && (value.fdwoptions !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServer {
export function is(value: any) : value is PgCatalog.Types.PgForeignServer {
if (
(value.oid !== undefined) && (value.srvname !== undefined) && (value.srvowner !== undefined) && (value.srvfdw !== undefined) && (value.srvtype !== undefined) && (value.srvversion !== undefined) && (value.srvacl !== undefined) && (value.srvoptions !== undefined)
) return true;
return false;
}
}
export namespace PgUserMapping {
export function is(value: any) : value is PgCatalog.Types.PgUserMapping {
if (
(value.oid !== undefined) && (value.umuser !== undefined) && (value.umserver !== undefined) && (value.umoptions !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTable {
export function is(value: any) : value is PgCatalog.Types.PgForeignTable {
if (
(value.ftrelid !== undefined) && (value.ftserver !== undefined) && (value.ftoptions !== undefined)
) return true;
return false;
}
}
export namespace PgPolicy {
export function is(value: any) : value is PgCatalog.Types.PgPolicy {
if (
(value.oid !== undefined) && (value.polname !== undefined) && (value.polrelid !== undefined) && (value.polcmd !== undefined) && (value.polpermissive !== undefined) && (value.polroles !== undefined) && (value.polqual !== undefined) && (value.polwithcheck !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOrigin {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOrigin {
if (
(value.roident !== undefined) && (value.roname !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAcl {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAcl {
if (
(value.oid !== undefined) && (value.defaclrole !== undefined) && (value.defaclnamespace !== undefined) && (value.defaclobjtype !== undefined) && (value.defaclacl !== undefined)
) return true;
return false;
}
}
export namespace PgInitPrivs {
export function is(value: any) : value is PgCatalog.Types.PgInitPrivs {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.privtype !== undefined) && (value.initprivs !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabel {
export function is(value: any) : value is PgCatalog.Types.PgSeclabel {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgShseclabel {
export function is(value: any) : value is PgCatalog.Types.PgShseclabel {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgCollation {
export function is(value: any) : value is PgCatalog.Types.PgCollation {
if (
(value.oid !== undefined) && (value.collname !== undefined) && (value.collnamespace !== undefined) && (value.collowner !== undefined) && (value.collprovider !== undefined) && (value.collisdeterministic !== undefined) && (value.collencoding !== undefined) && (value.collcollate !== undefined) && (value.collctype !== undefined) && (value.colliculocale !== undefined) && (value.collicurules !== undefined) && (value.collversion !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAcl {
export function is(value: any) : value is PgCatalog.Types.PgParameterAcl {
if (
(value.oid !== undefined) && (value.parname !== undefined) && (value.paracl !== undefined)
) return true;
return false;
}
}
export namespace PgPartitionedTable {
export function is(value: any) : value is PgCatalog.Types.PgPartitionedTable {
if (
(value.partrelid !== undefined) && (value.partstrat !== undefined) && (value.partnatts !== undefined) && (value.partdefid !== undefined) && (value.partattrs !== undefined) && (value.partclass !== undefined) && (value.partcollation !== undefined) && (value.partexprs !== undefined)
) return true;
return false;
}
}
export namespace PgRange {
export function is(value: any) : value is PgCatalog.Types.PgRange {
if (
(value.rngtypid !== undefined) && (value.rngsubtype !== undefined) && (value.rngmultitypid !== undefined) && (value.rngcollation !== undefined) && (value.rngsubopc !== undefined) && (value.rngcanonical !== undefined) && (value.rngsubdiff !== undefined)
) return true;
return false;
}
}
export namespace PgTransform {
export function is(value: any) : value is PgCatalog.Types.PgTransform {
if (
(value.oid !== undefined) && (value.trftype !== undefined) && (value.trflang !== undefined) && (value.trffromsql !== undefined) && (value.trftosql !== undefined)
) return true;
return false;
}
}
export namespace PgSequence {
export function is(value: any) : value is PgCatalog.Types.PgSequence {
if (
(value.seqrelid !== undefined) && (value.seqtypid !== undefined) && (value.seqstart !== undefined) && (value.seqincrement !== undefined) && (value.seqmax !== undefined) && (value.seqmin !== undefined) && (value.seqcache !== undefined) && (value.seqcycle !== undefined)
) return true;
return false;
}
}
export namespace PgPublication {
export function is(value: any) : value is PgCatalog.Types.PgPublication {
if (
(value.oid !== undefined) && (value.pubname !== undefined) && (value.pubowner !== undefined) && (value.puballtables !== undefined) && (value.pubinsert !== undefined) && (value.pubupdate !== undefined) && (value.pubdelete !== undefined) && (value.pubtruncate !== undefined) && (value.pubviaroot !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespace {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespace {
if (
(value.oid !== undefined) && (value.pnpubid !== undefined) && (value.pnnspid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRel {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRel {
if (
(value.oid !== undefined) && (value.prpubid !== undefined) && (value.prrelid !== undefined) && (value.prqual !== undefined) && (value.prattrs !== undefined)
) return true;
return false;
}
}
export namespace PgSubscription {
export function is(value: any) : value is PgCatalog.Types.PgSubscription {
if (
(value.oid !== undefined) && (value.subdbid !== undefined) && (value.subskiplsn !== undefined) && (value.subname !== undefined) && (value.subowner !== undefined) && (value.subenabled !== undefined) && (value.subbinary !== undefined) && (value.substream !== undefined) && (value.subtwophasestate !== undefined) && (value.subdisableonerr !== undefined) && (value.subpasswordrequired !== undefined) && (value.subrunasowner !== undefined) && (value.subconninfo !== undefined) && (value.subslotname !== undefined) && (value.subsynccommit !== undefined) && (value.subpublications !== undefined) && (value.suborigin !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionRel {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionRel {
if (
(value.srsubid !== undefined) && (value.srrelid !== undefined) && (value.srsubstate !== undefined) && (value.srsublsn !== undefined)
) return true;
return false;
}
}
export namespace PgRoles {
export function is(value: any) : value is PgCatalog.Types.PgRoles {
if (
(value.rolname !== undefined) && (value.rolsuper !== undefined) && (value.rolinherit !== undefined) && (value.rolcreaterole !== undefined) && (value.rolcreatedb !== undefined) && (value.rolcanlogin !== undefined) && (value.rolreplication !== undefined) && (value.rolconnlimit !== undefined) && (value.rolpassword !== undefined) && (value.rolvaliduntil !== undefined) && (value.rolbypassrls !== undefined) && (value.rolconfig !== undefined) && (value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgShadow {
export function is(value: any) : value is PgCatalog.Types.PgShadow {
if (
(value.usename !== undefined) && (value.usesysid !== undefined) && (value.usecreatedb !== undefined) && (value.usesuper !== undefined) && (value.userepl !== undefined) && (value.usebypassrls !== undefined) && (value.passwd !== undefined) && (value.valuntil !== undefined) && (value.useconfig !== undefined)
) return true;
return false;
}
}
export namespace PgGroup {
export function is(value: any) : value is PgCatalog.Types.PgGroup {
if (
(value.groname !== undefined) && (value.grosysid !== undefined) && (value.grolist !== undefined)
) return true;
return false;
}
}
export namespace PgUser {
export function is(value: any) : value is PgCatalog.Types.PgUser {
if (
(value.usename !== undefined) && (value.usesysid !== undefined) && (value.usecreatedb !== undefined) && (value.usesuper !== undefined) && (value.userepl !== undefined) && (value.usebypassrls !== undefined) && (value.passwd !== undefined) && (value.valuntil !== undefined) && (value.useconfig !== undefined)
) return true;
return false;
}
}
export namespace PgPolicies {
export function is(value: any) : value is PgCatalog.Types.PgPolicies {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.policyname !== undefined) && (value.permissive !== undefined) && (value.roles !== undefined) && (value.cmd !== undefined) && (value.qual !== undefined) && (value.withCheck !== undefined)
) return true;
return false;
}
}
export namespace PgRules {
export function is(value: any) : value is PgCatalog.Types.PgRules {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.rulename !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgViews {
export function is(value: any) : value is PgCatalog.Types.PgViews {
if (
(value.schemaname !== undefined) && (value.viewname !== undefined) && (value.viewowner !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgTables {
export function is(value: any) : value is PgCatalog.Types.PgTables {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.tableowner !== undefined) && (value.tablespace !== undefined) && (value.hasindexes !== undefined) && (value.hasrules !== undefined) && (value.hastriggers !== undefined) && (value.rowsecurity !== undefined)
) return true;
return false;
}
}
export namespace PgMatviews {
export function is(value: any) : value is PgCatalog.Types.PgMatviews {
if (
(value.schemaname !== undefined) && (value.matviewname !== undefined) && (value.matviewowner !== undefined) && (value.tablespace !== undefined) && (value.hasindexes !== undefined) && (value.ispopulated !== undefined) && (value.definition !== undefined)
) return true;
return false;
}
}
export namespace PgIndexes {
export function is(value: any) : value is PgCatalog.Types.PgIndexes {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.indexname !== undefined) && (value.tablespace !== undefined) && (value.indexdef !== undefined)
) return true;
return false;
}
}
export namespace PgSequences {
export function is(value: any) : value is PgCatalog.Types.PgSequences {
if (
(value.schemaname !== undefined) && (value.sequencename !== undefined) && (value.sequenceowner !== undefined) && (value.dataType !== undefined) && (value.startValue !== undefined) && (value.minValue !== undefined) && (value.maxValue !== undefined) && (value.incrementBy !== undefined) && (value.cycle !== undefined) && (value.cacheSize !== undefined) && (value.lastValue !== undefined)
) return true;
return false;
}
}
export namespace PgStats {
export function is(value: any) : value is PgCatalog.Types.PgStats {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.attname !== undefined) && (value.inherited !== undefined) && (value.nullFrac !== undefined) && (value.avgWidth !== undefined) && (value.nDistinct !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonFreqs !== undefined) && (value.histogramBounds !== undefined) && (value.correlation !== undefined) && (value.mostCommonElems !== undefined) && (value.mostCommonElemFreqs !== undefined) && (value.elemCountHistogram !== undefined)
) return true;
return false;
}
}
export namespace PgStatsExt {
export function is(value: any) : value is PgCatalog.Types.PgStatsExt {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.statisticsSchemaname !== undefined) && (value.statisticsName !== undefined) && (value.statisticsOwner !== undefined) && (value.attnames !== undefined) && (value.exprs !== undefined) && (value.kinds !== undefined) && (value.inherited !== undefined) && (value.nDistinct !== undefined) && (value.dependencies !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonValNulls !== undefined) && (value.mostCommonFreqs !== undefined) && (value.mostCommonBaseFreqs !== undefined)
) return true;
return false;
}
}
export namespace PgStatsExtExprs {
export function is(value: any) : value is PgCatalog.Types.PgStatsExtExprs {
if (
(value.schemaname !== undefined) && (value.tablename !== undefined) && (value.statisticsSchemaname !== undefined) && (value.statisticsName !== undefined) && (value.statisticsOwner !== undefined) && (value.expr !== undefined) && (value.inherited !== undefined) && (value.nullFrac !== undefined) && (value.avgWidth !== undefined) && (value.nDistinct !== undefined) && (value.mostCommonVals !== undefined) && (value.mostCommonFreqs !== undefined) && (value.histogramBounds !== undefined) && (value.correlation !== undefined) && (value.mostCommonElems !== undefined) && (value.mostCommonElemFreqs !== undefined) && (value.elemCountHistogram !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationTables {
export function is(value: any) : value is PgCatalog.Types.PgPublicationTables {
if (
(value.pubname !== undefined) && (value.schemaname !== undefined) && (value.tablename !== undefined) && (value.attnames !== undefined) && (value.rowfilter !== undefined)
) return true;
return false;
}
}
export namespace PgLocks {
export function is(value: any) : value is PgCatalog.Types.PgLocks {
if (
(value.locktype !== undefined) && (value.database !== undefined) && (value.relation !== undefined) && (value.page !== undefined) && (value.tuple !== undefined) && (value.virtualxid !== undefined) && (value.transactionid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined) && (value.virtualtransaction !== undefined) && (value.pid !== undefined) && (value.mode !== undefined) && (value.granted !== undefined) && (value.fastpath !== undefined) && (value.waitstart !== undefined)
) return true;
return false;
}
}
export namespace PgCursors {
export function is(value: any) : value is PgCatalog.Types.PgCursors {
if (
(value.name !== undefined) && (value.statement !== undefined) && (value.isHoldable !== undefined) && (value.isBinary !== undefined) && (value.isScrollable !== undefined) && (value.creationTime !== undefined)
) return true;
return false;
}
}
export namespace PgAvailableExtensions {
export function is(value: any) : value is PgCatalog.Types.PgAvailableExtensions {
if (
(value.name !== undefined) && (value.defaultVersion !== undefined) && (value.installedVersion !== undefined) && (value.comment !== undefined)
) return true;
return false;
}
}
export namespace PgAvailableExtensionVersions {
export function is(value: any) : value is PgCatalog.Types.PgAvailableExtensionVersions {
if (
(value.name !== undefined) && (value.version !== undefined) && (value.installed !== undefined) && (value.superuser !== undefined) && (value.trusted !== undefined) && (value.relocatable !== undefined) && (value.schema !== undefined) && (value.requires !== undefined) && (value.comment !== undefined)
) return true;
return false;
}
}
export namespace PgPreparedXacts {
export function is(value: any) : value is PgCatalog.Types.PgPreparedXacts {
if (
(value.transaction !== undefined) && (value.gid !== undefined) && (value.prepared !== undefined) && (value.owner !== undefined) && (value.database !== undefined)
) return true;
return false;
}
}
export namespace PgPreparedStatements {
export function is(value: any) : value is PgCatalog.Types.PgPreparedStatements {
if (
(value.name !== undefined) && (value.statement !== undefined) && (value.prepareTime !== undefined) && (value.parameterTypes !== undefined) && (value.resultTypes !== undefined) && (value.fromSql !== undefined) && (value.genericPlans !== undefined) && (value.customPlans !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabels {
export function is(value: any) : value is PgCatalog.Types.PgSeclabels {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.objtype !== undefined) && (value.objnamespace !== undefined) && (value.objname !== undefined) && (value.provider !== undefined) && (value.label !== undefined)
) return true;
return false;
}
}
export namespace PgSettings {
export function is(value: any) : value is PgCatalog.Types.PgSettings {
if (
(value.name !== undefined) && (value.setting !== undefined) && (value.unit !== undefined) && (value.category !== undefined) && (value.shortDesc !== undefined) && (value.extraDesc !== undefined) && (value.context !== undefined) && (value.vartype !== undefined) && (value.source !== undefined) && (value.minVal !== undefined) && (value.maxVal !== undefined) && (value.enumvals !== undefined) && (value.bootVal !== undefined) && (value.resetVal !== undefined) && (value.sourcefile !== undefined) && (value.sourceline !== undefined) && (value.pendingRestart !== undefined)
) return true;
return false;
}
}
export namespace PgFileSettings {
export function is(value: any) : value is PgCatalog.Types.PgFileSettings {
if (
(value.sourcefile !== undefined) && (value.sourceline !== undefined) && (value.seqno !== undefined) && (value.name !== undefined) && (value.setting !== undefined) && (value.applied !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgHbaFileRules {
export function is(value: any) : value is PgCatalog.Types.PgHbaFileRules {
if (
(value.ruleNumber !== undefined) && (value.fileName !== undefined) && (value.lineNumber !== undefined) && (value.type !== undefined) && (value.database !== undefined) && (value.userName !== undefined) && (value.address !== undefined) && (value.netmask !== undefined) && (value.authMethod !== undefined) && (value.options !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgIdentFileMappings {
export function is(value: any) : value is PgCatalog.Types.PgIdentFileMappings {
if (
(value.mapNumber !== undefined) && (value.fileName !== undefined) && (value.lineNumber !== undefined) && (value.mapName !== undefined) && (value.sysName !== undefined) && (value.pgUsername !== undefined) && (value.error !== undefined)
) return true;
return false;
}
}
export namespace PgTimezoneAbbrevs {
export function is(value: any) : value is PgCatalog.Types.PgTimezoneAbbrevs {
if (
(value.abbrev !== undefined) && (value.utcOffset !== undefined) && (value.isDst !== undefined)
) return true;
return false;
}
}
export namespace PgTimezoneNames {
export function is(value: any) : value is PgCatalog.Types.PgTimezoneNames {
if (
(value.name !== undefined) && (value.abbrev !== undefined) && (value.utcOffset !== undefined) && (value.isDst !== undefined)
) return true;
return false;
}
}
export namespace PgConfig {
export function is(value: any) : value is PgCatalog.Types.PgConfig {
if (
(value.name !== undefined) && (value.setting !== undefined)
) return true;
return false;
}
}
export namespace PgShmemAllocations {
export function is(value: any) : value is PgCatalog.Types.PgShmemAllocations {
if (
(value.name !== undefined) && (value.off !== undefined) && (value.size !== undefined) && (value.allocatedSize !== undefined)
) return true;
return false;
}
}
export namespace PgBackendMemoryContexts {
export function is(value: any) : value is PgCatalog.Types.PgBackendMemoryContexts {
if (
(value.name !== undefined) && (value.ident !== undefined) && (value.parent !== undefined) && (value.level !== undefined) && (value.totalBytes !== undefined) && (value.totalNblocks !== undefined) && (value.freeBytes !== undefined) && (value.freeChunks !== undefined) && (value.usedBytes !== undefined)
) return true;
return false;
}
}
export namespace PgStatAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.lastSeqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined) && (value.nLiveTup !== undefined) && (value.nDeadTup !== undefined) && (value.nModSinceAnalyze !== undefined) && (value.nInsSinceVacuum !== undefined) && (value.lastVacuum !== undefined) && (value.lastAutovacuum !== undefined) && (value.lastAnalyze !== undefined) && (value.lastAutoanalyze !== undefined) && (value.vacuumCount !== undefined) && (value.autovacuumCount !== undefined) && (value.analyzeCount !== undefined) && (value.autoanalyzeCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatXactUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.seqScan !== undefined) && (value.seqTupRead !== undefined) && (value.idxScan !== undefined) && (value.idxTupFetch !== undefined) && (value.nTupIns !== undefined) && (value.nTupUpd !== undefined) && (value.nTupDel !== undefined) && (value.nTupHotUpd !== undefined) && (value.nTupNewpageUpd !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserTables {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserTables {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.heapBlksRead !== undefined) && (value.heapBlksHit !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined) && (value.toastBlksRead !== undefined) && (value.toastBlksHit !== undefined) && (value.tidxBlksRead !== undefined) && (value.tidxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatAllIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatAllIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatSysIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatSysIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatUserIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxScan !== undefined) && (value.lastIdxScan !== undefined) && (value.idxTupRead !== undefined) && (value.idxTupFetch !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserIndexes {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserIndexes {
if (
(value.relid !== undefined) && (value.indexrelid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.indexrelname !== undefined) && (value.idxBlksRead !== undefined) && (value.idxBlksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioAllSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioAllSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioSysSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioSysSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatioUserSequences {
export function is(value: any) : value is PgCatalog.Types.PgStatioUserSequences {
if (
(value.relid !== undefined) && (value.schemaname !== undefined) && (value.relname !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined)
) return true;
return false;
}
}
export namespace PgStatActivity {
export function is(value: any) : value is PgCatalog.Types.PgStatActivity {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.pid !== undefined) && (value.leaderPid !== undefined) && (value.usesysid !== undefined) && (value.usename !== undefined) && (value.applicationName !== undefined) && (value.clientAddr !== undefined) && (value.clientHostname !== undefined) && (value.clientPort !== undefined) && (value.backendStart !== undefined) && (value.xactStart !== undefined) && (value.queryStart !== undefined) && (value.stateChange !== undefined) && (value.waitEventType !== undefined) && (value.waitEvent !== undefined) && (value.state !== undefined) && (value.backendXid !== undefined) && (value.backendXmin !== undefined) && (value.queryId !== undefined) && (value.query !== undefined) && (value.backendType !== undefined)
) return true;
return false;
}
}
export namespace PgStatReplication {
export function is(value: any) : value is PgCatalog.Types.PgStatReplication {
if (
(value.pid !== undefined) && (value.usesysid !== undefined) && (value.usename !== undefined) && (value.applicationName !== undefined) && (value.clientAddr !== undefined) && (value.clientHostname !== undefined) && (value.clientPort !== undefined) && (value.backendStart !== undefined) && (value.backendXmin !== undefined) && (value.state !== undefined) && (value.sentLsn !== undefined) && (value.writeLsn !== undefined) && (value.flushLsn !== undefined) && (value.replayLsn !== undefined) && (value.writeLag !== undefined) && (value.flushLag !== undefined) && (value.replayLag !== undefined) && (value.syncPriority !== undefined) && (value.syncState !== undefined) && (value.replyTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatSlru {
export function is(value: any) : value is PgCatalog.Types.PgStatSlru {
if (
(value.name !== undefined) && (value.blksZeroed !== undefined) && (value.blksHit !== undefined) && (value.blksRead !== undefined) && (value.blksWritten !== undefined) && (value.blksExists !== undefined) && (value.flushes !== undefined) && (value.truncates !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatWalReceiver {
export function is(value: any) : value is PgCatalog.Types.PgStatWalReceiver {
if (
(value.pid !== undefined) && (value.status !== undefined) && (value.receiveStartLsn !== undefined) && (value.receiveStartTli !== undefined) && (value.writtenLsn !== undefined) && (value.flushedLsn !== undefined) && (value.receivedTli !== undefined) && (value.lastMsgSendTime !== undefined) && (value.lastMsgReceiptTime !== undefined) && (value.latestEndLsn !== undefined) && (value.latestEndTime !== undefined) && (value.slotName !== undefined) && (value.senderHost !== undefined) && (value.senderPort !== undefined) && (value.conninfo !== undefined)
) return true;
return false;
}
}
export namespace PgStatRecoveryPrefetch {
export function is(value: any) : value is PgCatalog.Types.PgStatRecoveryPrefetch {
if (
(value.statsReset !== undefined) && (value.prefetch !== undefined) && (value.hit !== undefined) && (value.skipInit !== undefined) && (value.skipNew !== undefined) && (value.skipFpw !== undefined) && (value.skipRep !== undefined) && (value.walDistance !== undefined) && (value.blockDistance !== undefined) && (value.ioDepth !== undefined)
) return true;
return false;
}
}
export namespace PgStatSubscription {
export function is(value: any) : value is PgCatalog.Types.PgStatSubscription {
if (
(value.subid !== undefined) && (value.subname !== undefined) && (value.pid !== undefined) && (value.leaderPid !== undefined) && (value.relid !== undefined) && (value.receivedLsn !== undefined) && (value.lastMsgSendTime !== undefined) && (value.lastMsgReceiptTime !== undefined) && (value.latestEndLsn !== undefined) && (value.latestEndTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatSsl {
export function is(value: any) : value is PgCatalog.Types.PgStatSsl {
if (
(value.pid !== undefined) && (value.ssl !== undefined) && (value.version !== undefined) && (value.cipher !== undefined) && (value.bits !== undefined) && (value.clientDn !== undefined) && (value.clientSerial !== undefined) && (value.issuerDn !== undefined)
) return true;
return false;
}
}
export namespace PgStatGssapi {
export function is(value: any) : value is PgCatalog.Types.PgStatGssapi {
if (
(value.pid !== undefined) && (value.gssAuthenticated !== undefined) && (value.principal !== undefined) && (value.encrypted !== undefined) && (value.credentialsDelegated !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationSlots {
export function is(value: any) : value is PgCatalog.Types.PgReplicationSlots {
if (
(value.slotName !== undefined) && (value.plugin !== undefined) && (value.slotType !== undefined) && (value.datoid !== undefined) && (value.database !== undefined) && (value.temporary !== undefined) && (value.active !== undefined) && (value.activePid !== undefined) && (value.xmin !== undefined) && (value.catalogXmin !== undefined) && (value.restartLsn !== undefined) && (value.confirmedFlushLsn !== undefined) && (value.walStatus !== undefined) && (value.safeWalSize !== undefined) && (value.twoPhase !== undefined) && (value.conflicting !== undefined)
) return true;
return false;
}
}
export namespace PgStatReplicationSlots {
export function is(value: any) : value is PgCatalog.Types.PgStatReplicationSlots {
if (
(value.slotName !== undefined) && (value.spillTxns !== undefined) && (value.spillCount !== undefined) && (value.spillBytes !== undefined) && (value.streamTxns !== undefined) && (value.streamCount !== undefined) && (value.streamBytes !== undefined) && (value.totalTxns !== undefined) && (value.totalBytes !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatDatabase {
export function is(value: any) : value is PgCatalog.Types.PgStatDatabase {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.numbackends !== undefined) && (value.xactCommit !== undefined) && (value.xactRollback !== undefined) && (value.blksRead !== undefined) && (value.blksHit !== undefined) && (value.tupReturned !== undefined) && (value.tupFetched !== undefined) && (value.tupInserted !== undefined) && (value.tupUpdated !== undefined) && (value.tupDeleted !== undefined) && (value.conflicts !== undefined) && (value.tempFiles !== undefined) && (value.tempBytes !== undefined) && (value.deadlocks !== undefined) && (value.checksumFailures !== undefined) && (value.checksumLastFailure !== undefined) && (value.blkReadTime !== undefined) && (value.blkWriteTime !== undefined) && (value.sessionTime !== undefined) && (value.activeTime !== undefined) && (value.idleInTransactionTime !== undefined) && (value.sessions !== undefined) && (value.sessionsAbandoned !== undefined) && (value.sessionsFatal !== undefined) && (value.sessionsKilled !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatDatabaseConflicts {
export function is(value: any) : value is PgCatalog.Types.PgStatDatabaseConflicts {
if (
(value.datid !== undefined) && (value.datname !== undefined) && (value.conflTablespace !== undefined) && (value.conflLock !== undefined) && (value.conflSnapshot !== undefined) && (value.conflBufferpin !== undefined) && (value.conflDeadlock !== undefined) && (value.conflActiveLogicalslot !== undefined)
) return true;
return false;
}
}
export namespace PgStatUserFunctions {
export function is(value: any) : value is PgCatalog.Types.PgStatUserFunctions {
if (
(value.funcid !== undefined) && (value.schemaname !== undefined) && (value.funcname !== undefined) && (value.calls !== undefined) && (value.totalTime !== undefined) && (value.selfTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatXactUserFunctions {
export function is(value: any) : value is PgCatalog.Types.PgStatXactUserFunctions {
if (
(value.funcid !== undefined) && (value.schemaname !== undefined) && (value.funcname !== undefined) && (value.calls !== undefined) && (value.totalTime !== undefined) && (value.selfTime !== undefined)
) return true;
return false;
}
}
export namespace PgStatArchiver {
export function is(value: any) : value is PgCatalog.Types.PgStatArchiver {
if (
(value.archivedCount !== undefined) && (value.lastArchivedWal !== undefined) && (value.lastArchivedTime !== undefined) && (value.failedCount !== undefined) && (value.lastFailedWal !== undefined) && (value.lastFailedTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatBgwriter {
export function is(value: any) : value is PgCatalog.Types.PgStatBgwriter {
if (
(value.checkpointsTimed !== undefined) && (value.checkpointsReq !== undefined) && (value.checkpointWriteTime !== undefined) && (value.checkpointSyncTime !== undefined) && (value.buffersCheckpoint !== undefined) && (value.buffersClean !== undefined) && (value.maxwrittenClean !== undefined) && (value.buffersBackend !== undefined) && (value.buffersBackendFsync !== undefined) && (value.buffersAlloc !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatIo {
export function is(value: any) : value is PgCatalog.Types.PgStatIo {
if (
(value.backendType !== undefined) && (value.object !== undefined) && (value.context !== undefined) && (value.reads !== undefined) && (value.readTime !== undefined) && (value.writes !== undefined) && (value.writeTime !== undefined) && (value.writebacks !== undefined) && (value.writebackTime !== undefined) && (value.extends !== undefined) && (value.extendTime !== undefined) && (value.opBytes !== undefined) && (value.hits !== undefined) && (value.evictions !== undefined) && (value.reuses !== undefined) && (value.fsyncs !== undefined) && (value.fsyncTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatWal {
export function is(value: any) : value is PgCatalog.Types.PgStatWal {
if (
(value.walRecords !== undefined) && (value.walFpi !== undefined) && (value.walBytes !== undefined) && (value.walBuffersFull !== undefined) && (value.walWrite !== undefined) && (value.walSync !== undefined) && (value.walWriteTime !== undefined) && (value.walSyncTime !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressAnalyze {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressAnalyze {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.phase !== undefined) && (value.sampleBlksTotal !== undefined) && (value.sampleBlksScanned !== undefined) && (value.extStatsTotal !== undefined) && (value.extStatsComputed !== undefined) && (value.childTablesTotal !== undefined) && (value.childTablesDone !== undefined) && (value.currentChildTableRelid !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressVacuum {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressVacuum {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.phase !== undefined) && (value.heapBlksTotal !== undefined) && (value.heapBlksScanned !== undefined) && (value.heapBlksVacuumed !== undefined) && (value.indexVacuumCount !== undefined) && (value.maxDeadTuples !== undefined) && (value.numDeadTuples !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCluster {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCluster {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.command !== undefined) && (value.phase !== undefined) && (value.clusterIndexRelid !== undefined) && (value.heapTuplesScanned !== undefined) && (value.heapTuplesWritten !== undefined) && (value.heapBlksTotal !== undefined) && (value.heapBlksScanned !== undefined) && (value.indexRebuildCount !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCreateIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCreateIndex {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.indexRelid !== undefined) && (value.command !== undefined) && (value.phase !== undefined) && (value.lockersTotal !== undefined) && (value.lockersDone !== undefined) && (value.currentLockerPid !== undefined) && (value.blocksTotal !== undefined) && (value.blocksDone !== undefined) && (value.tuplesTotal !== undefined) && (value.tuplesDone !== undefined) && (value.partitionsTotal !== undefined) && (value.partitionsDone !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressBasebackup {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressBasebackup {
if (
(value.pid !== undefined) && (value.phase !== undefined) && (value.backupTotal !== undefined) && (value.backupStreamed !== undefined) && (value.tablespacesTotal !== undefined) && (value.tablespacesStreamed !== undefined)
) return true;
return false;
}
}
export namespace PgStatProgressCopy {
export function is(value: any) : value is PgCatalog.Types.PgStatProgressCopy {
if (
(value.pid !== undefined) && (value.datid !== undefined) && (value.datname !== undefined) && (value.relid !== undefined) && (value.command !== undefined) && (value.type !== undefined) && (value.bytesProcessed !== undefined) && (value.bytesTotal !== undefined) && (value.tuplesProcessed !== undefined) && (value.tuplesExcluded !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappings {
export function is(value: any) : value is PgCatalog.Types.PgUserMappings {
if (
(value.umid !== undefined) && (value.srvid !== undefined) && (value.srvname !== undefined) && (value.umuser !== undefined) && (value.usename !== undefined) && (value.umoptions !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginStatus {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginStatus {
if (
(value.localId !== undefined) && (value.externalId !== undefined) && (value.remoteLsn !== undefined) && (value.localLsn !== undefined)
) return true;
return false;
}
}
export namespace PgStatSubscriptionStats {
export function is(value: any) : value is PgCatalog.Types.PgStatSubscriptionStats {
if (
(value.subid !== undefined) && (value.subname !== undefined) && (value.applyErrorCount !== undefined) && (value.syncErrorCount !== undefined) && (value.statsReset !== undefined)
) return true;
return false;
}
}
export namespace PgProcOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgProcOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgProcPronameArgsNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgProcPronameArgsNspIndex {
if (
(value.proname !== undefined) && (value.proargtypes !== undefined) && (value.pronamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTypeOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTypeOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTypeTypnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgTypeTypnameNspIndex {
if (
(value.typname !== undefined) && (value.typnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgAttributeRelidAttnamIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttributeRelidAttnamIndex {
if (
(value.attrelid !== undefined) && (value.attname !== undefined)
) return true;
return false;
}
}
export namespace PgAttributeRelidAttnumIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttributeRelidAttnumIndex {
if (
(value.attrelid !== undefined) && (value.attnum !== undefined)
) return true;
return false;
}
}
export namespace PgClassOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgClassRelnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassRelnameNspIndex {
if (
(value.relname !== undefined) && (value.relnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgClassTblspcRelfilenodeIndex {
export function is(value: any) : value is PgCatalog.Types.PgClassTblspcRelfilenodeIndex {
if (
(value.reltablespace !== undefined) && (value.relfilenode !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdefAdrelidAdnumIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttrdefAdrelidAdnumIndex {
if (
(value.adrelid !== undefined) && (value.adnum !== undefined)
) return true;
return false;
}
}
export namespace PgAttrdefOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAttrdefOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConnameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConnameNspIndex {
if (
(value.conname !== undefined) && (value.connamespace !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConrelidContypidConnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConrelidContypidConnameIndex {
if (
(value.conrelid !== undefined) && (value.contypid !== undefined) && (value.conname !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintContypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintContypidIndex {
if (
(value.contypid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConstraintConparentidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConstraintConparentidIndex {
if (
(value.conparentid !== undefined)
) return true;
return false;
}
}
export namespace PgInheritsRelidSeqnoIndex {
export function is(value: any) : value is PgCatalog.Types.PgInheritsRelidSeqnoIndex {
if (
(value.inhrelid !== undefined) && (value.inhseqno !== undefined)
) return true;
return false;
}
}
export namespace PgInheritsParentIndex {
export function is(value: any) : value is PgCatalog.Types.PgInheritsParentIndex {
if (
(value.inhparent !== undefined)
) return true;
return false;
}
}
export namespace PgIndexIndrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndexIndrelidIndex {
if (
(value.indrelid !== undefined)
) return true;
return false;
}
}
export namespace PgIndexIndexrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgIndexIndexrelidIndex {
if (
(value.indexrelid !== undefined)
) return true;
return false;
}
}
export namespace PgOperatorOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOperatorOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgOperatorOprnameLRNIndex {
export function is(value: any) : value is PgCatalog.Types.PgOperatorOprnameLRNIndex {
if (
(value.oprname !== undefined) && (value.oprleft !== undefined) && (value.oprright !== undefined) && (value.oprnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamilyAmNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpfamilyAmNameNspIndex {
if (
(value.opfmethod !== undefined) && (value.opfname !== undefined) && (value.opfnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpfamilyOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpfamilyOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgOpclassAmNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpclassAmNameNspIndex {
if (
(value.opcmethod !== undefined) && (value.opcname !== undefined) && (value.opcnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgOpclassOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgOpclassOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmNameIndex {
if (
(value.amname !== undefined)
) return true;
return false;
}
}
export namespace PgAmOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmopFamStratIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopFamStratIndex {
if (
(value.amopfamily !== undefined) && (value.amoplefttype !== undefined) && (value.amoprighttype !== undefined) && (value.amopstrategy !== undefined)
) return true;
return false;
}
}
export namespace PgAmopOprFamIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopOprFamIndex {
if (
(value.amopopr !== undefined) && (value.amoppurpose !== undefined) && (value.amopfamily !== undefined)
) return true;
return false;
}
}
export namespace PgAmopOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmopOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAmprocFamProcIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmprocFamProcIndex {
if (
(value.amprocfamily !== undefined) && (value.amproclefttype !== undefined) && (value.amprocrighttype !== undefined) && (value.amprocnum !== undefined)
) return true;
return false;
}
}
export namespace PgAmprocOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAmprocOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLanguageNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgLanguageNameIndex {
if (
(value.lanname !== undefined)
) return true;
return false;
}
}
export namespace PgLanguageOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgLanguageOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectMetadataOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectMetadataOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgLargeobjectLoidPnIndex {
export function is(value: any) : value is PgCatalog.Types.PgLargeobjectLoidPnIndex {
if (
(value.loid !== undefined) && (value.pageno !== undefined)
) return true;
return false;
}
}
export namespace PgAggregateFnoidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAggregateFnoidIndex {
if (
(value.aggfnoid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticRelidAttInhIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticRelidAttInhIndex {
if (
(value.starelid !== undefined) && (value.staattnum !== undefined) && (value.stainherit !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtNameIndex {
if (
(value.stxname !== undefined) && (value.stxnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtRelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtRelidIndex {
if (
(value.stxrelid !== undefined)
) return true;
return false;
}
}
export namespace PgStatisticExtDataStxoidInhIndex {
export function is(value: any) : value is PgCatalog.Types.PgStatisticExtDataStxoidInhIndex {
if (
(value.stxoid !== undefined) && (value.stxdinherit !== undefined)
) return true;
return false;
}
}
export namespace PgRewriteOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRewriteOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgRewriteRelRulenameIndex {
export function is(value: any) : value is PgCatalog.Types.PgRewriteRelRulenameIndex {
if (
(value.evClass !== undefined) && (value.rulename !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerTgconstraintIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerTgconstraintIndex {
if (
(value.tgconstraint !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerTgrelidTgnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerTgrelidTgnameIndex {
if (
(value.tgrelid !== undefined) && (value.tgname !== undefined)
) return true;
return false;
}
}
export namespace PgTriggerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTriggerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgEventTriggerEvtnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgEventTriggerEvtnameIndex {
if (
(value.evtname !== undefined)
) return true;
return false;
}
}
export namespace PgEventTriggerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgEventTriggerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDescriptionOCOIndex {
export function is(value: any) : value is PgCatalog.Types.PgDescriptionOCOIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgCastOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgCastOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgCastSourceTargetIndex {
export function is(value: any) : value is PgCatalog.Types.PgCastSourceTargetIndex {
if (
(value.castsource !== undefined) && (value.casttarget !== undefined)
) return true;
return false;
}
}
export namespace PgEnumOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgEnumTypidLabelIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumTypidLabelIndex {
if (
(value.enumtypid !== undefined) && (value.enumlabel !== undefined)
) return true;
return false;
}
}
export namespace PgEnumTypidSortorderIndex {
export function is(value: any) : value is PgCatalog.Types.PgEnumTypidSortorderIndex {
if (
(value.enumtypid !== undefined) && (value.enumsortorder !== undefined)
) return true;
return false;
}
}
export namespace PgNamespaceNspnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgNamespaceNspnameIndex {
if (
(value.nspname !== undefined)
) return true;
return false;
}
}
export namespace PgNamespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgNamespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConversionDefaultIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionDefaultIndex {
if (
(value.connamespace !== undefined) && (value.conforencoding !== undefined) && (value.contoencoding !== undefined) && (value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgConversionNameNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionNameNspIndex {
if (
(value.conname !== undefined) && (value.connamespace !== undefined)
) return true;
return false;
}
}
export namespace PgConversionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgConversionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDependDependerIndex {
export function is(value: any) : value is PgCatalog.Types.PgDependDependerIndex {
if (
(value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgDependReferenceIndex {
export function is(value: any) : value is PgCatalog.Types.PgDependReferenceIndex {
if (
(value.refclassid !== undefined) && (value.refobjid !== undefined) && (value.refobjsubid !== undefined)
) return true;
return false;
}
}
export namespace PgDatabaseDatnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgDatabaseDatnameIndex {
if (
(value.datname !== undefined)
) return true;
return false;
}
}
export namespace PgDatabaseOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgDatabaseOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgDbRoleSettingDatabaseidRolIndex {
export function is(value: any) : value is PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex {
if (
(value.setdatabase !== undefined) && (value.setrole !== undefined)
) return true;
return false;
}
}
export namespace PgTablespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTablespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTablespaceSpcnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTablespaceSpcnameIndex {
if (
(value.spcname !== undefined)
) return true;
return false;
}
}
export namespace PgAuthidRolnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthidRolnameIndex {
if (
(value.rolname !== undefined)
) return true;
return false;
}
}
export namespace PgAuthidOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthidOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersRoleMemberIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersRoleMemberIndex {
if (
(value.roleid !== undefined) && (value.member !== undefined) && (value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersMemberRoleIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersMemberRoleIndex {
if (
(value.member !== undefined) && (value.roleid !== undefined) && (value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgAuthMembersGrantorIndex {
export function is(value: any) : value is PgCatalog.Types.PgAuthMembersGrantorIndex {
if (
(value.grantor !== undefined)
) return true;
return false;
}
}
export namespace PgShdependDependerIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdependDependerIndex {
if (
(value.dbid !== undefined) && (value.classid !== undefined) && (value.objid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgShdependReferenceIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdependReferenceIndex {
if (
(value.refclassid !== undefined) && (value.refobjid !== undefined)
) return true;
return false;
}
}
export namespace PgShdescriptionOCIndex {
export function is(value: any) : value is PgCatalog.Types.PgShdescriptionOCIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigCfgnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigCfgnameIndex {
if (
(value.cfgname !== undefined) && (value.cfgnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsConfigMapIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsConfigMapIndex {
if (
(value.mapcfg !== undefined) && (value.maptokentype !== undefined) && (value.mapseqno !== undefined)
) return true;
return false;
}
}
export namespace PgTsDictDictnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsDictDictnameIndex {
if (
(value.dictname !== undefined) && (value.dictnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsDictOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsDictOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsParserPrsnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsParserPrsnameIndex {
if (
(value.prsname !== undefined) && (value.prsnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsParserOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsParserOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplateTmplnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplateTmplnameIndex {
if (
(value.tmplname !== undefined) && (value.tmplnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgTsTemplateOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTsTemplateOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgExtensionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgExtensionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgExtensionNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgExtensionNameIndex {
if (
(value.extname !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapperOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapperOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrapperNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignDataWrapperNameIndex {
if (
(value.fdwname !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServerOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignServerOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServerNameIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignServerNameIndex {
if (
(value.srvname !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappingOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgUserMappingOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappingUserServerIndex {
export function is(value: any) : value is PgCatalog.Types.PgUserMappingUserServerIndex {
if (
(value.umuser !== undefined) && (value.umserver !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTableRelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgForeignTableRelidIndex {
if (
(value.ftrelid !== undefined)
) return true;
return false;
}
}
export namespace PgPolicyOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPolicyOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPolicyPolrelidPolnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgPolicyPolrelidPolnameIndex {
if (
(value.polrelid !== undefined) && (value.polname !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginRoiidentIndex {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginRoiidentIndex {
if (
(value.roident !== undefined)
) return true;
return false;
}
}
export namespace PgReplicationOriginRonameIndex {
export function is(value: any) : value is PgCatalog.Types.PgReplicationOriginRonameIndex {
if (
(value.roname !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAclRoleNspObjIndex {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAclRoleNspObjIndex {
if (
(value.defaclrole !== undefined) && (value.defaclnamespace !== undefined) && (value.defaclobjtype !== undefined)
) return true;
return false;
}
}
export namespace PgDefaultAclOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgDefaultAclOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgInitPrivsOCOIndex {
export function is(value: any) : value is PgCatalog.Types.PgInitPrivsOCOIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined)
) return true;
return false;
}
}
export namespace PgSeclabelObjectIndex {
export function is(value: any) : value is PgCatalog.Types.PgSeclabelObjectIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.objsubid !== undefined) && (value.provider !== undefined)
) return true;
return false;
}
}
export namespace PgShseclabelObjectIndex {
export function is(value: any) : value is PgCatalog.Types.PgShseclabelObjectIndex {
if (
(value.objoid !== undefined) && (value.classoid !== undefined) && (value.provider !== undefined)
) return true;
return false;
}
}
export namespace PgCollationNameEncNspIndex {
export function is(value: any) : value is PgCatalog.Types.PgCollationNameEncNspIndex {
if (
(value.collname !== undefined) && (value.collencoding !== undefined) && (value.collnamespace !== undefined)
) return true;
return false;
}
}
export namespace PgCollationOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgCollationOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAclParnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgParameterAclParnameIndex {
if (
(value.parname !== undefined)
) return true;
return false;
}
}
export namespace PgParameterAclOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgParameterAclOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPartitionedTablePartrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPartitionedTablePartrelidIndex {
if (
(value.partrelid !== undefined)
) return true;
return false;
}
}
export namespace PgRangeRngtypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRangeRngtypidIndex {
if (
(value.rngtypid !== undefined)
) return true;
return false;
}
}
export namespace PgRangeRngmultitypidIndex {
export function is(value: any) : value is PgCatalog.Types.PgRangeRngmultitypidIndex {
if (
(value.rngmultitypid !== undefined)
) return true;
return false;
}
}
export namespace PgTransformOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgTransformOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgTransformTypeLangIndex {
export function is(value: any) : value is PgCatalog.Types.PgTransformTypeLangIndex {
if (
(value.trftype !== undefined) && (value.trflang !== undefined)
) return true;
return false;
}
}
export namespace PgSequenceSeqrelidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSequenceSeqrelidIndex {
if (
(value.seqrelid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationPubnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationPubnameIndex {
if (
(value.pubname !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespaceOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespaceOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex {
if (
(value.pnnspid !== undefined) && (value.pnpubid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelPrrelidPrpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex {
if (
(value.prrelid !== undefined) && (value.prpubid !== undefined)
) return true;
return false;
}
}
export namespace PgPublicationRelPrpubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgPublicationRelPrpubidIndex {
if (
(value.prpubid !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionOidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionOidIndex {
if (
(value.oid !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionSubnameIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionSubnameIndex {
if (
(value.subdbid !== undefined) && (value.subname !== undefined)
) return true;
return false;
}
}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
export function is(value: any) : value is PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex {
if (
(value.srrelid !== undefined) && (value.srsubid !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
}
export namespace PgType {
}
export namespace PgForeignTable {
}
export namespace PgAuthid {
}
export namespace PgStatisticExtData {
}
export namespace PgUserMapping {
}
export namespace PgSubscription {
}
export namespace PgAttribute {
}
export namespace PgProc {
}
export namespace PgClass {
}
export namespace PgAttrdef {
}
export namespace PgConstraint {
}
export namespace PgInherits {
}
export namespace PgIndex {
}
export namespace PgOperator {
}
export namespace PgOpfamily {
}
export namespace PgOpclass {
}
export namespace PgAm {
}
export namespace PgAmop {
}
export namespace PgAmproc {
}
export namespace PgLanguage {
}
export namespace PgLargeobjectMetadata {
}
export namespace PgAggregate {
}
export namespace PgStatisticExt {
}
export namespace PgRewrite {
}
export namespace PgTrigger {
}
export namespace PgEventTrigger {
}
export namespace PgDescription {
}
export namespace PgCast {
}
export namespace PgEnum {
}
export namespace PgNamespace {
}
export namespace PgConversion {
}
export namespace PgDepend {
}
export namespace PgDatabase {
}
export namespace PgDbRoleSetting {
}
export namespace PgTablespace {
}
export namespace PgAuthMembers {
}
export namespace PgShdepend {
}
export namespace PgShdescription {
}
export namespace PgTsConfig {
}
export namespace PgTsConfigMap {
}
export namespace PgTsDict {
}
export namespace PgTsParser {
}
export namespace PgTsTemplate {
}
export namespace PgExtension {
}
export namespace PgForeignDataWrapper {
}
export namespace PgForeignServer {
}
export namespace PgPolicy {
}
export namespace PgReplicationOrigin {
}
export namespace PgDefaultAcl {
}
export namespace PgInitPrivs {
}
export namespace PgSeclabel {
}
export namespace PgShseclabel {
}
export namespace PgCollation {
}
export namespace PgParameterAcl {
}
export namespace PgPartitionedTable {
}
export namespace PgRange {
}
export namespace PgTransform {
}
export namespace PgSequence {
}
export namespace PgPublication {
}
export namespace PgPublicationNamespace {
}
export namespace PgPublicationRel {
}
export namespace PgSubscriptionRel {
}
export namespace PgLargeobject {
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace InformationSchemaCatalogName {
export function is(value: any) : value is InformationSchema.Types.InformationSchemaCatalogName {
if (
(value.catalogName !== undefined)
) return true;
return false;
}
}
export namespace ApplicableRoles {
export function is(value: any) : value is InformationSchema.Types.ApplicableRoles {
if (
(value.grantee !== undefined) && (value.roleName !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace AdministrableRoleAuthorizations {
export function is(value: any) : value is InformationSchema.Types.AdministrableRoleAuthorizations {
if (
(value.grantee !== undefined) && (value.roleName !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace Attributes {
export function is(value: any) : value is InformationSchema.Types.Attributes {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.attributeName !== undefined) && (value.ordinalPosition !== undefined) && (value.attributeDefault !== undefined) && (value.isNullable !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.attributeUdtCatalog !== undefined) && (value.attributeUdtSchema !== undefined) && (value.attributeUdtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.isDerivedReferenceAttribute !== undefined)
) return true;
return false;
}
}
export namespace CharacterSets {
export function is(value: any) : value is InformationSchema.Types.CharacterSets {
if (
(value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.characterRepertoire !== undefined) && (value.formOfUse !== undefined) && (value.defaultCollateCatalog !== undefined) && (value.defaultCollateSchema !== undefined) && (value.defaultCollateName !== undefined)
) return true;
return false;
}
}
export namespace CheckConstraintRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.CheckConstraintRoutineUsage {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined)
) return true;
return false;
}
}
export namespace CheckConstraints {
export function is(value: any) : value is InformationSchema.Types.CheckConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.checkClause !== undefined)
) return true;
return false;
}
}
export namespace Collations {
export function is(value: any) : value is InformationSchema.Types.Collations {
if (
(value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.padAttribute !== undefined)
) return true;
return false;
}
}
export namespace CollationCharacterSetApplicability {
export function is(value: any) : value is InformationSchema.Types.CollationCharacterSetApplicability {
if (
(value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined)
) return true;
return false;
}
}
export namespace ColumnColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnColumnUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.dependentColumn !== undefined)
) return true;
return false;
}
}
export namespace ColumnDomainUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnDomainUsage {
if (
(value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace ColumnPrivileges {
export function is(value: any) : value is InformationSchema.Types.ColumnPrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace ColumnUdtUsage {
export function is(value: any) : value is InformationSchema.Types.ColumnUdtUsage {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace Columns {
export function is(value: any) : value is InformationSchema.Types.Columns {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.ordinalPosition !== undefined) && (value.columnDefault !== undefined) && (value.isNullable !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.isSelfReferencing !== undefined) && (value.isIdentity !== undefined) && (value.identityGeneration !== undefined) && (value.identityStart !== undefined) && (value.identityIncrement !== undefined) && (value.identityMaximum !== undefined) && (value.identityMinimum !== undefined) && (value.identityCycle !== undefined) && (value.isGenerated !== undefined) && (value.generationExpression !== undefined) && (value.isUpdatable !== undefined)
) return true;
return false;
}
}
export namespace ConstraintColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ConstraintColumnUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined)
) return true;
return false;
}
}
export namespace ConstraintTableUsage {
export function is(value: any) : value is InformationSchema.Types.ConstraintTableUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined)
) return true;
return false;
}
}
export namespace DomainConstraints {
export function is(value: any) : value is InformationSchema.Types.DomainConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.isDeferrable !== undefined) && (value.initiallyDeferred !== undefined)
) return true;
return false;
}
}
export namespace DomainUdtUsage {
export function is(value: any) : value is InformationSchema.Types.DomainUdtUsage {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined)
) return true;
return false;
}
}
export namespace Domains {
export function is(value: any) : value is InformationSchema.Types.Domains {
if (
(value.domainCatalog !== undefined) && (value.domainSchema !== undefined) && (value.domainName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.domainDefault !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace EnabledRoles {
export function is(value: any) : value is InformationSchema.Types.EnabledRoles {
if (
(value.roleName !== undefined)
) return true;
return false;
}
}
export namespace KeyColumnUsage {
export function is(value: any) : value is InformationSchema.Types.KeyColumnUsage {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.ordinalPosition !== undefined) && (value.positionInUniqueConstraint !== undefined)
) return true;
return false;
}
}
export namespace Parameters {
export function is(value: any) : value is InformationSchema.Types.Parameters {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.ordinalPosition !== undefined) && (value.parameterMode !== undefined) && (value.isResult !== undefined) && (value.asLocator !== undefined) && (value.parameterName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.parameterDefault !== undefined)
) return true;
return false;
}
}
export namespace ReferentialConstraints {
export function is(value: any) : value is InformationSchema.Types.ReferentialConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.uniqueConstraintCatalog !== undefined) && (value.uniqueConstraintSchema !== undefined) && (value.uniqueConstraintName !== undefined) && (value.matchOption !== undefined) && (value.updateRule !== undefined) && (value.deleteRule !== undefined)
) return true;
return false;
}
}
export namespace RoleColumnGrants {
export function is(value: any) : value is InformationSchema.Types.RoleColumnGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoutineColumnUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineColumnUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace RoutinePrivileges {
export function is(value: any) : value is InformationSchema.Types.RoutinePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleRoutineGrants {
export function is(value: any) : value is InformationSchema.Types.RoleRoutineGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoutineRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineRoutineUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined)
) return true;
return false;
}
}
export namespace RoutineSequenceUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineSequenceUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.sequenceCatalog !== undefined) && (value.sequenceSchema !== undefined) && (value.sequenceName !== undefined)
) return true;
return false;
}
}
export namespace RoutineTableUsage {
export function is(value: any) : value is InformationSchema.Types.RoutineTableUsage {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
export namespace Routines {
export function is(value: any) : value is InformationSchema.Types.Routines {
if (
(value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.routineCatalog !== undefined) && (value.routineSchema !== undefined) && (value.routineName !== undefined) && (value.routineType !== undefined) && (value.moduleCatalog !== undefined) && (value.moduleSchema !== undefined) && (value.moduleName !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.typeUdtCatalog !== undefined) && (value.typeUdtSchema !== undefined) && (value.typeUdtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined) && (value.routineBody !== undefined) && (value.routineDefinition !== undefined) && (value.externalName !== undefined) && (value.externalLanguage !== undefined) && (value.parameterStyle !== undefined) && (value.isDeterministic !== undefined) && (value.sqlDataAccess !== undefined) && (value.isNullCall !== undefined) && (value.sqlPath !== undefined) && (value.schemaLevelRoutine !== undefined) && (value.maxDynamicResultSets !== undefined) && (value.isUserDefinedCast !== undefined) && (value.isImplicitlyInvocable !== undefined) && (value.securityType !== undefined) && (value.toSqlSpecificCatalog !== undefined) && (value.toSqlSpecificSchema !== undefined) && (value.toSqlSpecificName !== undefined) && (value.asLocator !== undefined) && (value.created !== undefined) && (value.lastAltered !== undefined) && (value.newSavepointLevel !== undefined) && (value.isUdtDependent !== undefined) && (value.resultCastFromDataType !== undefined) && (value.resultCastAsLocator !== undefined) && (value.resultCastCharMaxLength !== undefined) && (value.resultCastCharOctetLength !== undefined) && (value.resultCastCharSetCatalog !== undefined) && (value.resultCastCharSetSchema !== undefined) && (value.resultCastCharSetName !== undefined) && (value.resultCastCollationCatalog !== undefined) && (value.resultCastCollationSchema !== undefined) && (value.resultCastCollationName !== undefined) && (value.resultCastNumericPrecision !== undefined) && (value.resultCastNumericPrecisionRadix !== undefined) && (value.resultCastNumericScale !== undefined) && (value.resultCastDatetimePrecision !== undefined) && (value.resultCastIntervalType !== undefined) && (value.resultCastIntervalPrecision !== undefined) && (value.resultCastTypeUdtCatalog !== undefined) && (value.resultCastTypeUdtSchema !== undefined) && (value.resultCastTypeUdtName !== undefined) && (value.resultCastScopeCatalog !== undefined) && (value.resultCastScopeSchema !== undefined) && (value.resultCastScopeName !== undefined) && (value.resultCastMaximumCardinality !== undefined) && (value.resultCastDtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace Schemata {
export function is(value: any) : value is InformationSchema.Types.Schemata {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.schemaOwner !== undefined) && (value.defaultCharacterSetCatalog !== undefined) && (value.defaultCharacterSetSchema !== undefined) && (value.defaultCharacterSetName !== undefined) && (value.sqlPath !== undefined)
) return true;
return false;
}
}
export namespace Sequences {
export function is(value: any) : value is InformationSchema.Types.Sequences {
if (
(value.sequenceCatalog !== undefined) && (value.sequenceSchema !== undefined) && (value.sequenceName !== undefined) && (value.dataType !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.startValue !== undefined) && (value.minimumValue !== undefined) && (value.maximumValue !== undefined) && (value.increment !== undefined) && (value.cycleOption !== undefined)
) return true;
return false;
}
}
export namespace SqlFeatures {
export function is(value: any) : value is InformationSchema.Types.SqlFeatures {
if (
(value.featureId !== undefined) && (value.featureName !== undefined) && (value.subFeatureId !== undefined) && (value.subFeatureName !== undefined) && (value.isSupported !== undefined) && (value.isVerifiedBy !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlImplementationInfo {
export function is(value: any) : value is InformationSchema.Types.SqlImplementationInfo {
if (
(value.implementationInfoId !== undefined) && (value.implementationInfoName !== undefined) && (value.integerValue !== undefined) && (value.characterValue !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlParts {
export function is(value: any) : value is InformationSchema.Types.SqlParts {
if (
(value.featureId !== undefined) && (value.featureName !== undefined) && (value.isSupported !== undefined) && (value.isVerifiedBy !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace SqlSizing {
export function is(value: any) : value is InformationSchema.Types.SqlSizing {
if (
(value.sizingId !== undefined) && (value.sizingName !== undefined) && (value.supportedValue !== undefined) && (value.comments !== undefined)
) return true;
return false;
}
}
export namespace TableConstraints {
export function is(value: any) : value is InformationSchema.Types.TableConstraints {
if (
(value.constraintCatalog !== undefined) && (value.constraintSchema !== undefined) && (value.constraintName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.constraintType !== undefined) && (value.isDeferrable !== undefined) && (value.initiallyDeferred !== undefined) && (value.enforced !== undefined) && (value.nullsDistinct !== undefined)
) return true;
return false;
}
}
export namespace TablePrivileges {
export function is(value: any) : value is InformationSchema.Types.TablePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined) && (value.withHierarchy !== undefined)
) return true;
return false;
}
}
export namespace RoleTableGrants {
export function is(value: any) : value is InformationSchema.Types.RoleTableGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined) && (value.withHierarchy !== undefined)
) return true;
return false;
}
}
export namespace Tables {
export function is(value: any) : value is InformationSchema.Types.Tables {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.tableType !== undefined) && (value.selfReferencingColumnName !== undefined) && (value.referenceGeneration !== undefined) && (value.userDefinedTypeCatalog !== undefined) && (value.userDefinedTypeSchema !== undefined) && (value.userDefinedTypeName !== undefined) && (value.isInsertableInto !== undefined) && (value.isTyped !== undefined) && (value.commitAction !== undefined)
) return true;
return false;
}
}
export namespace Transforms {
export function is(value: any) : value is InformationSchema.Types.Transforms {
if (
(value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined) && (value.groupName !== undefined) && (value.transformType !== undefined)
) return true;
return false;
}
}
export namespace TriggeredUpdateColumns {
export function is(value: any) : value is InformationSchema.Types.TriggeredUpdateColumns {
if (
(value.triggerCatalog !== undefined) && (value.triggerSchema !== undefined) && (value.triggerName !== undefined) && (value.eventObjectCatalog !== undefined) && (value.eventObjectSchema !== undefined) && (value.eventObjectTable !== undefined) && (value.eventObjectColumn !== undefined)
) return true;
return false;
}
}
export namespace Triggers {
export function is(value: any) : value is InformationSchema.Types.Triggers {
if (
(value.triggerCatalog !== undefined) && (value.triggerSchema !== undefined) && (value.triggerName !== undefined) && (value.eventManipulation !== undefined) && (value.eventObjectCatalog !== undefined) && (value.eventObjectSchema !== undefined) && (value.eventObjectTable !== undefined) && (value.actionOrder !== undefined) && (value.actionCondition !== undefined) && (value.actionStatement !== undefined) && (value.actionOrientation !== undefined) && (value.actionTiming !== undefined) && (value.actionReferenceOldTable !== undefined) && (value.actionReferenceNewTable !== undefined) && (value.actionReferenceOldRow !== undefined) && (value.actionReferenceNewRow !== undefined) && (value.created !== undefined)
) return true;
return false;
}
}
export namespace UdtPrivileges {
export function is(value: any) : value is InformationSchema.Types.UdtPrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleUdtGrants {
export function is(value: any) : value is InformationSchema.Types.RoleUdtGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace UsagePrivileges {
export function is(value: any) : value is InformationSchema.Types.UsagePrivileges {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace RoleUsageGrants {
export function is(value: any) : value is InformationSchema.Types.RoleUsageGrants {
if (
(value.grantor !== undefined) && (value.grantee !== undefined) && (value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.privilegeType !== undefined) && (value.isGrantable !== undefined)
) return true;
return false;
}
}
export namespace UserDefinedTypes {
export function is(value: any) : value is InformationSchema.Types.UserDefinedTypes {
if (
(value.userDefinedTypeCatalog !== undefined) && (value.userDefinedTypeSchema !== undefined) && (value.userDefinedTypeName !== undefined) && (value.userDefinedTypeCategory !== undefined) && (value.isInstantiable !== undefined) && (value.isFinal !== undefined) && (value.orderingForm !== undefined) && (value.orderingCategory !== undefined) && (value.orderingRoutineCatalog !== undefined) && (value.orderingRoutineSchema !== undefined) && (value.orderingRoutineName !== undefined) && (value.referenceType !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.sourceDtdIdentifier !== undefined) && (value.refDtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ViewColumnUsage {
export function is(value: any) : value is InformationSchema.Types.ViewColumnUsage {
if (
(value.viewCatalog !== undefined) && (value.viewSchema !== undefined) && (value.viewName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
export namespace ViewRoutineUsage {
export function is(value: any) : value is InformationSchema.Types.ViewRoutineUsage {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.specificCatalog !== undefined) && (value.specificSchema !== undefined) && (value.specificName !== undefined)
) return true;
return false;
}
}
export namespace ViewTableUsage {
export function is(value: any) : value is InformationSchema.Types.ViewTableUsage {
if (
(value.viewCatalog !== undefined) && (value.viewSchema !== undefined) && (value.viewName !== undefined) && (value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
export namespace Views {
export function is(value: any) : value is InformationSchema.Types.Views {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.viewDefinition !== undefined) && (value.checkOption !== undefined) && (value.isUpdatable !== undefined) && (value.isInsertableInto !== undefined) && (value.isTriggerUpdatable !== undefined) && (value.isTriggerDeletable !== undefined) && (value.isTriggerInsertableInto !== undefined)
) return true;
return false;
}
}
export namespace DataTypePrivileges {
export function is(value: any) : value is InformationSchema.Types.DataTypePrivileges {
if (
(value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ElementTypes {
export function is(value: any) : value is InformationSchema.Types.ElementTypes {
if (
(value.objectCatalog !== undefined) && (value.objectSchema !== undefined) && (value.objectName !== undefined) && (value.objectType !== undefined) && (value.collectionTypeIdentifier !== undefined) && (value.dataType !== undefined) && (value.characterMaximumLength !== undefined) && (value.characterOctetLength !== undefined) && (value.characterSetCatalog !== undefined) && (value.characterSetSchema !== undefined) && (value.characterSetName !== undefined) && (value.collationCatalog !== undefined) && (value.collationSchema !== undefined) && (value.collationName !== undefined) && (value.numericPrecision !== undefined) && (value.numericPrecisionRadix !== undefined) && (value.numericScale !== undefined) && (value.datetimePrecision !== undefined) && (value.intervalType !== undefined) && (value.intervalPrecision !== undefined) && (value.domainDefault !== undefined) && (value.udtCatalog !== undefined) && (value.udtSchema !== undefined) && (value.udtName !== undefined) && (value.scopeCatalog !== undefined) && (value.scopeSchema !== undefined) && (value.scopeName !== undefined) && (value.maximumCardinality !== undefined) && (value.dtdIdentifier !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTableColumns {
export function is(value: any) : value is InformationSchema.Types.PgForeignTableColumns {
if (
(value.nspname !== undefined) && (value.relname !== undefined) && (value.attname !== undefined) && (value.attfdwoptions !== undefined)
) return true;
return false;
}
}
export namespace ColumnOptions {
export function is(value: any) : value is InformationSchema.Types.ColumnOptions {
if (
(value.tableCatalog !== undefined) && (value.tableSchema !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace PgForeignDataWrappers {
export function is(value: any) : value is InformationSchema.Types.PgForeignDataWrappers {
if (
(value.oid !== undefined) && (value.fdwowner !== undefined) && (value.fdwoptions !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.authorizationIdentifier !== undefined) && (value.foreignDataWrapperLanguage !== undefined)
) return true;
return false;
}
}
export namespace ForeignDataWrapperOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignDataWrapperOptions {
if (
(value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignDataWrappers {
export function is(value: any) : value is InformationSchema.Types.ForeignDataWrappers {
if (
(value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.authorizationIdentifier !== undefined) && (value.libraryName !== undefined) && (value.foreignDataWrapperLanguage !== undefined)
) return true;
return false;
}
}
export namespace PgForeignServers {
export function is(value: any) : value is InformationSchema.Types.PgForeignServers {
if (
(value.oid !== undefined) && (value.srvoptions !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.foreignServerType !== undefined) && (value.foreignServerVersion !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ForeignServerOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignServerOptions {
if (
(value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignServers {
export function is(value: any) : value is InformationSchema.Types.ForeignServers {
if (
(value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.foreignDataWrapperCatalog !== undefined) && (value.foreignDataWrapperName !== undefined) && (value.foreignServerType !== undefined) && (value.foreignServerVersion !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace PgForeignTables {
export function is(value: any) : value is InformationSchema.Types.PgForeignTables {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.ftoptions !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.authorizationIdentifier !== undefined)
) return true;
return false;
}
}
export namespace ForeignTableOptions {
export function is(value: any) : value is InformationSchema.Types.ForeignTableOptions {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace ForeignTables {
export function is(value: any) : value is InformationSchema.Types.ForeignTables {
if (
(value.foreignTableCatalog !== undefined) && (value.foreignTableSchema !== undefined) && (value.foreignTableName !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined)
) return true;
return false;
}
}
export namespace PgUserMappings {
export function is(value: any) : value is InformationSchema.Types.PgUserMappings {
if (
(value.oid !== undefined) && (value.umoptions !== undefined) && (value.umuser !== undefined) && (value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.srvowner !== undefined)
) return true;
return false;
}
}
export namespace UserMappingOptions {
export function is(value: any) : value is InformationSchema.Types.UserMappingOptions {
if (
(value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined) && (value.optionName !== undefined) && (value.optionValue !== undefined)
) return true;
return false;
}
}
export namespace UserMappings {
export function is(value: any) : value is InformationSchema.Types.UserMappings {
if (
(value.authorizationIdentifier !== undefined) && (value.foreignServerCatalog !== undefined) && (value.foreignServerName !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
}
export namespace SqlImplementationInfo {
}
export namespace SqlParts {
}
export namespace SqlSizing {
}
}
}
export namespace Public {
export namespace Types {
export namespace GeometryDump {
export function is(value: any) : value is Public.Types.GeometryDump {
if (
(value.path !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace SpatialRefSys {
export function is(value: any) : value is Public.Types.SpatialRefSys {
if (
(value.srid !== undefined) && (value.authName !== undefined) && (value.authSrid !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined)
) return true;
return false;
}
}
export namespace ValidDetail {
export function is(value: any) : value is Public.Types.ValidDetail {
if (
(value.valid !== undefined) && (value.reason !== undefined) && (value.location !== undefined)
) return true;
return false;
}
}
export namespace GeographyColumns {
export function is(value: any) : value is Public.Types.GeographyColumns {
if (
(value.fTableCatalog !== undefined) && (value.fTableSchema !== undefined) && (value.fTableName !== undefined) && (value.fGeographyColumn !== undefined) && (value.coordDimension !== undefined) && (value.srid !== undefined) && (value.type !== undefined)
) return true;
return false;
}
}
export namespace GeometryColumns {
export function is(value: any) : value is Public.Types.GeometryColumns {
if (
(value.fTableCatalog !== undefined) && (value.fTableSchema !== undefined) && (value.fTableName !== undefined) && (value.fGeometryColumn !== undefined) && (value.coordDimension !== undefined) && (value.srid !== undefined) && (value.type !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocks {
export function is(value: any) : value is Public.Types.NycCensusBlocks {
if (
(value.gid !== undefined) && (value.blkid !== undefined) && (value.popnTotal !== undefined) && (value.popnWhite !== undefined) && (value.popnBlack !== undefined) && (value.popnNativ !== undefined) && (value.popnAsian !== undefined) && (value.popnOther !== undefined) && (value.boroname !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycHomicides {
export function is(value: any) : value is Public.Types.NycHomicides {
if (
(value.gid !== undefined) && (value.incidentD !== undefined) && (value.boroname !== undefined) && (value.numVictim !== undefined) && (value.primaryMo !== undefined) && (value.id !== undefined) && (value.weapon !== undefined) && (value.lightDark !== undefined) && (value.year !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoods {
export function is(value: any) : value is Public.Types.NycNeighborhoods {
if (
(value.gid !== undefined) && (value.boroname !== undefined) && (value.name !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycStreets {
export function is(value: any) : value is Public.Types.NycStreets {
if (
(value.gid !== undefined) && (value.id !== undefined) && (value.name !== undefined) && (value.oneway !== undefined) && (value.type !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStations {
export function is(value: any) : value is Public.Types.NycSubwayStations {
if (
(value.gid !== undefined) && (value.objectid !== undefined) && (value.id !== undefined) && (value.name !== undefined) && (value.altName !== undefined) && (value.crossSt !== undefined) && (value.longName !== undefined) && (value.label !== undefined) && (value.borough !== undefined) && (value.nghbhd !== undefined) && (value.routes !== undefined) && (value.transfers !== undefined) && (value.color !== undefined) && (value.express !== undefined) && (value.closed !== undefined) && (value.geom !== undefined)
) return true;
return false;
}
}
export namespace SpatialRefSysPkey {
export function is(value: any) : value is Public.Types.SpatialRefSysPkey {
if (
(value.srid !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocksPkey {
export function is(value: any) : value is Public.Types.NycCensusBlocksPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycHomicidesPkey {
export function is(value: any) : value is Public.Types.NycHomicidesPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoodsPkey {
export function is(value: any) : value is Public.Types.NycNeighborhoodsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycStreetsPkey {
export function is(value: any) : value is Public.Types.NycStreetsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStationsPkey {
export function is(value: any) : value is Public.Types.NycSubwayStationsPkey {
if (
(value.gid !== undefined)
) return true;
return false;
}
}
export namespace NycCensusBlocksGeomIdx {
export function is(value: any) : value is Public.Types.NycCensusBlocksGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycHomicidesGeomIdx {
export function is(value: any) : value is Public.Types.NycHomicidesGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycNeighborhoodsGeomIdx {
export function is(value: any) : value is Public.Types.NycNeighborhoodsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycStreetsGeomIdx {
export function is(value: any) : value is Public.Types.NycStreetsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace NycSubwayStationsGeomIdx {
export function is(value: any) : value is Public.Types.NycSubwayStationsGeomIdx {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrs {
export function is(value: any) : value is Public.Types.PostgisSrs {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrsAll {
export function is(value: any) : value is Public.Types.PostgisSrsAll {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace PostgisSrsSearch {
export function is(value: any) : value is Public.Types.PostgisSrsSearch {
if (
(value.authName !== undefined) && (value.authSrid !== undefined) && (value.srname !== undefined) && (value.srtext !== undefined) && (value.proj4text !== undefined) && (value.pointSw !== undefined) && (value.pointNe !== undefined)
) return true;
return false;
}
}
export namespace StMinimumboundingradius {
export function is(value: any) : value is Public.Types.StMinimumboundingradius {
if (
(value.center !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StMaximuminscribedcircle {
export function is(value: any) : value is Public.Types.StMaximuminscribedcircle {
if (
(value.center !== undefined) && (value.nearest !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StLargestemptycircle {
export function is(value: any) : value is Public.Types.StLargestemptycircle {
if (
(value.center !== undefined) && (value.nearest !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
export namespace StHexagongrid {
export function is(value: any) : value is Public.Types.StHexagongrid {
if (
(value.geom !== undefined) && (value.i !== undefined) && (value.j !== undefined)
) return true;
return false;
}
}
export namespace StSquaregrid {
export function is(value: any) : value is Public.Types.StSquaregrid {
if (
(value.geom !== undefined) && (value.i !== undefined) && (value.j !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcepolygoncw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace SpheroidIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.SpheroidIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace SpheroidOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.SpheroidOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryTypmodIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryTypmodIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryTypmodOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryTypmodOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryAnalyze {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryAnalyze.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryRecv {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryRecv.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySend.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_6564 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_6564.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_8997 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_8997.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Point {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Point.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryB0d8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryB0d8.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Path {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Path.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryF1be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryF1be.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Polygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Polygon.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StX {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StX.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StY {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StY.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZ {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZ.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StM {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StM.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dfIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dfIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2dfOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2dfOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GidxIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GidxIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GidxOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GidxOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLt.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLe.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGt.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGe.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryEq {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryEq.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryCmp {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryCmp.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySortsupport {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySortsupport.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryHash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryHash.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDistance_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDistance_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistCompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistCompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPenalty_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPenalty_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPicksplit_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPicksplit_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistUnion_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistUnion_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSame_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSame_2d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDecompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDecompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSortsupport_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSortsupport_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcerhr {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcerhr.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisNoop {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisNoop.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcepolygonccw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcepolygonccw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistSel_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistSel_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistSelNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistSelNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistJoinsel_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistJoinsel_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GserializedGistJoinselNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GserializedGistJoinselNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlaps.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySame {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySame.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCentroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCentroid.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceBox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceBox.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContains {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContains.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryWithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryWithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryLeft {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryLeft.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverleft {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverleft.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryBelow {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryBelow.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverbelow {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverbelow.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverright {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverright.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryRight {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryRight.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverabove {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverabove.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryAbove {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryAbove.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPenaltyNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPenaltyNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistUnionNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistUnionNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistSameNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistSameNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDecompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDecompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlapsNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlapsNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContainsNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContainsNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryWithinNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryWithinNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySameNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySameNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCentroidNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCentroidNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryDistanceCpa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryDistanceCpa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryGistDistanceNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryGistDistanceNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StShiftlongitude {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShiftlongitude.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StWrapx {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWrapx.Parameters {
if (
(value.geom !== undefined) && (value.wrap !== undefined) && (value.move !== undefined)
) return true;
return false;
}
}
}
export namespace StXmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StXmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StYmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StYmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZmin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmin.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StXmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StXmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StYmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StYmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StZmax {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmax.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_269a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_269a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_96e3 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_96e3.Parameters {
if (
(value.box !== undefined) && (value.dx !== undefined) && (value.dy !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisGetbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisGetbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakebox2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakebox2d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextentD2f5 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextentD2f5.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextent_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextent_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEstimatedextent_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEstimatedextent_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StFindextent_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFindextent_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFindextent_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFindextent_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisAddbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisAddbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisDropbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisDropbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisHasbbox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisHasbbox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StQuantizecoordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StQuantizecoordinates.Parameters {
if (
(value.g !== undefined) && (value.precX !== undefined) && (value.precY !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined)
) return true;
return false;
}
}
}
export namespace StMemsize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMemsize.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSummary_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSummary_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNpoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNrings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNrings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlength {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlength.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthspheroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthspheroid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLength2dspheroid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLength2dspheroid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dperimeter {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dperimeter.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeter2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeter2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeter_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeter_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StArea2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StArea2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StArea_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StArea_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIspolygoncw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIspolygoncw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIspolygonccw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIspolygonccw.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancespheroidCd56 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancespheroidCd56.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancespheroid_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancespheroid_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistance_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistance_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointinsidecircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointinsidecircle.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StAzimuth_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAzimuth_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StProjectD5eb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProjectD5eb.Parameters {
if (
(value.geom1 !== undefined) && (value.distance !== undefined) && (value.azimuth !== undefined)
) return true;
return false;
}
}
}
export namespace StProject_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProject_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.distance !== undefined)
) return true;
return false;
}
}
}
export namespace StAngleE1dd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAngleE1dd.Parameters {
if (
(value.pt1 !== undefined) && (value.pt2 !== undefined) && (value.pt3 !== undefined) && (value.pt4 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineextend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineextend.Parameters {
if (
(value.geom !== undefined) && (value.distanceForward !== undefined) && (value.distanceBackward !== undefined)
) return true;
return false;
}
}
}
export namespace StForce2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3dz {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3dz.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3d.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce3dm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce3dm.Parameters {
if (
(value.geom !== undefined) && (value.mvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForce4d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForce4d.Parameters {
if (
(value.geom !== undefined) && (value.zvalue !== undefined) && (value.mvalue !== undefined)
) return true;
return false;
}
}
}
export namespace StForcecollection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcecollection.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionextract_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionextract_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionextract_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionextract_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectionhomogenize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectionhomogenize.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMulti {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMulti.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcecurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcecurve.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcesfs_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcesfs_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StForcesfs_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StForcesfs_88bc.Parameters {
if (
(value.argument_0 !== undefined) && (value.version !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_2074 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_2074.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_704e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_704e.Parameters {
if (
(value.box !== undefined) && (value.dx !== undefined) && (value.dy !== undefined) && (value.dz !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StExpand_5500 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExpand_5500.Parameters {
if (
(value.geom !== undefined) && (value.dx !== undefined) && (value.dy !== undefined) && (value.dz !== undefined) && (value.dm !== undefined)
) return true;
return false;
}
}
}
export namespace StEnvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEnvelope.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBoundingdiagonal {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBoundingdiagonal.Parameters {
if (
(value.geom !== undefined) && (value.fits !== undefined)
) return true;
return false;
}
}
}
export namespace StReverse {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StReverse.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StScroll {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScroll.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisGeosNoop {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisGeosNoop.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNormalize {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNormalize.Parameters {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
}
export namespace StZmflag {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StZmflag.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNdims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNdims.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstwkb_652e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstwkb_652e.Parameters {
if (
(value.geom !== undefined) && (value.prec !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined) && (value.withSizes !== undefined) && (value.withBoxes !== undefined)
) return true;
return false;
}
}
}
export namespace StAstwkbF3fd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstwkbF3fd.Parameters {
if (
(value.geom !== undefined) && (value.ids !== undefined) && (value.prec !== undefined) && (value.precZ !== undefined) && (value.precM !== undefined) && (value.withSizes !== undefined) && (value.withBoxes !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkb_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkb_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAshexewkb_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAshexewkb_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAshexewkb_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAshexewkb_88bc.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkb_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkb_88bc.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAslatlontext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAslatlontext.Parameters {
if (
(value.geom !== undefined) && (value.tmpl !== undefined)
) return true;
return false;
}
}
}
export namespace Geomfromewkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geomfromewkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromewkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromewkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geomfromewkt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geomfromewkt.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromewkt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromewkt.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisCacheBbox {
}
export namespace StMakepoint_0aec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_0aec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepoint_81ec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_81ec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepoint_570b {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepoint_570b.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepointm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepointm.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dmakebox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dmakebox.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakelineA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakelineA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefrommultipoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefrommultipoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakeline_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakeline_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddpoint_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddpoint_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StScaleD5eb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScaleD5eb.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddpointAa17 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddpointAa17.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRemovepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRemovepoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSetpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetpoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakeenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakeenvelope.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StTileenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTileenvelope.Parameters {
if (
(value.zoom !== undefined) && (value.x !== undefined) && (value.y !== undefined) && (value.bounds !== undefined) && (value.margin !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepolygonE2e3 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepolygonE2e3.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakepolygon_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakepolygon_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuildarea {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuildarea.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonizeA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonizeA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StClusterintersectingA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClusterintersectingA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StClusterwithin_0e49 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClusterwithin_0e49.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinemerge_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinemerge_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinemerge_4ba2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinemerge_4ba2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAffineE42d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAffineE42d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined) && (value.argument_6 !== undefined) && (value.argument_7 !== undefined) && (value.argument_8 !== undefined) && (value.argument_9 !== undefined) && (value.argument_10 !== undefined) && (value.argument_11 !== undefined) && (value.argument_12 !== undefined)
) return true;
return false;
}
}
}
export namespace StAffine_1962 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAffine_1962.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined) && (value.argument_6 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotate_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotate_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotate_8b9f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotate_8b9f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotate_463e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotate_463e.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatez {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatez.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatex {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatex.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StRotatey {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRotatey.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StTranslate_8b9f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTranslate_8b9f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StTranslateD5eb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTranslateD5eb.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_3651.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_1bee {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_1bee.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StScale_8b9f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StScale_8b9f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StTransscale {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransscale.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StDump {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDump.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumprings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumprings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumppoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumppoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDumpsegments {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDumpsegments.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PopulateGeometryColumns_23fc.Parameters {
if (
(value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PopulateGeometryColumns_4174.Parameters {
if (
(value.tblOid !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_8fbb.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSridIn !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_4617 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_4617.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSrid !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Addgeometrycolumn_093c {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addgeometrycolumn_093c.Parameters {
if (
(value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSrid !== undefined) && (value.newType !== undefined) && (value.newDim !== undefined) && (value.useTypmod !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrycolumn_0412.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrycolumn_2253.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrycolumnF11a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrycolumnF11a.Parameters {
if (
(value.tableName !== undefined) && (value.columnName !== undefined)
) return true;
return false;
}
}
}
export namespace Dropgeometrytable_2253 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Dropgeometrytable_2253.Parameters {
if (
(value.catalogName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace StSegmentize_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSegmentize_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrytableF11a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrytableF11a.Parameters {
if (
(value.schemaName !== undefined) && (value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace DropgeometrytableBfde {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.DropgeometrytableBfde.Parameters {
if (
(value.tableName !== undefined)
) return true;
return false;
}
}
}
export namespace UpdategeometrysridB2ee {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.UpdategeometrysridB2ee.Parameters {
if (
(value.catalognName !== undefined) && (value.schemaName !== undefined) && (value.tableName !== undefined) && (value.columnName !== undefined) && (value.newSridIn !== undefined)
) return true;
return false;
}
}
}
export namespace Updategeometrysrid_7b58 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Updategeometrysrid_7b58.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Updategeometrysrid_11c8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Updategeometrysrid_11c8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace FindSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.FindSrid.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GetProj4FromSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GetProj4FromSrid.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSetsrid_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetsrid_6cbe.Parameters {
if (
(value.geom !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StSrid_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSrid_0cdb.Parameters {
if (
(value.geom !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTransformGeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTransformGeometry.Parameters {
if (
(value.geom !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrsCodes {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrsCodes.Parameters {
if (
(value.authName !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrs {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrs.Parameters {
if (
(value.authName !== undefined) && (value.authSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisSrsAll {
}
export namespace PostgisSrsSearch {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisSrsSearch.Parameters {
if (
(value.bounds !== undefined) && (value.authname !== undefined)
) return true;
return false;
}
}
}
export namespace StTransform_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransform_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StTransform_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransform_88bc.Parameters {
if (
(value.geom !== undefined) && (value.toProj !== undefined)
) return true;
return false;
}
}
}
export namespace StTransform_655c {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransform_655c.Parameters {
if (
(value.geom !== undefined) && (value.fromProj !== undefined) && (value.toProj !== undefined)
) return true;
return false;
}
}
}
export namespace StTransform_5016 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransform_5016.Parameters {
if (
(value.geom !== undefined) && (value.fromProj !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTransformPipelineGeometry.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.forward !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace StTransformpipeline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTransformpipeline.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace StInversetransformpipeline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInversetransformpipeline.Parameters {
if (
(value.geom !== undefined) && (value.pipeline !== undefined) && (value.toSrid !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisVersion {
}
export namespace PostgisLiblwgeomVersion {
}
export namespace PostgisProjVersion {
}
export namespace PostgisWagyuVersion {
}
export namespace PostgisScriptsInstalled {
}
export namespace PostgisLibVersion {
}
export namespace PostgisScriptsReleased {
}
export namespace PostgisGeosVersion {
}
export namespace PostgisGeosCompiledVersion {
}
export namespace PostgisLibRevision {
}
export namespace PostgisSvnVersion {
}
export namespace PostgisLibxmlVersion {
}
export namespace PostgisScriptsBuildDate {
}
export namespace PostgisLibBuildDate {
}
export namespace PostgisExtensionsUpgrade {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisExtensionsUpgrade.Parameters {
if (
(value.targetVersion !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoint_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoint_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoints_8fda {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoints_8fda.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.repeat !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstringD5eb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstringD5eb.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepoint_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepoint_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAddmeasure {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAddmeasure.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpointofapproach {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpointofapproach.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisFullVersion {
}
export namespace Box2d_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2d_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3d_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3d_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box2d_07e9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box2d_07e9.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dE505 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dE505.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box_07e9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box_07e9.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Text {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Text.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Box3dtobox {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Box3dtobox.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryE505 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryE505.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_07e9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_07e9.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Bytea_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Bytea_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplify_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplify_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplify_8fda {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplify_8fda.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifyvw {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifyvw.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSeteffectivearea {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSeteffectivearea.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFilterbym {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFilterbym.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StChaikinsmoothing {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StChaikinsmoothing.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogrid_5500 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogrid_5500.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogridD5eb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogridD5eb.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogrid_7163 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogrid_7163.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnaptogrid_7f2e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnaptogrid_7f2e.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancecpa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancecpa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCpawithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCpawithin.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidtrajectory {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidtrajectory.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersection_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersection_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferBf44 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferBf44.Parameters {
if (
(value.geom !== undefined) && (value.radius !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferC33e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferC33e.Parameters {
if (
(value.geom !== undefined) && (value.radius !== undefined) && (value.quadsegs !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumboundingradius {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumboundingradius.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumboundingcircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumboundingcircle.Parameters {
if (
(value.inputgeom !== undefined) && (value.segsPerQuarter !== undefined)
) return true;
return false;
}
}
}
export namespace StOrientedenvelope {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOrientedenvelope.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StOffsetcurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOffsetcurve.Parameters {
if (
(value.line !== undefined) && (value.distance !== undefined) && (value.params !== undefined)
) return true;
return false;
}
}
}
export namespace StGeneratepoints_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeneratepoints_6cbe.Parameters {
if (
(value.area !== undefined) && (value.npoints !== undefined)
) return true;
return false;
}
}
}
export namespace StGeneratepointsD341 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeneratepointsD341.Parameters {
if (
(value.area !== undefined) && (value.npoints !== undefined) && (value.seed !== undefined)
) return true;
return false;
}
}
}
export namespace StConvexhull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StConvexhull.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifypreservetopology {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifypreservetopology.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidreason_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidreason_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvaliddetail {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvaliddetail.Parameters {
if (
(value.geom !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalidreason_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalidreason_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalid_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalid_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StHausdorffdistance_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHausdorffdistance_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StHausdorffdistance_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHausdorffdistance_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFrechetdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFrechetdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StMaximuminscribedcircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMaximuminscribedcircle.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLargestemptycircle {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLargestemptycircle.Parameters {
if (
(value.geom !== undefined) && (value.tolerance !== undefined) && (value.boundary !== undefined)
) return true;
return false;
}
}
}
export namespace StDifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StBoundary {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBoundary.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSymdifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSymdifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StSymmetricdifference {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSymmetricdifference.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnion_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnion_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnion_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnion_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StUnaryunion {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnaryunion.Parameters {
if (
(value.argument_0 !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StRemoverepeatedpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRemoverepeatedpoints.Parameters {
if (
(value.geom !== undefined) && (value.tolerance !== undefined)
) return true;
return false;
}
}
}
export namespace StClipbybox2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClipbybox2d.Parameters {
if (
(value.geom !== undefined) && (value.box !== undefined)
) return true;
return false;
}
}
}
export namespace StSubdivide {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSubdivide.Parameters {
if (
(value.geom !== undefined) && (value.maxvertices !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StReduceprecision {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StReduceprecision.Parameters {
if (
(value.geom !== undefined) && (value.gridsize !== undefined)
) return true;
return false;
}
}
}
export namespace StMakevalid_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakevalid_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMakevalid_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMakevalid_88bc.Parameters {
if (
(value.geom !== undefined) && (value.params !== undefined)
) return true;
return false;
}
}
}
export namespace StCleangeometry {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCleangeometry.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSplit {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSplit.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSharedpaths {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSharedpaths.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSnap {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSnap.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelatematch {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelatematch.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNode {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNode.Parameters {
if (
(value.g !== undefined)
) return true;
return false;
}
}
}
export namespace StDelaunaytriangles {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDelaunaytriangles.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StTriangulatepolygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTriangulatepolygon.Parameters {
if (
(value.g1 !== undefined)
) return true;
return false;
}
}
}
export namespace StVoronoipolygons {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StVoronoipolygons.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.extendTo !== undefined)
) return true;
return false;
}
}
}
export namespace StVoronoilines {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StVoronoilines.Parameters {
if (
(value.g1 !== undefined) && (value.tolerance !== undefined) && (value.extendTo !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebbox_1ee2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebbox_1ee2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebbox_9d67 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebbox_9d67.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCombinebbox_1a7e {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCombinebbox_1a7e.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollect_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollect_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCollectA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCollectA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfn_43cf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfn_7c68 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryAccumTransfn_0b93 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryCollectFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryMakelineFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelTransfn_43cf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelTransfn_7c68 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StUnionA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StUnionA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoverageunionA4b6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoverageunionA4b6.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelate_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelate_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelateAa17 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelateAa17.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StRelateCaf9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StRelateCaf9.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDisjoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDisjoint.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisIndexSupportfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisIndexSupportfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinecrossingdirection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinecrossingdirection.Parameters {
if (
(value.line1 !== undefined) && (value.line2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithin_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithin_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StTouches {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StTouches.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersects_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersects_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCrosses {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCrosses.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StContains {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StContains.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StContainsproperly {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StContainsproperly.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StWithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCovers_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCovers_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredby_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredby_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOverlaps.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDfullywithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDfullywithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddwithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddwithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddfullywithin {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddfullywithin.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dintersects {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dintersects.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StOrderingequals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StOrderingequals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StEquals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEquals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsvalid_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsvalid_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumclearance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumclearance.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMinimumclearanceline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMinimumclearanceline.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroid_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroid_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometricmedian {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometricmedian.Parameters {
if (
(value.g !== undefined) && (value.tolerance !== undefined) && (value.maxIter !== undefined) && (value.failIfNotConverged !== undefined)
) return true;
return false;
}
}
}
export namespace StIsring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointonsurface {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointonsurface.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIssimple {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIssimple.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIscollection {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIscollection.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Equals {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Equals.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgml_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgml_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGmltosqlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGmltosqlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGmltosql_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGmltosql_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromkml {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromkml.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfrommarc21 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfrommarc21.Parameters {
if (
(value.marc21xml !== undefined)
) return true;
return false;
}
}
}
export namespace StAsmarc21 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsmarc21.Parameters {
if (
(value.geom !== undefined) && (value.format !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojsonE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojsonE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojson_608f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojson_608f.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeojson_3c9d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisLibjsonVersion {
}
export namespace StLinefromencodedpolyline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromencodedpolyline.Parameters {
if (
(value.txtin !== undefined) && (value.nprecision !== undefined)
) return true;
return false;
}
}
}
export namespace StAsencodedpolyline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsencodedpolyline.Parameters {
if (
(value.geom !== undefined) && (value.nprecision !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvgD341 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvgD341.Parameters {
if (
(value.geom !== undefined) && (value.rel !== undefined) && (value.maxdecimaldigits !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlD341 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlD341.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgml_32a0 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgml_32a0.Parameters {
if (
(value.version !== undefined) && (value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAskmlCce7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskmlCce7.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.nprefix !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonD341 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonD341.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonF2c6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonF2c6.Parameters {
if (
(value.r !== undefined) && (value.geomColumn !== undefined) && (value.maxdecimaldigits !== undefined) && (value.prettyBool !== undefined)
) return true;
return false;
}
}
}
export namespace Json {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Json.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Jsonb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Jsonb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_27f4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfnF57f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfn_92c1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtTransfnF5be.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined) && (value.argument_5 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtCombinefn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtCombinefn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtSerialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtSerialfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsmvtDeserialfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsmvtDeserialfn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsmvtgeom {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsmvtgeom.Parameters {
if (
(value.geom !== undefined) && (value.bounds !== undefined) && (value.extent !== undefined) && (value.buffer !== undefined) && (value.clipGeom !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisLibprotobufVersion {
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsgeobufFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsgeobufFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PgisAsflatgeobufFinalfn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StFromflatgeobuftotable {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFromflatgeobuftotable.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StFromflatgeobuf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFromflatgeobuf.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeohash_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeohash_6cbe.Parameters {
if (
(value.geom !== undefined) && (value.maxchars !== undefined)
) return true;
return false;
}
}
}
export namespace StBox2dfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBox2dfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromgeohash {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromgeohash.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumpoints {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumpoints.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumgeometries {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumgeometries.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDimension {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDimension.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StExteriorring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StExteriorring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNuminteriorrings {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNuminteriorrings.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StNuminteriorring {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNuminteriorring.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StInteriorringn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInteriorringn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometrytype_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometrytype_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometrytype {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometrytype.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StNumpatches {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StNumpatches.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPatchn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPatchn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StStartpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StStartpoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StEndpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StEndpoint.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsclosed {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsclosed.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StIsempty {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIsempty.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_88bc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_88bc.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_6cbe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_6cbe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeometryfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeometryfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StWkttosql {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWkttosql.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinestringfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinestringfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinestringfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolygonfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolygonfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolygonfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromtext_27e2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromtextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromtextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinefromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinefromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinestringfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinestringfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinestringfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygonfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyAnalyze {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyAnalyze.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipointfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultilinefromwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultilinefromwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMlinefromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMlinefromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMpolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolyfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolyfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMultipolyfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromwkbD8af {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromwkbD8af.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeomcollfromwkb_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StMaxdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StMaxdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpoint_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpoint_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestline_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestline_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLongestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLongestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StSwapordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSwapordinates.Parameters {
if (
(value.geom !== undefined) && (value.ords !== undefined)
) return true;
return false;
}
}
}
export namespace StFlipcoordinates {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StFlipcoordinates.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StBdpolyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBdpolyfromtext.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBdmpolyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBdmpolyfromtext.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Unlockrows {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Unlockrows.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_28e9 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_28e9.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_2d19 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_2d19.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Bytea_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Bytea_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstext_3181 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstext_3181.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace LockrowE9aa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.LockrowE9aa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined) && (value.argument_4 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_02b4 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_02b4.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Lockrow_9a8a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Lockrow_9a8a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Addauth {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Addauth.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauth_27e1 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Checkauth_27e1.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauth_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Checkauth_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Checkauthtrigger {
}
export namespace Gettransactionid {
}
export namespace Enablelongtransactions {
}
export namespace Longtransactionsenabled {
}
export namespace Disablelongtransactions {
}
export namespace GeographyTypmodIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyTypmodIn.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyTypmodOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyTypmodOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyIn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyIn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyOut {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyOut.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyRecv {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyRecv.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySend {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySend.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAstextE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAstextE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeographyfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeographyfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeogfromtext {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeogfromtext.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeogfromwkb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeogfromwkb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodDims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodDims.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodSrid.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypmodType {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypmodType.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geography_0cdb {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geography_0cdb.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometry_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometry_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistConsistent {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistConsistent.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistCompress {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistCompress.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistPenalty {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistPenalty.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistPicksplit {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistPicksplit.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistUnion {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistUnion.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistSame {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistSame.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistDecompress {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistDecompress.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyOverlaps {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyOverlaps.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyDistanceKnn {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyDistanceKnn.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGistDistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGistDistance.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeog_52a8 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeog_52a8.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeog_25ba {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeog_25ba.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsGeog_8fd3 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsGeog_8fd3.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeogBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeogBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyLt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyLt.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyLe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyLe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGt {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGt.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyGe {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyGe.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyEq {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyEq.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographyCmp {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographyCmp.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvg_6ec5 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvg_6ec5.Parameters {
if (
(value.geog !== undefined) && (value.rel !== undefined) && (value.maxdecimaldigits !== undefined)
) return true;
return false;
}
}
}
export namespace StAssvgE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAssvgE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StProjectD4ec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProjectD4ec.Parameters {
if (
(value.geogFrom !== undefined) && (value.geogTo !== undefined) && (value.distance !== undefined)
) return true;
return false;
}
}
}
export namespace StAzimuthE452 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAzimuthE452.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_49f7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_49f7.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlE888 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlE888.Parameters {
if (
(value.version !== undefined) && (value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgml_2160 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgml_2160.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined) && (value.nprefix !== undefined) && (value.id !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAskmlF40a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskmlF40a.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.nprefix !== undefined)
) return true;
return false;
}
}
}
export namespace StAskmlE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAskmlE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojson_6ec5 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojson_6ec5.Parameters {
if (
(value.geog !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAsgeojsonE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsgeojsonE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistance_8dcd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistance_8dcd.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StDistance_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistance_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAreaEcae {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAreaEcae.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StAreaE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAreaE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthEcae {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthEcae.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLengthE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLengthE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StProjectEd46 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StProjectEd46.Parameters {
if (
(value.geog !== undefined) && (value.distance !== undefined) && (value.azimuth !== undefined)
) return true;
return false;
}
}
}
export namespace StPerimeterEcae {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPerimeterEcae.Parameters {
if (
(value.geog !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StSegmentizeCadf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSegmentizeCadf.Parameters {
if (
(value.geog !== undefined) && (value.maxSegmentLength !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsbinary_734d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsbinary_734d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewkt_3181 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewkt_3181.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StAsewktE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsewktE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace Geometrytype_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geometrytype_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StSummary_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSummary_7902.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StGeohash_3181 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StGeohash_3181.Parameters {
if (
(value.geog !== undefined) && (value.maxchars !== undefined)
) return true;
return false;
}
}
}
export namespace StSrid_7902 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSrid_7902.Parameters {
if (
(value.geog !== undefined)
) return true;
return false;
}
}
}
export namespace StSetsrid_3181 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSetsrid_3181.Parameters {
if (
(value.geog !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroidEcae {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroidEcae.Parameters {
if (
(value.argument_0 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StCentroidE728 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCentroidE728.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoversE452 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoversE452.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithin_55df {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithin_55df.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined) && (value.tolerance !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredbyE452 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredbyE452.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectsE452 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectsE452.Parameters {
if (
(value.geog1 !== undefined) && (value.geog2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferCadf {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferCadf.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_12e3 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_12e3.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBuffer_3aaa {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBuffer_3aaa.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StBufferF7c6 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StBufferF7c6.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersectionE452 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersectionE452.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersection_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersection_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCovers_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCovers_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoveredby_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoveredby_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDwithinEfc0 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDwithinEfc0.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StIntersects_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StIntersects_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpoint_8dcd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpoint_8dcd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StClosestpoint_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StClosestpoint_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestline_8dcd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestline_8dcd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StShortestline_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StShortestline_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstringEd46 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstringEd46.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinesubstringE586 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinesubstringE586.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepoint_8dcd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepoint_8dcd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinelocatepoint_2ec2.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoints_8796 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoints_8796.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined) && (value.repeat !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointsC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointsC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepoint_612b {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepoint_612b.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.useSpheroid !== undefined)
) return true;
return false;
}
}
}
export namespace StLineinterpolatepointC349 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLineinterpolatepointC349.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancesphere_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancesphere_3651.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StDistancesphere_6961 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StDistancesphere_6961.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined) && (value.radius !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisTypeName {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisTypeName.Parameters {
if (
(value.geomname !== undefined) && (value.coordDimension !== undefined) && (value.useNewName !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintSrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintSrid.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintDims {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintDims.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace PostgisConstraintType {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.PostgisConstraintType.Parameters {
if (
(value.geomschema !== undefined) && (value.geomtable !== undefined) && (value.geomcolumn !== undefined)
) return true;
return false;
}
}
}
export namespace St_3ddistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3ddistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dmaxdistance {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dmaxdistance.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dclosestpoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dclosestpoint.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dshortestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dshortestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlongestline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlongestline.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace StCoorddim {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCoorddim.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StCurvetoline {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StCurvetoline.Parameters {
if (
(value.geom !== undefined) && (value.tol !== undefined) && (value.toltype !== undefined) && (value.flags !== undefined)
) return true;
return false;
}
}
}
export namespace StHasarc {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHasarc.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StLinetocurve {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLinetocurve.Parameters {
if (
(value.geometry !== undefined)
) return true;
return false;
}
}
}
export namespace StPoint_0aec {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoint_0aec.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StPoint_0b7f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPoint_0b7f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointz {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointz.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.zcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointm.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.mcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPointzm {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPointzm.Parameters {
if (
(value.xcoordinate !== undefined) && (value.ycoordinate !== undefined) && (value.zcoordinate !== undefined) && (value.mcoordinate !== undefined) && (value.srid !== undefined)
) return true;
return false;
}
}
}
export namespace StPolygon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StPolygon.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace StWkbtosql {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StWkbtosql.Parameters {
if (
(value.wkb !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatebetween {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatebetween.Parameters {
if (
(value.geometry !== undefined) && (value.frommeasure !== undefined) && (value.tomeasure !== undefined) && (value.leftrightoffset !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatealong {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatealong.Parameters {
if (
(value.geometry !== undefined) && (value.measure !== undefined) && (value.leftrightoffset !== undefined)
) return true;
return false;
}
}
}
export namespace StLocatebetweenelevations {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLocatebetweenelevations.Parameters {
if (
(value.geometry !== undefined) && (value.fromelevation !== undefined) && (value.toelevation !== undefined)
) return true;
return false;
}
}
}
export namespace StInterpolatepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StInterpolatepoint.Parameters {
if (
(value.line !== undefined) && (value.point !== undefined)
) return true;
return false;
}
}
}
export namespace StHexagon {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHexagon.Parameters {
if (
(value.size !== undefined) && (value.cellI !== undefined) && (value.cellJ !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StSquare {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSquare.Parameters {
if (
(value.size !== undefined) && (value.cellI !== undefined) && (value.cellJ !== undefined) && (value.origin !== undefined)
) return true;
return false;
}
}
}
export namespace StHexagongrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StHexagongrid.Parameters {
if (
(value.size !== undefined) && (value.bounds !== undefined)
) return true;
return false;
}
}
}
export namespace StSquaregrid {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSquaregrid.Parameters {
if (
(value.size !== undefined) && (value.bounds !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2d_3f2a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2d_3f2a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2d_3f2a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2d_3f2a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2d_3f2a {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2d_3f2a.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2d_4f71 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2d_4f71.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2d_4f71 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2d_4f71.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2d_4f71 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2d_4f71.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Contains_2d_7d4f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Contains_2d_7d4f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace IsContained_2d_7d4f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.IsContained_2d_7d4f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Overlaps_2d_7d4f {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Overlaps_2d_7d4f.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNd_6173 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNd_6173.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNd_25ba {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNd_25ba.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace OverlapsNd_40b7 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.OverlapsNd_40b7.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom2dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom3dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.Geom4dBrinInclusionAddValue.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined) && (value.argument_2 !== undefined) && (value.argument_3 !== undefined)
) return true;
return false;
}
}
}
export namespace StSimplifypolygonhull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StSimplifypolygonhull.Parameters {
if (
(value.geom !== undefined) && (value.vertexFraction !== undefined) && (value.isOuter !== undefined)
) return true;
return false;
}
}
}
export namespace StConcavehull {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StConcavehull.Parameters {
if (
(value.paramGeom !== undefined) && (value.paramPctconvex !== undefined) && (value.paramAllowHoles !== undefined)
) return true;
return false;
}
}
}
export namespace StAsx3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAsx3d.Parameters {
if (
(value.geom !== undefined) && (value.maxdecimaldigits !== undefined) && (value.options !== undefined)
) return true;
return false;
}
}
}
export namespace StAngle_3651 {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StAngle_3651.Parameters {
if (
(value.line1 !== undefined) && (value.line2 !== undefined)
) return true;
return false;
}
}
}
export namespace St_3dlineinterpolatepoint {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.St_3dlineinterpolatepoint.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfig_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfig_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChoose_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChoose_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplit_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompress_2d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompress_2d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryOverlaps_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryOverlaps_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContains_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContains_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometryContained_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometryContained_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySame_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySame_3d.Parameters {
if (
(value.geom1 !== undefined) && (value.geom2 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfig_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfig_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChoose_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChoose_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplit_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompress_3d {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompress_3d.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistConfigNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistConfigNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistChooseNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistChooseNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeometrySpgistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeometrySpgistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistConfigNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistConfigNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistChooseNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistChooseNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistPicksplitNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistPicksplitNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistInnerConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistLeafConsistentNd.Parameters {
if (
(value.argument_0 !== undefined) && (value.argument_1 !== undefined)
) return true;
return false;
}
}
}
export namespace GeographySpgistCompressNd {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.GeographySpgistCompressNd.Parameters {
if (
(value.argument_0 !== undefined)
) return true;
return false;
}
}
}
export namespace StLetters {
export namespace Parameters {
export function is(value: any) : value is Public.Procedures.StLetters.Parameters {
if (
(value.letters !== undefined) && (value.font !== undefined)
) return true;
return false;
}
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
}
export namespace NycCensusBlocks {
}
export namespace NycHomicides {
}
export namespace NycNeighborhoods {
}
export namespace NycStreets {
}
export namespace NycSubwayStations {
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_47570Index {
export function is(value: any) : value is PgToast.Types.PgToast_47570Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_48328Index {
export function is(value: any) : value is PgToast.Types.PgToast_48328Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_48334Index {
export function is(value: any) : value is PgToast.Types.PgToast_48334Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1255Index {
export function is(value: any) : value is PgToast.Types.PgToast_1255Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1247Index {
export function is(value: any) : value is PgToast.Types.PgToast_1247Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2604Index {
export function is(value: any) : value is PgToast.Types.PgToast_2604Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2606Index {
export function is(value: any) : value is PgToast.Types.PgToast_2606Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2612Index {
export function is(value: any) : value is PgToast.Types.PgToast_2612Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2600Index {
export function is(value: any) : value is PgToast.Types.PgToast_2600Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2619Index {
export function is(value: any) : value is PgToast.Types.PgToast_2619Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3381Index {
export function is(value: any) : value is PgToast.Types.PgToast_3381Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3429Index {
export function is(value: any) : value is PgToast.Types.PgToast_3429Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2618Index {
export function is(value: any) : value is PgToast.Types.PgToast_2618Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2620Index {
export function is(value: any) : value is PgToast.Types.PgToast_2620Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3466Index {
export function is(value: any) : value is PgToast.Types.PgToast_3466Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2609Index {
export function is(value: any) : value is PgToast.Types.PgToast_2609Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_48340Index {
export function is(value: any) : value is PgToast.Types.PgToast_48340Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2615Index {
export function is(value: any) : value is PgToast.Types.PgToast_2615Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1262Index {
export function is(value: any) : value is PgToast.Types.PgToast_1262Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2964Index {
export function is(value: any) : value is PgToast.Types.PgToast_2964Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1213Index {
export function is(value: any) : value is PgToast.Types.PgToast_1213Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1260Index {
export function is(value: any) : value is PgToast.Types.PgToast_1260Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2396Index {
export function is(value: any) : value is PgToast.Types.PgToast_2396Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3600Index {
export function is(value: any) : value is PgToast.Types.PgToast_3600Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3079Index {
export function is(value: any) : value is PgToast.Types.PgToast_3079Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_2328Index {
export function is(value: any) : value is PgToast.Types.PgToast_2328Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1417Index {
export function is(value: any) : value is PgToast.Types.PgToast_1417Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_1418Index {
export function is(value: any) : value is PgToast.Types.PgToast_1418Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3118Index {
export function is(value: any) : value is PgToast.Types.PgToast_3118Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3256Index {
export function is(value: any) : value is PgToast.Types.PgToast_3256Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6000Index {
export function is(value: any) : value is PgToast.Types.PgToast_6000Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_826Index {
export function is(value: any) : value is PgToast.Types.PgToast_826Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3394Index {
export function is(value: any) : value is PgToast.Types.PgToast_3394Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3596Index {
export function is(value: any) : value is PgToast.Types.PgToast_3596Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3592Index {
export function is(value: any) : value is PgToast.Types.PgToast_3592Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3456Index {
export function is(value: any) : value is PgToast.Types.PgToast_3456Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6243Index {
export function is(value: any) : value is PgToast.Types.PgToast_6243Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_3350Index {
export function is(value: any) : value is PgToast.Types.PgToast_3350Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6106Index {
export function is(value: any) : value is PgToast.Types.PgToast_6106Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_6100Index {
export function is(value: any) : value is PgToast.Types.PgToast_6100Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_48346Index {
export function is(value: any) : value is PgToast.Types.PgToast_48346Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_48352Index {
export function is(value: any) : value is PgToast.Types.PgToast_48352Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13658Index {
export function is(value: any) : value is PgToast.Types.PgToast_13658Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13663Index {
export function is(value: any) : value is PgToast.Types.PgToast_13663Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13668Index {
export function is(value: any) : value is PgToast.Types.PgToast_13668Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
export namespace PgToast_13673Index {
export function is(value: any) : value is PgToast.Types.PgToast_13673Index {
if (
(value.chunkId !== undefined) && (value.chunkSeq !== undefined)
) return true;
return false;
}
}
}
export namespace Procedures {
}
export namespace Tables {
}
}
export namespace PgCatalog {
export namespace Types {
export namespace Bool {
 export function equals(l: PgCatalog.Types.Bool|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bytea {
 export function equals(l: PgCatalog.Types.Bytea|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Char {
 export function equals(l: PgCatalog.Types.Char|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Name {
 export function equals(l: PgCatalog.Types.Name|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8 {
 export function equals(l: PgCatalog.Types.Int8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2 {
 export function equals(l: PgCatalog.Types.Int2|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2vector {
 export function equals(l: PgCatalog.Types.Int2vector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4 {
 export function equals(l: PgCatalog.Types.Int4|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regproc {
 export function equals(l: PgCatalog.Types.Regproc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Text {
 export function equals(l: PgCatalog.Types.Text|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Oid {
 export function equals(l: PgCatalog.Types.Oid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tid {
 export function equals(l: PgCatalog.Types.Tid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid {
 export function equals(l: PgCatalog.Types.Xid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cid {
 export function equals(l: PgCatalog.Types.Cid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Oidvector {
 export function equals(l: PgCatalog.Types.Oidvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgType {
 export function equals(l: PgCatalog.Types.PgType|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttribute {
 export function equals(l: PgCatalog.Types.PgAttribute|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProc {
 export function equals(l: PgCatalog.Types.PgProc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClass {
 export function equals(l: PgCatalog.Types.PgClass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Json {
 export function equals(l: PgCatalog.Types.Json|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xml {
 export function equals(l: PgCatalog.Types.Xml|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNodeTree {
 export function equals(l: PgCatalog.Types.PgNodeTree|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNdistinct {
 export function equals(l: PgCatalog.Types.PgNdistinct|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependencies {
 export function equals(l: PgCatalog.Types.PgDependencies|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMcvList {
 export function equals(l: PgCatalog.Types.PgMcvList|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDdlCommand {
 export function equals(l: PgCatalog.Types.PgDdlCommand|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid8 {
 export function equals(l: PgCatalog.Types.Xid8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Point {
 export function equals(l: PgCatalog.Types.Point|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Lseg {
 export function equals(l: PgCatalog.Types.Lseg|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Path {
 export function equals(l: PgCatalog.Types.Path|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box {
 export function equals(l: PgCatalog.Types.Box|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Polygon {
 export function equals(l: PgCatalog.Types.Polygon|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Line {
 export function equals(l: PgCatalog.Types.Line|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float4 {
 export function equals(l: PgCatalog.Types.Float4|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float8 {
 export function equals(l: PgCatalog.Types.Float8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Unknown {
 export function equals(l: PgCatalog.Types.Unknown|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Circle {
 export function equals(l: PgCatalog.Types.Circle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Money {
 export function equals(l: PgCatalog.Types.Money|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr {
 export function equals(l: PgCatalog.Types.Macaddr|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Inet {
 export function equals(l: PgCatalog.Types.Inet|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cidr {
 export function equals(l: PgCatalog.Types.Cidr|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr8 {
 export function equals(l: PgCatalog.Types.Macaddr8|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Aclitem {
 export function equals(l: PgCatalog.Types.Aclitem|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bpchar {
 export function equals(l: PgCatalog.Types.Bpchar|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Varchar {
 export function equals(l: PgCatalog.Types.Varchar|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Date {
 export function equals(l: PgCatalog.Types.Date|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Time {
 export function equals(l: PgCatalog.Types.Time|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timestamp {
 export function equals(l: PgCatalog.Types.Timestamp|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timestamptz {
 export function equals(l: PgCatalog.Types.Timestamptz|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Interval {
 export function equals(l: PgCatalog.Types.Interval|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Timetz {
 export function equals(l: PgCatalog.Types.Timetz|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Bit {
 export function equals(l: PgCatalog.Types.Bit|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Varbit {
 export function equals(l: PgCatalog.Types.Varbit|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Numeric {
 export function equals(l: PgCatalog.Types.Numeric|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Refcursor {
 export function equals(l: PgCatalog.Types.Refcursor|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regprocedure {
 export function equals(l: PgCatalog.Types.Regprocedure|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regoper {
 export function equals(l: PgCatalog.Types.Regoper|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regoperator {
 export function equals(l: PgCatalog.Types.Regoperator|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regclass {
 export function equals(l: PgCatalog.Types.Regclass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regcollation {
 export function equals(l: PgCatalog.Types.Regcollation|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regtype {
 export function equals(l: PgCatalog.Types.Regtype|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regrole {
 export function equals(l: PgCatalog.Types.Regrole|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regnamespace {
 export function equals(l: PgCatalog.Types.Regnamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Uuid {
 export function equals(l: PgCatalog.Types.Uuid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLsn {
 export function equals(l: PgCatalog.Types.PgLsn|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsvector {
 export function equals(l: PgCatalog.Types.Tsvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Gtsvector {
 export function equals(l: PgCatalog.Types.Gtsvector|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsquery {
 export function equals(l: PgCatalog.Types.Tsquery|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regconfig {
 export function equals(l: PgCatalog.Types.Regconfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Regdictionary {
 export function equals(l: PgCatalog.Types.Regdictionary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Jsonb {
 export function equals(l: PgCatalog.Types.Jsonb|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Jsonpath {
 export function equals(l: PgCatalog.Types.Jsonpath|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TxidSnapshot {
 export function equals(l: PgCatalog.Types.TxidSnapshot|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSnapshot {
 export function equals(l: PgCatalog.Types.PgSnapshot|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4range {
 export function equals(l: PgCatalog.Types.Int4range|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Numrange {
 export function equals(l: PgCatalog.Types.Numrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsrange {
 export function equals(l: PgCatalog.Types.Tsrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tstzrange {
 export function equals(l: PgCatalog.Types.Tstzrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Daterange {
 export function equals(l: PgCatalog.Types.Daterange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8range {
 export function equals(l: PgCatalog.Types.Int8range|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4multirange {
 export function equals(l: PgCatalog.Types.Int4multirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Nummultirange {
 export function equals(l: PgCatalog.Types.Nummultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tsmultirange {
 export function equals(l: PgCatalog.Types.Tsmultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tstzmultirange {
 export function equals(l: PgCatalog.Types.Tstzmultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Datemultirange {
 export function equals(l: PgCatalog.Types.Datemultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8multirange {
 export function equals(l: PgCatalog.Types.Int8multirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Record {
 export function equals(l: PgCatalog.Types.Record|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RecordArray {
 export function equals(l: PgCatalog.Types.RecordArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Cstring {
 export function equals(l: PgCatalog.Types.Cstring|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Any {
 export function equals(l: PgCatalog.Types.Any|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyarray {
 export function equals(l: PgCatalog.Types.Anyarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Void {
 export function equals(l: PgCatalog.Types.Void|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Trigger {
 export function equals(l: PgCatalog.Types.Trigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EventTrigger {
 export function equals(l: PgCatalog.Types.EventTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LanguageHandler {
 export function equals(l: PgCatalog.Types.LanguageHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Internal {
 export function equals(l: PgCatalog.Types.Internal|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyelement {
 export function equals(l: PgCatalog.Types.Anyelement|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anynonarray {
 export function equals(l: PgCatalog.Types.Anynonarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyenum {
 export function equals(l: PgCatalog.Types.Anyenum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace FdwHandler {
 export function equals(l: PgCatalog.Types.FdwHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace IndexAmHandler {
 export function equals(l: PgCatalog.Types.IndexAmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsmHandler {
 export function equals(l: PgCatalog.Types.TsmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableAmHandler {
 export function equals(l: PgCatalog.Types.TableAmHandler|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anyrange {
 export function equals(l: PgCatalog.Types.Anyrange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatible {
 export function equals(l: PgCatalog.Types.Anycompatible|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblearray {
 export function equals(l: PgCatalog.Types.Anycompatiblearray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblenonarray {
 export function equals(l: PgCatalog.Types.Anycompatiblenonarray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblerange {
 export function equals(l: PgCatalog.Types.Anycompatiblerange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anymultirange {
 export function equals(l: PgCatalog.Types.Anymultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Anycompatiblemultirange {
 export function equals(l: PgCatalog.Types.Anycompatiblemultirange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBrinBloomSummary {
 export function equals(l: PgCatalog.Types.PgBrinBloomSummary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBrinMinmaxMultiSummary {
 export function equals(l: PgCatalog.Types.PgBrinMinmaxMultiSummary|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BoolArray {
 export function equals(l: PgCatalog.Types.BoolArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ByteaArray {
 export function equals(l: PgCatalog.Types.ByteaArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharArray {
 export function equals(l: PgCatalog.Types.CharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NameArray {
 export function equals(l: PgCatalog.Types.NameArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8Array {
 export function equals(l: PgCatalog.Types.Int8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2Array {
 export function equals(l: PgCatalog.Types.Int2Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int2vectorArray {
 export function equals(l: PgCatalog.Types.Int2vectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4Array {
 export function equals(l: PgCatalog.Types.Int4Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegprocArray {
 export function equals(l: PgCatalog.Types.RegprocArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TextArray {
 export function equals(l: PgCatalog.Types.TextArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace OidArray {
 export function equals(l: PgCatalog.Types.OidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TidArray {
 export function equals(l: PgCatalog.Types.TidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace XidArray {
 export function equals(l: PgCatalog.Types.XidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CidArray {
 export function equals(l: PgCatalog.Types.CidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace OidvectorArray {
 export function equals(l: PgCatalog.Types.OidvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeArray {
 export function equals(l: PgCatalog.Types.PgTypeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeArray {
 export function equals(l: PgCatalog.Types.PgAttributeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcArray {
 export function equals(l: PgCatalog.Types.PgProcArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassArray {
 export function equals(l: PgCatalog.Types.PgClassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonArray {
 export function equals(l: PgCatalog.Types.JsonArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace XmlArray {
 export function equals(l: PgCatalog.Types.XmlArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Xid8Array {
 export function equals(l: PgCatalog.Types.Xid8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PointArray {
 export function equals(l: PgCatalog.Types.PointArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LsegArray {
 export function equals(l: PgCatalog.Types.LsegArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PathArray {
 export function equals(l: PgCatalog.Types.PathArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BoxArray {
 export function equals(l: PgCatalog.Types.BoxArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PolygonArray {
 export function equals(l: PgCatalog.Types.PolygonArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace LineArray {
 export function equals(l: PgCatalog.Types.LineArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float4Array {
 export function equals(l: PgCatalog.Types.Float4Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Float8Array {
 export function equals(l: PgCatalog.Types.Float8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CircleArray {
 export function equals(l: PgCatalog.Types.CircleArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace MoneyArray {
 export function equals(l: PgCatalog.Types.MoneyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace MacaddrArray {
 export function equals(l: PgCatalog.Types.MacaddrArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InetArray {
 export function equals(l: PgCatalog.Types.InetArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CidrArray {
 export function equals(l: PgCatalog.Types.CidrArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Macaddr8Array {
 export function equals(l: PgCatalog.Types.Macaddr8Array|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AclitemArray {
 export function equals(l: PgCatalog.Types.AclitemArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BpcharArray {
 export function equals(l: PgCatalog.Types.BpcharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace VarcharArray {
 export function equals(l: PgCatalog.Types.VarcharArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DateArray {
 export function equals(l: PgCatalog.Types.DateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeArray {
 export function equals(l: PgCatalog.Types.TimeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimestampArray {
 export function equals(l: PgCatalog.Types.TimestampArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimestamptzArray {
 export function equals(l: PgCatalog.Types.TimestamptzArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace IntervalArray {
 export function equals(l: PgCatalog.Types.IntervalArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimetzArray {
 export function equals(l: PgCatalog.Types.TimetzArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace BitArray {
 export function equals(l: PgCatalog.Types.BitArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace VarbitArray {
 export function equals(l: PgCatalog.Types.VarbitArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NumericArray {
 export function equals(l: PgCatalog.Types.NumericArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RefcursorArray {
 export function equals(l: PgCatalog.Types.RefcursorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegprocedureArray {
 export function equals(l: PgCatalog.Types.RegprocedureArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegoperArray {
 export function equals(l: PgCatalog.Types.RegoperArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegoperatorArray {
 export function equals(l: PgCatalog.Types.RegoperatorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegclassArray {
 export function equals(l: PgCatalog.Types.RegclassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegcollationArray {
 export function equals(l: PgCatalog.Types.RegcollationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegtypeArray {
 export function equals(l: PgCatalog.Types.RegtypeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegroleArray {
 export function equals(l: PgCatalog.Types.RegroleArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegnamespaceArray {
 export function equals(l: PgCatalog.Types.RegnamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UuidArray {
 export function equals(l: PgCatalog.Types.UuidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLsnArray {
 export function equals(l: PgCatalog.Types.PgLsnArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsvectorArray {
 export function equals(l: PgCatalog.Types.TsvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GtsvectorArray {
 export function equals(l: PgCatalog.Types.GtsvectorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsqueryArray {
 export function equals(l: PgCatalog.Types.TsqueryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegconfigArray {
 export function equals(l: PgCatalog.Types.RegconfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RegdictionaryArray {
 export function equals(l: PgCatalog.Types.RegdictionaryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonbArray {
 export function equals(l: PgCatalog.Types.JsonbArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace JsonpathArray {
 export function equals(l: PgCatalog.Types.JsonpathArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TxidSnapshotArray {
 export function equals(l: PgCatalog.Types.TxidSnapshotArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSnapshotArray {
 export function equals(l: PgCatalog.Types.PgSnapshotArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4rangeArray {
 export function equals(l: PgCatalog.Types.Int4rangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NumrangeArray {
 export function equals(l: PgCatalog.Types.NumrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsrangeArray {
 export function equals(l: PgCatalog.Types.TsrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TstzrangeArray {
 export function equals(l: PgCatalog.Types.TstzrangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DaterangeArray {
 export function equals(l: PgCatalog.Types.DaterangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8rangeArray {
 export function equals(l: PgCatalog.Types.Int8rangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int4multirangeArray {
 export function equals(l: PgCatalog.Types.Int4multirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NummultirangeArray {
 export function equals(l: PgCatalog.Types.NummultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TsmultirangeArray {
 export function equals(l: PgCatalog.Types.TsmultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TstzmultirangeArray {
 export function equals(l: PgCatalog.Types.TstzmultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DatemultirangeArray {
 export function equals(l: PgCatalog.Types.DatemultirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Int8multirangeArray {
 export function equals(l: PgCatalog.Types.Int8multirangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CstringArray {
 export function equals(l: PgCatalog.Types.CstringArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdef {
 export function equals(l: PgCatalog.Types.PgAttrdef|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefArray {
 export function equals(l: PgCatalog.Types.PgAttrdefArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraint {
 export function equals(l: PgCatalog.Types.PgConstraint|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintArray {
 export function equals(l: PgCatalog.Types.PgConstraintArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInherits {
 export function equals(l: PgCatalog.Types.PgInherits|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsArray {
 export function equals(l: PgCatalog.Types.PgInheritsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndex {
 export function equals(l: PgCatalog.Types.PgIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexArray {
 export function equals(l: PgCatalog.Types.PgIndexArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperator {
 export function equals(l: PgCatalog.Types.PgOperator|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorArray {
 export function equals(l: PgCatalog.Types.PgOperatorArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamily {
 export function equals(l: PgCatalog.Types.PgOpfamily|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyArray {
 export function equals(l: PgCatalog.Types.PgOpfamilyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclass {
 export function equals(l: PgCatalog.Types.PgOpclass|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassArray {
 export function equals(l: PgCatalog.Types.PgOpclassArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAm {
 export function equals(l: PgCatalog.Types.PgAm|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmArray {
 export function equals(l: PgCatalog.Types.PgAmArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmop {
 export function equals(l: PgCatalog.Types.PgAmop|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopArray {
 export function equals(l: PgCatalog.Types.PgAmopArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmproc {
 export function equals(l: PgCatalog.Types.PgAmproc|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocArray {
 export function equals(l: PgCatalog.Types.PgAmprocArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguage {
 export function equals(l: PgCatalog.Types.PgLanguage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageArray {
 export function equals(l: PgCatalog.Types.PgLanguageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadata {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadata|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadataArray {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobject {
 export function equals(l: PgCatalog.Types.PgLargeobject|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectArray {
 export function equals(l: PgCatalog.Types.PgLargeobjectArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregate {
 export function equals(l: PgCatalog.Types.PgAggregate|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregateArray {
 export function equals(l: PgCatalog.Types.PgAggregateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatistic {
 export function equals(l: PgCatalog.Types.PgStatistic|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticArray {
 export function equals(l: PgCatalog.Types.PgStatisticArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExt {
 export function equals(l: PgCatalog.Types.PgStatisticExt|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtArray {
 export function equals(l: PgCatalog.Types.PgStatisticExtArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtData {
 export function equals(l: PgCatalog.Types.PgStatisticExtData|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtDataArray {
 export function equals(l: PgCatalog.Types.PgStatisticExtDataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewrite {
 export function equals(l: PgCatalog.Types.PgRewrite|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteArray {
 export function equals(l: PgCatalog.Types.PgRewriteArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTrigger {
 export function equals(l: PgCatalog.Types.PgTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerArray {
 export function equals(l: PgCatalog.Types.PgTriggerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTrigger {
 export function equals(l: PgCatalog.Types.PgEventTrigger|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerArray {
 export function equals(l: PgCatalog.Types.PgEventTriggerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescription {
 export function equals(l: PgCatalog.Types.PgDescription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescriptionArray {
 export function equals(l: PgCatalog.Types.PgDescriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCast {
 export function equals(l: PgCatalog.Types.PgCast|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastArray {
 export function equals(l: PgCatalog.Types.PgCastArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnum {
 export function equals(l: PgCatalog.Types.PgEnum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumArray {
 export function equals(l: PgCatalog.Types.PgEnumArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespace {
 export function equals(l: PgCatalog.Types.PgNamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceArray {
 export function equals(l: PgCatalog.Types.PgNamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversion {
 export function equals(l: PgCatalog.Types.PgConversion|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionArray {
 export function equals(l: PgCatalog.Types.PgConversionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDepend {
 export function equals(l: PgCatalog.Types.PgDepend|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependArray {
 export function equals(l: PgCatalog.Types.PgDependArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabase {
 export function equals(l: PgCatalog.Types.PgDatabase|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseArray {
 export function equals(l: PgCatalog.Types.PgDatabaseArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSetting {
 export function equals(l: PgCatalog.Types.PgDbRoleSetting|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSettingArray {
 export function equals(l: PgCatalog.Types.PgDbRoleSettingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespace {
 export function equals(l: PgCatalog.Types.PgTablespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceArray {
 export function equals(l: PgCatalog.Types.PgTablespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthid {
 export function equals(l: PgCatalog.Types.PgAuthid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidArray {
 export function equals(l: PgCatalog.Types.PgAuthidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembers {
 export function equals(l: PgCatalog.Types.PgAuthMembers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersArray {
 export function equals(l: PgCatalog.Types.PgAuthMembersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdepend {
 export function equals(l: PgCatalog.Types.PgShdepend|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependArray {
 export function equals(l: PgCatalog.Types.PgShdependArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescription {
 export function equals(l: PgCatalog.Types.PgShdescription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescriptionArray {
 export function equals(l: PgCatalog.Types.PgShdescriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfig {
 export function equals(l: PgCatalog.Types.PgTsConfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigArray {
 export function equals(l: PgCatalog.Types.PgTsConfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMap {
 export function equals(l: PgCatalog.Types.PgTsConfigMap|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMapArray {
 export function equals(l: PgCatalog.Types.PgTsConfigMapArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDict {
 export function equals(l: PgCatalog.Types.PgTsDict|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictArray {
 export function equals(l: PgCatalog.Types.PgTsDictArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParser {
 export function equals(l: PgCatalog.Types.PgTsParser|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserArray {
 export function equals(l: PgCatalog.Types.PgTsParserArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplate {
 export function equals(l: PgCatalog.Types.PgTsTemplate|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateArray {
 export function equals(l: PgCatalog.Types.PgTsTemplateArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtension {
 export function equals(l: PgCatalog.Types.PgExtension|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionArray {
 export function equals(l: PgCatalog.Types.PgExtensionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapper {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapper|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperArray {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServer {
 export function equals(l: PgCatalog.Types.PgForeignServer|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerArray {
 export function equals(l: PgCatalog.Types.PgForeignServerArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMapping {
 export function equals(l: PgCatalog.Types.PgUserMapping|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingArray {
 export function equals(l: PgCatalog.Types.PgUserMappingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTable {
 export function equals(l: PgCatalog.Types.PgForeignTable|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableArray {
 export function equals(l: PgCatalog.Types.PgForeignTableArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicy {
 export function equals(l: PgCatalog.Types.PgPolicy|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyArray {
 export function equals(l: PgCatalog.Types.PgPolicyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOrigin {
 export function equals(l: PgCatalog.Types.PgReplicationOrigin|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginArray {
 export function equals(l: PgCatalog.Types.PgReplicationOriginArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAcl {
 export function equals(l: PgCatalog.Types.PgDefaultAcl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclArray {
 export function equals(l: PgCatalog.Types.PgDefaultAclArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivs {
 export function equals(l: PgCatalog.Types.PgInitPrivs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivsArray {
 export function equals(l: PgCatalog.Types.PgInitPrivsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabel {
 export function equals(l: PgCatalog.Types.PgSeclabel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelArray {
 export function equals(l: PgCatalog.Types.PgSeclabelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabel {
 export function equals(l: PgCatalog.Types.PgShseclabel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabelArray {
 export function equals(l: PgCatalog.Types.PgShseclabelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollation {
 export function equals(l: PgCatalog.Types.PgCollation|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationArray {
 export function equals(l: PgCatalog.Types.PgCollationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAcl {
 export function equals(l: PgCatalog.Types.PgParameterAcl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclArray {
 export function equals(l: PgCatalog.Types.PgParameterAclArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTable {
 export function equals(l: PgCatalog.Types.PgPartitionedTable|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTableArray {
 export function equals(l: PgCatalog.Types.PgPartitionedTableArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRange {
 export function equals(l: PgCatalog.Types.PgRange|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeArray {
 export function equals(l: PgCatalog.Types.PgRangeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransform {
 export function equals(l: PgCatalog.Types.PgTransform|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformArray {
 export function equals(l: PgCatalog.Types.PgTransformArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequence {
 export function equals(l: PgCatalog.Types.PgSequence|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequenceArray {
 export function equals(l: PgCatalog.Types.PgSequenceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublication {
 export function equals(l: PgCatalog.Types.PgPublication|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationArray {
 export function equals(l: PgCatalog.Types.PgPublicationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespace {
 export function equals(l: PgCatalog.Types.PgPublicationNamespace|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespaceArray {
 export function equals(l: PgCatalog.Types.PgPublicationNamespaceArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRel {
 export function equals(l: PgCatalog.Types.PgPublicationRel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelArray {
 export function equals(l: PgCatalog.Types.PgPublicationRelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscription {
 export function equals(l: PgCatalog.Types.PgSubscription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionArray {
 export function equals(l: PgCatalog.Types.PgSubscriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRel {
 export function equals(l: PgCatalog.Types.PgSubscriptionRel|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRelArray {
 export function equals(l: PgCatalog.Types.PgSubscriptionRelArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRoles {
 export function equals(l: PgCatalog.Types.PgRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRolesArray {
 export function equals(l: PgCatalog.Types.PgRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShadow {
 export function equals(l: PgCatalog.Types.PgShadow|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShadowArray {
 export function equals(l: PgCatalog.Types.PgShadowArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgGroup {
 export function equals(l: PgCatalog.Types.PgGroup|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgGroupArray {
 export function equals(l: PgCatalog.Types.PgGroupArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUser {
 export function equals(l: PgCatalog.Types.PgUser|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserArray {
 export function equals(l: PgCatalog.Types.PgUserArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicies {
 export function equals(l: PgCatalog.Types.PgPolicies|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPoliciesArray {
 export function equals(l: PgCatalog.Types.PgPoliciesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRules {
 export function equals(l: PgCatalog.Types.PgRules|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRulesArray {
 export function equals(l: PgCatalog.Types.PgRulesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgViews {
 export function equals(l: PgCatalog.Types.PgViews|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgViewsArray {
 export function equals(l: PgCatalog.Types.PgViewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTables {
 export function equals(l: PgCatalog.Types.PgTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablesArray {
 export function equals(l: PgCatalog.Types.PgTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMatviews {
 export function equals(l: PgCatalog.Types.PgMatviews|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgMatviewsArray {
 export function equals(l: PgCatalog.Types.PgMatviewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexes {
 export function equals(l: PgCatalog.Types.PgIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexesArray {
 export function equals(l: PgCatalog.Types.PgIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequences {
 export function equals(l: PgCatalog.Types.PgSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequencesArray {
 export function equals(l: PgCatalog.Types.PgSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStats {
 export function equals(l: PgCatalog.Types.PgStats|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsArray {
 export function equals(l: PgCatalog.Types.PgStatsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExt {
 export function equals(l: PgCatalog.Types.PgStatsExt|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtArray {
 export function equals(l: PgCatalog.Types.PgStatsExtArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtExprs {
 export function equals(l: PgCatalog.Types.PgStatsExtExprs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatsExtExprsArray {
 export function equals(l: PgCatalog.Types.PgStatsExtExprsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationTables {
 export function equals(l: PgCatalog.Types.PgPublicationTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationTablesArray {
 export function equals(l: PgCatalog.Types.PgPublicationTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLocks {
 export function equals(l: PgCatalog.Types.PgLocks|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLocksArray {
 export function equals(l: PgCatalog.Types.PgLocksArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCursors {
 export function equals(l: PgCatalog.Types.PgCursors|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCursorsArray {
 export function equals(l: PgCatalog.Types.PgCursorsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensions {
 export function equals(l: PgCatalog.Types.PgAvailableExtensions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionsArray {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionVersions {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionVersions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAvailableExtensionVersionsArray {
 export function equals(l: PgCatalog.Types.PgAvailableExtensionVersionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedXacts {
 export function equals(l: PgCatalog.Types.PgPreparedXacts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedXactsArray {
 export function equals(l: PgCatalog.Types.PgPreparedXactsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedStatements {
 export function equals(l: PgCatalog.Types.PgPreparedStatements|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPreparedStatementsArray {
 export function equals(l: PgCatalog.Types.PgPreparedStatementsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabels {
 export function equals(l: PgCatalog.Types.PgSeclabels|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelsArray {
 export function equals(l: PgCatalog.Types.PgSeclabelsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSettings {
 export function equals(l: PgCatalog.Types.PgSettings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSettingsArray {
 export function equals(l: PgCatalog.Types.PgSettingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgFileSettings {
 export function equals(l: PgCatalog.Types.PgFileSettings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgFileSettingsArray {
 export function equals(l: PgCatalog.Types.PgFileSettingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgHbaFileRules {
 export function equals(l: PgCatalog.Types.PgHbaFileRules|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgHbaFileRulesArray {
 export function equals(l: PgCatalog.Types.PgHbaFileRulesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIdentFileMappings {
 export function equals(l: PgCatalog.Types.PgIdentFileMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIdentFileMappingsArray {
 export function equals(l: PgCatalog.Types.PgIdentFileMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneAbbrevs {
 export function equals(l: PgCatalog.Types.PgTimezoneAbbrevs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneAbbrevsArray {
 export function equals(l: PgCatalog.Types.PgTimezoneAbbrevsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneNames {
 export function equals(l: PgCatalog.Types.PgTimezoneNames|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTimezoneNamesArray {
 export function equals(l: PgCatalog.Types.PgTimezoneNamesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConfig {
 export function equals(l: PgCatalog.Types.PgConfig|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConfigArray {
 export function equals(l: PgCatalog.Types.PgConfigArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShmemAllocations {
 export function equals(l: PgCatalog.Types.PgShmemAllocations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShmemAllocationsArray {
 export function equals(l: PgCatalog.Types.PgShmemAllocationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBackendMemoryContexts {
 export function equals(l: PgCatalog.Types.PgBackendMemoryContexts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgBackendMemoryContextsArray {
 export function equals(l: PgCatalog.Types.PgBackendMemoryContextsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllTables {
 export function equals(l: PgCatalog.Types.PgStatAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactAllTables {
 export function equals(l: PgCatalog.Types.PgStatXactAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysTables {
 export function equals(l: PgCatalog.Types.PgStatSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactSysTables {
 export function equals(l: PgCatalog.Types.PgStatXactSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserTables {
 export function equals(l: PgCatalog.Types.PgStatUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserTables {
 export function equals(l: PgCatalog.Types.PgStatXactUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatXactUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllTables {
 export function equals(l: PgCatalog.Types.PgStatioAllTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysTables {
 export function equals(l: PgCatalog.Types.PgStatioSysTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserTables {
 export function equals(l: PgCatalog.Types.PgStatioUserTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserTablesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllIndexes {
 export function equals(l: PgCatalog.Types.PgStatAllIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatAllIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatAllIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysIndexes {
 export function equals(l: PgCatalog.Types.PgStatSysIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSysIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatSysIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserIndexes {
 export function equals(l: PgCatalog.Types.PgStatUserIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatUserIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllIndexes {
 export function equals(l: PgCatalog.Types.PgStatioAllIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysIndexes {
 export function equals(l: PgCatalog.Types.PgStatioSysIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserIndexes {
 export function equals(l: PgCatalog.Types.PgStatioUserIndexes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserIndexesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserIndexesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllSequences {
 export function equals(l: PgCatalog.Types.PgStatioAllSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioAllSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioAllSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysSequences {
 export function equals(l: PgCatalog.Types.PgStatioSysSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioSysSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioSysSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserSequences {
 export function equals(l: PgCatalog.Types.PgStatioUserSequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatioUserSequencesArray {
 export function equals(l: PgCatalog.Types.PgStatioUserSequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatActivity {
 export function equals(l: PgCatalog.Types.PgStatActivity|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatActivityArray {
 export function equals(l: PgCatalog.Types.PgStatActivityArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplication {
 export function equals(l: PgCatalog.Types.PgStatReplication|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationArray {
 export function equals(l: PgCatalog.Types.PgStatReplicationArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSlru {
 export function equals(l: PgCatalog.Types.PgStatSlru|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSlruArray {
 export function equals(l: PgCatalog.Types.PgStatSlruArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalReceiver {
 export function equals(l: PgCatalog.Types.PgStatWalReceiver|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalReceiverArray {
 export function equals(l: PgCatalog.Types.PgStatWalReceiverArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatRecoveryPrefetch {
 export function equals(l: PgCatalog.Types.PgStatRecoveryPrefetch|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatRecoveryPrefetchArray {
 export function equals(l: PgCatalog.Types.PgStatRecoveryPrefetchArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscription {
 export function equals(l: PgCatalog.Types.PgStatSubscription|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionArray {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSsl {
 export function equals(l: PgCatalog.Types.PgStatSsl|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSslArray {
 export function equals(l: PgCatalog.Types.PgStatSslArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatGssapi {
 export function equals(l: PgCatalog.Types.PgStatGssapi|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatGssapiArray {
 export function equals(l: PgCatalog.Types.PgStatGssapiArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationSlots {
 export function equals(l: PgCatalog.Types.PgReplicationSlots|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationSlotsArray {
 export function equals(l: PgCatalog.Types.PgReplicationSlotsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationSlots {
 export function equals(l: PgCatalog.Types.PgStatReplicationSlots|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatReplicationSlotsArray {
 export function equals(l: PgCatalog.Types.PgStatReplicationSlotsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabase {
 export function equals(l: PgCatalog.Types.PgStatDatabase|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseArray {
 export function equals(l: PgCatalog.Types.PgStatDatabaseArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseConflicts {
 export function equals(l: PgCatalog.Types.PgStatDatabaseConflicts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatDatabaseConflictsArray {
 export function equals(l: PgCatalog.Types.PgStatDatabaseConflictsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserFunctions {
 export function equals(l: PgCatalog.Types.PgStatUserFunctions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatUserFunctionsArray {
 export function equals(l: PgCatalog.Types.PgStatUserFunctionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserFunctions {
 export function equals(l: PgCatalog.Types.PgStatXactUserFunctions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatXactUserFunctionsArray {
 export function equals(l: PgCatalog.Types.PgStatXactUserFunctionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatArchiver {
 export function equals(l: PgCatalog.Types.PgStatArchiver|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatArchiverArray {
 export function equals(l: PgCatalog.Types.PgStatArchiverArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatBgwriter {
 export function equals(l: PgCatalog.Types.PgStatBgwriter|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatBgwriterArray {
 export function equals(l: PgCatalog.Types.PgStatBgwriterArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatIo {
 export function equals(l: PgCatalog.Types.PgStatIo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatIoArray {
 export function equals(l: PgCatalog.Types.PgStatIoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWal {
 export function equals(l: PgCatalog.Types.PgStatWal|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatWalArray {
 export function equals(l: PgCatalog.Types.PgStatWalArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressAnalyze {
 export function equals(l: PgCatalog.Types.PgStatProgressAnalyze|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressAnalyzeArray {
 export function equals(l: PgCatalog.Types.PgStatProgressAnalyzeArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressVacuum {
 export function equals(l: PgCatalog.Types.PgStatProgressVacuum|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressVacuumArray {
 export function equals(l: PgCatalog.Types.PgStatProgressVacuumArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCluster {
 export function equals(l: PgCatalog.Types.PgStatProgressCluster|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressClusterArray {
 export function equals(l: PgCatalog.Types.PgStatProgressClusterArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCreateIndex {
 export function equals(l: PgCatalog.Types.PgStatProgressCreateIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCreateIndexArray {
 export function equals(l: PgCatalog.Types.PgStatProgressCreateIndexArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressBasebackup {
 export function equals(l: PgCatalog.Types.PgStatProgressBasebackup|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressBasebackupArray {
 export function equals(l: PgCatalog.Types.PgStatProgressBasebackupArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCopy {
 export function equals(l: PgCatalog.Types.PgStatProgressCopy|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatProgressCopyArray {
 export function equals(l: PgCatalog.Types.PgStatProgressCopyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappings {
 export function equals(l: PgCatalog.Types.PgUserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingsArray {
 export function equals(l: PgCatalog.Types.PgUserMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginStatus {
 export function equals(l: PgCatalog.Types.PgReplicationOriginStatus|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginStatusArray {
 export function equals(l: PgCatalog.Types.PgReplicationOriginStatusArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionStats {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionStats|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatSubscriptionStatsArray {
 export function equals(l: PgCatalog.Types.PgStatSubscriptionStatsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcOidIndex {
 export function equals(l: PgCatalog.Types.PgProcOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgProcPronameArgsNspIndex {
 export function equals(l: PgCatalog.Types.PgProcPronameArgsNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeOidIndex {
 export function equals(l: PgCatalog.Types.PgTypeOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTypeTypnameNspIndex {
 export function equals(l: PgCatalog.Types.PgTypeTypnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeRelidAttnamIndex {
 export function equals(l: PgCatalog.Types.PgAttributeRelidAttnamIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttributeRelidAttnumIndex {
 export function equals(l: PgCatalog.Types.PgAttributeRelidAttnumIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassOidIndex {
 export function equals(l: PgCatalog.Types.PgClassOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassRelnameNspIndex {
 export function equals(l: PgCatalog.Types.PgClassRelnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgClassTblspcRelfilenodeIndex {
 export function equals(l: PgCatalog.Types.PgClassTblspcRelfilenodeIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefAdrelidAdnumIndex {
 export function equals(l: PgCatalog.Types.PgAttrdefAdrelidAdnumIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAttrdefOidIndex {
 export function equals(l: PgCatalog.Types.PgAttrdefOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConnameNspIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConnameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConrelidContypidConnameIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConrelidContypidConnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintContypidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintContypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintOidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConstraintConparentidIndex {
 export function equals(l: PgCatalog.Types.PgConstraintConparentidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsRelidSeqnoIndex {
 export function equals(l: PgCatalog.Types.PgInheritsRelidSeqnoIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInheritsParentIndex {
 export function equals(l: PgCatalog.Types.PgInheritsParentIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexIndrelidIndex {
 export function equals(l: PgCatalog.Types.PgIndexIndrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgIndexIndexrelidIndex {
 export function equals(l: PgCatalog.Types.PgIndexIndexrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorOidIndex {
 export function equals(l: PgCatalog.Types.PgOperatorOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOperatorOprnameLRNIndex {
 export function equals(l: PgCatalog.Types.PgOperatorOprnameLRNIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyAmNameNspIndex {
 export function equals(l: PgCatalog.Types.PgOpfamilyAmNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpfamilyOidIndex {
 export function equals(l: PgCatalog.Types.PgOpfamilyOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassAmNameNspIndex {
 export function equals(l: PgCatalog.Types.PgOpclassAmNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgOpclassOidIndex {
 export function equals(l: PgCatalog.Types.PgOpclassOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmNameIndex {
 export function equals(l: PgCatalog.Types.PgAmNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmOidIndex {
 export function equals(l: PgCatalog.Types.PgAmOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopFamStratIndex {
 export function equals(l: PgCatalog.Types.PgAmopFamStratIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopOprFamIndex {
 export function equals(l: PgCatalog.Types.PgAmopOprFamIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmopOidIndex {
 export function equals(l: PgCatalog.Types.PgAmopOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocFamProcIndex {
 export function equals(l: PgCatalog.Types.PgAmprocFamProcIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAmprocOidIndex {
 export function equals(l: PgCatalog.Types.PgAmprocOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageNameIndex {
 export function equals(l: PgCatalog.Types.PgLanguageNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLanguageOidIndex {
 export function equals(l: PgCatalog.Types.PgLanguageOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectMetadataOidIndex {
 export function equals(l: PgCatalog.Types.PgLargeobjectMetadataOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgLargeobjectLoidPnIndex {
 export function equals(l: PgCatalog.Types.PgLargeobjectLoidPnIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAggregateFnoidIndex {
 export function equals(l: PgCatalog.Types.PgAggregateFnoidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticRelidAttInhIndex {
 export function equals(l: PgCatalog.Types.PgStatisticRelidAttInhIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtOidIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtNameIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtRelidIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtRelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgStatisticExtDataStxoidInhIndex {
 export function equals(l: PgCatalog.Types.PgStatisticExtDataStxoidInhIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteOidIndex {
 export function equals(l: PgCatalog.Types.PgRewriteOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRewriteRelRulenameIndex {
 export function equals(l: PgCatalog.Types.PgRewriteRelRulenameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerTgconstraintIndex {
 export function equals(l: PgCatalog.Types.PgTriggerTgconstraintIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerTgrelidTgnameIndex {
 export function equals(l: PgCatalog.Types.PgTriggerTgrelidTgnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTriggerOidIndex {
 export function equals(l: PgCatalog.Types.PgTriggerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerEvtnameIndex {
 export function equals(l: PgCatalog.Types.PgEventTriggerEvtnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEventTriggerOidIndex {
 export function equals(l: PgCatalog.Types.PgEventTriggerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDescriptionOCOIndex {
 export function equals(l: PgCatalog.Types.PgDescriptionOCOIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastOidIndex {
 export function equals(l: PgCatalog.Types.PgCastOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCastSourceTargetIndex {
 export function equals(l: PgCatalog.Types.PgCastSourceTargetIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumOidIndex {
 export function equals(l: PgCatalog.Types.PgEnumOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumTypidLabelIndex {
 export function equals(l: PgCatalog.Types.PgEnumTypidLabelIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgEnumTypidSortorderIndex {
 export function equals(l: PgCatalog.Types.PgEnumTypidSortorderIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceNspnameIndex {
 export function equals(l: PgCatalog.Types.PgNamespaceNspnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgNamespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgNamespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionDefaultIndex {
 export function equals(l: PgCatalog.Types.PgConversionDefaultIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionNameNspIndex {
 export function equals(l: PgCatalog.Types.PgConversionNameNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgConversionOidIndex {
 export function equals(l: PgCatalog.Types.PgConversionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependDependerIndex {
 export function equals(l: PgCatalog.Types.PgDependDependerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDependReferenceIndex {
 export function equals(l: PgCatalog.Types.PgDependReferenceIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseDatnameIndex {
 export function equals(l: PgCatalog.Types.PgDatabaseDatnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDatabaseOidIndex {
 export function equals(l: PgCatalog.Types.PgDatabaseOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDbRoleSettingDatabaseidRolIndex {
 export function equals(l: PgCatalog.Types.PgDbRoleSettingDatabaseidRolIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgTablespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTablespaceSpcnameIndex {
 export function equals(l: PgCatalog.Types.PgTablespaceSpcnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidRolnameIndex {
 export function equals(l: PgCatalog.Types.PgAuthidRolnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthidOidIndex {
 export function equals(l: PgCatalog.Types.PgAuthidOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersOidIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersRoleMemberIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersRoleMemberIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersMemberRoleIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersMemberRoleIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgAuthMembersGrantorIndex {
 export function equals(l: PgCatalog.Types.PgAuthMembersGrantorIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependDependerIndex {
 export function equals(l: PgCatalog.Types.PgShdependDependerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdependReferenceIndex {
 export function equals(l: PgCatalog.Types.PgShdependReferenceIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShdescriptionOCIndex {
 export function equals(l: PgCatalog.Types.PgShdescriptionOCIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigCfgnameIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigCfgnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigOidIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsConfigMapIndex {
 export function equals(l: PgCatalog.Types.PgTsConfigMapIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictDictnameIndex {
 export function equals(l: PgCatalog.Types.PgTsDictDictnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsDictOidIndex {
 export function equals(l: PgCatalog.Types.PgTsDictOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserPrsnameIndex {
 export function equals(l: PgCatalog.Types.PgTsParserPrsnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsParserOidIndex {
 export function equals(l: PgCatalog.Types.PgTsParserOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateTmplnameIndex {
 export function equals(l: PgCatalog.Types.PgTsTemplateTmplnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTsTemplateOidIndex {
 export function equals(l: PgCatalog.Types.PgTsTemplateOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionOidIndex {
 export function equals(l: PgCatalog.Types.PgExtensionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgExtensionNameIndex {
 export function equals(l: PgCatalog.Types.PgExtensionNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperOidIndex {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrapperNameIndex {
 export function equals(l: PgCatalog.Types.PgForeignDataWrapperNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerOidIndex {
 export function equals(l: PgCatalog.Types.PgForeignServerOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServerNameIndex {
 export function equals(l: PgCatalog.Types.PgForeignServerNameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingOidIndex {
 export function equals(l: PgCatalog.Types.PgUserMappingOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappingUserServerIndex {
 export function equals(l: PgCatalog.Types.PgUserMappingUserServerIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableRelidIndex {
 export function equals(l: PgCatalog.Types.PgForeignTableRelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyOidIndex {
 export function equals(l: PgCatalog.Types.PgPolicyOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPolicyPolrelidPolnameIndex {
 export function equals(l: PgCatalog.Types.PgPolicyPolrelidPolnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginRoiidentIndex {
 export function equals(l: PgCatalog.Types.PgReplicationOriginRoiidentIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgReplicationOriginRonameIndex {
 export function equals(l: PgCatalog.Types.PgReplicationOriginRonameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclRoleNspObjIndex {
 export function equals(l: PgCatalog.Types.PgDefaultAclRoleNspObjIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgDefaultAclOidIndex {
 export function equals(l: PgCatalog.Types.PgDefaultAclOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgInitPrivsOCOIndex {
 export function equals(l: PgCatalog.Types.PgInitPrivsOCOIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSeclabelObjectIndex {
 export function equals(l: PgCatalog.Types.PgSeclabelObjectIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgShseclabelObjectIndex {
 export function equals(l: PgCatalog.Types.PgShseclabelObjectIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationNameEncNspIndex {
 export function equals(l: PgCatalog.Types.PgCollationNameEncNspIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgCollationOidIndex {
 export function equals(l: PgCatalog.Types.PgCollationOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclParnameIndex {
 export function equals(l: PgCatalog.Types.PgParameterAclParnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgParameterAclOidIndex {
 export function equals(l: PgCatalog.Types.PgParameterAclOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPartitionedTablePartrelidIndex {
 export function equals(l: PgCatalog.Types.PgPartitionedTablePartrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeRngtypidIndex {
 export function equals(l: PgCatalog.Types.PgRangeRngtypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgRangeRngmultitypidIndex {
 export function equals(l: PgCatalog.Types.PgRangeRngmultitypidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformOidIndex {
 export function equals(l: PgCatalog.Types.PgTransformOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgTransformTypeLangIndex {
 export function equals(l: PgCatalog.Types.PgTransformTypeLangIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSequenceSeqrelidIndex {
 export function equals(l: PgCatalog.Types.PgSequenceSeqrelidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationPubnameIndex {
 export function equals(l: PgCatalog.Types.PgPublicationPubnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespaceOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationNamespaceOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationNamespacePnnspidPnpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelOidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelPrrelidPrpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelPrrelidPrpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgPublicationRelPrpubidIndex {
 export function equals(l: PgCatalog.Types.PgPublicationRelPrpubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionOidIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionOidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionSubnameIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionSubnameIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
 export function equals(l: PgCatalog.Types.PgSubscriptionRelSrrelidSrsubidIndex|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
}
export namespace PgType {
}
export namespace PgForeignTable {
}
export namespace PgAuthid {
}
export namespace PgStatisticExtData {
}
export namespace PgUserMapping {
}
export namespace PgSubscription {
}
export namespace PgAttribute {
}
export namespace PgProc {
}
export namespace PgClass {
}
export namespace PgAttrdef {
}
export namespace PgConstraint {
}
export namespace PgInherits {
}
export namespace PgIndex {
}
export namespace PgOperator {
}
export namespace PgOpfamily {
}
export namespace PgOpclass {
}
export namespace PgAm {
}
export namespace PgAmop {
}
export namespace PgAmproc {
}
export namespace PgLanguage {
}
export namespace PgLargeobjectMetadata {
}
export namespace PgAggregate {
}
export namespace PgStatisticExt {
}
export namespace PgRewrite {
}
export namespace PgTrigger {
}
export namespace PgEventTrigger {
}
export namespace PgDescription {
}
export namespace PgCast {
}
export namespace PgEnum {
}
export namespace PgNamespace {
}
export namespace PgConversion {
}
export namespace PgDepend {
}
export namespace PgDatabase {
}
export namespace PgDbRoleSetting {
}
export namespace PgTablespace {
}
export namespace PgAuthMembers {
}
export namespace PgShdepend {
}
export namespace PgShdescription {
}
export namespace PgTsConfig {
}
export namespace PgTsConfigMap {
}
export namespace PgTsDict {
}
export namespace PgTsParser {
}
export namespace PgTsTemplate {
}
export namespace PgExtension {
}
export namespace PgForeignDataWrapper {
}
export namespace PgForeignServer {
}
export namespace PgPolicy {
}
export namespace PgReplicationOrigin {
}
export namespace PgDefaultAcl {
}
export namespace PgInitPrivs {
}
export namespace PgSeclabel {
}
export namespace PgShseclabel {
}
export namespace PgCollation {
}
export namespace PgParameterAcl {
}
export namespace PgPartitionedTable {
}
export namespace PgRange {
}
export namespace PgTransform {
}
export namespace PgSequence {
}
export namespace PgPublication {
}
export namespace PgPublicationNamespace {
}
export namespace PgPublicationRel {
}
export namespace PgSubscriptionRel {
}
export namespace PgLargeobject {
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace CardinalNumber {
 export function equals(l: InformationSchema.Types.CardinalNumber|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CardinalNumberArray {
 export function equals(l: InformationSchema.Types.CardinalNumberArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterData {
 export function equals(l: InformationSchema.Types.CharacterData|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterDataArray {
 export function equals(l: InformationSchema.Types.CharacterDataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlIdentifier {
 export function equals(l: InformationSchema.Types.SqlIdentifier|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlIdentifierArray {
 export function equals(l: InformationSchema.Types.SqlIdentifierArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InformationSchemaCatalogName {
 export function equals(l: InformationSchema.Types.InformationSchemaCatalogName|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace InformationSchemaCatalogNameArray {
 export function equals(l: InformationSchema.Types.InformationSchemaCatalogNameArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeStamp {
 export function equals(l: InformationSchema.Types.TimeStamp|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TimeStampArray {
 export function equals(l: InformationSchema.Types.TimeStampArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace YesOrNo {
 export function equals(l: InformationSchema.Types.YesOrNo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace YesOrNoArray {
 export function equals(l: InformationSchema.Types.YesOrNoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ApplicableRoles {
 export function equals(l: InformationSchema.Types.ApplicableRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ApplicableRolesArray {
 export function equals(l: InformationSchema.Types.ApplicableRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AdministrableRoleAuthorizations {
 export function equals(l: InformationSchema.Types.AdministrableRoleAuthorizations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AdministrableRoleAuthorizationsArray {
 export function equals(l: InformationSchema.Types.AdministrableRoleAuthorizationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Attributes {
 export function equals(l: InformationSchema.Types.Attributes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace AttributesArray {
 export function equals(l: InformationSchema.Types.AttributesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterSets {
 export function equals(l: InformationSchema.Types.CharacterSets|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CharacterSetsArray {
 export function equals(l: InformationSchema.Types.CharacterSetsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintRoutineUsage {
 export function equals(l: InformationSchema.Types.CheckConstraintRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintRoutineUsageArray {
 export function equals(l: InformationSchema.Types.CheckConstraintRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraints {
 export function equals(l: InformationSchema.Types.CheckConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CheckConstraintsArray {
 export function equals(l: InformationSchema.Types.CheckConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Collations {
 export function equals(l: InformationSchema.Types.Collations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationsArray {
 export function equals(l: InformationSchema.Types.CollationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationCharacterSetApplicability {
 export function equals(l: InformationSchema.Types.CollationCharacterSetApplicability|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace CollationCharacterSetApplicabilityArray {
 export function equals(l: InformationSchema.Types.CollationCharacterSetApplicabilityArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnColumnUsage {
 export function equals(l: InformationSchema.Types.ColumnColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnColumnUsageArray {
 export function equals(l: InformationSchema.Types.ColumnColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnDomainUsage {
 export function equals(l: InformationSchema.Types.ColumnDomainUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnDomainUsageArray {
 export function equals(l: InformationSchema.Types.ColumnDomainUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnPrivileges {
 export function equals(l: InformationSchema.Types.ColumnPrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnPrivilegesArray {
 export function equals(l: InformationSchema.Types.ColumnPrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnUdtUsage {
 export function equals(l: InformationSchema.Types.ColumnUdtUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnUdtUsageArray {
 export function equals(l: InformationSchema.Types.ColumnUdtUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Columns {
 export function equals(l: InformationSchema.Types.Columns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnsArray {
 export function equals(l: InformationSchema.Types.ColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintColumnUsage {
 export function equals(l: InformationSchema.Types.ConstraintColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintColumnUsageArray {
 export function equals(l: InformationSchema.Types.ConstraintColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintTableUsage {
 export function equals(l: InformationSchema.Types.ConstraintTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ConstraintTableUsageArray {
 export function equals(l: InformationSchema.Types.ConstraintTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainConstraints {
 export function equals(l: InformationSchema.Types.DomainConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainConstraintsArray {
 export function equals(l: InformationSchema.Types.DomainConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainUdtUsage {
 export function equals(l: InformationSchema.Types.DomainUdtUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainUdtUsageArray {
 export function equals(l: InformationSchema.Types.DomainUdtUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Domains {
 export function equals(l: InformationSchema.Types.Domains|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DomainsArray {
 export function equals(l: InformationSchema.Types.DomainsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EnabledRoles {
 export function equals(l: InformationSchema.Types.EnabledRoles|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace EnabledRolesArray {
 export function equals(l: InformationSchema.Types.EnabledRolesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace KeyColumnUsage {
 export function equals(l: InformationSchema.Types.KeyColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace KeyColumnUsageArray {
 export function equals(l: InformationSchema.Types.KeyColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Parameters {
 export function equals(l: InformationSchema.Types.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ParametersArray {
 export function equals(l: InformationSchema.Types.ParametersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ReferentialConstraints {
 export function equals(l: InformationSchema.Types.ReferentialConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ReferentialConstraintsArray {
 export function equals(l: InformationSchema.Types.ReferentialConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleColumnGrants {
 export function equals(l: InformationSchema.Types.RoleColumnGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleColumnGrantsArray {
 export function equals(l: InformationSchema.Types.RoleColumnGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineColumnUsage {
 export function equals(l: InformationSchema.Types.RoutineColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineColumnUsageArray {
 export function equals(l: InformationSchema.Types.RoutineColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinePrivileges {
 export function equals(l: InformationSchema.Types.RoutinePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinePrivilegesArray {
 export function equals(l: InformationSchema.Types.RoutinePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleRoutineGrants {
 export function equals(l: InformationSchema.Types.RoleRoutineGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleRoutineGrantsArray {
 export function equals(l: InformationSchema.Types.RoleRoutineGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineRoutineUsage {
 export function equals(l: InformationSchema.Types.RoutineRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineRoutineUsageArray {
 export function equals(l: InformationSchema.Types.RoutineRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineSequenceUsage {
 export function equals(l: InformationSchema.Types.RoutineSequenceUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineSequenceUsageArray {
 export function equals(l: InformationSchema.Types.RoutineSequenceUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineTableUsage {
 export function equals(l: InformationSchema.Types.RoutineTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutineTableUsageArray {
 export function equals(l: InformationSchema.Types.RoutineTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Routines {
 export function equals(l: InformationSchema.Types.Routines|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoutinesArray {
 export function equals(l: InformationSchema.Types.RoutinesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Schemata {
 export function equals(l: InformationSchema.Types.Schemata|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SchemataArray {
 export function equals(l: InformationSchema.Types.SchemataArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Sequences {
 export function equals(l: InformationSchema.Types.Sequences|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SequencesArray {
 export function equals(l: InformationSchema.Types.SequencesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlFeatures {
 export function equals(l: InformationSchema.Types.SqlFeatures|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlFeaturesArray {
 export function equals(l: InformationSchema.Types.SqlFeaturesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlImplementationInfo {
 export function equals(l: InformationSchema.Types.SqlImplementationInfo|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlImplementationInfoArray {
 export function equals(l: InformationSchema.Types.SqlImplementationInfoArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlParts {
 export function equals(l: InformationSchema.Types.SqlParts|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlPartsArray {
 export function equals(l: InformationSchema.Types.SqlPartsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlSizing {
 export function equals(l: InformationSchema.Types.SqlSizing|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SqlSizingArray {
 export function equals(l: InformationSchema.Types.SqlSizingArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableConstraints {
 export function equals(l: InformationSchema.Types.TableConstraints|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TableConstraintsArray {
 export function equals(l: InformationSchema.Types.TableConstraintsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablePrivileges {
 export function equals(l: InformationSchema.Types.TablePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablePrivilegesArray {
 export function equals(l: InformationSchema.Types.TablePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleTableGrants {
 export function equals(l: InformationSchema.Types.RoleTableGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleTableGrantsArray {
 export function equals(l: InformationSchema.Types.RoleTableGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Tables {
 export function equals(l: InformationSchema.Types.Tables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TablesArray {
 export function equals(l: InformationSchema.Types.TablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Transforms {
 export function equals(l: InformationSchema.Types.Transforms|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TransformsArray {
 export function equals(l: InformationSchema.Types.TransformsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggeredUpdateColumns {
 export function equals(l: InformationSchema.Types.TriggeredUpdateColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggeredUpdateColumnsArray {
 export function equals(l: InformationSchema.Types.TriggeredUpdateColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Triggers {
 export function equals(l: InformationSchema.Types.Triggers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace TriggersArray {
 export function equals(l: InformationSchema.Types.TriggersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UdtPrivileges {
 export function equals(l: InformationSchema.Types.UdtPrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UdtPrivilegesArray {
 export function equals(l: InformationSchema.Types.UdtPrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUdtGrants {
 export function equals(l: InformationSchema.Types.RoleUdtGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUdtGrantsArray {
 export function equals(l: InformationSchema.Types.RoleUdtGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UsagePrivileges {
 export function equals(l: InformationSchema.Types.UsagePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UsagePrivilegesArray {
 export function equals(l: InformationSchema.Types.UsagePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUsageGrants {
 export function equals(l: InformationSchema.Types.RoleUsageGrants|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace RoleUsageGrantsArray {
 export function equals(l: InformationSchema.Types.RoleUsageGrantsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserDefinedTypes {
 export function equals(l: InformationSchema.Types.UserDefinedTypes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserDefinedTypesArray {
 export function equals(l: InformationSchema.Types.UserDefinedTypesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewColumnUsage {
 export function equals(l: InformationSchema.Types.ViewColumnUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewColumnUsageArray {
 export function equals(l: InformationSchema.Types.ViewColumnUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewRoutineUsage {
 export function equals(l: InformationSchema.Types.ViewRoutineUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewRoutineUsageArray {
 export function equals(l: InformationSchema.Types.ViewRoutineUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewTableUsage {
 export function equals(l: InformationSchema.Types.ViewTableUsage|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewTableUsageArray {
 export function equals(l: InformationSchema.Types.ViewTableUsageArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Views {
 export function equals(l: InformationSchema.Types.Views|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ViewsArray {
 export function equals(l: InformationSchema.Types.ViewsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DataTypePrivileges {
 export function equals(l: InformationSchema.Types.DataTypePrivileges|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace DataTypePrivilegesArray {
 export function equals(l: InformationSchema.Types.DataTypePrivilegesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ElementTypes {
 export function equals(l: InformationSchema.Types.ElementTypes|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ElementTypesArray {
 export function equals(l: InformationSchema.Types.ElementTypesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTableColumns {
 export function equals(l: InformationSchema.Types.PgForeignTableColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnOptions {
 export function equals(l: InformationSchema.Types.ColumnOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ColumnOptionsArray {
 export function equals(l: InformationSchema.Types.ColumnOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignDataWrappers {
 export function equals(l: InformationSchema.Types.PgForeignDataWrappers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrapperOptions {
 export function equals(l: InformationSchema.Types.ForeignDataWrapperOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrapperOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignDataWrapperOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrappers {
 export function equals(l: InformationSchema.Types.ForeignDataWrappers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignDataWrappersArray {
 export function equals(l: InformationSchema.Types.ForeignDataWrappersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignServers {
 export function equals(l: InformationSchema.Types.PgForeignServers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServerOptions {
 export function equals(l: InformationSchema.Types.ForeignServerOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServerOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignServerOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServers {
 export function equals(l: InformationSchema.Types.ForeignServers|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignServersArray {
 export function equals(l: InformationSchema.Types.ForeignServersArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgForeignTables {
 export function equals(l: InformationSchema.Types.PgForeignTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTableOptions {
 export function equals(l: InformationSchema.Types.ForeignTableOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTableOptionsArray {
 export function equals(l: InformationSchema.Types.ForeignTableOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTables {
 export function equals(l: InformationSchema.Types.ForeignTables|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ForeignTablesArray {
 export function equals(l: InformationSchema.Types.ForeignTablesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgUserMappings {
 export function equals(l: InformationSchema.Types.PgUserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingOptions {
 export function equals(l: InformationSchema.Types.UserMappingOptions|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingOptionsArray {
 export function equals(l: InformationSchema.Types.UserMappingOptionsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappings {
 export function equals(l: InformationSchema.Types.UserMappings|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace UserMappingsArray {
 export function equals(l: InformationSchema.Types.UserMappingsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
}
export namespace SqlImplementationInfo {
}
export namespace SqlParts {
}
export namespace SqlSizing {
}
}
}
export namespace Public {
export namespace Types {
export namespace Spheroid {
 export function equals(l: Public.Types.Spheroid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpheroidArray {
 export function equals(l: Public.Types.SpheroidArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Geometry {
 export function equals(l: Public.Types.Geometry|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryArray {
 export function equals(l: Public.Types.GeometryArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box3d {
 export function equals(l: Public.Types.Box3d|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box3dArray {
 export function equals(l: Public.Types.Box3dArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2d {
 export function equals(l: Public.Types.Box2d|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2dArray {
 export function equals(l: Public.Types.Box2dArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2df {
 export function equals(l: Public.Types.Box2df|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Box2dfArray {
 export function equals(l: Public.Types.Box2dfArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Gidx {
 export function equals(l: Public.Types.Gidx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GidxArray {
 export function equals(l: Public.Types.GidxArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryDump {
 export function equals(l: Public.Types.GeometryDump|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryDumpArray {
 export function equals(l: Public.Types.GeometryDumpArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSys {
 export function equals(l: Public.Types.SpatialRefSys|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSysArray {
 export function equals(l: Public.Types.SpatialRefSysArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ValidDetail {
 export function equals(l: Public.Types.ValidDetail|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace ValidDetailArray {
 export function equals(l: Public.Types.ValidDetailArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace Geography {
 export function equals(l: Public.Types.Geography|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyArray {
 export function equals(l: Public.Types.GeographyArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyColumns {
 export function equals(l: Public.Types.GeographyColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeographyColumnsArray {
 export function equals(l: Public.Types.GeographyColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryColumns {
 export function equals(l: Public.Types.GeometryColumns|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace GeometryColumnsArray {
 export function equals(l: Public.Types.GeometryColumnsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocks {
 export function equals(l: Public.Types.NycCensusBlocks|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksArray {
 export function equals(l: Public.Types.NycCensusBlocksArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicides {
 export function equals(l: Public.Types.NycHomicides|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesArray {
 export function equals(l: Public.Types.NycHomicidesArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoods {
 export function equals(l: Public.Types.NycNeighborhoods|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsArray {
 export function equals(l: Public.Types.NycNeighborhoodsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreets {
 export function equals(l: Public.Types.NycStreets|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsArray {
 export function equals(l: Public.Types.NycStreetsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStations {
 export function equals(l: Public.Types.NycSubwayStations|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsArray {
 export function equals(l: Public.Types.NycSubwayStationsArray|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace SpatialRefSysPkey {
 export function equals(l: Public.Types.SpatialRefSysPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksPkey {
 export function equals(l: Public.Types.NycCensusBlocksPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesPkey {
 export function equals(l: Public.Types.NycHomicidesPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsPkey {
 export function equals(l: Public.Types.NycNeighborhoodsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsPkey {
 export function equals(l: Public.Types.NycStreetsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsPkey {
 export function equals(l: Public.Types.NycSubwayStationsPkey|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycCensusBlocksGeomIdx {
 export function equals(l: Public.Types.NycCensusBlocksGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycHomicidesGeomIdx {
 export function equals(l: Public.Types.NycHomicidesGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycNeighborhoodsGeomIdx {
 export function equals(l: Public.Types.NycNeighborhoodsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycStreetsGeomIdx {
 export function equals(l: Public.Types.NycStreetsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace NycSubwayStationsGeomIdx {
 export function equals(l: Public.Types.NycSubwayStationsGeomIdx|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrs {
 export function equals(l: Public.Types.PostgisSrs|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrsAll {
 export function equals(l: Public.Types.PostgisSrsAll|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PostgisSrsSearch {
 export function equals(l: Public.Types.PostgisSrsSearch|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StMinimumboundingradius {
 export function equals(l: Public.Types.StMinimumboundingradius|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StMaximuminscribedcircle {
 export function equals(l: Public.Types.StMaximuminscribedcircle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StLargestemptycircle {
 export function equals(l: Public.Types.StLargestemptycircle|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StHexagongrid {
 export function equals(l: Public.Types.StHexagongrid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace StSquaregrid {
 export function equals(l: Public.Types.StSquaregrid|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcepolygoncw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace SpheroidIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.SpheroidIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace SpheroidOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.SpheroidOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryTypmodIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryTypmodIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryTypmodOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryTypmodOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryAnalyze {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryAnalyze.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryRecv {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryRecv.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySend {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_6564 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_6564.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_8997 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_8997.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Point {
export namespace Parameters {
 export function equals(l: Public.Procedures.Point.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryB0d8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryB0d8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Path {
export namespace Parameters {
 export function equals(l: Public.Procedures.Path.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryF1be {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryF1be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Polygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.Polygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StX {
export namespace Parameters {
 export function equals(l: Public.Procedures.StX.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StY {
export namespace Parameters {
 export function equals(l: Public.Procedures.StY.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZ {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZ.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StM {
export namespace Parameters {
 export function equals(l: Public.Procedures.StM.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dfIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dfIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2dfOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2dfOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GidxIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GidxIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GidxOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GidxOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryEq {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryEq.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryCmp {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryCmp.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySortsupport {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySortsupport.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryHash {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryHash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDistance_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDistance_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistCompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistCompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPenalty_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPenalty_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPicksplit_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPicksplit_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistUnion_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistUnion_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSame_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSame_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDecompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDecompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSortsupport_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSortsupport_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcerhr {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcerhr.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisNoop {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisNoop.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcepolygonccw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcepolygonccw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistSel_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistSel_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistSelNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistSelNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistJoinsel_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistJoinsel_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GserializedGistJoinselNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GserializedGistJoinselNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySame {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySame.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCentroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCentroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceBox {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceBox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContains {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContains.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryWithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryWithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryLeft {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryLeft.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverleft {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverleft.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryBelow {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryBelow.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverbelow {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverbelow.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverright {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverright.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryRight {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryRight.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverabove {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverabove.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryAbove {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryAbove.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPenaltyNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPenaltyNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistUnionNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistUnionNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistSameNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistSameNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDecompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDecompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlapsNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlapsNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContainsNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContainsNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryWithinNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryWithinNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySameNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySameNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCentroidNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCentroidNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryDistanceCpa {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryDistanceCpa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryGistDistanceNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryGistDistanceNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShiftlongitude {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShiftlongitude.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWrapx {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWrapx.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StXmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StXmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StYmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StYmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StXmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StXmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StYmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StYmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmax {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmax.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_269a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_269a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_96e3 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_96e3.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisGetbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisGetbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakebox2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakebox2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextentD2f5 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextentD2f5.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextent_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextent_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEstimatedextent_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEstimatedextent_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFindextent_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFindextent_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFindextent_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFindextent_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisAddbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisAddbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisDropbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisDropbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisHasbbox {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisHasbbox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StQuantizecoordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StQuantizecoordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMemsize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMemsize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSummary_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSummary_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNrings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNrings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlength {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlength.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthspheroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthspheroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLength2dspheroid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLength2dspheroid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dperimeter {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dperimeter.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeter2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeter2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeter_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeter_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StArea2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StArea2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StArea_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StArea_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIspolygoncw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIspolygoncw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIspolygonccw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIspolygonccw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancespheroidCd56 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancespheroidCd56.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancespheroid_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancespheroid_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistance_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistance_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointinsidecircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointinsidecircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAzimuth_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAzimuth_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProjectD5eb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProjectD5eb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProject_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProject_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAngleE1dd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAngleE1dd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineextend {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineextend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3dz {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3dz.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce3dm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce3dm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForce4d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForce4d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcecollection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcecollection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionextract_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionextract_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionextract_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionextract_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectionhomogenize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectionhomogenize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMulti {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMulti.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcecurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcecurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcesfs_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcesfs_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StForcesfs_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StForcesfs_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_2074 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_2074.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_704e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_704e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExpand_5500 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExpand_5500.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEnvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEnvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBoundingdiagonal {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBoundingdiagonal.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StReverse {
export namespace Parameters {
 export function equals(l: Public.Procedures.StReverse.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScroll {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScroll.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisGeosNoop {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisGeosNoop.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNormalize {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNormalize.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StZmflag {
export namespace Parameters {
 export function equals(l: Public.Procedures.StZmflag.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNdims {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNdims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstwkb_652e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstwkb_652e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstwkbF3fd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstwkbF3fd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkb_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkb_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAshexewkb_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAshexewkb_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAshexewkb_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAshexewkb_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkb_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkb_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAslatlontext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAslatlontext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geomfromewkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geomfromewkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromewkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromewkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geomfromewkt {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geomfromewkt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromewkt {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromewkt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisCacheBbox {
}
export namespace StMakepoint_0aec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_0aec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepoint_81ec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_81ec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepoint_570b {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepoint_570b.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepointm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepointm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dmakebox {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dmakebox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakelineA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakelineA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefrommultipoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefrommultipoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakeline_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakeline_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddpoint_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddpoint_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScaleD5eb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScaleD5eb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddpointAa17 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddpointAa17.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRemovepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRemovepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakeenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakeenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTileenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTileenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepolygonE2e3 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepolygonE2e3.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakepolygon_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakepolygon_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuildarea {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuildarea.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonizeA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonizeA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClusterintersectingA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClusterintersectingA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClusterwithin_0e49 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClusterwithin_0e49.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinemerge_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinemerge_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinemerge_4ba2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinemerge_4ba2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAffineE42d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAffineE42d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAffine_1962 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAffine_1962.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotate_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotate_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotate_8b9f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotate_8b9f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotate_463e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotate_463e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatez {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatez.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatex {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatex.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRotatey {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRotatey.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTranslate_8b9f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTranslate_8b9f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTranslateD5eb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTranslateD5eb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_1bee {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_1bee.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StScale_8b9f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StScale_8b9f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransscale {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransscale.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDump {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDump.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumprings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumprings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumppoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumppoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDumpsegments {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDumpsegments.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Parameters {
 export function equals(l: Public.Procedures.PopulateGeometryColumns_23fc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PopulateGeometryColumns_4174.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_8fbb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_4617 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_4617.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addgeometrycolumn_093c {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addgeometrycolumn_093c.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrycolumn_0412.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrycolumn_2253.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrycolumnF11a {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrycolumnF11a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Dropgeometrytable_2253 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Dropgeometrytable_2253.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSegmentize_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSegmentize_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrytableF11a {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrytableF11a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace DropgeometrytableBfde {
export namespace Parameters {
 export function equals(l: Public.Procedures.DropgeometrytableBfde.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace UpdategeometrysridB2ee {
export namespace Parameters {
 export function equals(l: Public.Procedures.UpdategeometrysridB2ee.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Updategeometrysrid_7b58 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Updategeometrysrid_7b58.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Updategeometrysrid_11c8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Updategeometrysrid_11c8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace FindSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.FindSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GetProj4FromSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.GetProj4FromSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetsrid_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetsrid_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSrid_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSrid_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTransformGeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTransformGeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrsCodes {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrsCodes.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrs {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrs.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisSrsAll {
}
export namespace PostgisSrsSearch {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisSrsSearch.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransform_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransform_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransform_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransform_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransform_655c {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransform_655c.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransform_5016 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransform_5016.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTransformPipelineGeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTransformpipeline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTransformpipeline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInversetransformpipeline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInversetransformpipeline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisVersion {
}
export namespace PostgisLiblwgeomVersion {
}
export namespace PostgisProjVersion {
}
export namespace PostgisWagyuVersion {
}
export namespace PostgisScriptsInstalled {
}
export namespace PostgisLibVersion {
}
export namespace PostgisScriptsReleased {
}
export namespace PostgisGeosVersion {
}
export namespace PostgisGeosCompiledVersion {
}
export namespace PostgisLibRevision {
}
export namespace PostgisSvnVersion {
}
export namespace PostgisLibxmlVersion {
}
export namespace PostgisScriptsBuildDate {
}
export namespace PostgisLibBuildDate {
}
export namespace PostgisExtensionsUpgrade {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisExtensionsUpgrade.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoint_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoint_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoints_8fda {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoints_8fda.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstringD5eb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstringD5eb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepoint_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepoint_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAddmeasure {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAddmeasure.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpointofapproach {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpointofapproach.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisFullVersion {
}
export namespace Box2d_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2d_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3d_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3d_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box2d_07e9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box2d_07e9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dE505 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dE505.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box_07e9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box_07e9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Text {
export namespace Parameters {
 export function equals(l: Public.Procedures.Text.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Box3dtobox {
export namespace Parameters {
 export function equals(l: Public.Procedures.Box3dtobox.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryE505 {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryE505.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_07e9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_07e9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Bytea_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Bytea_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplify_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplify_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplify_8fda {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplify_8fda.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifyvw {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifyvw.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSeteffectivearea {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSeteffectivearea.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFilterbym {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFilterbym.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StChaikinsmoothing {
export namespace Parameters {
 export function equals(l: Public.Procedures.StChaikinsmoothing.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogrid_5500 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogrid_5500.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogridD5eb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogridD5eb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogrid_7163 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogrid_7163.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnaptogrid_7f2e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnaptogrid_7f2e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancecpa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancecpa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCpawithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCpawithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidtrajectory {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidtrajectory.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersection_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersection_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferBf44 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferBf44.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferC33e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferC33e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumboundingradius {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumboundingradius.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumboundingcircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumboundingcircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOrientedenvelope {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOrientedenvelope.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOffsetcurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOffsetcurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeneratepoints_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeneratepoints_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeneratepointsD341 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeneratepointsD341.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StConvexhull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StConvexhull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifypreservetopology {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifypreservetopology.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidreason_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidreason_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvaliddetail {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvaliddetail.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalidreason_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalidreason_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalid_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalid_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHausdorffdistance_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHausdorffdistance_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHausdorffdistance_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHausdorffdistance_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFrechetdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFrechetdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMaximuminscribedcircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMaximuminscribedcircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLargestemptycircle {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLargestemptycircle.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBoundary {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBoundary.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSymdifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSymdifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSymmetricdifference {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSymmetricdifference.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnion_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnion_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnion_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnion_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnaryunion {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnaryunion.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRemoverepeatedpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRemoverepeatedpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClipbybox2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClipbybox2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSubdivide {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSubdivide.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StReduceprecision {
export namespace Parameters {
 export function equals(l: Public.Procedures.StReduceprecision.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakevalid_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakevalid_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMakevalid_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMakevalid_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCleangeometry {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCleangeometry.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSplit {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSplit.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSharedpaths {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSharedpaths.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSnap {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSnap.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelatematch {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelatematch.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNode {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNode.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDelaunaytriangles {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDelaunaytriangles.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTriangulatepolygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTriangulatepolygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StVoronoipolygons {
export namespace Parameters {
 export function equals(l: Public.Procedures.StVoronoipolygons.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StVoronoilines {
export namespace Parameters {
 export function equals(l: Public.Procedures.StVoronoilines.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebbox_1ee2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebbox_1ee2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebbox_9d67 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebbox_9d67.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCombinebbox_1a7e {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCombinebbox_1a7e.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollect_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollect_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCollectA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCollectA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfn_43cf {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfn_43cf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfn_7c68 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfn_7c68.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryAccumTransfn_0b93 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryAccumTransfn_0b93.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryCollectFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryPolygonizeFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryClusterintersectingFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryClusterwithinFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryMakelineFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryCoverageunionFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelTransfn_43cf {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelTransfn_43cf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelTransfn_7c68 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelTransfn_7c68.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelCombinefn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelSerialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelDeserialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisGeometryUnionParallelFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StUnionA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StUnionA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoverageunionA4b6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoverageunionA4b6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelate_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelate_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelateAa17 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelateAa17.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StRelateCaf9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StRelateCaf9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDisjoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDisjoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisIndexSupportfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisIndexSupportfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinecrossingdirection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinecrossingdirection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithin_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithin_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StTouches {
export namespace Parameters {
 export function equals(l: Public.Procedures.StTouches.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersects_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersects_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCrosses {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCrosses.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StContains {
export namespace Parameters {
 export function equals(l: Public.Procedures.StContains.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StContainsproperly {
export namespace Parameters {
 export function equals(l: Public.Procedures.StContainsproperly.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCovers_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCovers_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredby_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredby_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDfullywithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDfullywithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddwithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddwithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddfullywithin {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddfullywithin.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dintersects {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dintersects.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StOrderingequals {
export namespace Parameters {
 export function equals(l: Public.Procedures.StOrderingequals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEquals {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEquals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsvalid_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsvalid_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumclearance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumclearance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMinimumclearanceline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMinimumclearanceline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroid_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroid_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometricmedian {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometricmedian.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointonsurface {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointonsurface.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIssimple {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIssimple.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIscollection {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIscollection.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Equals {
export namespace Parameters {
 export function equals(l: Public.Procedures.Equals.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgml_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgml_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGmltosqlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGmltosqlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGmltosql_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGmltosql_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromkml {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromkml.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfrommarc21 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfrommarc21.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsmarc21 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsmarc21.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojsonE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojsonE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojson_608f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojson_608f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeojson_3c9d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisLibjsonVersion {
}
export namespace StLinefromencodedpolyline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromencodedpolyline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsencodedpolyline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsencodedpolyline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvgD341 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvgD341.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlD341 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlD341.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgml_32a0 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgml_32a0.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskmlCce7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskmlCce7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonD341 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonD341.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonF2c6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonF2c6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Json {
export namespace Parameters {
 export function equals(l: Public.Procedures.Json.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Jsonb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Jsonb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_27f4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfnF57f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfn_92c1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtTransfnF5be.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtCombinefn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtCombinefn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtSerialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtSerialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsmvtDeserialfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsmvtDeserialfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsmvtgeom {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsmvtgeom.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisLibprotobufVersion {
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufTransfn_27f4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsgeobufFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsgeobufFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_647f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_9633.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufTransfn_521f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Parameters {
 export function equals(l: Public.Procedures.PgisAsflatgeobufFinalfn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFromflatgeobuftotable {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFromflatgeobuftotable.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFromflatgeobuf {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFromflatgeobuf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeohash_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeohash_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBox2dfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBox2dfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromgeohash {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromgeohash.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumpoints {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumpoints.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumgeometries {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumgeometries.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDimension {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDimension.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StExteriorring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StExteriorring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNuminteriorrings {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNuminteriorrings.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNuminteriorring {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNuminteriorring.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInteriorringn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInteriorringn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometrytype_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometrytype_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometrytype {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometrytype.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StNumpatches {
export namespace Parameters {
 export function equals(l: Public.Procedures.StNumpatches.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPatchn {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPatchn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StStartpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StStartpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StEndpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StEndpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsclosed {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsclosed.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIsempty {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIsempty.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_88bc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_88bc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_6cbe {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_6cbe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeometryfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeometryfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWkttosql {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWkttosql.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinestringfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinestringfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinestringfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolygonfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolygonfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolygonfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromtext_27e2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromtextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromtextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinefromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinefromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinestringfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinestringfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinestringfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygonfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyAnalyze {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyAnalyze.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipointfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultilinefromwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultilinefromwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMlinefromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMlinefromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMpolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolyfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolyfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMultipolyfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromwkbD8af {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromwkbD8af.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeomcollfromwkb_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StMaxdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.StMaxdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpoint_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpoint_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestline_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestline_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLongestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLongestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSwapordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSwapordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StFlipcoordinates {
export namespace Parameters {
 export function equals(l: Public.Procedures.StFlipcoordinates.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBdpolyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBdpolyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBdmpolyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBdmpolyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Unlockrows {
export namespace Parameters {
 export function equals(l: Public.Procedures.Unlockrows.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_28e9 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_28e9.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_2d19 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_2d19.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Bytea_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Bytea_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstext_3181 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstext_3181.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace LockrowE9aa {
export namespace Parameters {
 export function equals(l: Public.Procedures.LockrowE9aa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_02b4 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_02b4.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Lockrow_9a8a {
export namespace Parameters {
 export function equals(l: Public.Procedures.Lockrow_9a8a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Addauth {
export namespace Parameters {
 export function equals(l: Public.Procedures.Addauth.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauth_27e1 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Checkauth_27e1.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauth_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Checkauth_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Checkauthtrigger {
}
export namespace Gettransactionid {
}
export namespace Enablelongtransactions {
}
export namespace Longtransactionsenabled {
}
export namespace Disablelongtransactions {
}
export namespace GeographyTypmodIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyTypmodIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyTypmodOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyTypmodOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyIn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyIn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyOut {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyOut.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyRecv {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyRecv.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySend {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySend.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAstextE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAstextE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeographyfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeographyfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeogfromtext {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeogfromtext.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeogfromwkb {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeogfromwkb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodDims {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodDims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypmodType {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypmodType.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geography_0cdb {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geography_0cdb.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometry_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometry_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistConsistent {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistConsistent.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistCompress {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistCompress.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistPenalty {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistPenalty.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistPicksplit {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistPicksplit.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistUnion {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistUnion.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistSame {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistSame.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistDecompress {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistDecompress.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyOverlaps {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyOverlaps.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyDistanceKnn {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyDistanceKnn.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGistDistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGistDistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeog_52a8 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeog_52a8.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeog_25ba {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeog_25ba.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsGeog_8fd3 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsGeog_8fd3.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeogBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeogBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyLt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyLt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyLe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyLe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGt {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGt.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyGe {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyGe.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyEq {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyEq.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographyCmp {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographyCmp.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvg_6ec5 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvg_6ec5.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAssvgE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAssvgE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProjectD4ec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProjectD4ec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAzimuthE452 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAzimuthE452.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_49f7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_49f7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlE888 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlE888.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgml_2160 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgml_2160.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskmlF40a {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskmlF40a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAskmlE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAskmlE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojson_6ec5 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojson_6ec5.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsgeojsonE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsgeojsonE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistance_8dcd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistance_8dcd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistance_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistance_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAreaEcae {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAreaEcae.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAreaE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAreaE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthEcae {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthEcae.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLengthE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLengthE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StProjectEd46 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StProjectEd46.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPerimeterEcae {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPerimeterEcae.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSegmentizeCadf {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSegmentizeCadf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsbinary_734d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsbinary_734d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewkt_3181 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewkt_3181.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsewktE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsewktE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geometrytype_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geometrytype_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSummary_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSummary_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StGeohash_3181 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StGeohash_3181.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSrid_7902 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSrid_7902.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSetsrid_3181 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSetsrid_3181.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroidEcae {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroidEcae.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCentroidE728 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCentroidE728.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoversE452 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoversE452.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithin_55df {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithin_55df.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredbyE452 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredbyE452.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectsE452 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectsE452.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferCadf {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferCadf.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_12e3 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_12e3.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBuffer_3aaa {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBuffer_3aaa.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StBufferF7c6 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StBufferF7c6.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersectionE452 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersectionE452.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersection_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersection_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCovers_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCovers_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoveredby_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoveredby_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDwithinEfc0 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDwithinEfc0.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StIntersects_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StIntersects_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpoint_8dcd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpoint_8dcd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StClosestpoint_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StClosestpoint_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestline_8dcd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestline_8dcd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StShortestline_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StShortestline_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstringEd46 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstringEd46.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinesubstringE586 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinesubstringE586.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepoint_8dcd {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepoint_8dcd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinelocatepoint_2ec2.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoints_8796 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoints_8796.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointsC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointsC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepoint_612b {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepoint_612b.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLineinterpolatepointC349 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLineinterpolatepointC349.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancesphere_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancesphere_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StDistancesphere_6961 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StDistancesphere_6961.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisTypeName {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisTypeName.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintSrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintSrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintDims {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintDims.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace PostgisConstraintType {
export namespace Parameters {
 export function equals(l: Public.Procedures.PostgisConstraintType.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3ddistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3ddistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dmaxdistance {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dmaxdistance.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dclosestpoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dclosestpoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dshortestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dshortestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlongestline {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlongestline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCoorddim {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCoorddim.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StCurvetoline {
export namespace Parameters {
 export function equals(l: Public.Procedures.StCurvetoline.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHasarc {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHasarc.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLinetocurve {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLinetocurve.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoint_0aec {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoint_0aec.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPoint_0b7f {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPoint_0b7f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointz {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointz.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPointzm {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPointzm.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StPolygon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StPolygon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StWkbtosql {
export namespace Parameters {
 export function equals(l: Public.Procedures.StWkbtosql.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatebetween {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatebetween.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatealong {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatealong.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLocatebetweenelevations {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLocatebetweenelevations.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StInterpolatepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.StInterpolatepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHexagon {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHexagon.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSquare {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSquare.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StHexagongrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StHexagongrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSquaregrid {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSquaregrid.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2d_3f2a {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2d_3f2a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2d_3f2a {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2d_3f2a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2d_3f2a {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2d_3f2a.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2d_4f71 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2d_4f71.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2d_4f71 {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2d_4f71.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2d_4f71 {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2d_4f71.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Contains_2d_7d4f {
export namespace Parameters {
 export function equals(l: Public.Procedures.Contains_2d_7d4f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace IsContained_2d_7d4f {
export namespace Parameters {
 export function equals(l: Public.Procedures.IsContained_2d_7d4f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Overlaps_2d_7d4f {
export namespace Parameters {
 export function equals(l: Public.Procedures.Overlaps_2d_7d4f.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNd_6173 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNd_6173.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNd_25ba {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNd_25ba.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace OverlapsNd_40b7 {
export namespace Parameters {
 export function equals(l: Public.Procedures.OverlapsNd_40b7.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom2dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom3dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Parameters {
 export function equals(l: Public.Procedures.Geom4dBrinInclusionAddValue.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StSimplifypolygonhull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StSimplifypolygonhull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StConcavehull {
export namespace Parameters {
 export function equals(l: Public.Procedures.StConcavehull.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAsx3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAsx3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StAngle_3651 {
export namespace Parameters {
 export function equals(l: Public.Procedures.StAngle_3651.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace St_3dlineinterpolatepoint {
export namespace Parameters {
 export function equals(l: Public.Procedures.St_3dlineinterpolatepoint.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfig_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfig_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChoose_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChoose_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplit_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistent_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompress_2d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompress_2d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryOverlaps_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryOverlaps_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContains_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContains_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometryContained_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometryContained_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySame_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySame_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfig_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfig_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChoose_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChoose_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplit_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistent_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistent_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompress_3d {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompress_3d.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistConfigNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistConfigNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistChooseNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistChooseNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistInnerConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistLeafConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeometrySpgistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeometrySpgistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistConfigNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistConfigNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistChooseNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistChooseNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistPicksplitNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistPicksplitNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistInnerConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistLeafConsistentNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace GeographySpgistCompressNd {
export namespace Parameters {
 export function equals(l: Public.Procedures.GeographySpgistCompressNd.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace StLetters {
export namespace Parameters {
 export function equals(l: Public.Procedures.StLetters.Parameters|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
}
export namespace NycCensusBlocks {
}
export namespace NycHomicides {
}
export namespace NycNeighborhoods {
}
export namespace NycStreets {
}
export namespace NycSubwayStations {
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_47570Index {
 export function equals(l: PgToast.Types.PgToast_47570Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_48328Index {
 export function equals(l: PgToast.Types.PgToast_48328Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_48334Index {
 export function equals(l: PgToast.Types.PgToast_48334Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1255Index {
 export function equals(l: PgToast.Types.PgToast_1255Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1247Index {
 export function equals(l: PgToast.Types.PgToast_1247Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2604Index {
 export function equals(l: PgToast.Types.PgToast_2604Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2606Index {
 export function equals(l: PgToast.Types.PgToast_2606Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2612Index {
 export function equals(l: PgToast.Types.PgToast_2612Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2600Index {
 export function equals(l: PgToast.Types.PgToast_2600Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2619Index {
 export function equals(l: PgToast.Types.PgToast_2619Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3381Index {
 export function equals(l: PgToast.Types.PgToast_3381Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3429Index {
 export function equals(l: PgToast.Types.PgToast_3429Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2618Index {
 export function equals(l: PgToast.Types.PgToast_2618Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2620Index {
 export function equals(l: PgToast.Types.PgToast_2620Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3466Index {
 export function equals(l: PgToast.Types.PgToast_3466Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2609Index {
 export function equals(l: PgToast.Types.PgToast_2609Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_48340Index {
 export function equals(l: PgToast.Types.PgToast_48340Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2615Index {
 export function equals(l: PgToast.Types.PgToast_2615Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1262Index {
 export function equals(l: PgToast.Types.PgToast_1262Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2964Index {
 export function equals(l: PgToast.Types.PgToast_2964Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1213Index {
 export function equals(l: PgToast.Types.PgToast_1213Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1260Index {
 export function equals(l: PgToast.Types.PgToast_1260Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2396Index {
 export function equals(l: PgToast.Types.PgToast_2396Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3600Index {
 export function equals(l: PgToast.Types.PgToast_3600Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3079Index {
 export function equals(l: PgToast.Types.PgToast_3079Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_2328Index {
 export function equals(l: PgToast.Types.PgToast_2328Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1417Index {
 export function equals(l: PgToast.Types.PgToast_1417Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_1418Index {
 export function equals(l: PgToast.Types.PgToast_1418Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3118Index {
 export function equals(l: PgToast.Types.PgToast_3118Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3256Index {
 export function equals(l: PgToast.Types.PgToast_3256Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6000Index {
 export function equals(l: PgToast.Types.PgToast_6000Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_826Index {
 export function equals(l: PgToast.Types.PgToast_826Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3394Index {
 export function equals(l: PgToast.Types.PgToast_3394Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3596Index {
 export function equals(l: PgToast.Types.PgToast_3596Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3592Index {
 export function equals(l: PgToast.Types.PgToast_3592Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3456Index {
 export function equals(l: PgToast.Types.PgToast_3456Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6243Index {
 export function equals(l: PgToast.Types.PgToast_6243Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_3350Index {
 export function equals(l: PgToast.Types.PgToast_3350Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6106Index {
 export function equals(l: PgToast.Types.PgToast_6106Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_6100Index {
 export function equals(l: PgToast.Types.PgToast_6100Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_48346Index {
 export function equals(l: PgToast.Types.PgToast_48346Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_48352Index {
 export function equals(l: PgToast.Types.PgToast_48352Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13658Index {
 export function equals(l: PgToast.Types.PgToast_13658Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13663Index {
 export function equals(l: PgToast.Types.PgToast_13663Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13668Index {
 export function equals(l: PgToast.Types.PgToast_13668Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
export namespace PgToast_13673Index {
 export function equals(l: PgToast.Types.PgToast_13673Index|undefined, r: unknown) {
  return JSON.stringify(l) === JSON.stringify(r);
 }
}
}
export namespace Procedures {
}
export namespace Tables {
}
}
export namespace PgCatalog {
export namespace Types {
export namespace Bool {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bytea {

      export type Options = InvokeQueryOptions;
    
}
export namespace Char {

      export type Options = InvokeQueryOptions;
    
}
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int8 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int2vector {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regproc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Text {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Xid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oidvector {
export type Options = InvokeQueryOptions;
}
export namespace PgType {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typlen {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typbyval {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typcategory {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typispreferred {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typisdefined {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typdelim {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typsubscript {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typelem {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typarray {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typinput {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typoutput {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typreceive {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typsend {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typmodin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typmodout {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typanalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typalign {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typstorage {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typnotnull {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typbasetype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typtypmod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typndims {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typcollation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typdefaultbin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typdefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
typname?: PgCatalog.Types.Name.Options,
typnamespace?: PgCatalog.Types.Oid.Options,
typowner?: PgCatalog.Types.Oid.Options,
typlen?: PgCatalog.Types.Int2.Options,
typbyval?: PgCatalog.Types.Bool.Options,
typtype?: PgCatalog.Types.Char.Options,
typcategory?: PgCatalog.Types.Char.Options,
typispreferred?: PgCatalog.Types.Bool.Options,
typisdefined?: PgCatalog.Types.Bool.Options,
typdelim?: PgCatalog.Types.Char.Options,
typrelid?: PgCatalog.Types.Oid.Options,
typsubscript?: PgCatalog.Types.Regproc.Options,
typelem?: PgCatalog.Types.Oid.Options,
typarray?: PgCatalog.Types.Oid.Options,
typinput?: PgCatalog.Types.Regproc.Options,
typoutput?: PgCatalog.Types.Regproc.Options,
typreceive?: PgCatalog.Types.Regproc.Options,
typsend?: PgCatalog.Types.Regproc.Options,
typmodin?: PgCatalog.Types.Regproc.Options,
typmodout?: PgCatalog.Types.Regproc.Options,
typanalyze?: PgCatalog.Types.Regproc.Options,
typalign?: PgCatalog.Types.Char.Options,
typstorage?: PgCatalog.Types.Char.Options,
typnotnull?: PgCatalog.Types.Bool.Options,
typbasetype?: PgCatalog.Types.Oid.Options,
typtypmod?: PgCatalog.Types.Int4.Options,
typndims?: PgCatalog.Types.Int4.Options,
typcollation?: PgCatalog.Types.Oid.Options,
typdefaultbin?: PgCatalog.Types.PgNodeTree.Options,
typdefault?: PgCatalog.Types.Text.Options,
typacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgAttribute {
export namespace Attrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Atttypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attlen {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attnum {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attcacheoff {

      export type Options = InvokeQueryOptions;
    
}
export namespace Atttypmod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attndims {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attbyval {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attalign {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attstorage {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attcompression {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attnotnull {

      export type Options = InvokeQueryOptions;
    
}
export namespace Atthasdef {

      export type Options = InvokeQueryOptions;
    
}
export namespace Atthasmissing {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attidentity {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attgenerated {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attisdropped {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attislocal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attinhcount {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attstattarget {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attcollation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attacl {
export type Options = InvokeQueryOptions;
}
export namespace Attoptions {
export type Options = InvokeQueryOptions;
}
export namespace Attfdwoptions {
export type Options = InvokeQueryOptions;
}
export namespace Attmissingval {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 attrelid?: PgCatalog.Types.Oid.Options,
attname?: PgCatalog.Types.Name.Options,
atttypid?: PgCatalog.Types.Oid.Options,
attlen?: PgCatalog.Types.Int2.Options,
attnum?: PgCatalog.Types.Int2.Options,
attcacheoff?: PgCatalog.Types.Int4.Options,
atttypmod?: PgCatalog.Types.Int4.Options,
attndims?: PgCatalog.Types.Int2.Options,
attbyval?: PgCatalog.Types.Bool.Options,
attalign?: PgCatalog.Types.Char.Options,
attstorage?: PgCatalog.Types.Char.Options,
attcompression?: PgCatalog.Types.Char.Options,
attnotnull?: PgCatalog.Types.Bool.Options,
atthasdef?: PgCatalog.Types.Bool.Options,
atthasmissing?: PgCatalog.Types.Bool.Options,
attidentity?: PgCatalog.Types.Char.Options,
attgenerated?: PgCatalog.Types.Char.Options,
attisdropped?: PgCatalog.Types.Bool.Options,
attislocal?: PgCatalog.Types.Bool.Options,
attinhcount?: PgCatalog.Types.Int2.Options,
attstattarget?: PgCatalog.Types.Int2.Options,
attcollation?: PgCatalog.Types.Oid.Options,
attacl?: PgCatalog.Types.AclitemArray.Options,
attoptions?: PgCatalog.Types.TextArray.Options,
attfdwoptions?: PgCatalog.Types.TextArray.Options,
attmissingval?: PgCatalog.Types.Anyarray.Options
}
}
export namespace PgProc {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pronamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prolang {

      export type Options = InvokeQueryOptions;
    
}
export namespace Procost {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prorows {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provariadic {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prosupport {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prokind {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prosecdef {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proleakproof {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proisstrict {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proretset {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provolatile {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proparallel {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pronargs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pronargdefaults {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prorettype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proargtypes {
export type Options = InvokeQueryOptions;
}
export namespace Proallargtypes {
export type Options = InvokeQueryOptions;
}
export namespace Proargmodes {
export type Options = InvokeQueryOptions;
}
export namespace Proargnames {
export type Options = InvokeQueryOptions;
}
export namespace Proargdefaults {

      export type Options = InvokeQueryOptions;
    
}
export namespace Protrftypes {
export type Options = InvokeQueryOptions;
}
export namespace Prosrc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Probin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prosqlbody {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proconfig {
export type Options = InvokeQueryOptions;
}
export namespace Proacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
proname?: PgCatalog.Types.Name.Options,
pronamespace?: PgCatalog.Types.Oid.Options,
proowner?: PgCatalog.Types.Oid.Options,
prolang?: PgCatalog.Types.Oid.Options,
procost?: PgCatalog.Types.Float4.Options,
prorows?: PgCatalog.Types.Float4.Options,
provariadic?: PgCatalog.Types.Oid.Options,
prosupport?: PgCatalog.Types.Regproc.Options,
prokind?: PgCatalog.Types.Char.Options,
prosecdef?: PgCatalog.Types.Bool.Options,
proleakproof?: PgCatalog.Types.Bool.Options,
proisstrict?: PgCatalog.Types.Bool.Options,
proretset?: PgCatalog.Types.Bool.Options,
provolatile?: PgCatalog.Types.Char.Options,
proparallel?: PgCatalog.Types.Char.Options,
pronargs?: PgCatalog.Types.Int2.Options,
pronargdefaults?: PgCatalog.Types.Int2.Options,
prorettype?: PgCatalog.Types.Oid.Options,
proargtypes?: PgCatalog.Types.Oidvector.Options,
proallargtypes?: PgCatalog.Types.OidArray.Options,
proargmodes?: PgCatalog.Types.CharArray.Options,
proargnames?: PgCatalog.Types.TextArray.Options,
proargdefaults?: PgCatalog.Types.PgNodeTree.Options,
protrftypes?: PgCatalog.Types.OidArray.Options,
prosrc?: PgCatalog.Types.Text.Options,
probin?: PgCatalog.Types.Text.Options,
prosqlbody?: PgCatalog.Types.PgNodeTree.Options,
proconfig?: PgCatalog.Types.TextArray.Options,
proacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgClass {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reltype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reloftype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relam {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relfilenode {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reltablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relpages {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reltuples {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relallvisible {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reltoastrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relhasindex {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relisshared {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relpersistence {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relkind {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relnatts {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relchecks {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relhasrules {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relhastriggers {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relhassubclass {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relrowsecurity {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relforcerowsecurity {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relispopulated {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relreplident {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relispartition {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relrewrite {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relfrozenxid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relminmxid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relacl {
export type Options = InvokeQueryOptions;
}
export namespace Reloptions {
export type Options = InvokeQueryOptions;
}
export namespace Relpartbound {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
relname?: PgCatalog.Types.Name.Options,
relnamespace?: PgCatalog.Types.Oid.Options,
reltype?: PgCatalog.Types.Oid.Options,
reloftype?: PgCatalog.Types.Oid.Options,
relowner?: PgCatalog.Types.Oid.Options,
relam?: PgCatalog.Types.Oid.Options,
relfilenode?: PgCatalog.Types.Oid.Options,
reltablespace?: PgCatalog.Types.Oid.Options,
relpages?: PgCatalog.Types.Int4.Options,
reltuples?: PgCatalog.Types.Float4.Options,
relallvisible?: PgCatalog.Types.Int4.Options,
reltoastrelid?: PgCatalog.Types.Oid.Options,
relhasindex?: PgCatalog.Types.Bool.Options,
relisshared?: PgCatalog.Types.Bool.Options,
relpersistence?: PgCatalog.Types.Char.Options,
relkind?: PgCatalog.Types.Char.Options,
relnatts?: PgCatalog.Types.Int2.Options,
relchecks?: PgCatalog.Types.Int2.Options,
relhasrules?: PgCatalog.Types.Bool.Options,
relhastriggers?: PgCatalog.Types.Bool.Options,
relhassubclass?: PgCatalog.Types.Bool.Options,
relrowsecurity?: PgCatalog.Types.Bool.Options,
relforcerowsecurity?: PgCatalog.Types.Bool.Options,
relispopulated?: PgCatalog.Types.Bool.Options,
relreplident?: PgCatalog.Types.Char.Options,
relispartition?: PgCatalog.Types.Bool.Options,
relrewrite?: PgCatalog.Types.Oid.Options,
relfrozenxid?: PgCatalog.Types.Xid.Options,
relminmxid?: PgCatalog.Types.Xid.Options,
relacl?: PgCatalog.Types.AclitemArray.Options,
reloptions?: PgCatalog.Types.TextArray.Options,
relpartbound?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace Json {

      export type Options = InvokeQueryOptions;
    
}
export namespace Xml {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgNodeTree {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgNdistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgDependencies {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgMcvList {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgDdlCommand {

      export type Options = InvokeQueryOptions;
    
}
export namespace Xid8 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Point {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lseg {

      export type Options = InvokeQueryOptions;
    
}
export namespace Path {

      export type Options = InvokeQueryOptions;
    
}
export namespace Box {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polygon {

      export type Options = InvokeQueryOptions;
    
}
export namespace Line {

      export type Options = InvokeQueryOptions;
    
}
export namespace Float4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Float8 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Unknown {

      export type Options = InvokeQueryOptions;
    
}
export namespace Circle {

      export type Options = InvokeQueryOptions;
    
}
export namespace Money {

      export type Options = InvokeQueryOptions;
    
}
export namespace Macaddr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inet {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cidr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Macaddr8 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aclitem {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bpchar {

      export type Options = InvokeQueryOptions;
    
}
export namespace Varchar {

      export type Options = InvokeQueryOptions;
    
}
export namespace Date {

      export type Options = InvokeQueryOptions;
    
}
export namespace Time {

      export type Options = InvokeQueryOptions;
    
}
export namespace Timestamp {

      export type Options = InvokeQueryOptions;
    
}
export namespace Timestamptz {

      export type Options = InvokeQueryOptions;
    
}
export namespace Interval {

      export type Options = InvokeQueryOptions;
    
}
export namespace Timetz {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Varbit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Numeric {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refcursor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regprocedure {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regoper {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regoperator {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regclass {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regcollation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regrole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Uuid {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tsvector {

       /**
         * Fulltext queries have different parsers that turn your query search
         * text into a runnable search in the database.
         *
         * For PostgreSQL these are documented at:
         * https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-HEADLINE
         */
        export enum FulltextParser {
        Default = "to_tsquery",
        Plain = "plainto_tsquery",
        Phrase = "phraseto_tsquery",
        Web = "websearch_to_tsquery",
        }
        export type Options = InvokeQueryOptions & {
            queryParser?: FulltextParser;
            configuration?: string;
        }
        
            
}
export namespace Gtsvector {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tsquery {

       /**
         * Fulltext queries have different parsers that turn your query search
         * text into a runnable search in the database.
         *
         * For PostgreSQL these are documented at:
         * https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-HEADLINE
         */
        export enum FulltextParser {
        Default = "to_tsquery",
        Plain = "plainto_tsquery",
        Phrase = "phraseto_tsquery",
        Web = "websearch_to_tsquery",
        }
        export type Options = InvokeQueryOptions & {
            queryParser?: FulltextParser;
            configuration?: string;
        }
        
            
}
export namespace Regconfig {

      export type Options = InvokeQueryOptions;
    
}
export namespace Regdictionary {

      export type Options = InvokeQueryOptions;
    
}
export namespace Jsonb {

      export type Options = InvokeQueryOptions;
    
}
export namespace Jsonpath {

      export type Options = InvokeQueryOptions;
    
}
export namespace TxidSnapshot {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgSnapshot {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int4range {

      export type Options = InvokeQueryOptions;
    
}
export namespace Numrange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tsrange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tstzrange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Daterange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int8range {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int4multirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nummultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tsmultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tstzmultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datemultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Int8multirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Record {

      export type Options = InvokeQueryOptions;
    
}
export namespace RecordArray {
export type Options = InvokeQueryOptions;
}
export namespace Cstring {

      export type Options = InvokeQueryOptions;
    
}
export namespace Any {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anyarray {

      export type Options = InvokeQueryOptions;
    
}
export namespace Void {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trigger {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventTrigger {

      export type Options = InvokeQueryOptions;
    
}
export namespace LanguageHandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace Internal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anyelement {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anynonarray {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anyenum {

      export type Options = InvokeQueryOptions;
    
}
export namespace FdwHandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace IndexAmHandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace TsmHandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableAmHandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anyrange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anycompatible {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anycompatiblearray {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anycompatiblenonarray {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anycompatiblerange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anymultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace Anycompatiblemultirange {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgBrinBloomSummary {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgBrinMinmaxMultiSummary {

      export type Options = InvokeQueryOptions;
    
}
export namespace BoolArray {
export type Options = InvokeQueryOptions;
}
export namespace ByteaArray {
export type Options = InvokeQueryOptions;
}
export namespace CharArray {
export type Options = InvokeQueryOptions;
}
export namespace NameArray {
export type Options = InvokeQueryOptions;
}
export namespace Int8Array {
export type Options = InvokeQueryOptions;
}
export namespace Int2Array {
export type Options = InvokeQueryOptions;
}
export namespace Int2vectorArray {
export type Options = InvokeQueryOptions;
}
export namespace Int4Array {
export type Options = InvokeQueryOptions;
}
export namespace RegprocArray {
export type Options = InvokeQueryOptions;
}
export namespace TextArray {
export type Options = InvokeQueryOptions;
}
export namespace OidArray {
export type Options = InvokeQueryOptions;
}
export namespace TidArray {
export type Options = InvokeQueryOptions;
}
export namespace XidArray {
export type Options = InvokeQueryOptions;
}
export namespace CidArray {
export type Options = InvokeQueryOptions;
}
export namespace OidvectorArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTypeArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAttributeArray {
export type Options = InvokeQueryOptions;
}
export namespace PgProcArray {
export type Options = InvokeQueryOptions;
}
export namespace PgClassArray {
export type Options = InvokeQueryOptions;
}
export namespace JsonArray {
export type Options = InvokeQueryOptions;
}
export namespace XmlArray {
export type Options = InvokeQueryOptions;
}
export namespace Xid8Array {
export type Options = InvokeQueryOptions;
}
export namespace PointArray {
export type Options = InvokeQueryOptions;
}
export namespace LsegArray {
export type Options = InvokeQueryOptions;
}
export namespace PathArray {
export type Options = InvokeQueryOptions;
}
export namespace BoxArray {
export type Options = InvokeQueryOptions;
}
export namespace PolygonArray {
export type Options = InvokeQueryOptions;
}
export namespace LineArray {
export type Options = InvokeQueryOptions;
}
export namespace Float4Array {
export type Options = InvokeQueryOptions;
}
export namespace Float8Array {
export type Options = InvokeQueryOptions;
}
export namespace CircleArray {
export type Options = InvokeQueryOptions;
}
export namespace MoneyArray {
export type Options = InvokeQueryOptions;
}
export namespace MacaddrArray {
export type Options = InvokeQueryOptions;
}
export namespace InetArray {
export type Options = InvokeQueryOptions;
}
export namespace CidrArray {
export type Options = InvokeQueryOptions;
}
export namespace Macaddr8Array {
export type Options = InvokeQueryOptions;
}
export namespace AclitemArray {
export type Options = InvokeQueryOptions;
}
export namespace BpcharArray {
export type Options = InvokeQueryOptions;
}
export namespace VarcharArray {
export type Options = InvokeQueryOptions;
}
export namespace DateArray {
export type Options = InvokeQueryOptions;
}
export namespace TimeArray {
export type Options = InvokeQueryOptions;
}
export namespace TimestampArray {
export type Options = InvokeQueryOptions;
}
export namespace TimestamptzArray {
export type Options = InvokeQueryOptions;
}
export namespace IntervalArray {
export type Options = InvokeQueryOptions;
}
export namespace TimetzArray {
export type Options = InvokeQueryOptions;
}
export namespace BitArray {
export type Options = InvokeQueryOptions;
}
export namespace VarbitArray {
export type Options = InvokeQueryOptions;
}
export namespace NumericArray {
export type Options = InvokeQueryOptions;
}
export namespace RefcursorArray {
export type Options = InvokeQueryOptions;
}
export namespace RegprocedureArray {
export type Options = InvokeQueryOptions;
}
export namespace RegoperArray {
export type Options = InvokeQueryOptions;
}
export namespace RegoperatorArray {
export type Options = InvokeQueryOptions;
}
export namespace RegclassArray {
export type Options = InvokeQueryOptions;
}
export namespace RegcollationArray {
export type Options = InvokeQueryOptions;
}
export namespace RegtypeArray {
export type Options = InvokeQueryOptions;
}
export namespace RegroleArray {
export type Options = InvokeQueryOptions;
}
export namespace RegnamespaceArray {
export type Options = InvokeQueryOptions;
}
export namespace UuidArray {
export type Options = InvokeQueryOptions;
}
export namespace PgLsnArray {
export type Options = InvokeQueryOptions;
}
export namespace TsvectorArray {
export type Options = InvokeQueryOptions;
}
export namespace GtsvectorArray {
export type Options = InvokeQueryOptions;
}
export namespace TsqueryArray {
export type Options = InvokeQueryOptions;
}
export namespace RegconfigArray {
export type Options = InvokeQueryOptions;
}
export namespace RegdictionaryArray {
export type Options = InvokeQueryOptions;
}
export namespace JsonbArray {
export type Options = InvokeQueryOptions;
}
export namespace JsonpathArray {
export type Options = InvokeQueryOptions;
}
export namespace TxidSnapshotArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSnapshotArray {
export type Options = InvokeQueryOptions;
}
export namespace Int4rangeArray {
export type Options = InvokeQueryOptions;
}
export namespace NumrangeArray {
export type Options = InvokeQueryOptions;
}
export namespace TsrangeArray {
export type Options = InvokeQueryOptions;
}
export namespace TstzrangeArray {
export type Options = InvokeQueryOptions;
}
export namespace DaterangeArray {
export type Options = InvokeQueryOptions;
}
export namespace Int8rangeArray {
export type Options = InvokeQueryOptions;
}
export namespace Int4multirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace NummultirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace TsmultirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace TstzmultirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace DatemultirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace Int8multirangeArray {
export type Options = InvokeQueryOptions;
}
export namespace CstringArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAttrdef {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Adrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Adnum {

      export type Options = InvokeQueryOptions;
    
}
export namespace Adbin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
adrelid?: PgCatalog.Types.Oid.Options,
adnum?: PgCatalog.Types.Int2.Options,
adbin?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgAttrdefArray {
export type Options = InvokeQueryOptions;
}
export namespace PgConstraint {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Connamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Contype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Condeferrable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Condeferred {

      export type Options = InvokeQueryOptions;
    
}
export namespace Convalidated {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Contypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conindid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conparentid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Confrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Confupdtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Confdeltype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Confmatchtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conislocal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Coninhcount {

      export type Options = InvokeQueryOptions;
    
}
export namespace Connoinherit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conkey {
export type Options = InvokeQueryOptions;
}
export namespace Confkey {
export type Options = InvokeQueryOptions;
}
export namespace Conpfeqop {
export type Options = InvokeQueryOptions;
}
export namespace Conppeqop {
export type Options = InvokeQueryOptions;
}
export namespace Conffeqop {
export type Options = InvokeQueryOptions;
}
export namespace Confdelsetcols {
export type Options = InvokeQueryOptions;
}
export namespace Conexclop {
export type Options = InvokeQueryOptions;
}
export namespace Conbin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
conname?: PgCatalog.Types.Name.Options,
connamespace?: PgCatalog.Types.Oid.Options,
contype?: PgCatalog.Types.Char.Options,
condeferrable?: PgCatalog.Types.Bool.Options,
condeferred?: PgCatalog.Types.Bool.Options,
convalidated?: PgCatalog.Types.Bool.Options,
conrelid?: PgCatalog.Types.Oid.Options,
contypid?: PgCatalog.Types.Oid.Options,
conindid?: PgCatalog.Types.Oid.Options,
conparentid?: PgCatalog.Types.Oid.Options,
confrelid?: PgCatalog.Types.Oid.Options,
confupdtype?: PgCatalog.Types.Char.Options,
confdeltype?: PgCatalog.Types.Char.Options,
confmatchtype?: PgCatalog.Types.Char.Options,
conislocal?: PgCatalog.Types.Bool.Options,
coninhcount?: PgCatalog.Types.Int2.Options,
connoinherit?: PgCatalog.Types.Bool.Options,
conkey?: PgCatalog.Types.Int2Array.Options,
confkey?: PgCatalog.Types.Int2Array.Options,
conpfeqop?: PgCatalog.Types.OidArray.Options,
conppeqop?: PgCatalog.Types.OidArray.Options,
conffeqop?: PgCatalog.Types.OidArray.Options,
confdelsetcols?: PgCatalog.Types.Int2Array.Options,
conexclop?: PgCatalog.Types.OidArray.Options,
conbin?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgConstraintArray {
export type Options = InvokeQueryOptions;
}
export namespace PgInherits {
export namespace Inhrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inhparent {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inhseqno {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inhdetachpending {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 inhrelid?: PgCatalog.Types.Oid.Options,
inhparent?: PgCatalog.Types.Oid.Options,
inhseqno?: PgCatalog.Types.Int4.Options,
inhdetachpending?: PgCatalog.Types.Bool.Options
}
}
export namespace PgInheritsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgIndex {
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indnatts {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indnkeyatts {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisunique {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indnullsnotdistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisprimary {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisexclusion {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indimmediate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisclustered {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisvalid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indcheckxmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisready {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indislive {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indisreplident {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indkey {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indcollation {
export type Options = InvokeQueryOptions;
}
export namespace Indclass {
export type Options = InvokeQueryOptions;
}
export namespace Indoption {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexprs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indpred {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 indexrelid?: PgCatalog.Types.Oid.Options,
indrelid?: PgCatalog.Types.Oid.Options,
indnatts?: PgCatalog.Types.Int2.Options,
indnkeyatts?: PgCatalog.Types.Int2.Options,
indisunique?: PgCatalog.Types.Bool.Options,
indnullsnotdistinct?: PgCatalog.Types.Bool.Options,
indisprimary?: PgCatalog.Types.Bool.Options,
indisexclusion?: PgCatalog.Types.Bool.Options,
indimmediate?: PgCatalog.Types.Bool.Options,
indisclustered?: PgCatalog.Types.Bool.Options,
indisvalid?: PgCatalog.Types.Bool.Options,
indcheckxmin?: PgCatalog.Types.Bool.Options,
indisready?: PgCatalog.Types.Bool.Options,
indislive?: PgCatalog.Types.Bool.Options,
indisreplident?: PgCatalog.Types.Bool.Options,
indkey?: PgCatalog.Types.Int2vector.Options,
indcollation?: PgCatalog.Types.Oidvector.Options,
indclass?: PgCatalog.Types.Oidvector.Options,
indoption?: PgCatalog.Types.Int2vector.Options,
indexprs?: PgCatalog.Types.PgNodeTree.Options,
indpred?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgIndexArray {
export type Options = InvokeQueryOptions;
}
export namespace PgOperator {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprkind {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprcanmerge {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprcanhash {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprleft {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprright {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprresult {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprcom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprnegate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprcode {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprrest {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprjoin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
oprname?: PgCatalog.Types.Name.Options,
oprnamespace?: PgCatalog.Types.Oid.Options,
oprowner?: PgCatalog.Types.Oid.Options,
oprkind?: PgCatalog.Types.Char.Options,
oprcanmerge?: PgCatalog.Types.Bool.Options,
oprcanhash?: PgCatalog.Types.Bool.Options,
oprleft?: PgCatalog.Types.Oid.Options,
oprright?: PgCatalog.Types.Oid.Options,
oprresult?: PgCatalog.Types.Oid.Options,
oprcom?: PgCatalog.Types.Oid.Options,
oprnegate?: PgCatalog.Types.Oid.Options,
oprcode?: PgCatalog.Types.Regproc.Options,
oprrest?: PgCatalog.Types.Regproc.Options,
oprjoin?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgOperatorArray {
export type Options = InvokeQueryOptions;
}
export namespace PgOpfamily {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfmethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfowner {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
opfmethod?: PgCatalog.Types.Oid.Options,
opfname?: PgCatalog.Types.Name.Options,
opfnamespace?: PgCatalog.Types.Oid.Options,
opfowner?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpfamilyArray {
export type Options = InvokeQueryOptions;
}
export namespace PgOpclass {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcmethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcfamily {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcintype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcdefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opckeytype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
opcmethod?: PgCatalog.Types.Oid.Options,
opcname?: PgCatalog.Types.Name.Options,
opcnamespace?: PgCatalog.Types.Oid.Options,
opcowner?: PgCatalog.Types.Oid.Options,
opcfamily?: PgCatalog.Types.Oid.Options,
opcintype?: PgCatalog.Types.Oid.Options,
opcdefault?: PgCatalog.Types.Bool.Options,
opckeytype?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpclassArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAm {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amhandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amtype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
amname?: PgCatalog.Types.Name.Options,
amhandler?: PgCatalog.Types.Regproc.Options,
amtype?: PgCatalog.Types.Char.Options
}
}
export namespace PgAmArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAmop {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopfamily {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoplefttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoprighttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopstrategy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoppurpose {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopopr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopmethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopsortfamily {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
amopfamily?: PgCatalog.Types.Oid.Options,
amoplefttype?: PgCatalog.Types.Oid.Options,
amoprighttype?: PgCatalog.Types.Oid.Options,
amopstrategy?: PgCatalog.Types.Int2.Options,
amoppurpose?: PgCatalog.Types.Char.Options,
amopopr?: PgCatalog.Types.Oid.Options,
amopmethod?: PgCatalog.Types.Oid.Options,
amopsortfamily?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAmopArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAmproc {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amprocfamily {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amproclefttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amprocrighttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amprocnum {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amproc {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
amprocfamily?: PgCatalog.Types.Oid.Options,
amproclefttype?: PgCatalog.Types.Oid.Options,
amprocrighttype?: PgCatalog.Types.Oid.Options,
amprocnum?: PgCatalog.Types.Int2.Options,
amproc?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgAmprocArray {
export type Options = InvokeQueryOptions;
}
export namespace PgLanguage {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanispl {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanpltrusted {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanplcallfoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Laninline {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanvalidator {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lanacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
lanname?: PgCatalog.Types.Name.Options,
lanowner?: PgCatalog.Types.Oid.Options,
lanispl?: PgCatalog.Types.Bool.Options,
lanpltrusted?: PgCatalog.Types.Bool.Options,
lanplcallfoid?: PgCatalog.Types.Oid.Options,
laninline?: PgCatalog.Types.Oid.Options,
lanvalidator?: PgCatalog.Types.Oid.Options,
lanacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgLanguageArray {
export type Options = InvokeQueryOptions;
}
export namespace PgLargeobjectMetadata {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lomowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Lomacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
lomowner?: PgCatalog.Types.Oid.Options,
lomacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgLargeobjectMetadataArray {
export type Options = InvokeQueryOptions;
}
export namespace PgLargeobject {
export namespace Loid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pageno {

      export type Options = InvokeQueryOptions;
    
}
export namespace Data {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 loid?: PgCatalog.Types.Oid.Options,
pageno?: PgCatalog.Types.Int4.Options,
data?: PgCatalog.Types.Bytea.Options
}
}
export namespace PgLargeobjectArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAggregate {
export namespace Aggfnoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggkind {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggnumdirectargs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggtransfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggfinalfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggcombinefn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggserialfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggdeserialfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmtransfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggminvtransfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmfinalfn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggfinalextra {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmfinalextra {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggfinalmodify {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmfinalmodify {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggsortop {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggtranstype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggtransspace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmtranstype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggmtransspace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Agginitval {

      export type Options = InvokeQueryOptions;
    
}
export namespace Aggminitval {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 aggfnoid?: PgCatalog.Types.Regproc.Options,
aggkind?: PgCatalog.Types.Char.Options,
aggnumdirectargs?: PgCatalog.Types.Int2.Options,
aggtransfn?: PgCatalog.Types.Regproc.Options,
aggfinalfn?: PgCatalog.Types.Regproc.Options,
aggcombinefn?: PgCatalog.Types.Regproc.Options,
aggserialfn?: PgCatalog.Types.Regproc.Options,
aggdeserialfn?: PgCatalog.Types.Regproc.Options,
aggmtransfn?: PgCatalog.Types.Regproc.Options,
aggminvtransfn?: PgCatalog.Types.Regproc.Options,
aggmfinalfn?: PgCatalog.Types.Regproc.Options,
aggfinalextra?: PgCatalog.Types.Bool.Options,
aggmfinalextra?: PgCatalog.Types.Bool.Options,
aggfinalmodify?: PgCatalog.Types.Char.Options,
aggmfinalmodify?: PgCatalog.Types.Char.Options,
aggsortop?: PgCatalog.Types.Oid.Options,
aggtranstype?: PgCatalog.Types.Oid.Options,
aggtransspace?: PgCatalog.Types.Int4.Options,
aggmtranstype?: PgCatalog.Types.Oid.Options,
aggmtransspace?: PgCatalog.Types.Int4.Options,
agginitval?: PgCatalog.Types.Text.Options,
aggminitval?: PgCatalog.Types.Text.Options
}
}
export namespace PgAggregateArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatistic {
export namespace Starelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staattnum {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stainherit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stanullfrac {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stawidth {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stadistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stakind1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stakind2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stakind3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stakind4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stakind5 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staop1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staop2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staop3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staop4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staop5 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stacoll1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stacoll2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stacoll3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stacoll4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stacoll5 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stanumbers1 {
export type Options = InvokeQueryOptions;
}
export namespace Stanumbers2 {
export type Options = InvokeQueryOptions;
}
export namespace Stanumbers3 {
export type Options = InvokeQueryOptions;
}
export namespace Stanumbers4 {
export type Options = InvokeQueryOptions;
}
export namespace Stanumbers5 {
export type Options = InvokeQueryOptions;
}
export namespace Stavalues1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stavalues2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stavalues3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stavalues4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stavalues5 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 starelid?: PgCatalog.Types.Oid.Options,
staattnum?: PgCatalog.Types.Int2.Options,
stainherit?: PgCatalog.Types.Bool.Options,
stanullfrac?: PgCatalog.Types.Float4.Options,
stawidth?: PgCatalog.Types.Int4.Options,
stadistinct?: PgCatalog.Types.Float4.Options,
stakind1?: PgCatalog.Types.Int2.Options,
stakind2?: PgCatalog.Types.Int2.Options,
stakind3?: PgCatalog.Types.Int2.Options,
stakind4?: PgCatalog.Types.Int2.Options,
stakind5?: PgCatalog.Types.Int2.Options,
staop1?: PgCatalog.Types.Oid.Options,
staop2?: PgCatalog.Types.Oid.Options,
staop3?: PgCatalog.Types.Oid.Options,
staop4?: PgCatalog.Types.Oid.Options,
staop5?: PgCatalog.Types.Oid.Options,
stacoll1?: PgCatalog.Types.Oid.Options,
stacoll2?: PgCatalog.Types.Oid.Options,
stacoll3?: PgCatalog.Types.Oid.Options,
stacoll4?: PgCatalog.Types.Oid.Options,
stacoll5?: PgCatalog.Types.Oid.Options,
stanumbers1?: PgCatalog.Types.Float4Array.Options,
stanumbers2?: PgCatalog.Types.Float4Array.Options,
stanumbers3?: PgCatalog.Types.Float4Array.Options,
stanumbers4?: PgCatalog.Types.Float4Array.Options,
stanumbers5?: PgCatalog.Types.Float4Array.Options,
stavalues1?: PgCatalog.Types.Anyarray.Options,
stavalues2?: PgCatalog.Types.Anyarray.Options,
stavalues3?: PgCatalog.Types.Anyarray.Options,
stavalues4?: PgCatalog.Types.Anyarray.Options,
stavalues5?: PgCatalog.Types.Anyarray.Options
}
}
export namespace PgStatisticArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatisticExt {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxstattarget {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxkeys {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxkind {
export type Options = InvokeQueryOptions;
}
export namespace Stxexprs {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
stxrelid?: PgCatalog.Types.Oid.Options,
stxname?: PgCatalog.Types.Name.Options,
stxnamespace?: PgCatalog.Types.Oid.Options,
stxowner?: PgCatalog.Types.Oid.Options,
stxstattarget?: PgCatalog.Types.Int4.Options,
stxkeys?: PgCatalog.Types.Int2vector.Options,
stxkind?: PgCatalog.Types.CharArray.Options,
stxexprs?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgStatisticExtArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatisticExtData {
export namespace Stxoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxdinherit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxdndistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxddependencies {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxdmcv {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxdexpr {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 stxoid?: PgCatalog.Types.Oid.Options,
stxdinherit?: PgCatalog.Types.Bool.Options,
stxdndistinct?: PgCatalog.Types.PgNdistinct.Options,
stxddependencies?: PgCatalog.Types.PgDependencies.Options,
stxdmcv?: PgCatalog.Types.PgMcvList.Options,
stxdexpr?: PgCatalog.Types.PgStatisticArray.Options
}
}
export namespace PgStatisticExtDataArray {
export type Options = InvokeQueryOptions;
}
export namespace PgRewrite {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rulename {

      export type Options = InvokeQueryOptions;
    
}
export namespace EvClass {

      export type Options = InvokeQueryOptions;
    
}
export namespace EvType {

      export type Options = InvokeQueryOptions;
    
}
export namespace EvEnabled {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsInstead {

      export type Options = InvokeQueryOptions;
    
}
export namespace EvQual {

      export type Options = InvokeQueryOptions;
    
}
export namespace EvAction {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
rulename?: PgCatalog.Types.Name.Options,
evClass?: PgCatalog.Types.Oid.Options,
evType?: PgCatalog.Types.Char.Options,
evEnabled?: PgCatalog.Types.Char.Options,
isInstead?: PgCatalog.Types.Bool.Options,
evQual?: PgCatalog.Types.PgNodeTree.Options,
evAction?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgRewriteArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTrigger {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgparentid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgfoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgenabled {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgisinternal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgconstrrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgconstrindid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgconstraint {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgdeferrable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tginitdeferred {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgnargs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgattr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgargs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgqual {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgoldtable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgnewtable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
tgrelid?: PgCatalog.Types.Oid.Options,
tgparentid?: PgCatalog.Types.Oid.Options,
tgname?: PgCatalog.Types.Name.Options,
tgfoid?: PgCatalog.Types.Oid.Options,
tgtype?: PgCatalog.Types.Int2.Options,
tgenabled?: PgCatalog.Types.Char.Options,
tgisinternal?: PgCatalog.Types.Bool.Options,
tgconstrrelid?: PgCatalog.Types.Oid.Options,
tgconstrindid?: PgCatalog.Types.Oid.Options,
tgconstraint?: PgCatalog.Types.Oid.Options,
tgdeferrable?: PgCatalog.Types.Bool.Options,
tginitdeferred?: PgCatalog.Types.Bool.Options,
tgnargs?: PgCatalog.Types.Int2.Options,
tgattr?: PgCatalog.Types.Int2vector.Options,
tgargs?: PgCatalog.Types.Bytea.Options,
tgqual?: PgCatalog.Types.PgNodeTree.Options,
tgoldtable?: PgCatalog.Types.Name.Options,
tgnewtable?: PgCatalog.Types.Name.Options
}
}
export namespace PgTriggerArray {
export type Options = InvokeQueryOptions;
}
export namespace PgEventTrigger {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evtname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evtevent {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evtowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evtfoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evtenabled {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evttags {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
evtname?: PgCatalog.Types.Name.Options,
evtevent?: PgCatalog.Types.Name.Options,
evtowner?: PgCatalog.Types.Oid.Options,
evtfoid?: PgCatalog.Types.Oid.Options,
evtenabled?: PgCatalog.Types.Char.Options,
evttags?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgEventTriggerArray {
export type Options = InvokeQueryOptions;
}
export namespace PgDescription {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Description {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
description?: PgCatalog.Types.Text.Options
}
}
export namespace PgDescriptionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgCast {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Castsource {

      export type Options = InvokeQueryOptions;
    
}
export namespace Casttarget {

      export type Options = InvokeQueryOptions;
    
}
export namespace Castfunc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Castcontext {

      export type Options = InvokeQueryOptions;
    
}
export namespace Castmethod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
castsource?: PgCatalog.Types.Oid.Options,
casttarget?: PgCatalog.Types.Oid.Options,
castfunc?: PgCatalog.Types.Oid.Options,
castcontext?: PgCatalog.Types.Char.Options,
castmethod?: PgCatalog.Types.Char.Options
}
}
export namespace PgCastArray {
export type Options = InvokeQueryOptions;
}
export namespace PgEnum {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumtypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumsortorder {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumlabel {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
enumtypid?: PgCatalog.Types.Oid.Options,
enumsortorder?: PgCatalog.Types.Float4.Options,
enumlabel?: PgCatalog.Types.Name.Options
}
}
export namespace PgEnumArray {
export type Options = InvokeQueryOptions;
}
export namespace PgNamespace {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nspname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nspowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nspacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
nspname?: PgCatalog.Types.Name.Options,
nspowner?: PgCatalog.Types.Oid.Options,
nspacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgNamespaceArray {
export type Options = InvokeQueryOptions;
}
export namespace PgConversion {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Connamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conforencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Contoencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conproc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Condefault {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
conname?: PgCatalog.Types.Name.Options,
connamespace?: PgCatalog.Types.Oid.Options,
conowner?: PgCatalog.Types.Oid.Options,
conforencoding?: PgCatalog.Types.Int4.Options,
contoencoding?: PgCatalog.Types.Int4.Options,
conproc?: PgCatalog.Types.Regproc.Options,
condefault?: PgCatalog.Types.Bool.Options
}
}
export namespace PgConversionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgDepend {
export namespace Classid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refclassid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Deptype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 classid?: PgCatalog.Types.Oid.Options,
objid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
refclassid?: PgCatalog.Types.Oid.Options,
refobjid?: PgCatalog.Types.Oid.Options,
refobjsubid?: PgCatalog.Types.Int4.Options,
deptype?: PgCatalog.Types.Char.Options
}
}
export namespace PgDependArray {
export type Options = InvokeQueryOptions;
}
export namespace PgDatabase {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datdba {

      export type Options = InvokeQueryOptions;
    
}
export namespace Encoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datlocprovider {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datistemplate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datallowconn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datconnlimit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datfrozenxid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datminmxid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dattablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datcollate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datctype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Daticulocale {

      export type Options = InvokeQueryOptions;
    
}
export namespace Daticurules {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datcollversion {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
datdba?: PgCatalog.Types.Oid.Options,
encoding?: PgCatalog.Types.Int4.Options,
datlocprovider?: PgCatalog.Types.Char.Options,
datistemplate?: PgCatalog.Types.Bool.Options,
datallowconn?: PgCatalog.Types.Bool.Options,
datconnlimit?: PgCatalog.Types.Int4.Options,
datfrozenxid?: PgCatalog.Types.Xid.Options,
datminmxid?: PgCatalog.Types.Xid.Options,
dattablespace?: PgCatalog.Types.Oid.Options,
datcollate?: PgCatalog.Types.Text.Options,
datctype?: PgCatalog.Types.Text.Options,
daticulocale?: PgCatalog.Types.Text.Options,
daticurules?: PgCatalog.Types.Text.Options,
datcollversion?: PgCatalog.Types.Text.Options,
datacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgDatabaseArray {
export type Options = InvokeQueryOptions;
}
export namespace PgDbRoleSetting {
export namespace Setdatabase {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setrole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setconfig {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 setdatabase?: PgCatalog.Types.Oid.Options,
setrole?: PgCatalog.Types.Oid.Options,
setconfig?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgDbRoleSettingArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTablespace {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Spcname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Spcowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Spcacl {
export type Options = InvokeQueryOptions;
}
export namespace Spcoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
spcname?: PgCatalog.Types.Name.Options,
spcowner?: PgCatalog.Types.Oid.Options,
spcacl?: PgCatalog.Types.AclitemArray.Options,
spcoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgTablespaceArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAuthid {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolsuper {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolinherit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcreaterole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcreatedb {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcanlogin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolreplication {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolbypassrls {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolconnlimit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolpassword {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolvaliduntil {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
rolname?: PgCatalog.Types.Name.Options,
rolsuper?: PgCatalog.Types.Bool.Options,
rolinherit?: PgCatalog.Types.Bool.Options,
rolcreaterole?: PgCatalog.Types.Bool.Options,
rolcreatedb?: PgCatalog.Types.Bool.Options,
rolcanlogin?: PgCatalog.Types.Bool.Options,
rolreplication?: PgCatalog.Types.Bool.Options,
rolbypassrls?: PgCatalog.Types.Bool.Options,
rolconnlimit?: PgCatalog.Types.Int4.Options,
rolpassword?: PgCatalog.Types.Text.Options,
rolvaliduntil?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgAuthidArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAuthMembers {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Roleid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Member {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace AdminOption {

      export type Options = InvokeQueryOptions;
    
}
export namespace InheritOption {

      export type Options = InvokeQueryOptions;
    
}
export namespace SetOption {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
roleid?: PgCatalog.Types.Oid.Options,
member?: PgCatalog.Types.Oid.Options,
grantor?: PgCatalog.Types.Oid.Options,
adminOption?: PgCatalog.Types.Bool.Options,
inheritOption?: PgCatalog.Types.Bool.Options,
setOption?: PgCatalog.Types.Bool.Options
}
}
export namespace PgAuthMembersArray {
export type Options = InvokeQueryOptions;
}
export namespace PgShdepend {
export namespace Dbid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refclassid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Deptype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 dbid?: PgCatalog.Types.Oid.Options,
classid?: PgCatalog.Types.Oid.Options,
objid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
refclassid?: PgCatalog.Types.Oid.Options,
refobjid?: PgCatalog.Types.Oid.Options,
deptype?: PgCatalog.Types.Char.Options
}
}
export namespace PgShdependArray {
export type Options = InvokeQueryOptions;
}
export namespace PgShdescription {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Description {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
description?: PgCatalog.Types.Text.Options
}
}
export namespace PgShdescriptionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTsConfig {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cfgname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cfgnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cfgowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cfgparser {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
cfgname?: PgCatalog.Types.Name.Options,
cfgnamespace?: PgCatalog.Types.Oid.Options,
cfgowner?: PgCatalog.Types.Oid.Options,
cfgparser?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsConfigArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTsConfigMap {
export namespace Mapcfg {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maptokentype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mapseqno {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mapdict {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 mapcfg?: PgCatalog.Types.Oid.Options,
maptokentype?: PgCatalog.Types.Int4.Options,
mapseqno?: PgCatalog.Types.Int4.Options,
mapdict?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsConfigMapArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTsDict {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dictname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dictnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dictowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dicttemplate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dictinitoption {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
dictname?: PgCatalog.Types.Name.Options,
dictnamespace?: PgCatalog.Types.Oid.Options,
dictowner?: PgCatalog.Types.Oid.Options,
dicttemplate?: PgCatalog.Types.Oid.Options,
dictinitoption?: PgCatalog.Types.Text.Options
}
}
export namespace PgTsDictArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTsParser {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsstart {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prstoken {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsend {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsheadline {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prslextype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
prsname?: PgCatalog.Types.Name.Options,
prsnamespace?: PgCatalog.Types.Oid.Options,
prsstart?: PgCatalog.Types.Regproc.Options,
prstoken?: PgCatalog.Types.Regproc.Options,
prsend?: PgCatalog.Types.Regproc.Options,
prsheadline?: PgCatalog.Types.Regproc.Options,
prslextype?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgTsParserArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTsTemplate {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmplname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmplnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmplinit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmpllexize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
tmplname?: PgCatalog.Types.Name.Options,
tmplnamespace?: PgCatalog.Types.Oid.Options,
tmplinit?: PgCatalog.Types.Regproc.Options,
tmpllexize?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgTsTemplateArray {
export type Options = InvokeQueryOptions;
}
export namespace PgExtension {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extrelocatable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extversion {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extconfig {
export type Options = InvokeQueryOptions;
}
export namespace Extcondition {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
extname?: PgCatalog.Types.Name.Options,
extowner?: PgCatalog.Types.Oid.Options,
extnamespace?: PgCatalog.Types.Oid.Options,
extrelocatable?: PgCatalog.Types.Bool.Options,
extversion?: PgCatalog.Types.Text.Options,
extconfig?: PgCatalog.Types.OidArray.Options,
extcondition?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgExtensionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignDataWrapper {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwhandler {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwvalidator {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwacl {
export type Options = InvokeQueryOptions;
}
export namespace Fdwoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
fdwname?: PgCatalog.Types.Name.Options,
fdwowner?: PgCatalog.Types.Oid.Options,
fdwhandler?: PgCatalog.Types.Oid.Options,
fdwvalidator?: PgCatalog.Types.Oid.Options,
fdwacl?: PgCatalog.Types.AclitemArray.Options,
fdwoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgForeignDataWrapperArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignServer {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvfdw {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvversion {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvacl {
export type Options = InvokeQueryOptions;
}
export namespace Srvoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
srvname?: PgCatalog.Types.Name.Options,
srvowner?: PgCatalog.Types.Oid.Options,
srvfdw?: PgCatalog.Types.Oid.Options,
srvtype?: PgCatalog.Types.Text.Options,
srvversion?: PgCatalog.Types.Text.Options,
srvacl?: PgCatalog.Types.AclitemArray.Options,
srvoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgForeignServerArray {
export type Options = InvokeQueryOptions;
}
export namespace PgUserMapping {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umuser {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umserver {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
umuser?: PgCatalog.Types.Oid.Options,
umserver?: PgCatalog.Types.Oid.Options,
umoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgUserMappingArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignTable {
export namespace Ftrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ftserver {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ftoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 ftrelid?: PgCatalog.Types.Oid.Options,
ftserver?: PgCatalog.Types.Oid.Options,
ftoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgForeignTableArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPolicy {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polcmd {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polpermissive {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polroles {
export type Options = InvokeQueryOptions;
}
export namespace Polqual {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polwithcheck {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
polname?: PgCatalog.Types.Name.Options,
polrelid?: PgCatalog.Types.Oid.Options,
polcmd?: PgCatalog.Types.Char.Options,
polpermissive?: PgCatalog.Types.Bool.Options,
polroles?: PgCatalog.Types.OidArray.Options,
polqual?: PgCatalog.Types.PgNodeTree.Options,
polwithcheck?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgPolicyArray {
export type Options = InvokeQueryOptions;
}
export namespace PgReplicationOrigin {
export namespace Roident {

      export type Options = InvokeQueryOptions;
    
}
export namespace Roname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 roident?: PgCatalog.Types.Oid.Options,
roname?: PgCatalog.Types.Text.Options
}
}
export namespace PgReplicationOriginArray {
export type Options = InvokeQueryOptions;
}
export namespace PgDefaultAcl {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclrole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclobjtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclacl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
defaclrole?: PgCatalog.Types.Oid.Options,
defaclnamespace?: PgCatalog.Types.Oid.Options,
defaclobjtype?: PgCatalog.Types.Char.Options,
defaclacl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgDefaultAclArray {
export type Options = InvokeQueryOptions;
}
export namespace PgInitPrivs {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Privtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Initprivs {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
privtype?: PgCatalog.Types.Char.Options,
initprivs?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgInitPrivsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSeclabel {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provider {

      export type Options = InvokeQueryOptions;
    
}
export namespace Label {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
provider?: PgCatalog.Types.Text.Options,
label?: PgCatalog.Types.Text.Options
}
}
export namespace PgSeclabelArray {
export type Options = InvokeQueryOptions;
}
export namespace PgShseclabel {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provider {

      export type Options = InvokeQueryOptions;
    
}
export namespace Label {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
provider?: PgCatalog.Types.Text.Options,
label?: PgCatalog.Types.Text.Options
}
}
export namespace PgShseclabelArray {
export type Options = InvokeQueryOptions;
}
export namespace PgCollation {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collprovider {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collisdeterministic {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collcollate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collctype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Colliculocale {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collicurules {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collversion {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
collname?: PgCatalog.Types.Name.Options,
collnamespace?: PgCatalog.Types.Oid.Options,
collowner?: PgCatalog.Types.Oid.Options,
collprovider?: PgCatalog.Types.Char.Options,
collisdeterministic?: PgCatalog.Types.Bool.Options,
collencoding?: PgCatalog.Types.Int4.Options,
collcollate?: PgCatalog.Types.Text.Options,
collctype?: PgCatalog.Types.Text.Options,
colliculocale?: PgCatalog.Types.Text.Options,
collicurules?: PgCatalog.Types.Text.Options,
collversion?: PgCatalog.Types.Text.Options
}
}
export namespace PgCollationArray {
export type Options = InvokeQueryOptions;
}
export namespace PgParameterAcl {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Parname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Paracl {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
parname?: PgCatalog.Types.Text.Options,
paracl?: PgCatalog.Types.AclitemArray.Options
}
}
export namespace PgParameterAclArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPartitionedTable {
export namespace Partrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Partstrat {

      export type Options = InvokeQueryOptions;
    
}
export namespace Partnatts {

      export type Options = InvokeQueryOptions;
    
}
export namespace Partdefid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Partattrs {

      export type Options = InvokeQueryOptions;
    
}
export namespace Partclass {
export type Options = InvokeQueryOptions;
}
export namespace Partcollation {
export type Options = InvokeQueryOptions;
}
export namespace Partexprs {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 partrelid?: PgCatalog.Types.Oid.Options,
partstrat?: PgCatalog.Types.Char.Options,
partnatts?: PgCatalog.Types.Int2.Options,
partdefid?: PgCatalog.Types.Oid.Options,
partattrs?: PgCatalog.Types.Int2vector.Options,
partclass?: PgCatalog.Types.Oidvector.Options,
partcollation?: PgCatalog.Types.Oidvector.Options,
partexprs?: PgCatalog.Types.PgNodeTree.Options
}
}
export namespace PgPartitionedTableArray {
export type Options = InvokeQueryOptions;
}
export namespace PgRange {
export namespace Rngtypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngsubtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngmultitypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngcollation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngsubopc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngcanonical {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rngsubdiff {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 rngtypid?: PgCatalog.Types.Oid.Options,
rngsubtype?: PgCatalog.Types.Oid.Options,
rngmultitypid?: PgCatalog.Types.Oid.Options,
rngcollation?: PgCatalog.Types.Oid.Options,
rngsubopc?: PgCatalog.Types.Oid.Options,
rngcanonical?: PgCatalog.Types.Regproc.Options,
rngsubdiff?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgRangeArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTransform {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trftype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trflang {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trffromsql {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trftosql {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
trftype?: PgCatalog.Types.Oid.Options,
trflang?: PgCatalog.Types.Oid.Options,
trffromsql?: PgCatalog.Types.Regproc.Options,
trftosql?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgTransformArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSequence {
export namespace Seqrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqtypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqstart {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqincrement {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqmax {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqcache {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqcycle {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 seqrelid?: PgCatalog.Types.Oid.Options,
seqtypid?: PgCatalog.Types.Oid.Options,
seqstart?: PgCatalog.Types.Int8.Options,
seqincrement?: PgCatalog.Types.Int8.Options,
seqmax?: PgCatalog.Types.Int8.Options,
seqmin?: PgCatalog.Types.Int8.Options,
seqcache?: PgCatalog.Types.Int8.Options,
seqcycle?: PgCatalog.Types.Bool.Options
}
}
export namespace PgSequenceArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPublication {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Puballtables {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubinsert {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubupdate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubdelete {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubtruncate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pubviaroot {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
pubname?: PgCatalog.Types.Name.Options,
pubowner?: PgCatalog.Types.Oid.Options,
puballtables?: PgCatalog.Types.Bool.Options,
pubinsert?: PgCatalog.Types.Bool.Options,
pubupdate?: PgCatalog.Types.Bool.Options,
pubdelete?: PgCatalog.Types.Bool.Options,
pubtruncate?: PgCatalog.Types.Bool.Options,
pubviaroot?: PgCatalog.Types.Bool.Options
}
}
export namespace PgPublicationArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPublicationNamespace {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pnpubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pnnspid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
pnpubid?: PgCatalog.Types.Oid.Options,
pnnspid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationNamespaceArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPublicationRel {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prpubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prqual {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prattrs {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
prpubid?: PgCatalog.Types.Oid.Options,
prrelid?: PgCatalog.Types.Oid.Options,
prqual?: PgCatalog.Types.PgNodeTree.Options,
prattrs?: PgCatalog.Types.Int2vector.Options
}
}
export namespace PgPublicationRelArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSubscription {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subdbid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subskiplsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subenabled {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subbinary {

      export type Options = InvokeQueryOptions;
    
}
export namespace Substream {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subtwophasestate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subdisableonerr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subpasswordrequired {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subrunasowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subconninfo {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subslotname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subsynccommit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subpublications {
export type Options = InvokeQueryOptions;
}
export namespace Suborigin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
subdbid?: PgCatalog.Types.Oid.Options,
subskiplsn?: PgCatalog.Types.PgLsn.Options,
subname?: PgCatalog.Types.Name.Options,
subowner?: PgCatalog.Types.Oid.Options,
subenabled?: PgCatalog.Types.Bool.Options,
subbinary?: PgCatalog.Types.Bool.Options,
substream?: PgCatalog.Types.Char.Options,
subtwophasestate?: PgCatalog.Types.Char.Options,
subdisableonerr?: PgCatalog.Types.Bool.Options,
subpasswordrequired?: PgCatalog.Types.Bool.Options,
subrunasowner?: PgCatalog.Types.Bool.Options,
subconninfo?: PgCatalog.Types.Text.Options,
subslotname?: PgCatalog.Types.Name.Options,
subsynccommit?: PgCatalog.Types.Text.Options,
subpublications?: PgCatalog.Types.TextArray.Options,
suborigin?: PgCatalog.Types.Text.Options
}
}
export namespace PgSubscriptionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSubscriptionRel {
export namespace Srsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srsubstate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srsublsn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 srsubid?: PgCatalog.Types.Oid.Options,
srrelid?: PgCatalog.Types.Oid.Options,
srsubstate?: PgCatalog.Types.Char.Options,
srsublsn?: PgCatalog.Types.PgLsn.Options
}
}
export namespace PgSubscriptionRelArray {
export type Options = InvokeQueryOptions;
}
export namespace PgRoles {
export namespace Rolname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolsuper {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolinherit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcreaterole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcreatedb {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolcanlogin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolreplication {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolconnlimit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolpassword {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolvaliduntil {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolbypassrls {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rolconfig {
export type Options = InvokeQueryOptions;
}
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 rolname?: PgCatalog.Types.Name.Options,
rolsuper?: PgCatalog.Types.Bool.Options,
rolinherit?: PgCatalog.Types.Bool.Options,
rolcreaterole?: PgCatalog.Types.Bool.Options,
rolcreatedb?: PgCatalog.Types.Bool.Options,
rolcanlogin?: PgCatalog.Types.Bool.Options,
rolreplication?: PgCatalog.Types.Bool.Options,
rolconnlimit?: PgCatalog.Types.Int4.Options,
rolpassword?: PgCatalog.Types.Text.Options,
rolvaliduntil?: PgCatalog.Types.Timestamptz.Options,
rolbypassrls?: PgCatalog.Types.Bool.Options,
rolconfig?: PgCatalog.Types.TextArray.Options,
oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgRolesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgShadow {
export namespace Usename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesysid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usecreatedb {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesuper {

      export type Options = InvokeQueryOptions;
    
}
export namespace Userepl {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usebypassrls {

      export type Options = InvokeQueryOptions;
    
}
export namespace Passwd {

      export type Options = InvokeQueryOptions;
    
}
export namespace Valuntil {

      export type Options = InvokeQueryOptions;
    
}
export namespace Useconfig {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 usename?: PgCatalog.Types.Name.Options,
usesysid?: PgCatalog.Types.Oid.Options,
usecreatedb?: PgCatalog.Types.Bool.Options,
usesuper?: PgCatalog.Types.Bool.Options,
userepl?: PgCatalog.Types.Bool.Options,
usebypassrls?: PgCatalog.Types.Bool.Options,
passwd?: PgCatalog.Types.Text.Options,
valuntil?: PgCatalog.Types.Timestamptz.Options,
useconfig?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgShadowArray {
export type Options = InvokeQueryOptions;
}
export namespace PgGroup {
export namespace Groname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grosysid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grolist {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 groname?: PgCatalog.Types.Name.Options,
grosysid?: PgCatalog.Types.Oid.Options,
grolist?: PgCatalog.Types.OidArray.Options
}
}
export namespace PgGroupArray {
export type Options = InvokeQueryOptions;
}
export namespace PgUser {
export namespace Usename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesysid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usecreatedb {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesuper {

      export type Options = InvokeQueryOptions;
    
}
export namespace Userepl {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usebypassrls {

      export type Options = InvokeQueryOptions;
    
}
export namespace Passwd {

      export type Options = InvokeQueryOptions;
    
}
export namespace Valuntil {

      export type Options = InvokeQueryOptions;
    
}
export namespace Useconfig {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 usename?: PgCatalog.Types.Name.Options,
usesysid?: PgCatalog.Types.Oid.Options,
usecreatedb?: PgCatalog.Types.Bool.Options,
usesuper?: PgCatalog.Types.Bool.Options,
userepl?: PgCatalog.Types.Bool.Options,
usebypassrls?: PgCatalog.Types.Bool.Options,
passwd?: PgCatalog.Types.Text.Options,
valuntil?: PgCatalog.Types.Timestamptz.Options,
useconfig?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgUserArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPolicies {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Policyname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Permissive {

      export type Options = InvokeQueryOptions;
    
}
export namespace Roles {
export type Options = InvokeQueryOptions;
}
export namespace Cmd {

      export type Options = InvokeQueryOptions;
    
}
export namespace Qual {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithCheck {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
policyname?: PgCatalog.Types.Name.Options,
permissive?: PgCatalog.Types.Text.Options,
roles?: PgCatalog.Types.NameArray.Options,
cmd?: PgCatalog.Types.Text.Options,
qual?: PgCatalog.Types.Text.Options,
withCheck?: PgCatalog.Types.Text.Options
}
}
export namespace PgPoliciesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgRules {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rulename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Definition {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
rulename?: PgCatalog.Types.Name.Options,
definition?: PgCatalog.Types.Text.Options
}
}
export namespace PgRulesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgViews {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Viewname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Viewowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Definition {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
viewname?: PgCatalog.Types.Name.Options,
viewowner?: PgCatalog.Types.Name.Options,
definition?: PgCatalog.Types.Text.Options
}
}
export namespace PgViewsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTables {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tableowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hasindexes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hasrules {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hastriggers {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rowsecurity {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
tableowner?: PgCatalog.Types.Name.Options,
tablespace?: PgCatalog.Types.Name.Options,
hasindexes?: PgCatalog.Types.Bool.Options,
hasrules?: PgCatalog.Types.Bool.Options,
hastriggers?: PgCatalog.Types.Bool.Options,
rowsecurity?: PgCatalog.Types.Bool.Options
}
}
export namespace PgTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgMatviews {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Matviewname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Matviewowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hasindexes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ispopulated {

      export type Options = InvokeQueryOptions;
    
}
export namespace Definition {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
matviewname?: PgCatalog.Types.Name.Options,
matviewowner?: PgCatalog.Types.Name.Options,
tablespace?: PgCatalog.Types.Name.Options,
hasindexes?: PgCatalog.Types.Bool.Options,
ispopulated?: PgCatalog.Types.Bool.Options,
definition?: PgCatalog.Types.Text.Options
}
}
export namespace PgMatviewsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgIndexes {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexdef {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
indexname?: PgCatalog.Types.Name.Options,
tablespace?: PgCatalog.Types.Name.Options,
indexdef?: PgCatalog.Types.Text.Options
}
}
export namespace PgIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSequences {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sequencename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sequenceowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace StartValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace MinValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace IncrementBy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cycle {

      export type Options = InvokeQueryOptions;
    
}
export namespace CacheSize {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
sequencename?: PgCatalog.Types.Name.Options,
sequenceowner?: PgCatalog.Types.Name.Options,
dataType?: PgCatalog.Types.Regtype.Options,
startValue?: PgCatalog.Types.Int8.Options,
minValue?: PgCatalog.Types.Int8.Options,
maxValue?: PgCatalog.Types.Int8.Options,
incrementBy?: PgCatalog.Types.Int8.Options,
cycle?: PgCatalog.Types.Bool.Options,
cacheSize?: PgCatalog.Types.Int8.Options,
lastValue?: PgCatalog.Types.Int8.Options
}
}
export namespace PgSequencesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStats {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inherited {

      export type Options = InvokeQueryOptions;
    
}
export namespace NullFrac {

      export type Options = InvokeQueryOptions;
    
}
export namespace AvgWidth {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonVals {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonFreqs {
export type Options = InvokeQueryOptions;
}
export namespace HistogramBounds {

      export type Options = InvokeQueryOptions;
    
}
export namespace Correlation {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonElems {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonElemFreqs {
export type Options = InvokeQueryOptions;
}
export namespace ElemCountHistogram {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
attname?: PgCatalog.Types.Name.Options,
inherited?: PgCatalog.Types.Bool.Options,
nullFrac?: PgCatalog.Types.Float4.Options,
avgWidth?: PgCatalog.Types.Int4.Options,
nDistinct?: PgCatalog.Types.Float4.Options,
mostCommonVals?: PgCatalog.Types.Anyarray.Options,
mostCommonFreqs?: PgCatalog.Types.Float4Array.Options,
histogramBounds?: PgCatalog.Types.Anyarray.Options,
correlation?: PgCatalog.Types.Float4.Options,
mostCommonElems?: PgCatalog.Types.Anyarray.Options,
mostCommonElemFreqs?: PgCatalog.Types.Float4Array.Options,
elemCountHistogram?: PgCatalog.Types.Float4Array.Options
}
}
export namespace PgStatsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatsExt {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsSchemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsName {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsOwner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attnames {
export type Options = InvokeQueryOptions;
}
export namespace Exprs {
export type Options = InvokeQueryOptions;
}
export namespace Kinds {
export type Options = InvokeQueryOptions;
}
export namespace Inherited {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dependencies {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonVals {
export type Options = InvokeQueryOptions;
}
export namespace MostCommonValNulls {
export type Options = InvokeQueryOptions;
}
export namespace MostCommonFreqs {
export type Options = InvokeQueryOptions;
}
export namespace MostCommonBaseFreqs {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
statisticsSchemaname?: PgCatalog.Types.Name.Options,
statisticsName?: PgCatalog.Types.Name.Options,
statisticsOwner?: PgCatalog.Types.Name.Options,
attnames?: PgCatalog.Types.NameArray.Options,
exprs?: PgCatalog.Types.TextArray.Options,
kinds?: PgCatalog.Types.CharArray.Options,
inherited?: PgCatalog.Types.Bool.Options,
nDistinct?: PgCatalog.Types.PgNdistinct.Options,
dependencies?: PgCatalog.Types.PgDependencies.Options,
mostCommonVals?: PgCatalog.Types.TextArray.Options,
mostCommonValNulls?: PgCatalog.Types.BoolArray.Options,
mostCommonFreqs?: PgCatalog.Types.Float8Array.Options,
mostCommonBaseFreqs?: PgCatalog.Types.Float8Array.Options
}
}
export namespace PgStatsExtArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatsExtExprs {
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsSchemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsName {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatisticsOwner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Expr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inherited {

      export type Options = InvokeQueryOptions;
    
}
export namespace NullFrac {

      export type Options = InvokeQueryOptions;
    
}
export namespace AvgWidth {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDistinct {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonVals {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonFreqs {
export type Options = InvokeQueryOptions;
}
export namespace HistogramBounds {

      export type Options = InvokeQueryOptions;
    
}
export namespace Correlation {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonElems {

      export type Options = InvokeQueryOptions;
    
}
export namespace MostCommonElemFreqs {
export type Options = InvokeQueryOptions;
}
export namespace ElemCountHistogram {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
statisticsSchemaname?: PgCatalog.Types.Name.Options,
statisticsName?: PgCatalog.Types.Name.Options,
statisticsOwner?: PgCatalog.Types.Name.Options,
expr?: PgCatalog.Types.Text.Options,
inherited?: PgCatalog.Types.Bool.Options,
nullFrac?: PgCatalog.Types.Float4.Options,
avgWidth?: PgCatalog.Types.Int4.Options,
nDistinct?: PgCatalog.Types.Float4.Options,
mostCommonVals?: PgCatalog.Types.Anyarray.Options,
mostCommonFreqs?: PgCatalog.Types.Float4Array.Options,
histogramBounds?: PgCatalog.Types.Anyarray.Options,
correlation?: PgCatalog.Types.Float4.Options,
mostCommonElems?: PgCatalog.Types.Anyarray.Options,
mostCommonElemFreqs?: PgCatalog.Types.Float4Array.Options,
elemCountHistogram?: PgCatalog.Types.Float4Array.Options
}
}
export namespace PgStatsExtExprsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPublicationTables {
export namespace Pubname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tablename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attnames {
export type Options = InvokeQueryOptions;
}
export namespace Rowfilter {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pubname?: PgCatalog.Types.Name.Options,
schemaname?: PgCatalog.Types.Name.Options,
tablename?: PgCatalog.Types.Name.Options,
attnames?: PgCatalog.Types.NameArray.Options,
rowfilter?: PgCatalog.Types.Text.Options
}
}
export namespace PgPublicationTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgLocks {
export namespace Locktype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Database {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Page {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tuple {

      export type Options = InvokeQueryOptions;
    
}
export namespace Virtualxid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Transactionid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Virtualtransaction {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mode {

      export type Options = InvokeQueryOptions;
    
}
export namespace Granted {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fastpath {

      export type Options = InvokeQueryOptions;
    
}
export namespace Waitstart {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 locktype?: PgCatalog.Types.Text.Options,
database?: PgCatalog.Types.Oid.Options,
relation?: PgCatalog.Types.Oid.Options,
page?: PgCatalog.Types.Int4.Options,
tuple?: PgCatalog.Types.Int2.Options,
virtualxid?: PgCatalog.Types.Text.Options,
transactionid?: PgCatalog.Types.Xid.Options,
classid?: PgCatalog.Types.Oid.Options,
objid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int2.Options,
virtualtransaction?: PgCatalog.Types.Text.Options,
pid?: PgCatalog.Types.Int4.Options,
mode?: PgCatalog.Types.Text.Options,
granted?: PgCatalog.Types.Bool.Options,
fastpath?: PgCatalog.Types.Bool.Options,
waitstart?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgLocksArray {
export type Options = InvokeQueryOptions;
}
export namespace PgCursors {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Statement {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsHoldable {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsBinary {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsScrollable {

      export type Options = InvokeQueryOptions;
    
}
export namespace CreationTime {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
statement?: PgCatalog.Types.Text.Options,
isHoldable?: PgCatalog.Types.Bool.Options,
isBinary?: PgCatalog.Types.Bool.Options,
isScrollable?: PgCatalog.Types.Bool.Options,
creationTime?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgCursorsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAvailableExtensions {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultVersion {

      export type Options = InvokeQueryOptions;
    
}
export namespace InstalledVersion {

      export type Options = InvokeQueryOptions;
    
}
export namespace Comment {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Name.Options,
defaultVersion?: PgCatalog.Types.Text.Options,
installedVersion?: PgCatalog.Types.Text.Options,
comment?: PgCatalog.Types.Text.Options
}
}
export namespace PgAvailableExtensionsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgAvailableExtensionVersions {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Version {

      export type Options = InvokeQueryOptions;
    
}
export namespace Installed {

      export type Options = InvokeQueryOptions;
    
}
export namespace Superuser {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trusted {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relocatable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schema {

      export type Options = InvokeQueryOptions;
    
}
export namespace Requires {
export type Options = InvokeQueryOptions;
}
export namespace Comment {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Name.Options,
version?: PgCatalog.Types.Text.Options,
installed?: PgCatalog.Types.Bool.Options,
superuser?: PgCatalog.Types.Bool.Options,
trusted?: PgCatalog.Types.Bool.Options,
relocatable?: PgCatalog.Types.Bool.Options,
schema?: PgCatalog.Types.Name.Options,
requires?: PgCatalog.Types.NameArray.Options,
comment?: PgCatalog.Types.Text.Options
}
}
export namespace PgAvailableExtensionVersionsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPreparedXacts {
export namespace Transaction {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prepared {

      export type Options = InvokeQueryOptions;
    
}
export namespace Owner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Database {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 transaction?: PgCatalog.Types.Xid.Options,
gid?: PgCatalog.Types.Text.Options,
prepared?: PgCatalog.Types.Timestamptz.Options,
owner?: PgCatalog.Types.Name.Options,
database?: PgCatalog.Types.Name.Options
}
}
export namespace PgPreparedXactsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgPreparedStatements {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Statement {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrepareTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParameterTypes {
export type Options = InvokeQueryOptions;
}
export namespace ResultTypes {
export type Options = InvokeQueryOptions;
}
export namespace FromSql {

      export type Options = InvokeQueryOptions;
    
}
export namespace GenericPlans {

      export type Options = InvokeQueryOptions;
    
}
export namespace CustomPlans {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
statement?: PgCatalog.Types.Text.Options,
prepareTime?: PgCatalog.Types.Timestamptz.Options,
parameterTypes?: PgCatalog.Types.RegtypeArray.Options,
resultTypes?: PgCatalog.Types.RegtypeArray.Options,
fromSql?: PgCatalog.Types.Bool.Options,
genericPlans?: PgCatalog.Types.Int8.Options,
customPlans?: PgCatalog.Types.Int8.Options
}
}
export namespace PgPreparedStatementsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSeclabels {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objtype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provider {

      export type Options = InvokeQueryOptions;
    
}
export namespace Label {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
objtype?: PgCatalog.Types.Text.Options,
objnamespace?: PgCatalog.Types.Oid.Options,
objname?: PgCatalog.Types.Text.Options,
provider?: PgCatalog.Types.Text.Options,
label?: PgCatalog.Types.Text.Options
}
}
export namespace PgSeclabelsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgSettings {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setting {

      export type Options = InvokeQueryOptions;
    
}
export namespace Unit {

      export type Options = InvokeQueryOptions;
    
}
export namespace Category {

      export type Options = InvokeQueryOptions;
    
}
export namespace ShortDesc {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtraDesc {

      export type Options = InvokeQueryOptions;
    
}
export namespace Context {

      export type Options = InvokeQueryOptions;
    
}
export namespace Vartype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Source {

      export type Options = InvokeQueryOptions;
    
}
export namespace MinVal {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxVal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumvals {
export type Options = InvokeQueryOptions;
}
export namespace BootVal {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResetVal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sourcefile {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sourceline {

      export type Options = InvokeQueryOptions;
    
}
export namespace PendingRestart {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
setting?: PgCatalog.Types.Text.Options,
unit?: PgCatalog.Types.Text.Options,
category?: PgCatalog.Types.Text.Options,
shortDesc?: PgCatalog.Types.Text.Options,
extraDesc?: PgCatalog.Types.Text.Options,
context?: PgCatalog.Types.Text.Options,
vartype?: PgCatalog.Types.Text.Options,
source?: PgCatalog.Types.Text.Options,
minVal?: PgCatalog.Types.Text.Options,
maxVal?: PgCatalog.Types.Text.Options,
enumvals?: PgCatalog.Types.TextArray.Options,
bootVal?: PgCatalog.Types.Text.Options,
resetVal?: PgCatalog.Types.Text.Options,
sourcefile?: PgCatalog.Types.Text.Options,
sourceline?: PgCatalog.Types.Int4.Options,
pendingRestart?: PgCatalog.Types.Bool.Options
}
}
export namespace PgSettingsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgFileSettings {
export namespace Sourcefile {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sourceline {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seqno {

      export type Options = InvokeQueryOptions;
    
}
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setting {

      export type Options = InvokeQueryOptions;
    
}
export namespace Applied {

      export type Options = InvokeQueryOptions;
    
}
export namespace Error {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 sourcefile?: PgCatalog.Types.Text.Options,
sourceline?: PgCatalog.Types.Int4.Options,
seqno?: PgCatalog.Types.Int4.Options,
name?: PgCatalog.Types.Text.Options,
setting?: PgCatalog.Types.Text.Options,
applied?: PgCatalog.Types.Bool.Options,
error?: PgCatalog.Types.Text.Options
}
}
export namespace PgFileSettingsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgHbaFileRules {
export namespace RuleNumber {

      export type Options = InvokeQueryOptions;
    
}
export namespace FileName {

      export type Options = InvokeQueryOptions;
    
}
export namespace LineNumber {

      export type Options = InvokeQueryOptions;
    
}
export namespace Type {

      export type Options = InvokeQueryOptions;
    
}
export namespace Database {
export type Options = InvokeQueryOptions;
}
export namespace UserName {
export type Options = InvokeQueryOptions;
}
export namespace Address {

      export type Options = InvokeQueryOptions;
    
}
export namespace Netmask {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthMethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {
export type Options = InvokeQueryOptions;
}
export namespace Error {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 ruleNumber?: PgCatalog.Types.Int4.Options,
fileName?: PgCatalog.Types.Text.Options,
lineNumber?: PgCatalog.Types.Int4.Options,
type?: PgCatalog.Types.Text.Options,
database?: PgCatalog.Types.TextArray.Options,
userName?: PgCatalog.Types.TextArray.Options,
address?: PgCatalog.Types.Text.Options,
netmask?: PgCatalog.Types.Text.Options,
authMethod?: PgCatalog.Types.Text.Options,
options?: PgCatalog.Types.TextArray.Options,
error?: PgCatalog.Types.Text.Options
}
}
export namespace PgHbaFileRulesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgIdentFileMappings {
export namespace MapNumber {

      export type Options = InvokeQueryOptions;
    
}
export namespace FileName {

      export type Options = InvokeQueryOptions;
    
}
export namespace LineNumber {

      export type Options = InvokeQueryOptions;
    
}
export namespace MapName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SysName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PgUsername {

      export type Options = InvokeQueryOptions;
    
}
export namespace Error {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 mapNumber?: PgCatalog.Types.Int4.Options,
fileName?: PgCatalog.Types.Text.Options,
lineNumber?: PgCatalog.Types.Int4.Options,
mapName?: PgCatalog.Types.Text.Options,
sysName?: PgCatalog.Types.Text.Options,
pgUsername?: PgCatalog.Types.Text.Options,
error?: PgCatalog.Types.Text.Options
}
}
export namespace PgIdentFileMappingsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTimezoneAbbrevs {
export namespace Abbrev {

      export type Options = InvokeQueryOptions;
    
}
export namespace UtcOffset {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDst {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 abbrev?: PgCatalog.Types.Text.Options,
utcOffset?: PgCatalog.Types.Interval.Options,
isDst?: PgCatalog.Types.Bool.Options
}
}
export namespace PgTimezoneAbbrevsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgTimezoneNames {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Abbrev {

      export type Options = InvokeQueryOptions;
    
}
export namespace UtcOffset {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDst {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
abbrev?: PgCatalog.Types.Text.Options,
utcOffset?: PgCatalog.Types.Interval.Options,
isDst?: PgCatalog.Types.Bool.Options
}
}
export namespace PgTimezoneNamesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgConfig {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setting {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
setting?: PgCatalog.Types.Text.Options
}
}
export namespace PgConfigArray {
export type Options = InvokeQueryOptions;
}
export namespace PgShmemAllocations {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Off {

      export type Options = InvokeQueryOptions;
    
}
export namespace Size {

      export type Options = InvokeQueryOptions;
    
}
export namespace AllocatedSize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
off?: PgCatalog.Types.Int8.Options,
size?: PgCatalog.Types.Int8.Options,
allocatedSize?: PgCatalog.Types.Int8.Options
}
}
export namespace PgShmemAllocationsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgBackendMemoryContexts {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ident {

      export type Options = InvokeQueryOptions;
    
}
export namespace Parent {

      export type Options = InvokeQueryOptions;
    
}
export namespace Level {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalNblocks {

      export type Options = InvokeQueryOptions;
    
}
export namespace FreeBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace FreeChunks {

      export type Options = InvokeQueryOptions;
    
}
export namespace UsedBytes {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
ident?: PgCatalog.Types.Text.Options,
parent?: PgCatalog.Types.Text.Options,
level?: PgCatalog.Types.Int4.Options,
totalBytes?: PgCatalog.Types.Int8.Options,
totalNblocks?: PgCatalog.Types.Int8.Options,
freeBytes?: PgCatalog.Types.Int8.Options,
freeChunks?: PgCatalog.Types.Int8.Options,
usedBytes?: PgCatalog.Types.Int8.Options
}
}
export namespace PgBackendMemoryContextsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatAllTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastSeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NLiveTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDeadTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NModSinceAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace NInsSinceVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutovacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutoanalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace VacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutovacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AnalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutoanalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
lastSeqScan?: PgCatalog.Types.Timestamptz.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options,
nLiveTup?: PgCatalog.Types.Int8.Options,
nDeadTup?: PgCatalog.Types.Int8.Options,
nModSinceAnalyze?: PgCatalog.Types.Int8.Options,
nInsSinceVacuum?: PgCatalog.Types.Int8.Options,
lastVacuum?: PgCatalog.Types.Timestamptz.Options,
lastAutovacuum?: PgCatalog.Types.Timestamptz.Options,
lastAnalyze?: PgCatalog.Types.Timestamptz.Options,
lastAutoanalyze?: PgCatalog.Types.Timestamptz.Options,
vacuumCount?: PgCatalog.Types.Int8.Options,
autovacuumCount?: PgCatalog.Types.Int8.Options,
analyzeCount?: PgCatalog.Types.Int8.Options,
autoanalyzeCount?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatAllTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatXactAllTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatXactAllTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSysTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastSeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NLiveTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDeadTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NModSinceAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace NInsSinceVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutovacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutoanalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace VacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutovacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AnalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutoanalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
lastSeqScan?: PgCatalog.Types.Timestamptz.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options,
nLiveTup?: PgCatalog.Types.Int8.Options,
nDeadTup?: PgCatalog.Types.Int8.Options,
nModSinceAnalyze?: PgCatalog.Types.Int8.Options,
nInsSinceVacuum?: PgCatalog.Types.Int8.Options,
lastVacuum?: PgCatalog.Types.Timestamptz.Options,
lastAutovacuum?: PgCatalog.Types.Timestamptz.Options,
lastAnalyze?: PgCatalog.Types.Timestamptz.Options,
lastAutoanalyze?: PgCatalog.Types.Timestamptz.Options,
vacuumCount?: PgCatalog.Types.Int8.Options,
autovacuumCount?: PgCatalog.Types.Int8.Options,
analyzeCount?: PgCatalog.Types.Int8.Options,
autoanalyzeCount?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatSysTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatXactSysTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatXactSysTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatUserTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastSeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NLiveTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NDeadTup {

      export type Options = InvokeQueryOptions;
    
}
export namespace NModSinceAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace NInsSinceVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastVacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutovacuum {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAnalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAutoanalyze {

      export type Options = InvokeQueryOptions;
    
}
export namespace VacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutovacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AnalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace AutoanalyzeCount {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
lastSeqScan?: PgCatalog.Types.Timestamptz.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options,
nLiveTup?: PgCatalog.Types.Int8.Options,
nDeadTup?: PgCatalog.Types.Int8.Options,
nModSinceAnalyze?: PgCatalog.Types.Int8.Options,
nInsSinceVacuum?: PgCatalog.Types.Int8.Options,
lastVacuum?: PgCatalog.Types.Timestamptz.Options,
lastAutovacuum?: PgCatalog.Types.Timestamptz.Options,
lastAnalyze?: PgCatalog.Types.Timestamptz.Options,
lastAutoanalyze?: PgCatalog.Types.Timestamptz.Options,
vacuumCount?: PgCatalog.Types.Int8.Options,
autovacuumCount?: PgCatalog.Types.Int8.Options,
analyzeCount?: PgCatalog.Types.Int8.Options,
autoanalyzeCount?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatUserTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatXactUserTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace SeqTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupIns {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupDel {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupHotUpd {

      export type Options = InvokeQueryOptions;
    
}
export namespace NTupNewpageUpd {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
seqScan?: PgCatalog.Types.Int8.Options,
seqTupRead?: PgCatalog.Types.Int8.Options,
idxScan?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options,
nTupIns?: PgCatalog.Types.Int8.Options,
nTupUpd?: PgCatalog.Types.Int8.Options,
nTupDel?: PgCatalog.Types.Int8.Options,
nTupHotUpd?: PgCatalog.Types.Int8.Options,
nTupNewpageUpd?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatXactUserTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioAllTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
heapBlksRead?: PgCatalog.Types.Int8.Options,
heapBlksHit?: PgCatalog.Types.Int8.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options,
toastBlksRead?: PgCatalog.Types.Int8.Options,
toastBlksHit?: PgCatalog.Types.Int8.Options,
tidxBlksRead?: PgCatalog.Types.Int8.Options,
tidxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioAllTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioSysTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
heapBlksRead?: PgCatalog.Types.Int8.Options,
heapBlksHit?: PgCatalog.Types.Int8.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options,
toastBlksRead?: PgCatalog.Types.Int8.Options,
toastBlksHit?: PgCatalog.Types.Int8.Options,
tidxBlksRead?: PgCatalog.Types.Int8.Options,
tidxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioSysTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioUserTables {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToastBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace TidxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
heapBlksRead?: PgCatalog.Types.Int8.Options,
heapBlksHit?: PgCatalog.Types.Int8.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options,
toastBlksRead?: PgCatalog.Types.Int8.Options,
toastBlksHit?: PgCatalog.Types.Int8.Options,
tidxBlksRead?: PgCatalog.Types.Int8.Options,
tidxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioUserTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatAllIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupRead?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatAllIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSysIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupRead?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatSysIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatUserIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastIdxScan {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxTupFetch {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxScan?: PgCatalog.Types.Int8.Options,
lastIdxScan?: PgCatalog.Types.Timestamptz.Options,
idxTupRead?: PgCatalog.Types.Int8.Options,
idxTupFetch?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatUserIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioAllIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioAllIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioSysIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioSysIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioUserIndexes {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Indexrelname {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdxBlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
indexrelid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
indexrelname?: PgCatalog.Types.Name.Options,
idxBlksRead?: PgCatalog.Types.Int8.Options,
idxBlksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioUserIndexesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioAllSequences {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
blksRead?: PgCatalog.Types.Int8.Options,
blksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioAllSequencesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioSysSequences {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
blksRead?: PgCatalog.Types.Int8.Options,
blksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioSysSequencesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatioUserSequences {
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksHit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
blksRead?: PgCatalog.Types.Int8.Options,
blksHit?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatioUserSequencesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatActivity {
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace LeaderPid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesysid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usename {

      export type Options = InvokeQueryOptions;
    
}
export namespace ApplicationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientAddr {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientHostname {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientPort {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendStart {

      export type Options = InvokeQueryOptions;
    
}
export namespace XactStart {

      export type Options = InvokeQueryOptions;
    
}
export namespace QueryStart {

      export type Options = InvokeQueryOptions;
    
}
export namespace StateChange {

      export type Options = InvokeQueryOptions;
    
}
export namespace WaitEventType {

      export type Options = InvokeQueryOptions;
    
}
export namespace WaitEvent {

      export type Options = InvokeQueryOptions;
    
}
export namespace State {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendXid {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendXmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace QueryId {

      export type Options = InvokeQueryOptions;
    
}
export namespace Query {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendType {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
pid?: PgCatalog.Types.Int4.Options,
leaderPid?: PgCatalog.Types.Int4.Options,
usesysid?: PgCatalog.Types.Oid.Options,
usename?: PgCatalog.Types.Name.Options,
applicationName?: PgCatalog.Types.Text.Options,
clientAddr?: PgCatalog.Types.Inet.Options,
clientHostname?: PgCatalog.Types.Text.Options,
clientPort?: PgCatalog.Types.Int4.Options,
backendStart?: PgCatalog.Types.Timestamptz.Options,
xactStart?: PgCatalog.Types.Timestamptz.Options,
queryStart?: PgCatalog.Types.Timestamptz.Options,
stateChange?: PgCatalog.Types.Timestamptz.Options,
waitEventType?: PgCatalog.Types.Text.Options,
waitEvent?: PgCatalog.Types.Text.Options,
state?: PgCatalog.Types.Text.Options,
backendXid?: PgCatalog.Types.Xid.Options,
backendXmin?: PgCatalog.Types.Xid.Options,
queryId?: PgCatalog.Types.Int8.Options,
query?: PgCatalog.Types.Text.Options,
backendType?: PgCatalog.Types.Text.Options
}
}
export namespace PgStatActivityArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatReplication {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usesysid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usename {

      export type Options = InvokeQueryOptions;
    
}
export namespace ApplicationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientAddr {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientHostname {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientPort {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendStart {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackendXmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace State {

      export type Options = InvokeQueryOptions;
    
}
export namespace SentLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace WriteLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace FlushLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReplayLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace WriteLag {

      export type Options = InvokeQueryOptions;
    
}
export namespace FlushLag {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReplayLag {

      export type Options = InvokeQueryOptions;
    
}
export namespace SyncPriority {

      export type Options = InvokeQueryOptions;
    
}
export namespace SyncState {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReplyTime {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
usesysid?: PgCatalog.Types.Oid.Options,
usename?: PgCatalog.Types.Name.Options,
applicationName?: PgCatalog.Types.Text.Options,
clientAddr?: PgCatalog.Types.Inet.Options,
clientHostname?: PgCatalog.Types.Text.Options,
clientPort?: PgCatalog.Types.Int4.Options,
backendStart?: PgCatalog.Types.Timestamptz.Options,
backendXmin?: PgCatalog.Types.Xid.Options,
state?: PgCatalog.Types.Text.Options,
sentLsn?: PgCatalog.Types.PgLsn.Options,
writeLsn?: PgCatalog.Types.PgLsn.Options,
flushLsn?: PgCatalog.Types.PgLsn.Options,
replayLsn?: PgCatalog.Types.PgLsn.Options,
writeLag?: PgCatalog.Types.Interval.Options,
flushLag?: PgCatalog.Types.Interval.Options,
replayLag?: PgCatalog.Types.Interval.Options,
syncPriority?: PgCatalog.Types.Int4.Options,
syncState?: PgCatalog.Types.Text.Options,
replyTime?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatReplicationArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSlru {
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksZeroed {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksWritten {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksExists {

      export type Options = InvokeQueryOptions;
    
}
export namespace Flushes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Truncates {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 name?: PgCatalog.Types.Text.Options,
blksZeroed?: PgCatalog.Types.Int8.Options,
blksHit?: PgCatalog.Types.Int8.Options,
blksRead?: PgCatalog.Types.Int8.Options,
blksWritten?: PgCatalog.Types.Int8.Options,
blksExists?: PgCatalog.Types.Int8.Options,
flushes?: PgCatalog.Types.Int8.Options,
truncates?: PgCatalog.Types.Int8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatSlruArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatWalReceiver {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Status {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReceiveStartLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReceiveStartTli {

      export type Options = InvokeQueryOptions;
    
}
export namespace WrittenLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace FlushedLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReceivedTli {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastMsgSendTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastMsgReceiptTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace LatestEndLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace LatestEndTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace SlotName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SenderHost {

      export type Options = InvokeQueryOptions;
    
}
export namespace SenderPort {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conninfo {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
status?: PgCatalog.Types.Text.Options,
receiveStartLsn?: PgCatalog.Types.PgLsn.Options,
receiveStartTli?: PgCatalog.Types.Int4.Options,
writtenLsn?: PgCatalog.Types.PgLsn.Options,
flushedLsn?: PgCatalog.Types.PgLsn.Options,
receivedTli?: PgCatalog.Types.Int4.Options,
lastMsgSendTime?: PgCatalog.Types.Timestamptz.Options,
lastMsgReceiptTime?: PgCatalog.Types.Timestamptz.Options,
latestEndLsn?: PgCatalog.Types.PgLsn.Options,
latestEndTime?: PgCatalog.Types.Timestamptz.Options,
slotName?: PgCatalog.Types.Text.Options,
senderHost?: PgCatalog.Types.Text.Options,
senderPort?: PgCatalog.Types.Int4.Options,
conninfo?: PgCatalog.Types.Text.Options
}
}
export namespace PgStatWalReceiverArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatRecoveryPrefetch {
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prefetch {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hit {

      export type Options = InvokeQueryOptions;
    
}
export namespace SkipInit {

      export type Options = InvokeQueryOptions;
    
}
export namespace SkipNew {

      export type Options = InvokeQueryOptions;
    
}
export namespace SkipFpw {

      export type Options = InvokeQueryOptions;
    
}
export namespace SkipRep {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalDistance {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlockDistance {

      export type Options = InvokeQueryOptions;
    
}
export namespace IoDepth {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 statsReset?: PgCatalog.Types.Timestamptz.Options,
prefetch?: PgCatalog.Types.Int8.Options,
hit?: PgCatalog.Types.Int8.Options,
skipInit?: PgCatalog.Types.Int8.Options,
skipNew?: PgCatalog.Types.Int8.Options,
skipFpw?: PgCatalog.Types.Int8.Options,
skipRep?: PgCatalog.Types.Int8.Options,
walDistance?: PgCatalog.Types.Int4.Options,
blockDistance?: PgCatalog.Types.Int4.Options,
ioDepth?: PgCatalog.Types.Int4.Options
}
}
export namespace PgStatRecoveryPrefetchArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSubscription {
export namespace Subid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace LeaderPid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReceivedLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastMsgSendTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastMsgReceiptTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace LatestEndLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace LatestEndTime {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 subid?: PgCatalog.Types.Oid.Options,
subname?: PgCatalog.Types.Name.Options,
pid?: PgCatalog.Types.Int4.Options,
leaderPid?: PgCatalog.Types.Int4.Options,
relid?: PgCatalog.Types.Oid.Options,
receivedLsn?: PgCatalog.Types.PgLsn.Options,
lastMsgSendTime?: PgCatalog.Types.Timestamptz.Options,
lastMsgReceiptTime?: PgCatalog.Types.Timestamptz.Options,
latestEndLsn?: PgCatalog.Types.PgLsn.Options,
latestEndTime?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatSubscriptionArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSsl {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ssl {

      export type Options = InvokeQueryOptions;
    
}
export namespace Version {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cipher {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bits {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientDn {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClientSerial {

      export type Options = InvokeQueryOptions;
    
}
export namespace IssuerDn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
ssl?: PgCatalog.Types.Bool.Options,
version?: PgCatalog.Types.Text.Options,
cipher?: PgCatalog.Types.Text.Options,
bits?: PgCatalog.Types.Int4.Options,
clientDn?: PgCatalog.Types.Text.Options,
clientSerial?: PgCatalog.Types.Numeric.Options,
issuerDn?: PgCatalog.Types.Text.Options
}
}
export namespace PgStatSslArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatGssapi {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace GssAuthenticated {

      export type Options = InvokeQueryOptions;
    
}
export namespace Principal {

      export type Options = InvokeQueryOptions;
    
}
export namespace Encrypted {

      export type Options = InvokeQueryOptions;
    
}
export namespace CredentialsDelegated {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
gssAuthenticated?: PgCatalog.Types.Bool.Options,
principal?: PgCatalog.Types.Text.Options,
encrypted?: PgCatalog.Types.Bool.Options,
credentialsDelegated?: PgCatalog.Types.Bool.Options
}
}
export namespace PgStatGssapiArray {
export type Options = InvokeQueryOptions;
}
export namespace PgReplicationSlots {
export namespace SlotName {

      export type Options = InvokeQueryOptions;
    
}
export namespace Plugin {

      export type Options = InvokeQueryOptions;
    
}
export namespace SlotType {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Database {

      export type Options = InvokeQueryOptions;
    
}
export namespace Temporary {

      export type Options = InvokeQueryOptions;
    
}
export namespace Active {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActivePid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Xmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace CatalogXmin {

      export type Options = InvokeQueryOptions;
    
}
export namespace RestartLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConfirmedFlushLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalStatus {

      export type Options = InvokeQueryOptions;
    
}
export namespace SafeWalSize {

      export type Options = InvokeQueryOptions;
    
}
export namespace TwoPhase {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conflicting {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 slotName?: PgCatalog.Types.Name.Options,
plugin?: PgCatalog.Types.Name.Options,
slotType?: PgCatalog.Types.Text.Options,
datoid?: PgCatalog.Types.Oid.Options,
database?: PgCatalog.Types.Name.Options,
temporary?: PgCatalog.Types.Bool.Options,
active?: PgCatalog.Types.Bool.Options,
activePid?: PgCatalog.Types.Int4.Options,
xmin?: PgCatalog.Types.Xid.Options,
catalogXmin?: PgCatalog.Types.Xid.Options,
restartLsn?: PgCatalog.Types.PgLsn.Options,
confirmedFlushLsn?: PgCatalog.Types.PgLsn.Options,
walStatus?: PgCatalog.Types.Text.Options,
safeWalSize?: PgCatalog.Types.Int8.Options,
twoPhase?: PgCatalog.Types.Bool.Options,
conflicting?: PgCatalog.Types.Bool.Options
}
}
export namespace PgReplicationSlotsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatReplicationSlots {
export namespace SlotName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpillTxns {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpillCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpillBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace StreamTxns {

      export type Options = InvokeQueryOptions;
    
}
export namespace StreamCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace StreamBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalTxns {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 slotName?: PgCatalog.Types.Text.Options,
spillTxns?: PgCatalog.Types.Int8.Options,
spillCount?: PgCatalog.Types.Int8.Options,
spillBytes?: PgCatalog.Types.Int8.Options,
streamTxns?: PgCatalog.Types.Int8.Options,
streamCount?: PgCatalog.Types.Int8.Options,
streamBytes?: PgCatalog.Types.Int8.Options,
totalTxns?: PgCatalog.Types.Int8.Options,
totalBytes?: PgCatalog.Types.Int8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatReplicationSlotsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatDatabase {
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Numbackends {

      export type Options = InvokeQueryOptions;
    
}
export namespace XactCommit {

      export type Options = InvokeQueryOptions;
    
}
export namespace XactRollback {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksRead {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlksHit {

      export type Options = InvokeQueryOptions;
    
}
export namespace TupReturned {

      export type Options = InvokeQueryOptions;
    
}
export namespace TupFetched {

      export type Options = InvokeQueryOptions;
    
}
export namespace TupInserted {

      export type Options = InvokeQueryOptions;
    
}
export namespace TupUpdated {

      export type Options = InvokeQueryOptions;
    
}
export namespace TupDeleted {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conflicts {

      export type Options = InvokeQueryOptions;
    
}
export namespace TempFiles {

      export type Options = InvokeQueryOptions;
    
}
export namespace TempBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Deadlocks {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChecksumFailures {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChecksumLastFailure {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlkReadTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlkWriteTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace SessionTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActiveTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdleInTransactionTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace Sessions {

      export type Options = InvokeQueryOptions;
    
}
export namespace SessionsAbandoned {

      export type Options = InvokeQueryOptions;
    
}
export namespace SessionsFatal {

      export type Options = InvokeQueryOptions;
    
}
export namespace SessionsKilled {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
numbackends?: PgCatalog.Types.Int4.Options,
xactCommit?: PgCatalog.Types.Int8.Options,
xactRollback?: PgCatalog.Types.Int8.Options,
blksRead?: PgCatalog.Types.Int8.Options,
blksHit?: PgCatalog.Types.Int8.Options,
tupReturned?: PgCatalog.Types.Int8.Options,
tupFetched?: PgCatalog.Types.Int8.Options,
tupInserted?: PgCatalog.Types.Int8.Options,
tupUpdated?: PgCatalog.Types.Int8.Options,
tupDeleted?: PgCatalog.Types.Int8.Options,
conflicts?: PgCatalog.Types.Int8.Options,
tempFiles?: PgCatalog.Types.Int8.Options,
tempBytes?: PgCatalog.Types.Int8.Options,
deadlocks?: PgCatalog.Types.Int8.Options,
checksumFailures?: PgCatalog.Types.Int8.Options,
checksumLastFailure?: PgCatalog.Types.Timestamptz.Options,
blkReadTime?: PgCatalog.Types.Float8.Options,
blkWriteTime?: PgCatalog.Types.Float8.Options,
sessionTime?: PgCatalog.Types.Float8.Options,
activeTime?: PgCatalog.Types.Float8.Options,
idleInTransactionTime?: PgCatalog.Types.Float8.Options,
sessions?: PgCatalog.Types.Int8.Options,
sessionsAbandoned?: PgCatalog.Types.Int8.Options,
sessionsFatal?: PgCatalog.Types.Int8.Options,
sessionsKilled?: PgCatalog.Types.Int8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatDatabaseArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatDatabaseConflicts {
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflTablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflLock {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflSnapshot {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflBufferpin {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflDeadlock {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConflActiveLogicalslot {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
conflTablespace?: PgCatalog.Types.Int8.Options,
conflLock?: PgCatalog.Types.Int8.Options,
conflSnapshot?: PgCatalog.Types.Int8.Options,
conflBufferpin?: PgCatalog.Types.Int8.Options,
conflDeadlock?: PgCatalog.Types.Int8.Options,
conflActiveLogicalslot?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatDatabaseConflictsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatUserFunctions {
export namespace Funcid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Funcname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Calls {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace SelfTime {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 funcid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
funcname?: PgCatalog.Types.Name.Options,
calls?: PgCatalog.Types.Int8.Options,
totalTime?: PgCatalog.Types.Float8.Options,
selfTime?: PgCatalog.Types.Float8.Options
}
}
export namespace PgStatUserFunctionsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatXactUserFunctions {
export namespace Funcid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Schemaname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Funcname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Calls {

      export type Options = InvokeQueryOptions;
    
}
export namespace TotalTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace SelfTime {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 funcid?: PgCatalog.Types.Oid.Options,
schemaname?: PgCatalog.Types.Name.Options,
funcname?: PgCatalog.Types.Name.Options,
calls?: PgCatalog.Types.Int8.Options,
totalTime?: PgCatalog.Types.Float8.Options,
selfTime?: PgCatalog.Types.Float8.Options
}
}
export namespace PgStatXactUserFunctionsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatArchiver {
export namespace ArchivedCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastArchivedWal {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastArchivedTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace FailedCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastFailedWal {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastFailedTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 archivedCount?: PgCatalog.Types.Int8.Options,
lastArchivedWal?: PgCatalog.Types.Text.Options,
lastArchivedTime?: PgCatalog.Types.Timestamptz.Options,
failedCount?: PgCatalog.Types.Int8.Options,
lastFailedWal?: PgCatalog.Types.Text.Options,
lastFailedTime?: PgCatalog.Types.Timestamptz.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatArchiverArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatBgwriter {
export namespace CheckpointsTimed {

      export type Options = InvokeQueryOptions;
    
}
export namespace CheckpointsReq {

      export type Options = InvokeQueryOptions;
    
}
export namespace CheckpointWriteTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace CheckpointSyncTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace BuffersCheckpoint {

      export type Options = InvokeQueryOptions;
    
}
export namespace BuffersClean {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxwrittenClean {

      export type Options = InvokeQueryOptions;
    
}
export namespace BuffersBackend {

      export type Options = InvokeQueryOptions;
    
}
export namespace BuffersBackendFsync {

      export type Options = InvokeQueryOptions;
    
}
export namespace BuffersAlloc {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 checkpointsTimed?: PgCatalog.Types.Int8.Options,
checkpointsReq?: PgCatalog.Types.Int8.Options,
checkpointWriteTime?: PgCatalog.Types.Float8.Options,
checkpointSyncTime?: PgCatalog.Types.Float8.Options,
buffersCheckpoint?: PgCatalog.Types.Int8.Options,
buffersClean?: PgCatalog.Types.Int8.Options,
maxwrittenClean?: PgCatalog.Types.Int8.Options,
buffersBackend?: PgCatalog.Types.Int8.Options,
buffersBackendFsync?: PgCatalog.Types.Int8.Options,
buffersAlloc?: PgCatalog.Types.Int8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatBgwriterArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatIo {
export namespace BackendType {

      export type Options = InvokeQueryOptions;
    
}
export namespace Object {

      export type Options = InvokeQueryOptions;
    
}
export namespace Context {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reads {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReadTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace Writes {

      export type Options = InvokeQueryOptions;
    
}
export namespace WriteTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace Writebacks {

      export type Options = InvokeQueryOptions;
    
}
export namespace WritebackTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extends {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtendTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace OpBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Hits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Evictions {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reuses {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fsyncs {

      export type Options = InvokeQueryOptions;
    
}
export namespace FsyncTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 backendType?: PgCatalog.Types.Text.Options,
object?: PgCatalog.Types.Text.Options,
context?: PgCatalog.Types.Text.Options,
reads?: PgCatalog.Types.Int8.Options,
readTime?: PgCatalog.Types.Float8.Options,
writes?: PgCatalog.Types.Int8.Options,
writeTime?: PgCatalog.Types.Float8.Options,
writebacks?: PgCatalog.Types.Int8.Options,
writebackTime?: PgCatalog.Types.Float8.Options,
extends?: PgCatalog.Types.Int8.Options,
extendTime?: PgCatalog.Types.Float8.Options,
opBytes?: PgCatalog.Types.Int8.Options,
hits?: PgCatalog.Types.Int8.Options,
evictions?: PgCatalog.Types.Int8.Options,
reuses?: PgCatalog.Types.Int8.Options,
fsyncs?: PgCatalog.Types.Int8.Options,
fsyncTime?: PgCatalog.Types.Float8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatIoArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatWal {
export namespace WalRecords {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalFpi {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalBytes {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalBuffersFull {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalWrite {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalSync {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalWriteTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace WalSyncTime {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 walRecords?: PgCatalog.Types.Int8.Options,
walFpi?: PgCatalog.Types.Int8.Options,
walBytes?: PgCatalog.Types.Numeric.Options,
walBuffersFull?: PgCatalog.Types.Int8.Options,
walWrite?: PgCatalog.Types.Int8.Options,
walSync?: PgCatalog.Types.Int8.Options,
walWriteTime?: PgCatalog.Types.Float8.Options,
walSyncTime?: PgCatalog.Types.Float8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatWalArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressAnalyze {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Phase {

      export type Options = InvokeQueryOptions;
    
}
export namespace SampleBlksTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace SampleBlksScanned {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtStatsTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtStatsComputed {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChildTablesTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChildTablesDone {

      export type Options = InvokeQueryOptions;
    
}
export namespace CurrentChildTableRelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
relid?: PgCatalog.Types.Oid.Options,
phase?: PgCatalog.Types.Text.Options,
sampleBlksTotal?: PgCatalog.Types.Int8.Options,
sampleBlksScanned?: PgCatalog.Types.Int8.Options,
extStatsTotal?: PgCatalog.Types.Int8.Options,
extStatsComputed?: PgCatalog.Types.Int8.Options,
childTablesTotal?: PgCatalog.Types.Int8.Options,
childTablesDone?: PgCatalog.Types.Int8.Options,
currentChildTableRelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgStatProgressAnalyzeArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressVacuum {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Phase {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksScanned {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksVacuumed {

      export type Options = InvokeQueryOptions;
    
}
export namespace IndexVacuumCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxDeadTuples {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumDeadTuples {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
relid?: PgCatalog.Types.Oid.Options,
phase?: PgCatalog.Types.Text.Options,
heapBlksTotal?: PgCatalog.Types.Int8.Options,
heapBlksScanned?: PgCatalog.Types.Int8.Options,
heapBlksVacuumed?: PgCatalog.Types.Int8.Options,
indexVacuumCount?: PgCatalog.Types.Int8.Options,
maxDeadTuples?: PgCatalog.Types.Int8.Options,
numDeadTuples?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatProgressVacuumArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressCluster {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Command {

      export type Options = InvokeQueryOptions;
    
}
export namespace Phase {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClusterIndexRelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapTuplesScanned {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapTuplesWritten {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace HeapBlksScanned {

      export type Options = InvokeQueryOptions;
    
}
export namespace IndexRebuildCount {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
relid?: PgCatalog.Types.Oid.Options,
command?: PgCatalog.Types.Text.Options,
phase?: PgCatalog.Types.Text.Options,
clusterIndexRelid?: PgCatalog.Types.Oid.Options,
heapTuplesScanned?: PgCatalog.Types.Int8.Options,
heapTuplesWritten?: PgCatalog.Types.Int8.Options,
heapBlksTotal?: PgCatalog.Types.Int8.Options,
heapBlksScanned?: PgCatalog.Types.Int8.Options,
indexRebuildCount?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatProgressClusterArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressCreateIndex {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace IndexRelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Command {

      export type Options = InvokeQueryOptions;
    
}
export namespace Phase {

      export type Options = InvokeQueryOptions;
    
}
export namespace LockersTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace LockersDone {

      export type Options = InvokeQueryOptions;
    
}
export namespace CurrentLockerPid {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlocksTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace BlocksDone {

      export type Options = InvokeQueryOptions;
    
}
export namespace TuplesTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace TuplesDone {

      export type Options = InvokeQueryOptions;
    
}
export namespace PartitionsTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace PartitionsDone {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
relid?: PgCatalog.Types.Oid.Options,
indexRelid?: PgCatalog.Types.Oid.Options,
command?: PgCatalog.Types.Text.Options,
phase?: PgCatalog.Types.Text.Options,
lockersTotal?: PgCatalog.Types.Int8.Options,
lockersDone?: PgCatalog.Types.Int8.Options,
currentLockerPid?: PgCatalog.Types.Int8.Options,
blocksTotal?: PgCatalog.Types.Int8.Options,
blocksDone?: PgCatalog.Types.Int8.Options,
tuplesTotal?: PgCatalog.Types.Int8.Options,
tuplesDone?: PgCatalog.Types.Int8.Options,
partitionsTotal?: PgCatalog.Types.Int8.Options,
partitionsDone?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatProgressCreateIndexArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressBasebackup {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Phase {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackupTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace BackupStreamed {

      export type Options = InvokeQueryOptions;
    
}
export namespace TablespacesTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace TablespacesStreamed {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
phase?: PgCatalog.Types.Text.Options,
backupTotal?: PgCatalog.Types.Int8.Options,
backupStreamed?: PgCatalog.Types.Int8.Options,
tablespacesTotal?: PgCatalog.Types.Int8.Options,
tablespacesStreamed?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatProgressBasebackupArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatProgressCopy {
export namespace Pid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Command {

      export type Options = InvokeQueryOptions;
    
}
export namespace Type {

      export type Options = InvokeQueryOptions;
    
}
export namespace BytesProcessed {

      export type Options = InvokeQueryOptions;
    
}
export namespace BytesTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace TuplesProcessed {

      export type Options = InvokeQueryOptions;
    
}
export namespace TuplesExcluded {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pid?: PgCatalog.Types.Int4.Options,
datid?: PgCatalog.Types.Oid.Options,
datname?: PgCatalog.Types.Name.Options,
relid?: PgCatalog.Types.Oid.Options,
command?: PgCatalog.Types.Text.Options,
type?: PgCatalog.Types.Text.Options,
bytesProcessed?: PgCatalog.Types.Int8.Options,
bytesTotal?: PgCatalog.Types.Int8.Options,
tuplesProcessed?: PgCatalog.Types.Int8.Options,
tuplesExcluded?: PgCatalog.Types.Int8.Options
}
}
export namespace PgStatProgressCopyArray {
export type Options = InvokeQueryOptions;
}
export namespace PgUserMappings {
export namespace Umid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umuser {

      export type Options = InvokeQueryOptions;
    
}
export namespace Usename {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 umid?: PgCatalog.Types.Oid.Options,
srvid?: PgCatalog.Types.Oid.Options,
srvname?: PgCatalog.Types.Name.Options,
umuser?: PgCatalog.Types.Oid.Options,
usename?: PgCatalog.Types.Name.Options,
umoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace PgUserMappingsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgReplicationOriginStatus {
export namespace LocalId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExternalId {

      export type Options = InvokeQueryOptions;
    
}
export namespace RemoteLsn {

      export type Options = InvokeQueryOptions;
    
}
export namespace LocalLsn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 localId?: PgCatalog.Types.Oid.Options,
externalId?: PgCatalog.Types.Text.Options,
remoteLsn?: PgCatalog.Types.PgLsn.Options,
localLsn?: PgCatalog.Types.PgLsn.Options
}
}
export namespace PgReplicationOriginStatusArray {
export type Options = InvokeQueryOptions;
}
export namespace PgStatSubscriptionStats {
export namespace Subid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subname {

      export type Options = InvokeQueryOptions;
    
}
export namespace ApplyErrorCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace SyncErrorCount {

      export type Options = InvokeQueryOptions;
    
}
export namespace StatsReset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 subid?: PgCatalog.Types.Oid.Options,
subname?: PgCatalog.Types.Name.Options,
applyErrorCount?: PgCatalog.Types.Int8.Options,
syncErrorCount?: PgCatalog.Types.Int8.Options,
statsReset?: PgCatalog.Types.Timestamptz.Options
}
}
export namespace PgStatSubscriptionStatsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgProcOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgProcPronameArgsNspIndex {
export namespace Proname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proargtypes {
export type Options = InvokeQueryOptions;
}
export namespace Pronamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 proname?: PgCatalog.Types.Name.Options,
proargtypes?: PgCatalog.Types.Oidvector.Options,
pronamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTypeOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTypeTypnameNspIndex {
export namespace Typname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Typnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 typname?: PgCatalog.Types.Name.Options,
typnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAttributeRelidAttnamIndex {
export namespace Attrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 attrelid?: PgCatalog.Types.Oid.Options,
attname?: PgCatalog.Types.Name.Options
}
}
export namespace PgAttributeRelidAttnumIndex {
export namespace Attrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attnum {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 attrelid?: PgCatalog.Types.Oid.Options,
attnum?: PgCatalog.Types.Int2.Options
}
}
export namespace PgClassOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgClassRelnameNspIndex {
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 relname?: PgCatalog.Types.Name.Options,
relnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgClassTblspcRelfilenodeIndex {
export namespace Reltablespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relfilenode {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 reltablespace?: PgCatalog.Types.Oid.Options,
relfilenode?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAttrdefAdrelidAdnumIndex {
export namespace Adrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Adnum {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 adrelid?: PgCatalog.Types.Oid.Options,
adnum?: PgCatalog.Types.Int2.Options
}
}
export namespace PgAttrdefOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConstraintConnameNspIndex {
export namespace Conname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Connamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 conname?: PgCatalog.Types.Name.Options,
connamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConstraintConrelidContypidConnameIndex {
export namespace Conrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Contypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 conrelid?: PgCatalog.Types.Oid.Options,
contypid?: PgCatalog.Types.Oid.Options,
conname?: PgCatalog.Types.Name.Options
}
}
export namespace PgConstraintContypidIndex {
export namespace Contypid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 contypid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConstraintOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConstraintConparentidIndex {
export namespace Conparentid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 conparentid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgInheritsRelidSeqnoIndex {
export namespace Inhrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Inhseqno {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 inhrelid?: PgCatalog.Types.Oid.Options,
inhseqno?: PgCatalog.Types.Int4.Options
}
}
export namespace PgInheritsParentIndex {
export namespace Inhparent {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 inhparent?: PgCatalog.Types.Oid.Options
}
}
export namespace PgIndexIndrelidIndex {
export namespace Indrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 indrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgIndexIndexrelidIndex {
export namespace Indexrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 indexrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOperatorOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOperatorOprnameLRNIndex {
export namespace Oprname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprleft {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprright {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oprnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oprname?: PgCatalog.Types.Name.Options,
oprleft?: PgCatalog.Types.Oid.Options,
oprright?: PgCatalog.Types.Oid.Options,
oprnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpfamilyAmNameNspIndex {
export namespace Opfmethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opfnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 opfmethod?: PgCatalog.Types.Oid.Options,
opfname?: PgCatalog.Types.Name.Options,
opfnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpfamilyOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpclassAmNameNspIndex {
export namespace Opcmethod {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Opcnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 opcmethod?: PgCatalog.Types.Oid.Options,
opcname?: PgCatalog.Types.Name.Options,
opcnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgOpclassOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAmNameIndex {
export namespace Amname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 amname?: PgCatalog.Types.Name.Options
}
}
export namespace PgAmOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAmopFamStratIndex {
export namespace Amopfamily {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoplefttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoprighttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopstrategy {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 amopfamily?: PgCatalog.Types.Oid.Options,
amoplefttype?: PgCatalog.Types.Oid.Options,
amoprighttype?: PgCatalog.Types.Oid.Options,
amopstrategy?: PgCatalog.Types.Int2.Options
}
}
export namespace PgAmopOprFamIndex {
export namespace Amopopr {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amoppurpose {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amopfamily {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 amopopr?: PgCatalog.Types.Oid.Options,
amoppurpose?: PgCatalog.Types.Char.Options,
amopfamily?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAmopOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAmprocFamProcIndex {
export namespace Amprocfamily {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amproclefttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amprocrighttype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Amprocnum {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 amprocfamily?: PgCatalog.Types.Oid.Options,
amproclefttype?: PgCatalog.Types.Oid.Options,
amprocrighttype?: PgCatalog.Types.Oid.Options,
amprocnum?: PgCatalog.Types.Int2.Options
}
}
export namespace PgAmprocOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgLanguageNameIndex {
export namespace Lanname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 lanname?: PgCatalog.Types.Name.Options
}
}
export namespace PgLanguageOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgLargeobjectMetadataOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgLargeobjectLoidPnIndex {
export namespace Loid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pageno {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 loid?: PgCatalog.Types.Oid.Options,
pageno?: PgCatalog.Types.Int4.Options
}
}
export namespace PgAggregateFnoidIndex {
export namespace Aggfnoid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 aggfnoid?: PgCatalog.Types.Regproc.Options
}
}
export namespace PgStatisticRelidAttInhIndex {
export namespace Starelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Staattnum {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stainherit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 starelid?: PgCatalog.Types.Oid.Options,
staattnum?: PgCatalog.Types.Int2.Options,
stainherit?: PgCatalog.Types.Bool.Options
}
}
export namespace PgStatisticExtOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgStatisticExtNameIndex {
export namespace Stxname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 stxname?: PgCatalog.Types.Name.Options,
stxnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgStatisticExtRelidIndex {
export namespace Stxrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 stxrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgStatisticExtDataStxoidInhIndex {
export namespace Stxoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Stxdinherit {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 stxoid?: PgCatalog.Types.Oid.Options,
stxdinherit?: PgCatalog.Types.Bool.Options
}
}
export namespace PgRewriteOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgRewriteRelRulenameIndex {
export namespace EvClass {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rulename {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 evClass?: PgCatalog.Types.Oid.Options,
rulename?: PgCatalog.Types.Name.Options
}
}
export namespace PgTriggerTgconstraintIndex {
export namespace Tgconstraint {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tgconstraint?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTriggerTgrelidTgnameIndex {
export namespace Tgrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tgname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tgrelid?: PgCatalog.Types.Oid.Options,
tgname?: PgCatalog.Types.Name.Options
}
}
export namespace PgTriggerOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgEventTriggerEvtnameIndex {
export namespace Evtname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 evtname?: PgCatalog.Types.Name.Options
}
}
export namespace PgEventTriggerOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgDescriptionOCOIndex {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options
}
}
export namespace PgCastOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgCastSourceTargetIndex {
export namespace Castsource {

      export type Options = InvokeQueryOptions;
    
}
export namespace Casttarget {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 castsource?: PgCatalog.Types.Oid.Options,
casttarget?: PgCatalog.Types.Oid.Options
}
}
export namespace PgEnumOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgEnumTypidLabelIndex {
export namespace Enumtypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumlabel {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 enumtypid?: PgCatalog.Types.Oid.Options,
enumlabel?: PgCatalog.Types.Name.Options
}
}
export namespace PgEnumTypidSortorderIndex {
export namespace Enumtypid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enumsortorder {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 enumtypid?: PgCatalog.Types.Oid.Options,
enumsortorder?: PgCatalog.Types.Float4.Options
}
}
export namespace PgNamespaceNspnameIndex {
export namespace Nspname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 nspname?: PgCatalog.Types.Name.Options
}
}
export namespace PgNamespaceOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConversionDefaultIndex {
export namespace Connamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Conforencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Contoencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 connamespace?: PgCatalog.Types.Oid.Options,
conforencoding?: PgCatalog.Types.Int4.Options,
contoencoding?: PgCatalog.Types.Int4.Options,
oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConversionNameNspIndex {
export namespace Conname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Connamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 conname?: PgCatalog.Types.Name.Options,
connamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgConversionOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgDependDependerIndex {
export namespace Classid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 classid?: PgCatalog.Types.Oid.Options,
objid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options
}
}
export namespace PgDependReferenceIndex {
export namespace Refclassid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 refclassid?: PgCatalog.Types.Oid.Options,
refobjid?: PgCatalog.Types.Oid.Options,
refobjsubid?: PgCatalog.Types.Int4.Options
}
}
export namespace PgDatabaseDatnameIndex {
export namespace Datname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 datname?: PgCatalog.Types.Name.Options
}
}
export namespace PgDatabaseOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgDbRoleSettingDatabaseidRolIndex {
export namespace Setdatabase {

      export type Options = InvokeQueryOptions;
    
}
export namespace Setrole {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 setdatabase?: PgCatalog.Types.Oid.Options,
setrole?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTablespaceOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTablespaceSpcnameIndex {
export namespace Spcname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 spcname?: PgCatalog.Types.Name.Options
}
}
export namespace PgAuthidRolnameIndex {
export namespace Rolname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 rolname?: PgCatalog.Types.Name.Options
}
}
export namespace PgAuthidOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAuthMembersOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAuthMembersRoleMemberIndex {
export namespace Roleid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Member {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 roleid?: PgCatalog.Types.Oid.Options,
member?: PgCatalog.Types.Oid.Options,
grantor?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAuthMembersMemberRoleIndex {
export namespace Member {

      export type Options = InvokeQueryOptions;
    
}
export namespace Roleid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 member?: PgCatalog.Types.Oid.Options,
roleid?: PgCatalog.Types.Oid.Options,
grantor?: PgCatalog.Types.Oid.Options
}
}
export namespace PgAuthMembersGrantorIndex {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: PgCatalog.Types.Oid.Options
}
}
export namespace PgShdependDependerIndex {
export namespace Dbid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 dbid?: PgCatalog.Types.Oid.Options,
classid?: PgCatalog.Types.Oid.Options,
objid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options
}
}
export namespace PgShdependReferenceIndex {
export namespace Refclassid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Refobjid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 refclassid?: PgCatalog.Types.Oid.Options,
refobjid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgShdescriptionOCIndex {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsConfigCfgnameIndex {
export namespace Cfgname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Cfgnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 cfgname?: PgCatalog.Types.Name.Options,
cfgnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsConfigOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsConfigMapIndex {
export namespace Mapcfg {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maptokentype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mapseqno {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 mapcfg?: PgCatalog.Types.Oid.Options,
maptokentype?: PgCatalog.Types.Int4.Options,
mapseqno?: PgCatalog.Types.Int4.Options
}
}
export namespace PgTsDictDictnameIndex {
export namespace Dictname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dictnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 dictname?: PgCatalog.Types.Name.Options,
dictnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsDictOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsParserPrsnameIndex {
export namespace Prsname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prsnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 prsname?: PgCatalog.Types.Name.Options,
prsnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsParserOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsTemplateTmplnameIndex {
export namespace Tmplname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmplnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tmplname?: PgCatalog.Types.Name.Options,
tmplnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTsTemplateOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgExtensionOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgExtensionNameIndex {
export namespace Extname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 extname?: PgCatalog.Types.Name.Options
}
}
export namespace PgForeignDataWrapperOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgForeignDataWrapperNameIndex {
export namespace Fdwname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 fdwname?: PgCatalog.Types.Name.Options
}
}
export namespace PgForeignServerOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgForeignServerNameIndex {
export namespace Srvname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 srvname?: PgCatalog.Types.Name.Options
}
}
export namespace PgUserMappingOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgUserMappingUserServerIndex {
export namespace Umuser {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umserver {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 umuser?: PgCatalog.Types.Oid.Options,
umserver?: PgCatalog.Types.Oid.Options
}
}
export namespace PgForeignTableRelidIndex {
export namespace Ftrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 ftrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPolicyOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPolicyPolrelidPolnameIndex {
export namespace Polrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Polname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 polrelid?: PgCatalog.Types.Oid.Options,
polname?: PgCatalog.Types.Name.Options
}
}
export namespace PgReplicationOriginRoiidentIndex {
export namespace Roident {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 roident?: PgCatalog.Types.Oid.Options
}
}
export namespace PgReplicationOriginRonameIndex {
export namespace Roname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 roname?: PgCatalog.Types.Text.Options
}
}
export namespace PgDefaultAclRoleNspObjIndex {
export namespace Defaclrole {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclnamespace {

      export type Options = InvokeQueryOptions;
    
}
export namespace Defaclobjtype {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 defaclrole?: PgCatalog.Types.Oid.Options,
defaclnamespace?: PgCatalog.Types.Oid.Options,
defaclobjtype?: PgCatalog.Types.Char.Options
}
}
export namespace PgDefaultAclOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgInitPrivsOCOIndex {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options
}
}
export namespace PgSeclabelObjectIndex {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objsubid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provider {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
objsubid?: PgCatalog.Types.Int4.Options,
provider?: PgCatalog.Types.Text.Options
}
}
export namespace PgShseclabelObjectIndex {
export namespace Objoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Classoid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Provider {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objoid?: PgCatalog.Types.Oid.Options,
classoid?: PgCatalog.Types.Oid.Options,
provider?: PgCatalog.Types.Text.Options
}
}
export namespace PgCollationNameEncNspIndex {
export namespace Collname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collencoding {

      export type Options = InvokeQueryOptions;
    
}
export namespace Collnamespace {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 collname?: PgCatalog.Types.Name.Options,
collencoding?: PgCatalog.Types.Int4.Options,
collnamespace?: PgCatalog.Types.Oid.Options
}
}
export namespace PgCollationOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgParameterAclParnameIndex {
export namespace Parname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 parname?: PgCatalog.Types.Text.Options
}
}
export namespace PgParameterAclOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPartitionedTablePartrelidIndex {
export namespace Partrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 partrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgRangeRngtypidIndex {
export namespace Rngtypid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 rngtypid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgRangeRngmultitypidIndex {
export namespace Rngmultitypid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 rngmultitypid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTransformOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgTransformTypeLangIndex {
export namespace Trftype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Trflang {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 trftype?: PgCatalog.Types.Oid.Options,
trflang?: PgCatalog.Types.Oid.Options
}
}
export namespace PgSequenceSeqrelidIndex {
export namespace Seqrelid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 seqrelid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationPubnameIndex {
export namespace Pubname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pubname?: PgCatalog.Types.Name.Options
}
}
export namespace PgPublicationNamespaceOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationNamespacePnnspidPnpubidIndex {
export namespace Pnnspid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pnpubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pnnspid?: PgCatalog.Types.Oid.Options,
pnpubid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationRelOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationRelPrrelidPrpubidIndex {
export namespace Prrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prpubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 prrelid?: PgCatalog.Types.Oid.Options,
prpubid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgPublicationRelPrpubidIndex {
export namespace Prpubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 prpubid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgSubscriptionOidIndex {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options
}
}
export namespace PgSubscriptionSubnameIndex {
export namespace Subdbid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Subname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 subdbid?: PgCatalog.Types.Oid.Options,
subname?: PgCatalog.Types.Name.Options
}
}
export namespace PgSubscriptionRelSrrelidSrsubidIndex {
export namespace Srrelid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srsubid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 srrelid?: PgCatalog.Types.Oid.Options,
srsubid?: PgCatalog.Types.Oid.Options
}
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace PgStatistic {
}
export namespace PgType {
}
export namespace PgForeignTable {
}
export namespace PgAuthid {
}
export namespace PgStatisticExtData {
}
export namespace PgUserMapping {
}
export namespace PgSubscription {
}
export namespace PgAttribute {
}
export namespace PgProc {
}
export namespace PgClass {
}
export namespace PgAttrdef {
}
export namespace PgConstraint {
}
export namespace PgInherits {
}
export namespace PgIndex {
}
export namespace PgOperator {
}
export namespace PgOpfamily {
}
export namespace PgOpclass {
}
export namespace PgAm {
}
export namespace PgAmop {
}
export namespace PgAmproc {
}
export namespace PgLanguage {
}
export namespace PgLargeobjectMetadata {
}
export namespace PgAggregate {
}
export namespace PgStatisticExt {
}
export namespace PgRewrite {
}
export namespace PgTrigger {
}
export namespace PgEventTrigger {
}
export namespace PgDescription {
}
export namespace PgCast {
}
export namespace PgEnum {
}
export namespace PgNamespace {
}
export namespace PgConversion {
}
export namespace PgDepend {
}
export namespace PgDatabase {
}
export namespace PgDbRoleSetting {
}
export namespace PgTablespace {
}
export namespace PgAuthMembers {
}
export namespace PgShdepend {
}
export namespace PgShdescription {
}
export namespace PgTsConfig {
}
export namespace PgTsConfigMap {
}
export namespace PgTsDict {
}
export namespace PgTsParser {
}
export namespace PgTsTemplate {
}
export namespace PgExtension {
}
export namespace PgForeignDataWrapper {
}
export namespace PgForeignServer {
}
export namespace PgPolicy {
}
export namespace PgReplicationOrigin {
}
export namespace PgDefaultAcl {
}
export namespace PgInitPrivs {
}
export namespace PgSeclabel {
}
export namespace PgShseclabel {
}
export namespace PgCollation {
}
export namespace PgParameterAcl {
}
export namespace PgPartitionedTable {
}
export namespace PgRange {
}
export namespace PgTransform {
}
export namespace PgSequence {
}
export namespace PgPublication {
}
export namespace PgPublicationNamespace {
}
export namespace PgPublicationRel {
}
export namespace PgSubscriptionRel {
}
export namespace PgLargeobject {
}
}
}
export namespace InformationSchema {
export namespace Types {
export namespace CardinalNumber {

      export type Options = InvokeQueryOptions;
    
}
export namespace CardinalNumberArray {
export type Options = InvokeQueryOptions;
}
export namespace CharacterData {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterDataArray {
export type Options = InvokeQueryOptions;
}
export namespace SqlIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace SqlIdentifierArray {
export type Options = InvokeQueryOptions;
}
export namespace InformationSchemaCatalogName {
export namespace CatalogName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalogName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace InformationSchemaCatalogNameArray {
export type Options = InvokeQueryOptions;
}
export namespace TimeStamp {

      export type Options = InvokeQueryOptions;
    
}
export namespace TimeStampArray {
export type Options = InvokeQueryOptions;
}
export namespace YesOrNo {

      export type Options = InvokeQueryOptions;
    
}
export namespace YesOrNoArray {
export type Options = InvokeQueryOptions;
}
export namespace ApplicableRoles {
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoleName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantee?: InformationSchema.Types.SqlIdentifier.Options,
roleName?: InformationSchema.Types.SqlIdentifier.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace ApplicableRolesArray {
export type Options = InvokeQueryOptions;
}
export namespace AdministrableRoleAuthorizations {
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoleName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantee?: InformationSchema.Types.SqlIdentifier.Options,
roleName?: InformationSchema.Types.SqlIdentifier.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace AdministrableRoleAuthorizationsArray {
export type Options = InvokeQueryOptions;
}
export namespace Attributes {
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AttributeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrdinalPosition {

      export type Options = InvokeQueryOptions;
    
}
export namespace AttributeDefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsNullable {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace AttributeUdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace AttributeUdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace AttributeUdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDerivedReferenceAttribute {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
attributeName?: InformationSchema.Types.SqlIdentifier.Options,
ordinalPosition?: InformationSchema.Types.CardinalNumber.Options,
attributeDefault?: InformationSchema.Types.CharacterData.Options,
isNullable?: InformationSchema.Types.YesOrNo.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
attributeUdtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
attributeUdtSchema?: InformationSchema.Types.SqlIdentifier.Options,
attributeUdtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
isDerivedReferenceAttribute?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace AttributesArray {
export type Options = InvokeQueryOptions;
}
export namespace CharacterSets {
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterRepertoire {

      export type Options = InvokeQueryOptions;
    
}
export namespace FormOfUse {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCollateCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCollateSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCollateName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
characterRepertoire?: InformationSchema.Types.SqlIdentifier.Options,
formOfUse?: InformationSchema.Types.SqlIdentifier.Options,
defaultCollateCatalog?: InformationSchema.Types.SqlIdentifier.Options,
defaultCollateSchema?: InformationSchema.Types.SqlIdentifier.Options,
defaultCollateName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace CharacterSetsArray {
export type Options = InvokeQueryOptions;
}
export namespace CheckConstraintRoutineUsage {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace CheckConstraintRoutineUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace CheckConstraints {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CheckClause {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
checkClause?: InformationSchema.Types.CharacterData.Options
}
}
export namespace CheckConstraintsArray {
export type Options = InvokeQueryOptions;
}
export namespace Collations {
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PadAttribute {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
padAttribute?: InformationSchema.Types.CharacterData.Options
}
}
export namespace CollationsArray {
export type Options = InvokeQueryOptions;
}
export namespace CollationCharacterSetApplicability {
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace CollationCharacterSetApplicabilityArray {
export type Options = InvokeQueryOptions;
}
export namespace ColumnColumnUsage {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DependentColumn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
dependentColumn?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ColumnColumnUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace ColumnDomainUsage {
export namespace DomainCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 domainCatalog?: InformationSchema.Types.SqlIdentifier.Options,
domainSchema?: InformationSchema.Types.SqlIdentifier.Options,
domainName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ColumnDomainUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace ColumnPrivileges {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace ColumnPrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace ColumnUdtUsage {
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ColumnUdtUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace Columns {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrdinalPosition {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnDefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsNullable {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainName {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsSelfReferencing {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsIdentity {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityGeneration {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityStart {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityIncrement {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityMaximum {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityMinimum {

      export type Options = InvokeQueryOptions;
    
}
export namespace IdentityCycle {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGenerated {

      export type Options = InvokeQueryOptions;
    
}
export namespace GenerationExpression {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsUpdatable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
ordinalPosition?: InformationSchema.Types.CardinalNumber.Options,
columnDefault?: InformationSchema.Types.CharacterData.Options,
isNullable?: InformationSchema.Types.YesOrNo.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
domainCatalog?: InformationSchema.Types.SqlIdentifier.Options,
domainSchema?: InformationSchema.Types.SqlIdentifier.Options,
domainName?: InformationSchema.Types.SqlIdentifier.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
isSelfReferencing?: InformationSchema.Types.YesOrNo.Options,
isIdentity?: InformationSchema.Types.YesOrNo.Options,
identityGeneration?: InformationSchema.Types.CharacterData.Options,
identityStart?: InformationSchema.Types.CharacterData.Options,
identityIncrement?: InformationSchema.Types.CharacterData.Options,
identityMaximum?: InformationSchema.Types.CharacterData.Options,
identityMinimum?: InformationSchema.Types.CharacterData.Options,
identityCycle?: InformationSchema.Types.YesOrNo.Options,
isGenerated?: InformationSchema.Types.CharacterData.Options,
generationExpression?: InformationSchema.Types.CharacterData.Options,
isUpdatable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace ColumnsArray {
export type Options = InvokeQueryOptions;
}
export namespace ConstraintColumnUsage {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ConstraintColumnUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace ConstraintTableUsage {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ConstraintTableUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace DomainConstraints {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDeferrable {

      export type Options = InvokeQueryOptions;
    
}
export namespace InitiallyDeferred {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
domainCatalog?: InformationSchema.Types.SqlIdentifier.Options,
domainSchema?: InformationSchema.Types.SqlIdentifier.Options,
domainName?: InformationSchema.Types.SqlIdentifier.Options,
isDeferrable?: InformationSchema.Types.YesOrNo.Options,
initiallyDeferred?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace DomainConstraintsArray {
export type Options = InvokeQueryOptions;
}
export namespace DomainUdtUsage {
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
domainCatalog?: InformationSchema.Types.SqlIdentifier.Options,
domainSchema?: InformationSchema.Types.SqlIdentifier.Options,
domainName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace DomainUdtUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace Domains {
export namespace DomainCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainDefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 domainCatalog?: InformationSchema.Types.SqlIdentifier.Options,
domainSchema?: InformationSchema.Types.SqlIdentifier.Options,
domainName?: InformationSchema.Types.SqlIdentifier.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
domainDefault?: InformationSchema.Types.CharacterData.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace DomainsArray {
export type Options = InvokeQueryOptions;
}
export namespace EnabledRoles {
export namespace RoleName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 roleName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace EnabledRolesArray {
export type Options = InvokeQueryOptions;
}
export namespace KeyColumnUsage {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrdinalPosition {

      export type Options = InvokeQueryOptions;
    
}
export namespace PositionInUniqueConstraint {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
ordinalPosition?: InformationSchema.Types.CardinalNumber.Options,
positionInUniqueConstraint?: InformationSchema.Types.CardinalNumber.Options
}
}
export namespace KeyColumnUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace Parameters {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrdinalPosition {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParameterMode {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsResult {

      export type Options = InvokeQueryOptions;
    
}
export namespace AsLocator {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParameterName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParameterDefault {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
ordinalPosition?: InformationSchema.Types.CardinalNumber.Options,
parameterMode?: InformationSchema.Types.CharacterData.Options,
isResult?: InformationSchema.Types.YesOrNo.Options,
asLocator?: InformationSchema.Types.YesOrNo.Options,
parameterName?: InformationSchema.Types.SqlIdentifier.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
parameterDefault?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ParametersArray {
export type Options = InvokeQueryOptions;
}
export namespace ReferentialConstraints {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace UniqueConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UniqueConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UniqueConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MatchOption {

      export type Options = InvokeQueryOptions;
    
}
export namespace UpdateRule {

      export type Options = InvokeQueryOptions;
    
}
export namespace DeleteRule {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
uniqueConstraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
uniqueConstraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
uniqueConstraintName?: InformationSchema.Types.SqlIdentifier.Options,
matchOption?: InformationSchema.Types.CharacterData.Options,
updateRule?: InformationSchema.Types.CharacterData.Options,
deleteRule?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ReferentialConstraintsArray {
export type Options = InvokeQueryOptions;
}
export namespace RoleColumnGrants {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoleColumnGrantsArray {
export type Options = InvokeQueryOptions;
}
export namespace RoutineColumnUsage {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace RoutineColumnUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace RoutinePrivileges {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoutinePrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace RoleRoutineGrants {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoleRoutineGrantsArray {
export type Options = InvokeQueryOptions;
}
export namespace RoutineRoutineUsage {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace RoutineRoutineUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace RoutineSequenceUsage {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SequenceCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SequenceSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SequenceName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
sequenceCatalog?: InformationSchema.Types.SqlIdentifier.Options,
sequenceSchema?: InformationSchema.Types.SqlIdentifier.Options,
sequenceName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace RoutineSequenceUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace RoutineTableUsage {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace RoutineTableUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace Routines {
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ModuleCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ModuleSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ModuleName {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace TypeUdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TypeUdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TypeUdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineBody {

      export type Options = InvokeQueryOptions;
    
}
export namespace RoutineDefinition {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExternalName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExternalLanguage {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParameterStyle {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDeterministic {

      export type Options = InvokeQueryOptions;
    
}
export namespace SqlDataAccess {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsNullCall {

      export type Options = InvokeQueryOptions;
    
}
export namespace SqlPath {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaLevelRoutine {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxDynamicResultSets {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsUserDefinedCast {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsImplicitlyInvocable {

      export type Options = InvokeQueryOptions;
    
}
export namespace SecurityType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSqlSpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSqlSpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSqlSpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AsLocator {

      export type Options = InvokeQueryOptions;
    
}
export namespace Created {

      export type Options = InvokeQueryOptions;
    
}
export namespace LastAltered {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewSavepointLevel {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsUdtDependent {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastFromDataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastAsLocator {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCharMaxLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCharOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCharSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCharSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCharSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastCollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastNumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastNumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastNumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastDatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastIntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastIntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastTypeUdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastTypeUdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastTypeUdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastMaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace ResultCastDtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
routineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
routineSchema?: InformationSchema.Types.SqlIdentifier.Options,
routineName?: InformationSchema.Types.SqlIdentifier.Options,
routineType?: InformationSchema.Types.CharacterData.Options,
moduleCatalog?: InformationSchema.Types.SqlIdentifier.Options,
moduleSchema?: InformationSchema.Types.SqlIdentifier.Options,
moduleName?: InformationSchema.Types.SqlIdentifier.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
typeUdtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
typeUdtSchema?: InformationSchema.Types.SqlIdentifier.Options,
typeUdtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
routineBody?: InformationSchema.Types.CharacterData.Options,
routineDefinition?: InformationSchema.Types.CharacterData.Options,
externalName?: InformationSchema.Types.CharacterData.Options,
externalLanguage?: InformationSchema.Types.CharacterData.Options,
parameterStyle?: InformationSchema.Types.CharacterData.Options,
isDeterministic?: InformationSchema.Types.YesOrNo.Options,
sqlDataAccess?: InformationSchema.Types.CharacterData.Options,
isNullCall?: InformationSchema.Types.YesOrNo.Options,
sqlPath?: InformationSchema.Types.CharacterData.Options,
schemaLevelRoutine?: InformationSchema.Types.YesOrNo.Options,
maxDynamicResultSets?: InformationSchema.Types.CardinalNumber.Options,
isUserDefinedCast?: InformationSchema.Types.YesOrNo.Options,
isImplicitlyInvocable?: InformationSchema.Types.YesOrNo.Options,
securityType?: InformationSchema.Types.CharacterData.Options,
toSqlSpecificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
toSqlSpecificSchema?: InformationSchema.Types.SqlIdentifier.Options,
toSqlSpecificName?: InformationSchema.Types.SqlIdentifier.Options,
asLocator?: InformationSchema.Types.YesOrNo.Options,
created?: InformationSchema.Types.TimeStamp.Options,
lastAltered?: InformationSchema.Types.TimeStamp.Options,
newSavepointLevel?: InformationSchema.Types.YesOrNo.Options,
isUdtDependent?: InformationSchema.Types.YesOrNo.Options,
resultCastFromDataType?: InformationSchema.Types.CharacterData.Options,
resultCastAsLocator?: InformationSchema.Types.YesOrNo.Options,
resultCastCharMaxLength?: InformationSchema.Types.CardinalNumber.Options,
resultCastCharOctetLength?: InformationSchema.Types.CardinalNumber.Options,
resultCastCharSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
resultCastCharSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
resultCastCharSetName?: InformationSchema.Types.SqlIdentifier.Options,
resultCastCollationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
resultCastCollationSchema?: InformationSchema.Types.SqlIdentifier.Options,
resultCastCollationName?: InformationSchema.Types.SqlIdentifier.Options,
resultCastNumericPrecision?: InformationSchema.Types.CardinalNumber.Options,
resultCastNumericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
resultCastNumericScale?: InformationSchema.Types.CardinalNumber.Options,
resultCastDatetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
resultCastIntervalType?: InformationSchema.Types.CharacterData.Options,
resultCastIntervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
resultCastTypeUdtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
resultCastTypeUdtSchema?: InformationSchema.Types.SqlIdentifier.Options,
resultCastTypeUdtName?: InformationSchema.Types.SqlIdentifier.Options,
resultCastScopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
resultCastScopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
resultCastScopeName?: InformationSchema.Types.SqlIdentifier.Options,
resultCastMaximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
resultCastDtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace RoutinesArray {
export type Options = InvokeQueryOptions;
}
export namespace Schemata {
export namespace CatalogName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaOwner {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace DefaultCharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SqlPath {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalogName?: InformationSchema.Types.SqlIdentifier.Options,
schemaName?: InformationSchema.Types.SqlIdentifier.Options,
schemaOwner?: InformationSchema.Types.SqlIdentifier.Options,
defaultCharacterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
defaultCharacterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
defaultCharacterSetName?: InformationSchema.Types.SqlIdentifier.Options,
sqlPath?: InformationSchema.Types.CharacterData.Options
}
}
export namespace SchemataArray {
export type Options = InvokeQueryOptions;
}
export namespace Sequences {
export namespace SequenceCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SequenceSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SequenceName {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace StartValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace MinimumValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace Increment {

      export type Options = InvokeQueryOptions;
    
}
export namespace CycleOption {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 sequenceCatalog?: InformationSchema.Types.SqlIdentifier.Options,
sequenceSchema?: InformationSchema.Types.SqlIdentifier.Options,
sequenceName?: InformationSchema.Types.SqlIdentifier.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
startValue?: InformationSchema.Types.CharacterData.Options,
minimumValue?: InformationSchema.Types.CharacterData.Options,
maximumValue?: InformationSchema.Types.CharacterData.Options,
increment?: InformationSchema.Types.CharacterData.Options,
cycleOption?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace SequencesArray {
export type Options = InvokeQueryOptions;
}
export namespace SqlFeatures {
export namespace FeatureId {

      export type Options = InvokeQueryOptions;
    
}
export namespace FeatureName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SubFeatureId {

      export type Options = InvokeQueryOptions;
    
}
export namespace SubFeatureName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsSupported {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsVerifiedBy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Comments {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 featureId?: InformationSchema.Types.CharacterData.Options,
featureName?: InformationSchema.Types.CharacterData.Options,
subFeatureId?: InformationSchema.Types.CharacterData.Options,
subFeatureName?: InformationSchema.Types.CharacterData.Options,
isSupported?: InformationSchema.Types.YesOrNo.Options,
isVerifiedBy?: InformationSchema.Types.CharacterData.Options,
comments?: InformationSchema.Types.CharacterData.Options
}
}
export namespace SqlFeaturesArray {
export type Options = InvokeQueryOptions;
}
export namespace SqlImplementationInfo {
export namespace ImplementationInfoId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ImplementationInfoName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntegerValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace Comments {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 implementationInfoId?: InformationSchema.Types.CharacterData.Options,
implementationInfoName?: InformationSchema.Types.CharacterData.Options,
integerValue?: InformationSchema.Types.CardinalNumber.Options,
characterValue?: InformationSchema.Types.CharacterData.Options,
comments?: InformationSchema.Types.CharacterData.Options
}
}
export namespace SqlImplementationInfoArray {
export type Options = InvokeQueryOptions;
}
export namespace SqlParts {
export namespace FeatureId {

      export type Options = InvokeQueryOptions;
    
}
export namespace FeatureName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsSupported {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsVerifiedBy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Comments {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 featureId?: InformationSchema.Types.CharacterData.Options,
featureName?: InformationSchema.Types.CharacterData.Options,
isSupported?: InformationSchema.Types.YesOrNo.Options,
isVerifiedBy?: InformationSchema.Types.CharacterData.Options,
comments?: InformationSchema.Types.CharacterData.Options
}
}
export namespace SqlPartsArray {
export type Options = InvokeQueryOptions;
}
export namespace SqlSizing {
export namespace SizingId {

      export type Options = InvokeQueryOptions;
    
}
export namespace SizingName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SupportedValue {

      export type Options = InvokeQueryOptions;
    
}
export namespace Comments {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 sizingId?: InformationSchema.Types.CardinalNumber.Options,
sizingName?: InformationSchema.Types.CharacterData.Options,
supportedValue?: InformationSchema.Types.CardinalNumber.Options,
comments?: InformationSchema.Types.CharacterData.Options
}
}
export namespace SqlSizingArray {
export type Options = InvokeQueryOptions;
}
export namespace TableConstraints {
export namespace ConstraintCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ConstraintType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsDeferrable {

      export type Options = InvokeQueryOptions;
    
}
export namespace InitiallyDeferred {

      export type Options = InvokeQueryOptions;
    
}
export namespace Enforced {

      export type Options = InvokeQueryOptions;
    
}
export namespace NullsDistinct {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 constraintCatalog?: InformationSchema.Types.SqlIdentifier.Options,
constraintSchema?: InformationSchema.Types.SqlIdentifier.Options,
constraintName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
constraintType?: InformationSchema.Types.CharacterData.Options,
isDeferrable?: InformationSchema.Types.YesOrNo.Options,
initiallyDeferred?: InformationSchema.Types.YesOrNo.Options,
enforced?: InformationSchema.Types.YesOrNo.Options,
nullsDistinct?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace TableConstraintsArray {
export type Options = InvokeQueryOptions;
}
export namespace TablePrivileges {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithHierarchy {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options,
withHierarchy?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace TablePrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace RoleTableGrants {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithHierarchy {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options,
withHierarchy?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoleTableGrantsArray {
export type Options = InvokeQueryOptions;
}
export namespace Tables {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableType {

      export type Options = InvokeQueryOptions;
    
}
export namespace SelfReferencingColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReferenceGeneration {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsInsertableInto {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsTyped {

      export type Options = InvokeQueryOptions;
    
}
export namespace CommitAction {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
tableType?: InformationSchema.Types.CharacterData.Options,
selfReferencingColumnName?: InformationSchema.Types.SqlIdentifier.Options,
referenceGeneration?: InformationSchema.Types.CharacterData.Options,
userDefinedTypeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
userDefinedTypeSchema?: InformationSchema.Types.SqlIdentifier.Options,
userDefinedTypeName?: InformationSchema.Types.SqlIdentifier.Options,
isInsertableInto?: InformationSchema.Types.YesOrNo.Options,
isTyped?: InformationSchema.Types.YesOrNo.Options,
commitAction?: InformationSchema.Types.CharacterData.Options
}
}
export namespace TablesArray {
export type Options = InvokeQueryOptions;
}
export namespace Transforms {
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export namespace GroupName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TransformType {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options,
groupName?: InformationSchema.Types.SqlIdentifier.Options,
transformType?: InformationSchema.Types.CharacterData.Options
}
}
export namespace TransformsArray {
export type Options = InvokeQueryOptions;
}
export namespace TriggeredUpdateColumns {
export namespace TriggerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TriggerSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TriggerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectTable {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectColumn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 triggerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
triggerSchema?: InformationSchema.Types.SqlIdentifier.Options,
triggerName?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectSchema?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectTable?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectColumn?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace TriggeredUpdateColumnsArray {
export type Options = InvokeQueryOptions;
}
export namespace Triggers {
export namespace TriggerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TriggerSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TriggerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventManipulation {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace EventObjectTable {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionOrder {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionCondition {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionStatement {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionOrientation {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionTiming {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionReferenceOldTable {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionReferenceNewTable {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionReferenceOldRow {

      export type Options = InvokeQueryOptions;
    
}
export namespace ActionReferenceNewRow {

      export type Options = InvokeQueryOptions;
    
}
export namespace Created {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 triggerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
triggerSchema?: InformationSchema.Types.SqlIdentifier.Options,
triggerName?: InformationSchema.Types.SqlIdentifier.Options,
eventManipulation?: InformationSchema.Types.CharacterData.Options,
eventObjectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectSchema?: InformationSchema.Types.SqlIdentifier.Options,
eventObjectTable?: InformationSchema.Types.SqlIdentifier.Options,
actionOrder?: InformationSchema.Types.CardinalNumber.Options,
actionCondition?: InformationSchema.Types.CharacterData.Options,
actionStatement?: InformationSchema.Types.CharacterData.Options,
actionOrientation?: InformationSchema.Types.CharacterData.Options,
actionTiming?: InformationSchema.Types.CharacterData.Options,
actionReferenceOldTable?: InformationSchema.Types.SqlIdentifier.Options,
actionReferenceNewTable?: InformationSchema.Types.SqlIdentifier.Options,
actionReferenceOldRow?: InformationSchema.Types.SqlIdentifier.Options,
actionReferenceNewRow?: InformationSchema.Types.SqlIdentifier.Options,
created?: InformationSchema.Types.TimeStamp.Options
}
}
export namespace TriggersArray {
export type Options = InvokeQueryOptions;
}
export namespace UdtPrivileges {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace UdtPrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace RoleUdtGrants {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoleUdtGrantsArray {
export type Options = InvokeQueryOptions;
}
export namespace UsagePrivileges {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectType {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
objectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
objectSchema?: InformationSchema.Types.SqlIdentifier.Options,
objectName?: InformationSchema.Types.SqlIdentifier.Options,
objectType?: InformationSchema.Types.CharacterData.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace UsagePrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace RoleUsageGrants {
export namespace Grantor {

      export type Options = InvokeQueryOptions;
    
}
export namespace Grantee {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectType {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrivilegeType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsGrantable {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 grantor?: InformationSchema.Types.SqlIdentifier.Options,
grantee?: InformationSchema.Types.SqlIdentifier.Options,
objectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
objectSchema?: InformationSchema.Types.SqlIdentifier.Options,
objectName?: InformationSchema.Types.SqlIdentifier.Options,
objectType?: InformationSchema.Types.CharacterData.Options,
privilegeType?: InformationSchema.Types.CharacterData.Options,
isGrantable?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace RoleUsageGrantsArray {
export type Options = InvokeQueryOptions;
}
export namespace UserDefinedTypes {
export namespace UserDefinedTypeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace UserDefinedTypeCategory {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsInstantiable {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsFinal {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrderingForm {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrderingCategory {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrderingRoutineCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrderingRoutineSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace OrderingRoutineName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ReferenceType {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace SourceDtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace RefDtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 userDefinedTypeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
userDefinedTypeSchema?: InformationSchema.Types.SqlIdentifier.Options,
userDefinedTypeName?: InformationSchema.Types.SqlIdentifier.Options,
userDefinedTypeCategory?: InformationSchema.Types.CharacterData.Options,
isInstantiable?: InformationSchema.Types.YesOrNo.Options,
isFinal?: InformationSchema.Types.YesOrNo.Options,
orderingForm?: InformationSchema.Types.CharacterData.Options,
orderingCategory?: InformationSchema.Types.CharacterData.Options,
orderingRoutineCatalog?: InformationSchema.Types.SqlIdentifier.Options,
orderingRoutineSchema?: InformationSchema.Types.SqlIdentifier.Options,
orderingRoutineName?: InformationSchema.Types.SqlIdentifier.Options,
referenceType?: InformationSchema.Types.CharacterData.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
sourceDtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
refDtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace UserDefinedTypesArray {
export type Options = InvokeQueryOptions;
}
export namespace ViewColumnUsage {
export namespace ViewCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ViewSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ViewName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 viewCatalog?: InformationSchema.Types.SqlIdentifier.Options,
viewSchema?: InformationSchema.Types.SqlIdentifier.Options,
viewName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ViewColumnUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace ViewRoutineUsage {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpecificName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
specificCatalog?: InformationSchema.Types.SqlIdentifier.Options,
specificSchema?: InformationSchema.Types.SqlIdentifier.Options,
specificName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ViewRoutineUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace ViewTableUsage {
export namespace ViewCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ViewSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ViewName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 viewCatalog?: InformationSchema.Types.SqlIdentifier.Options,
viewSchema?: InformationSchema.Types.SqlIdentifier.Options,
viewName?: InformationSchema.Types.SqlIdentifier.Options,
tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ViewTableUsageArray {
export type Options = InvokeQueryOptions;
}
export namespace Views {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ViewDefinition {

      export type Options = InvokeQueryOptions;
    
}
export namespace CheckOption {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsUpdatable {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsInsertableInto {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsTriggerUpdatable {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsTriggerDeletable {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsTriggerInsertableInto {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
viewDefinition?: InformationSchema.Types.CharacterData.Options,
checkOption?: InformationSchema.Types.CharacterData.Options,
isUpdatable?: InformationSchema.Types.YesOrNo.Options,
isInsertableInto?: InformationSchema.Types.YesOrNo.Options,
isTriggerUpdatable?: InformationSchema.Types.YesOrNo.Options,
isTriggerDeletable?: InformationSchema.Types.YesOrNo.Options,
isTriggerInsertableInto?: InformationSchema.Types.YesOrNo.Options
}
}
export namespace ViewsArray {
export type Options = InvokeQueryOptions;
}
export namespace DataTypePrivileges {
export namespace ObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectType {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
objectSchema?: InformationSchema.Types.SqlIdentifier.Options,
objectName?: InformationSchema.Types.SqlIdentifier.Options,
objectType?: InformationSchema.Types.CharacterData.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace DataTypePrivilegesArray {
export type Options = InvokeQueryOptions;
}
export namespace ElementTypes {
export namespace ObjectCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ObjectType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollectionTypeIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace DataType {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterMaximumLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterOctetLength {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CharacterSetName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace CollationName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericPrecisionRadix {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumericScale {

      export type Options = InvokeQueryOptions;
    
}
export namespace DatetimePrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalType {

      export type Options = InvokeQueryOptions;
    
}
export namespace IntervalPrecision {

      export type Options = InvokeQueryOptions;
    
}
export namespace DomainDefault {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace UdtName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ScopeName {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaximumCardinality {

      export type Options = InvokeQueryOptions;
    
}
export namespace DtdIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 objectCatalog?: InformationSchema.Types.SqlIdentifier.Options,
objectSchema?: InformationSchema.Types.SqlIdentifier.Options,
objectName?: InformationSchema.Types.SqlIdentifier.Options,
objectType?: InformationSchema.Types.CharacterData.Options,
collectionTypeIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
dataType?: InformationSchema.Types.CharacterData.Options,
characterMaximumLength?: InformationSchema.Types.CardinalNumber.Options,
characterOctetLength?: InformationSchema.Types.CardinalNumber.Options,
characterSetCatalog?: InformationSchema.Types.SqlIdentifier.Options,
characterSetSchema?: InformationSchema.Types.SqlIdentifier.Options,
characterSetName?: InformationSchema.Types.SqlIdentifier.Options,
collationCatalog?: InformationSchema.Types.SqlIdentifier.Options,
collationSchema?: InformationSchema.Types.SqlIdentifier.Options,
collationName?: InformationSchema.Types.SqlIdentifier.Options,
numericPrecision?: InformationSchema.Types.CardinalNumber.Options,
numericPrecisionRadix?: InformationSchema.Types.CardinalNumber.Options,
numericScale?: InformationSchema.Types.CardinalNumber.Options,
datetimePrecision?: InformationSchema.Types.CardinalNumber.Options,
intervalType?: InformationSchema.Types.CharacterData.Options,
intervalPrecision?: InformationSchema.Types.CardinalNumber.Options,
domainDefault?: InformationSchema.Types.CharacterData.Options,
udtCatalog?: InformationSchema.Types.SqlIdentifier.Options,
udtSchema?: InformationSchema.Types.SqlIdentifier.Options,
udtName?: InformationSchema.Types.SqlIdentifier.Options,
scopeCatalog?: InformationSchema.Types.SqlIdentifier.Options,
scopeSchema?: InformationSchema.Types.SqlIdentifier.Options,
scopeName?: InformationSchema.Types.SqlIdentifier.Options,
maximumCardinality?: InformationSchema.Types.CardinalNumber.Options,
dtdIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ElementTypesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignTableColumns {
export namespace Nspname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Relname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Attfdwoptions {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 nspname?: PgCatalog.Types.Name.Options,
relname?: PgCatalog.Types.Name.Options,
attname?: PgCatalog.Types.Name.Options,
attfdwoptions?: PgCatalog.Types.TextArray.Options
}
}
export namespace ColumnOptions {
export namespace TableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
tableSchema?: InformationSchema.Types.SqlIdentifier.Options,
tableName?: InformationSchema.Types.SqlIdentifier.Options,
columnName?: InformationSchema.Types.SqlIdentifier.Options,
optionName?: InformationSchema.Types.SqlIdentifier.Options,
optionValue?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ColumnOptionsArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignDataWrappers {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwowner {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fdwoptions {
export type Options = InvokeQueryOptions;
}
export namespace ForeignDataWrapperCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperLanguage {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
fdwowner?: PgCatalog.Types.Oid.Options,
fdwoptions?: PgCatalog.Types.TextArray.Options,
foreignDataWrapperCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperName?: InformationSchema.Types.SqlIdentifier.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperLanguage?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ForeignDataWrapperOptions {
export namespace ForeignDataWrapperCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignDataWrapperCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperName?: InformationSchema.Types.SqlIdentifier.Options,
optionName?: InformationSchema.Types.SqlIdentifier.Options,
optionValue?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ForeignDataWrapperOptionsArray {
export type Options = InvokeQueryOptions;
}
export namespace ForeignDataWrappers {
export namespace ForeignDataWrapperCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace LibraryName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperLanguage {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignDataWrapperCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperName?: InformationSchema.Types.SqlIdentifier.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
libraryName?: InformationSchema.Types.CharacterData.Options,
foreignDataWrapperLanguage?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ForeignDataWrappersArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignServers {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvoptions {
export type Options = InvokeQueryOptions;
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerVersion {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
srvoptions?: PgCatalog.Types.TextArray.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperName?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerType?: InformationSchema.Types.CharacterData.Options,
foreignServerVersion?: InformationSchema.Types.CharacterData.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ForeignServerOptions {
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
optionName?: InformationSchema.Types.SqlIdentifier.Options,
optionValue?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ForeignServerOptionsArray {
export type Options = InvokeQueryOptions;
}
export namespace ForeignServers {
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignDataWrapperName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerType {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerVersion {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignDataWrapperName?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerType?: InformationSchema.Types.CharacterData.Options,
foreignServerVersion?: InformationSchema.Types.CharacterData.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ForeignServersArray {
export type Options = InvokeQueryOptions;
}
export namespace PgForeignTables {
export namespace ForeignTableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ftoptions {
export type Options = InvokeQueryOptions;
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignTableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableSchema?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableName?: InformationSchema.Types.SqlIdentifier.Options,
ftoptions?: PgCatalog.Types.TextArray.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ForeignTableOptions {
export namespace ForeignTableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignTableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableSchema?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableName?: InformationSchema.Types.SqlIdentifier.Options,
optionName?: InformationSchema.Types.SqlIdentifier.Options,
optionValue?: InformationSchema.Types.CharacterData.Options
}
}
export namespace ForeignTableOptionsArray {
export type Options = InvokeQueryOptions;
}
export namespace ForeignTables {
export namespace ForeignTableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignTableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 foreignTableCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableSchema?: InformationSchema.Types.SqlIdentifier.Options,
foreignTableName?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace ForeignTablesArray {
export type Options = InvokeQueryOptions;
}
export namespace PgUserMappings {
export namespace Oid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Umoptions {
export type Options = InvokeQueryOptions;
}
export namespace Umuser {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srvowner {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 oid?: PgCatalog.Types.Oid.Options,
umoptions?: PgCatalog.Types.TextArray.Options,
umuser?: PgCatalog.Types.Oid.Options,
authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
srvowner?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace UserMappingOptions {
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionName {

      export type Options = InvokeQueryOptions;
    
}
export namespace OptionValue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options,
optionName?: InformationSchema.Types.SqlIdentifier.Options,
optionValue?: InformationSchema.Types.CharacterData.Options
}
}
export namespace UserMappingOptionsArray {
export type Options = InvokeQueryOptions;
}
export namespace UserMappings {
export namespace AuthorizationIdentifier {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace ForeignServerName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authorizationIdentifier?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerCatalog?: InformationSchema.Types.SqlIdentifier.Options,
foreignServerName?: InformationSchema.Types.SqlIdentifier.Options
}
}
export namespace UserMappingsArray {
export type Options = InvokeQueryOptions;
}
}
export namespace Procedures {
}
export namespace Tables {
export namespace SqlFeatures {
}
export namespace SqlImplementationInfo {
}
export namespace SqlParts {
}
export namespace SqlSizing {
}
}
}
export namespace Public {
export namespace Types {
export namespace Spheroid {

      export type Options = InvokeQueryOptions;
    
}
export namespace SpheroidArray {
export type Options = InvokeQueryOptions;
}
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export namespace GeometryArray {
export type Options = InvokeQueryOptions;
}
export namespace Box3d {

      export type Options = InvokeQueryOptions;
    
}
export namespace Box3dArray {
export type Options = InvokeQueryOptions;
}
export namespace Box2d {

      export type Options = InvokeQueryOptions;
    
}
export namespace Box2dArray {
export type Options = InvokeQueryOptions;
}
export namespace Box2df {

      export type Options = InvokeQueryOptions;
    
}
export namespace Box2dfArray {
export type Options = InvokeQueryOptions;
}
export namespace Gidx {

      export type Options = InvokeQueryOptions;
    
}
export namespace GidxArray {
export type Options = InvokeQueryOptions;
}
export namespace GeometryDump {
export namespace Path {
export type Options = InvokeQueryOptions;
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 path?: PgCatalog.Types.Int4Array.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace GeometryDumpArray {
export type Options = InvokeQueryOptions;
}
export namespace SpatialRefSys {
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srtext {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proj4text {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 srid?: PgCatalog.Types.Int4.Options,
authName?: PgCatalog.Types.Varchar.Options,
authSrid?: PgCatalog.Types.Int4.Options,
srtext?: PgCatalog.Types.Varchar.Options,
proj4text?: PgCatalog.Types.Varchar.Options
}
}
export namespace SpatialRefSysArray {
export type Options = InvokeQueryOptions;
}
export namespace ValidDetail {
export namespace Valid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Reason {

      export type Options = InvokeQueryOptions;
    
}
export namespace Location {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 valid?: PgCatalog.Types.Bool.Options,
reason?: PgCatalog.Types.Varchar.Options,
location?: Public.Types.Geometry.Options
}
}
export namespace ValidDetailArray {
export type Options = InvokeQueryOptions;
}
export namespace Geography {

      export type Options = InvokeQueryOptions;
    
}
export namespace GeographyArray {
export type Options = InvokeQueryOptions;
}
export namespace GeographyColumns {
export namespace FTableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace FTableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace FTableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace FGeographyColumn {

      export type Options = InvokeQueryOptions;
    
}
export namespace CoordDimension {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Type {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 fTableCatalog?: PgCatalog.Types.Name.Options,
fTableSchema?: PgCatalog.Types.Name.Options,
fTableName?: PgCatalog.Types.Name.Options,
fGeographyColumn?: PgCatalog.Types.Name.Options,
coordDimension?: PgCatalog.Types.Int4.Options,
srid?: PgCatalog.Types.Int4.Options,
type?: PgCatalog.Types.Text.Options
}
}
export namespace GeographyColumnsArray {
export type Options = InvokeQueryOptions;
}
export namespace GeometryColumns {
export namespace FTableCatalog {

      export type Options = InvokeQueryOptions;
    
}
export namespace FTableSchema {

      export type Options = InvokeQueryOptions;
    
}
export namespace FTableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace FGeometryColumn {

      export type Options = InvokeQueryOptions;
    
}
export namespace CoordDimension {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Type {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 fTableCatalog?: PgCatalog.Types.Varchar.Options,
fTableSchema?: PgCatalog.Types.Name.Options,
fTableName?: PgCatalog.Types.Name.Options,
fGeometryColumn?: PgCatalog.Types.Name.Options,
coordDimension?: PgCatalog.Types.Int4.Options,
srid?: PgCatalog.Types.Int4.Options,
type?: PgCatalog.Types.Varchar.Options
}
}
export namespace GeometryColumnsArray {
export type Options = InvokeQueryOptions;
}
export namespace NycCensusBlocks {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Blkid {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnTotal {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnWhite {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnBlack {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnNativ {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnAsian {

      export type Options = InvokeQueryOptions;
    
}
export namespace PopnOther {

      export type Options = InvokeQueryOptions;
    
}
export namespace Boroname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options,
blkid?: PgCatalog.Types.Varchar.Options,
popnTotal?: PgCatalog.Types.Float8.Options,
popnWhite?: PgCatalog.Types.Float8.Options,
popnBlack?: PgCatalog.Types.Float8.Options,
popnNativ?: PgCatalog.Types.Float8.Options,
popnAsian?: PgCatalog.Types.Float8.Options,
popnOther?: PgCatalog.Types.Float8.Options,
boroname?: PgCatalog.Types.Varchar.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace NycCensusBlocksArray {
export type Options = InvokeQueryOptions;
}
export namespace NycHomicides {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace IncidentD {

      export type Options = InvokeQueryOptions;
    
}
export namespace Boroname {

      export type Options = InvokeQueryOptions;
    
}
export namespace NumVictim {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrimaryMo {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export namespace Weapon {

      export type Options = InvokeQueryOptions;
    
}
export namespace LightDark {

      export type Options = InvokeQueryOptions;
    
}
export namespace Year {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options,
incidentD?: PgCatalog.Types.Date.Options,
boroname?: PgCatalog.Types.Varchar.Options,
numVictim?: PgCatalog.Types.Varchar.Options,
primaryMo?: PgCatalog.Types.Varchar.Options,
id?: PgCatalog.Types.Float8.Options,
weapon?: PgCatalog.Types.Varchar.Options,
lightDark?: PgCatalog.Types.Varchar.Options,
year?: PgCatalog.Types.Float8.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace NycHomicidesArray {
export type Options = InvokeQueryOptions;
}
export namespace NycNeighborhoods {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Boroname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options,
boroname?: PgCatalog.Types.Varchar.Options,
name?: PgCatalog.Types.Varchar.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace NycNeighborhoodsArray {
export type Options = InvokeQueryOptions;
}
export namespace NycStreets {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace Oneway {

      export type Options = InvokeQueryOptions;
    
}
export namespace Type {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options,
id?: PgCatalog.Types.Float8.Options,
name?: PgCatalog.Types.Varchar.Options,
oneway?: PgCatalog.Types.Varchar.Options,
type?: PgCatalog.Types.Varchar.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace NycStreetsArray {
export type Options = InvokeQueryOptions;
}
export namespace NycSubwayStations {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Objectid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export namespace Name {

      export type Options = InvokeQueryOptions;
    
}
export namespace AltName {

      export type Options = InvokeQueryOptions;
    
}
export namespace CrossSt {

      export type Options = InvokeQueryOptions;
    
}
export namespace LongName {

      export type Options = InvokeQueryOptions;
    
}
export namespace Label {

      export type Options = InvokeQueryOptions;
    
}
export namespace Borough {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nghbhd {

      export type Options = InvokeQueryOptions;
    
}
export namespace Routes {

      export type Options = InvokeQueryOptions;
    
}
export namespace Transfers {

      export type Options = InvokeQueryOptions;
    
}
export namespace Color {

      export type Options = InvokeQueryOptions;
    
}
export namespace Express {

      export type Options = InvokeQueryOptions;
    
}
export namespace Closed {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options,
objectid?: PgCatalog.Types.Numeric.Options,
id?: PgCatalog.Types.Numeric.Options,
name?: PgCatalog.Types.Varchar.Options,
altName?: PgCatalog.Types.Varchar.Options,
crossSt?: PgCatalog.Types.Varchar.Options,
longName?: PgCatalog.Types.Varchar.Options,
label?: PgCatalog.Types.Varchar.Options,
borough?: PgCatalog.Types.Varchar.Options,
nghbhd?: PgCatalog.Types.Varchar.Options,
routes?: PgCatalog.Types.Varchar.Options,
transfers?: PgCatalog.Types.Varchar.Options,
color?: PgCatalog.Types.Varchar.Options,
express?: PgCatalog.Types.Varchar.Options,
closed?: PgCatalog.Types.Varchar.Options,
geom?: Public.Types.Geometry.Options
}
}
export namespace NycSubwayStationsArray {
export type Options = InvokeQueryOptions;
}
export namespace SpatialRefSysPkey {
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 srid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycCensusBlocksPkey {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycHomicidesPkey {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycNeighborhoodsPkey {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycStreetsPkey {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycSubwayStationsPkey {
export namespace Gid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 gid?: PgCatalog.Types.Int4.Options
}
}
export namespace NycCensusBlocksGeomIdx {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
export namespace NycHomicidesGeomIdx {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
export namespace NycNeighborhoodsGeomIdx {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
export namespace NycStreetsGeomIdx {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
export namespace NycSubwayStationsGeomIdx {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
export namespace PostgisSrs {
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srtext {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proj4text {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointSw {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointNe {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authName?: PgCatalog.Types.Text.Options,
authSrid?: PgCatalog.Types.Text.Options,
srname?: PgCatalog.Types.Text.Options,
srtext?: PgCatalog.Types.Text.Options,
proj4text?: PgCatalog.Types.Text.Options,
pointSw?: Public.Types.Geometry.Options,
pointNe?: Public.Types.Geometry.Options
}
}
export namespace PostgisSrsAll {
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srtext {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proj4text {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointSw {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointNe {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authName?: PgCatalog.Types.Text.Options,
authSrid?: PgCatalog.Types.Text.Options,
srname?: PgCatalog.Types.Text.Options,
srtext?: PgCatalog.Types.Text.Options,
proj4text?: PgCatalog.Types.Text.Options,
pointSw?: Public.Types.Geometry.Options,
pointNe?: Public.Types.Geometry.Options
}
}
export namespace PostgisSrsSearch {
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srname {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srtext {

      export type Options = InvokeQueryOptions;
    
}
export namespace Proj4text {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointSw {

      export type Options = InvokeQueryOptions;
    
}
export namespace PointNe {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authName?: PgCatalog.Types.Text.Options,
authSrid?: PgCatalog.Types.Text.Options,
srname?: PgCatalog.Types.Text.Options,
srtext?: PgCatalog.Types.Text.Options,
proj4text?: PgCatalog.Types.Text.Options,
pointSw?: Public.Types.Geometry.Options,
pointNe?: Public.Types.Geometry.Options
}
}
export namespace StMinimumboundingradius {
export namespace Center {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 center?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options
}
}
export namespace StMaximuminscribedcircle {
export namespace Center {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nearest {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 center?: Public.Types.Geometry.Options,
nearest?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options
}
}
export namespace StLargestemptycircle {
export namespace Center {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nearest {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 center?: Public.Types.Geometry.Options,
nearest?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options
}
}
export namespace StHexagongrid {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace I {

      export type Options = InvokeQueryOptions;
    
}
export namespace J {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
i?: PgCatalog.Types.Int4.Options,
j?: PgCatalog.Types.Int4.Options
}
}
export namespace StSquaregrid {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace I {

      export type Options = InvokeQueryOptions;
    
}
export namespace J {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
i?: PgCatalog.Types.Int4.Options,
j?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Procedures {
export namespace StForcepolygoncw {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace SpheroidIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace SpheroidOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Spheroid.Options
}
}
}
export namespace GeometryIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace GeometryOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryTypmodIn {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.CstringArray.Options
}
}
}
export namespace GeometryTypmodOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeometryAnalyze {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryRecv {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySend {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Geometry_6564 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options,
argument_2?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Geometry_8997 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Point.Options
}
}
}
export namespace Point {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryB0d8 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Path.Options
}
}
}
export namespace Path {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryF1be {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Polygon.Options
}
}
}
export namespace Polygon {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StX {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StY {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StZ {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StM {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Box3dIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace Box3dOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace Box2dIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace Box2dOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options
}
}
}
export namespace Box2dfIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace Box2dfOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options
}
}
}
export namespace GidxIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace GidxOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Gidx.Options
}
}
}
export namespace GeometryLt {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryLe {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryGt {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryGe {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryEq {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryCmp {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometrySortsupport {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryHash {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryGistDistance_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeometryGistConsistent_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeometryGistCompress_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistPenalty_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistPicksplit_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistUnion_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistSame_2d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistDecompress_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistSortsupport_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StForcerhr {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisNoop {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StForcepolygonccw {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace GserializedGistSel_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GserializedGistSelNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GserializedGistJoinsel_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Int2.Options
}
}
}
export namespace GserializedGistJoinselNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Int2.Options
}
}
}
export namespace GeometryOverlaps {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometrySame {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryDistanceCentroid {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryDistanceBox {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryContains {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryWithin {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryLeft {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryOverleft {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryBelow {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryOverbelow {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryOverright {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryRight {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryOverabove {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryAbove {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryGistConsistentNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeometryGistCompressNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistPenaltyNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistPicksplitNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistUnionNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistSameNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryGistDecompressNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryOverlapsNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryContainsNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryWithinNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometrySameNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryDistanceCentroidNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryDistanceCpa {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryGistDistanceNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StShiftlongitude {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StWrapx {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Wrap {

      export type Options = InvokeQueryOptions;
    
}
export namespace Move {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
wrap?: PgCatalog.Types.Float8.Options,
move?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StXmin {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StYmin {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StZmin {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StXmax {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StYmax {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StZmax {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace StExpand_269a {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StExpand_96e3 {
export namespace Parameters {
export namespace Box {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dx {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dy {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 box?: Public.Types.Box2d.Options,
dx?: PgCatalog.Types.Float8.Options,
dy?: PgCatalog.Types.Float8.Options
}
}
}
export namespace PostgisGetbbox {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMakebox2d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StEstimatedextentD2f5 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StEstimatedextent_27e1 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace StEstimatedextent_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StFindextent_27e1 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace StFindextent_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisAddbbox {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisDropbbox {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisHasbbox {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StQuantizecoordinates {
export namespace Parameters {
export namespace G {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecX {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecY {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecZ {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecM {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g?: Public.Types.Geometry.Options,
precX?: PgCatalog.Types.Int4.Options,
precY?: PgCatalog.Types.Int4.Options,
precZ?: PgCatalog.Types.Int4.Options,
precM?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMemsize {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StSummary_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNpoints {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNrings {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dlength {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StLength2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StLength_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StLengthspheroid {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Spheroid.Options
}
}
}
export namespace StLength2dspheroid {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Spheroid.Options
}
}
}
export namespace St_3dperimeter {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPerimeter2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPerimeter_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StArea2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StArea_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIspolygoncw {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIspolygonccw {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StDistancespheroidCd56 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: Public.Types.Spheroid.Options
}
}
}
export namespace StDistancespheroid_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StDistance_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StPointinsidecircle {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAzimuth_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StProjectD5eb {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Distance {

      export type Options = InvokeQueryOptions;
    
}
export namespace Azimuth {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
distance?: PgCatalog.Types.Float8.Options,
azimuth?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StProject_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Distance {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
distance?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAngleE1dd {
export namespace Parameters {
export namespace Pt1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pt2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pt3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pt4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 pt1?: Public.Types.Geometry.Options,
pt2?: Public.Types.Geometry.Options,
pt3?: Public.Types.Geometry.Options,
pt4?: Public.Types.Geometry.Options
}
}
}
export namespace StLineextend {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace DistanceForward {

      export type Options = InvokeQueryOptions;
    
}
export namespace DistanceBackward {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
distanceForward?: PgCatalog.Types.Float8.Options,
distanceBackward?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StForce2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StForce3dz {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Zvalue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
zvalue?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StForce3d {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Zvalue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
zvalue?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StForce3dm {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mvalue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
mvalue?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StForce4d {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Zvalue {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mvalue {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
zvalue?: PgCatalog.Types.Float8.Options,
mvalue?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StForcecollection {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StCollectionextract_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StCollectionextract_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StCollectionhomogenize {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMulti {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StForcecurve {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StForcesfs_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StForcesfs_88bc {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Version {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
version?: PgCatalog.Types.Text.Options
}
}
}
export namespace StExpand_2074 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StExpand_704e {
export namespace Parameters {
export namespace Box {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dx {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dz {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 box?: Public.Types.Box3d.Options,
dx?: PgCatalog.Types.Float8.Options,
dy?: PgCatalog.Types.Float8.Options,
dz?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StExpand_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StExpand_5500 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dx {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dy {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dz {

      export type Options = InvokeQueryOptions;
    
}
export namespace Dm {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
dx?: PgCatalog.Types.Float8.Options,
dy?: PgCatalog.Types.Float8.Options,
dz?: PgCatalog.Types.Float8.Options,
dm?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StEnvelope {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StBoundingdiagonal {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fits {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
fits?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StReverse {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StScroll {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisGeosNoop {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNormalize {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
}
export namespace StZmflag {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNdims {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAsewkt_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAsewkt_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAstwkb_652e {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Prec {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecZ {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecM {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithSizes {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithBoxes {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
prec?: PgCatalog.Types.Int4.Options,
precZ?: PgCatalog.Types.Int4.Options,
precM?: PgCatalog.Types.Int4.Options,
withSizes?: PgCatalog.Types.Bool.Options,
withBoxes?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StAstwkbF3fd {
export namespace Parameters {
export namespace Geom {
export type Options = InvokeQueryOptions;
}
export namespace Ids {
export type Options = InvokeQueryOptions;
}
export namespace Prec {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecZ {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrecM {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithSizes {

      export type Options = InvokeQueryOptions;
    
}
export namespace WithBoxes {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.GeometryArray.Options,
ids?: PgCatalog.Types.Int8Array.Options,
prec?: PgCatalog.Types.Int4.Options,
precZ?: PgCatalog.Types.Int4.Options,
precM?: PgCatalog.Types.Int4.Options,
withSizes?: PgCatalog.Types.Bool.Options,
withBoxes?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StAsewkb_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAshexewkb_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAshexewkb_88bc {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsewkb_88bc {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAslatlontext {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tmpl {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
tmpl?: PgCatalog.Types.Text.Options
}
}
}
export namespace Geomfromewkb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StGeomfromewkb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StGeomfromtwkb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace Geomfromewkt {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfromewkt {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisCacheBbox {
}
export namespace StMakepoint_0aec {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMakepoint_81ec {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMakepoint_570b {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMakepointm {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace St_3dmakebox {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StMakelineA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace StLinefrommultipoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMakeline_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StAddpoint_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StScaleD5eb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAddpointAa17 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StRemovepoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StSetpoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options,
argument_2?: Public.Types.Geometry.Options
}
}
}
export namespace StMakeenvelope {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StTileenvelope {
export namespace Parameters {
export namespace Zoom {

      export type Options = InvokeQueryOptions;
    
}
export namespace X {

      export type Options = InvokeQueryOptions;
    
}
export namespace Y {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bounds {

      export type Options = InvokeQueryOptions;
    
}
export namespace Margin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 zoom?: PgCatalog.Types.Int4.Options,
x?: PgCatalog.Types.Int4.Options,
y?: PgCatalog.Types.Int4.Options,
bounds?: Public.Types.Geometry.Options,
margin?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMakepolygonE2e3 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.GeometryArray.Options
}
}
}
export namespace StMakepolygon_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StBuildarea {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPolygonizeA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace StClusterintersectingA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace StClusterwithin_0e49 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLinemerge_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StLinemerge_4ba2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StAffineE42d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_5 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_6 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_7 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_8 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_9 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_10 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_11 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_12 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Float8.Options,
argument_5?: PgCatalog.Types.Float8.Options,
argument_6?: PgCatalog.Types.Float8.Options,
argument_7?: PgCatalog.Types.Float8.Options,
argument_8?: PgCatalog.Types.Float8.Options,
argument_9?: PgCatalog.Types.Float8.Options,
argument_10?: PgCatalog.Types.Float8.Options,
argument_11?: PgCatalog.Types.Float8.Options,
argument_12?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAffine_1962 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_5 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_6 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Float8.Options,
argument_5?: PgCatalog.Types.Float8.Options,
argument_6?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRotate_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRotate_8b9f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRotate_463e {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: Public.Types.Geometry.Options
}
}
}
export namespace StRotatez {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRotatex {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRotatey {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StTranslate_8b9f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StTranslateD5eb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StScale_3651 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace StScale_1bee {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Origin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options,
origin?: Public.Types.Geometry.Options
}
}
}
export namespace StScale_8b9f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StTransscale {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StDump {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StDumprings {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StDumppoints {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StDumpsegments {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace PopulateGeometryColumns_23fc {
export namespace Parameters {
export namespace UseTypmod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 useTypmod?: PgCatalog.Types.Bool.Options
}
}
}
export namespace PopulateGeometryColumns_4174 {
export namespace Parameters {
export namespace TblOid {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseTypmod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tblOid?: PgCatalog.Types.Oid.Options,
useTypmod?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Addgeometrycolumn_8fbb {
export namespace Parameters {
export namespace CatalogName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewSridIn {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewType {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewDim {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseTypmod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalogName?: PgCatalog.Types.Varchar.Options,
schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options,
newSridIn?: PgCatalog.Types.Int4.Options,
newType?: PgCatalog.Types.Varchar.Options,
newDim?: PgCatalog.Types.Int4.Options,
useTypmod?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Addgeometrycolumn_4617 {
export namespace Parameters {
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewType {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewDim {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseTypmod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options,
newSrid?: PgCatalog.Types.Int4.Options,
newType?: PgCatalog.Types.Varchar.Options,
newDim?: PgCatalog.Types.Int4.Options,
useTypmod?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Addgeometrycolumn_093c {
export namespace Parameters {
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewSrid {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewType {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewDim {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseTypmod {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options,
newSrid?: PgCatalog.Types.Int4.Options,
newType?: PgCatalog.Types.Varchar.Options,
newDim?: PgCatalog.Types.Int4.Options,
useTypmod?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Dropgeometrycolumn_0412 {
export namespace Parameters {
export namespace CatalogName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalogName?: PgCatalog.Types.Varchar.Options,
schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace Dropgeometrycolumn_2253 {
export namespace Parameters {
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace DropgeometrycolumnF11a {
export namespace Parameters {
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace Dropgeometrytable_2253 {
export namespace Parameters {
export namespace CatalogName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalogName?: PgCatalog.Types.Varchar.Options,
schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace StSegmentize_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace DropgeometrytableF11a {
export namespace Parameters {
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace DropgeometrytableBfde {
export namespace Parameters {
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 tableName?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace UpdategeometrysridB2ee {
export namespace Parameters {
export namespace CatalognName {

      export type Options = InvokeQueryOptions;
    
}
export namespace SchemaName {

      export type Options = InvokeQueryOptions;
    
}
export namespace TableName {

      export type Options = InvokeQueryOptions;
    
}
export namespace ColumnName {

      export type Options = InvokeQueryOptions;
    
}
export namespace NewSridIn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 catalognName?: PgCatalog.Types.Varchar.Options,
schemaName?: PgCatalog.Types.Varchar.Options,
tableName?: PgCatalog.Types.Varchar.Options,
columnName?: PgCatalog.Types.Varchar.Options,
newSridIn?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Updategeometrysrid_7b58 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Varchar.Options,
argument_1?: PgCatalog.Types.Varchar.Options,
argument_2?: PgCatalog.Types.Varchar.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Updategeometrysrid_11c8 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Varchar.Options,
argument_1?: PgCatalog.Types.Varchar.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace FindSrid {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Varchar.Options,
argument_1?: PgCatalog.Types.Varchar.Options,
argument_2?: PgCatalog.Types.Varchar.Options
}
}
}
export namespace GetProj4FromSrid {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StSetsrid_6cbe {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StSrid_0cdb {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisTransformGeometry {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PostgisSrsCodes {
export namespace Parameters {
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authName?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisSrs {
export namespace Parameters {
export namespace AuthName {

      export type Options = InvokeQueryOptions;
    
}
export namespace AuthSrid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 authName?: PgCatalog.Types.Text.Options,
authSrid?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisSrsAll {
}
export namespace PostgisSrsSearch {
export namespace Parameters {
export namespace Bounds {

      export type Options = InvokeQueryOptions;
    
}
export namespace Authname {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 bounds?: Public.Types.Geometry.Options,
authname?: PgCatalog.Types.Text.Options
}
}
}
export namespace StTransform_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StTransform_88bc {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToProj {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
toProj?: PgCatalog.Types.Text.Options
}
}
}
export namespace StTransform_655c {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace FromProj {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToProj {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
fromProj?: PgCatalog.Types.Text.Options,
toProj?: PgCatalog.Types.Text.Options
}
}
}
export namespace StTransform_5016 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace FromProj {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSrid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
fromProj?: PgCatalog.Types.Text.Options,
toSrid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PostgisTransformPipelineGeometry {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pipeline {

      export type Options = InvokeQueryOptions;
    
}
export namespace Forward {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSrid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
pipeline?: PgCatalog.Types.Text.Options,
forward?: PgCatalog.Types.Bool.Options,
toSrid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StTransformpipeline {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pipeline {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSrid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
pipeline?: PgCatalog.Types.Text.Options,
toSrid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StInversetransformpipeline {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Pipeline {

      export type Options = InvokeQueryOptions;
    
}
export namespace ToSrid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
pipeline?: PgCatalog.Types.Text.Options,
toSrid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PostgisVersion {
}
export namespace PostgisLiblwgeomVersion {
}
export namespace PostgisProjVersion {
}
export namespace PostgisWagyuVersion {
}
export namespace PostgisScriptsInstalled {
}
export namespace PostgisLibVersion {
}
export namespace PostgisScriptsReleased {
}
export namespace PostgisGeosVersion {
}
export namespace PostgisGeosCompiledVersion {
}
export namespace PostgisLibRevision {
}
export namespace PostgisSvnVersion {
}
export namespace PostgisLibxmlVersion {
}
export namespace PostgisScriptsBuildDate {
}
export namespace PostgisLibBuildDate {
}
export namespace PostgisExtensionsUpgrade {
export namespace Parameters {
export namespace TargetVersion {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 targetVersion?: PgCatalog.Types.Text.Options
}
}
}
export namespace StLineinterpolatepoint_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLineinterpolatepoints_8fda {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Repeat {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
repeat?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StLinesubstringD5eb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLinelocatepoint_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StAddmeasure {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StClosestpointofapproach {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisFullVersion {
}
export namespace Box2d_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Box3d_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Box_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Box2d_07e9 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace Box3dE505 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options
}
}
}
export namespace Box_07e9 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace Text {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Box3dtobox {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace GeometryE505 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options
}
}
}
export namespace Geometry_07e9 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options
}
}
}
export namespace GeometryE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace Geometry_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace Bytea_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StSimplify_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSimplify_8fda {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StSimplifyvw {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSeteffectivearea {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StFilterbym {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StChaikinsmoothing {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options,
argument_2?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StSnaptogrid_5500 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSnaptogridD5eb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSnaptogrid_7163 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSnaptogrid_7f2e {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_5 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Float8.Options,
argument_4?: PgCatalog.Types.Float8.Options,
argument_5?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StDistancecpa {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace StCpawithin {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StIsvalidtrajectory {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIntersection_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StBufferBf44 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options,
options?: PgCatalog.Types.Text.Options
}
}
}
export namespace StBufferC33e {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export namespace Quadsegs {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options,
quadsegs?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMinimumboundingradius {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMinimumboundingcircle {
export namespace Parameters {
export namespace Inputgeom {

      export type Options = InvokeQueryOptions;
    
}
export namespace SegsPerQuarter {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 inputgeom?: Public.Types.Geometry.Options,
segsPerQuarter?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StOrientedenvelope {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StOffsetcurve {
export namespace Parameters {
export namespace Line {

      export type Options = InvokeQueryOptions;
    
}
export namespace Distance {

      export type Options = InvokeQueryOptions;
    
}
export namespace Params {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 line?: Public.Types.Geometry.Options,
distance?: PgCatalog.Types.Float8.Options,
params?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeneratepoints_6cbe {
export namespace Parameters {
export namespace Area {

      export type Options = InvokeQueryOptions;
    
}
export namespace Npoints {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 area?: Public.Types.Geometry.Options,
npoints?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeneratepointsD341 {
export namespace Parameters {
export namespace Area {

      export type Options = InvokeQueryOptions;
    
}
export namespace Npoints {

      export type Options = InvokeQueryOptions;
    
}
export namespace Seed {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 area?: Public.Types.Geometry.Options,
npoints?: PgCatalog.Types.Int4.Options,
seed?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StConvexhull {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StSimplifypreservetopology {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StIsvalidreason_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIsvaliddetail {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Flags {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
flags?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StIsvalidreason_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StIsvalid_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StHausdorffdistance_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StHausdorffdistance_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StFrechetdistance {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMaximuminscribedcircle {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StLargestemptycircle {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace Boundary {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options,
boundary?: Public.Types.Geometry.Options
}
}
}
export namespace StDifference {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StBoundary {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPoints {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StSymdifference {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StSymmetricdifference {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StUnion_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StUnion_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StUnaryunion {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRemoverepeatedpoints {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StClipbybox2d {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Box {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
box?: Public.Types.Box2d.Options
}
}
}
export namespace StSubdivide {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxvertices {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxvertices?: PgCatalog.Types.Int4.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StReduceprecision {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Gridsize {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
gridsize?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StMakevalid_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMakevalid_88bc {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Params {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
params?: PgCatalog.Types.Text.Options
}
}
}
export namespace StCleangeometry {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StSplit {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StSharedpaths {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StSnap {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StRelatematch {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StNode {
export namespace Parameters {
export namespace G {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g?: Public.Types.Geometry.Options
}
}
}
export namespace StDelaunaytriangles {
export namespace Parameters {
export namespace G1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace Flags {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g1?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options,
flags?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StTriangulatepolygon {
export namespace Parameters {
export namespace G1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g1?: Public.Types.Geometry.Options
}
}
}
export namespace StVoronoipolygons {
export namespace Parameters {
export namespace G1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtendTo {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g1?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options,
extendTo?: Public.Types.Geometry.Options
}
}
}
export namespace StVoronoilines {
export namespace Parameters {
export namespace G1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace ExtendTo {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g1?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options,
extendTo?: Public.Types.Geometry.Options
}
}
}
export namespace StCombinebbox_1ee2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace StCombinebbox_9d67 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box3d.Options,
argument_1?: Public.Types.Box3d.Options
}
}
}
export namespace StCombinebbox_1a7e {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace StCollect_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StCollectA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace PgisGeometryAccumTransfn_43cf {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace PgisGeometryAccumTransfn_7c68 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace PgisGeometryAccumTransfn_0b93 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PgisGeometryCollectFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryPolygonizeFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryClusterintersectingFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryClusterwithinFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryMakelineFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryCoverageunionFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryUnionParallelTransfn_43cf {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace PgisGeometryUnionParallelTransfn_7c68 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace PgisGeometryUnionParallelCombinefn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryUnionParallelSerialfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryUnionParallelDeserialfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisGeometryUnionParallelFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StUnionA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace StCoverageunionA4b6 {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.GeometryArray.Options
}
}
}
export namespace StRelate_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StRelateAa17 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StRelateCaf9 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace StDisjoint {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace PostgisIndexSupportfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StLinecrossingdirection {
export namespace Parameters {
export namespace Line1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Line2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 line1?: Public.Types.Geometry.Options,
line2?: Public.Types.Geometry.Options
}
}
}
export namespace StDwithin_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StTouches {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StIntersects_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StCrosses {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StContains {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StContainsproperly {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StWithin {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StCovers_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StCoveredby_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StOverlaps {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StDfullywithin {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace St_3ddwithin {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace St_3ddfullywithin {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace St_3dintersects {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StOrderingequals {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StEquals {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StIsvalid_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMinimumclearance {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StMinimumclearanceline {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StCentroid_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StGeometricmedian {
export namespace Parameters {
export namespace G {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxIter {

      export type Options = InvokeQueryOptions;
    
}
export namespace FailIfNotConverged {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 g?: Public.Types.Geometry.Options,
tolerance?: PgCatalog.Types.Float8.Options,
maxIter?: PgCatalog.Types.Int4.Options,
failIfNotConverged?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StIsring {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPointonsurface {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIssimple {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIscollection {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Equals {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StGeomfromgml_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomfromgmlE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGmltosqlE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGmltosql_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomfromkml {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfrommarc21 {
export namespace Parameters {
export namespace Marc21xml {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 marc21xml?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsmarc21 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Format {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
format?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfromgeojsonE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfromgeojson_608f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Json.Options
}
}
}
export namespace StGeomfromgeojson_3c9d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Jsonb.Options
}
}
}
export namespace PostgisLibjsonVersion {
}
export namespace StLinefromencodedpolyline {
export namespace Parameters {
export namespace Txtin {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprecision {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 txtin?: PgCatalog.Types.Text.Options,
nprecision?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsencodedpolyline {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprecision {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
nprecision?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAssvgD341 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rel {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
rel?: PgCatalog.Types.Int4.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsgmlD341 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsgml_32a0 {
export namespace Parameters {
export namespace Version {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprefix {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 version?: PgCatalog.Types.Int4.Options,
geom?: Public.Types.Geometry.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options,
nprefix?: PgCatalog.Types.Text.Options,
id?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAskmlCce7 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprefix {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
nprefix?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsgeojsonD341 {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsgeojsonF2c6 {
export namespace Parameters {
export namespace R {

      export type Options = InvokeQueryOptions;
    
}
export namespace GeomColumn {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace PrettyBool {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 r?: PgCatalog.Types.Record.Options,
geomColumn?: PgCatalog.Types.Text.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
prettyBool?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Json {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Jsonb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace PgisAsmvtTransfn_647f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options
}
}
}
export namespace PgisAsmvtTransfn_27f4 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace PgisAsmvtTransfnF57f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PgisAsmvtTransfn_92c1 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Int4.Options,
argument_4?: PgCatalog.Types.Text.Options
}
}
}
export namespace PgisAsmvtTransfnF5be {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_5 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Int4.Options,
argument_4?: PgCatalog.Types.Text.Options,
argument_5?: PgCatalog.Types.Text.Options
}
}
}
export namespace PgisAsmvtFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisAsmvtCombinefn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisAsmvtSerialfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisAsmvtDeserialfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StAsmvtgeom {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bounds {

      export type Options = InvokeQueryOptions;
    
}
export namespace Extent {

      export type Options = InvokeQueryOptions;
    
}
export namespace Buffer {

      export type Options = InvokeQueryOptions;
    
}
export namespace ClipGeom {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
bounds?: Public.Types.Box2d.Options,
extent?: PgCatalog.Types.Int4.Options,
buffer?: PgCatalog.Types.Int4.Options,
clipGeom?: PgCatalog.Types.Bool.Options
}
}
}
export namespace PostgisLibprotobufVersion {
}
export namespace PgisAsgeobufTransfn_647f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options
}
}
}
export namespace PgisAsgeobufTransfn_27f4 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace PgisAsgeobufFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace PgisAsflatgeobufTransfn_647f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options
}
}
}
export namespace PgisAsflatgeobufTransfn_9633 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Bool.Options
}
}
}
export namespace PgisAsflatgeobufTransfn_521f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Anyelement.Options,
argument_2?: PgCatalog.Types.Bool.Options,
argument_3?: PgCatalog.Types.Text.Options
}
}
}
export namespace PgisAsflatgeobufFinalfn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StFromflatgeobuftotable {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StFromflatgeobuf {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Anyelement.Options,
argument_1?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StGeohash_6cbe {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxchars {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxchars?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StBox2dfromgeohash {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointfromgeohash {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomfromgeohash {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StNumpoints {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNumgeometries {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StGeometryn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StDimension {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StExteriorring {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNuminteriorrings {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StNuminteriorring {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StInteriorringn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Geometrytype_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StGeometrytype {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPointn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StNumpatches {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StPatchn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StStartpoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StEndpoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIsclosed {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StIsempty {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAsbinary_88bc {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsbinary_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAstext_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StAstext_6cbe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeometryfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeometryfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StWkttosql {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StPointfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StPointfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StLinefromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StLinefromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolyfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StPolyfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolygonfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolygonfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMlinefromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMlinefromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMultilinestringfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMultilinestringfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMpointfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMpointfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMultipointfromtext {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMpolyfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMpolyfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StMultipolygonfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMultipolygonfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomcollfromtext_27e2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomcollfromtextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeomfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StGeomfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StLinefromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StLinefromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StLinestringfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StLinestringfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StPolyfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolyfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StPolygonfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolygonfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMpointfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMpointfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMultipointfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeographyAnalyze {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StMultipointfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMultilinefromwkb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMlinefromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMlinefromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMpolyfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMpolyfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMultipolyfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StMultipolyfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StGeomcollfromwkbD8af {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StGeomcollfromwkb_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StMaxdistance {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StClosestpoint_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StShortestline_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StLongestline {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StSwapordinates {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ords {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
ords?: PgCatalog.Types.Cstring.Options
}
}
}
export namespace StFlipcoordinates {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace StBdpolyfromtext {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StBdmpolyfromtext {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Unlockrows {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace Geography_28e9 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Int4.Options,
argument_2?: PgCatalog.Types.Bool.Options
}
}
}
export namespace Geography_2d19 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace Bytea_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StAstext_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StAstext_3181 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace LockrowE9aa {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_4 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Text.Options,
argument_4?: PgCatalog.Types.Timestamp.Options
}
}
}
export namespace Lockrow_02b4 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Text.Options
}
}
}
export namespace Lockrow_27e1 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace Lockrow_9a8a {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options,
argument_3?: PgCatalog.Types.Timestamp.Options
}
}
}
export namespace Addauth {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace Checkauth_27e1 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace Checkauth_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace Checkauthtrigger {
}
export namespace Gettransactionid {
}
export namespace Enablelongtransactions {
}
export namespace Longtransactionsenabled {
}
export namespace Disablelongtransactions {
}
export namespace GeographyTypmodIn {
export namespace Parameters {
export namespace Argument_0 {
export type Options = InvokeQueryOptions;
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.CstringArray.Options
}
}
}
export namespace GeographyTypmodOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeographyIn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Cstring.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeographyOut {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace GeographyRecv {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Oid.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeographySend {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StAstextE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeographyfromtext {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeogfromtext {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StGeogfromwkb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace PostgisTypmodDims {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PostgisTypmodSrid {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace PostgisTypmodType {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Geography_0cdb {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options
}
}
}
export namespace Geometry_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace GeographyGistConsistent {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geography.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace GeographyGistCompress {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyGistPenalty {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyGistPicksplit {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyGistUnion {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Bytea.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyGistSame {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2d.Options,
argument_1?: Public.Types.Box2d.Options,
argument_2?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyGistDecompress {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyOverlaps {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyDistanceKnn {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyGistDistance {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: Public.Types.Geography.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace OverlapsGeog_52a8 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Gidx.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace OverlapsGeog_25ba {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Gidx.Options,
argument_1?: Public.Types.Gidx.Options
}
}
}
export namespace OverlapsGeog_8fd3 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Gidx.Options
}
}
}
export namespace GeogBrinInclusionAddValue {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographyLt {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyLe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyGt {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyGe {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyEq {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace GeographyCmp {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace StAssvg_6ec5 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Rel {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
rel?: PgCatalog.Types.Int4.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAssvgE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StProjectD4ec {
export namespace Parameters {
export namespace GeogFrom {

      export type Options = InvokeQueryOptions;
    
}
export namespace GeogTo {

      export type Options = InvokeQueryOptions;
    
}
export namespace Distance {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geogFrom?: Public.Types.Geography.Options,
geogTo?: Public.Types.Geography.Options,
distance?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAzimuthE452 {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options
}
}
}
export namespace StBuffer_49f7 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsgmlE888 {
export namespace Parameters {
export namespace Version {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprefix {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 version?: PgCatalog.Types.Int4.Options,
geog?: Public.Types.Geography.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options,
nprefix?: PgCatalog.Types.Text.Options,
id?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsgml_2160 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprefix {

      export type Options = InvokeQueryOptions;
    
}
export namespace Id {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options,
nprefix?: PgCatalog.Types.Text.Options,
id?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsgmlE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAskmlF40a {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Nprefix {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
nprefix?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAskmlE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsgeojson_6ec5 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsgeojsonE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StDistance_8dcd {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StDistance_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAreaEcae {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StAreaE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StLengthEcae {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StLengthE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StProjectEd46 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Distance {

      export type Options = InvokeQueryOptions;
    
}
export namespace Azimuth {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
distance?: PgCatalog.Types.Float8.Options,
azimuth?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StPerimeterEcae {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StSegmentizeCadf {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace MaxSegmentLength {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
maxSegmentLength?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StAsbinary_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StAsbinary_734d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StAsewkt_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StAsewkt_3181 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAsewktE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace Geometrytype_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StSummary_7902 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options
}
}
}
export namespace StGeohash_3181 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxchars {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
maxchars?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StSrid_7902 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options
}
}
}
export namespace StSetsrid_3181 {
export namespace Parameters {
export namespace Geog {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog?: Public.Types.Geography.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StCentroidEcae {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StCentroidE728 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options
}
}
}
export namespace StCoversE452 {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options
}
}
}
export namespace StDwithin_55df {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tolerance {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options,
tolerance?: PgCatalog.Types.Float8.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StCoveredbyE452 {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options
}
}
}
export namespace StIntersectsE452 {
export namespace Parameters {
export namespace Geog1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geog2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geog1?: Public.Types.Geography.Options,
geog2?: Public.Types.Geography.Options
}
}
}
export namespace StBufferCadf {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StBuffer_12e3 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StBuffer_3aaa {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace StBufferC349 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StBufferF7c6 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Text.Options
}
}
}
export namespace StIntersectionE452 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options
}
}
}
export namespace StIntersection_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StCovers_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StCoveredby_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StDwithinEfc0 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StIntersects_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StClosestpoint_8dcd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StClosestpoint_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StShortestline_8dcd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StShortestline_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StLinesubstringEd46 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLinesubstringE586 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options,
argument_2?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLinelocatepoint_8dcd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: Public.Types.Geography.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StLinelocatepoint_2ec2 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Text.Options
}
}
}
export namespace StLineinterpolatepoints_8796 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export namespace Repeat {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options,
useSpheroid?: PgCatalog.Types.Bool.Options,
repeat?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StLineinterpolatepointsC349 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLineinterpolatepoint_612b {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseSpheroid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geography.Options,
argument_1?: PgCatalog.Types.Float8.Options,
useSpheroid?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StLineinterpolatepointC349 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Text.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StDistancesphere_3651 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StDistancesphere_6961 {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Radius {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options,
radius?: PgCatalog.Types.Float8.Options
}
}
}
export namespace PostgisTypeName {
export namespace Parameters {
export namespace Geomname {

      export type Options = InvokeQueryOptions;
    
}
export namespace CoordDimension {

      export type Options = InvokeQueryOptions;
    
}
export namespace UseNewName {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geomname?: PgCatalog.Types.Varchar.Options,
coordDimension?: PgCatalog.Types.Int4.Options,
useNewName?: PgCatalog.Types.Bool.Options
}
}
}
export namespace PostgisConstraintSrid {
export namespace Parameters {
export namespace Geomschema {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomtable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomcolumn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geomschema?: PgCatalog.Types.Text.Options,
geomtable?: PgCatalog.Types.Text.Options,
geomcolumn?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisConstraintDims {
export namespace Parameters {
export namespace Geomschema {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomtable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomcolumn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geomschema?: PgCatalog.Types.Text.Options,
geomtable?: PgCatalog.Types.Text.Options,
geomcolumn?: PgCatalog.Types.Text.Options
}
}
}
export namespace PostgisConstraintType {
export namespace Parameters {
export namespace Geomschema {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomtable {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geomcolumn {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geomschema?: PgCatalog.Types.Text.Options,
geomtable?: PgCatalog.Types.Text.Options,
geomcolumn?: PgCatalog.Types.Text.Options
}
}
}
export namespace St_3ddistance {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dmaxdistance {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dclosestpoint {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dshortestline {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dlongestline {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace StCoorddim {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options
}
}
}
export namespace StCurvetoline {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tol {

      export type Options = InvokeQueryOptions;
    
}
export namespace Toltype {

      export type Options = InvokeQueryOptions;
    
}
export namespace Flags {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
tol?: PgCatalog.Types.Float8.Options,
toltype?: PgCatalog.Types.Int4.Options,
flags?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StHasarc {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options
}
}
}
export namespace StLinetocurve {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options
}
}
}
export namespace StPoint_0aec {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StPoint_0b7f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Float8.Options,
argument_1?: PgCatalog.Types.Float8.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointz {
export namespace Parameters {
export namespace Xcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ycoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Zcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 xcoordinate?: PgCatalog.Types.Float8.Options,
ycoordinate?: PgCatalog.Types.Float8.Options,
zcoordinate?: PgCatalog.Types.Float8.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointm {
export namespace Parameters {
export namespace Xcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ycoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 xcoordinate?: PgCatalog.Types.Float8.Options,
ycoordinate?: PgCatalog.Types.Float8.Options,
mcoordinate?: PgCatalog.Types.Float8.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPointzm {
export namespace Parameters {
export namespace Xcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Ycoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Zcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Mcoordinate {

      export type Options = InvokeQueryOptions;
    
}
export namespace Srid {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 xcoordinate?: PgCatalog.Types.Float8.Options,
ycoordinate?: PgCatalog.Types.Float8.Options,
zcoordinate?: PgCatalog.Types.Float8.Options,
mcoordinate?: PgCatalog.Types.Float8.Options,
srid?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StPolygon {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StWkbtosql {
export namespace Parameters {
export namespace Wkb {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 wkb?: PgCatalog.Types.Bytea.Options
}
}
}
export namespace StLocatebetween {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export namespace Frommeasure {

      export type Options = InvokeQueryOptions;
    
}
export namespace Tomeasure {

      export type Options = InvokeQueryOptions;
    
}
export namespace Leftrightoffset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options,
frommeasure?: PgCatalog.Types.Float8.Options,
tomeasure?: PgCatalog.Types.Float8.Options,
leftrightoffset?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLocatealong {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export namespace Measure {

      export type Options = InvokeQueryOptions;
    
}
export namespace Leftrightoffset {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options,
measure?: PgCatalog.Types.Float8.Options,
leftrightoffset?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StLocatebetweenelevations {
export namespace Parameters {
export namespace Geometry {

      export type Options = InvokeQueryOptions;
    
}
export namespace Fromelevation {

      export type Options = InvokeQueryOptions;
    
}
export namespace Toelevation {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geometry?: Public.Types.Geometry.Options,
fromelevation?: PgCatalog.Types.Float8.Options,
toelevation?: PgCatalog.Types.Float8.Options
}
}
}
export namespace StInterpolatepoint {
export namespace Parameters {
export namespace Line {

      export type Options = InvokeQueryOptions;
    
}
export namespace Point {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 line?: Public.Types.Geometry.Options,
point?: Public.Types.Geometry.Options
}
}
}
export namespace StHexagon {
export namespace Parameters {
export namespace Size {

      export type Options = InvokeQueryOptions;
    
}
export namespace CellI {

      export type Options = InvokeQueryOptions;
    
}
export namespace CellJ {

      export type Options = InvokeQueryOptions;
    
}
export namespace Origin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 size?: PgCatalog.Types.Float8.Options,
cellI?: PgCatalog.Types.Int4.Options,
cellJ?: PgCatalog.Types.Int4.Options,
origin?: Public.Types.Geometry.Options
}
}
}
export namespace StSquare {
export namespace Parameters {
export namespace Size {

      export type Options = InvokeQueryOptions;
    
}
export namespace CellI {

      export type Options = InvokeQueryOptions;
    
}
export namespace CellJ {

      export type Options = InvokeQueryOptions;
    
}
export namespace Origin {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 size?: PgCatalog.Types.Float8.Options,
cellI?: PgCatalog.Types.Int4.Options,
cellJ?: PgCatalog.Types.Int4.Options,
origin?: Public.Types.Geometry.Options
}
}
}
export namespace StHexagongrid {
export namespace Parameters {
export namespace Size {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bounds {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 size?: PgCatalog.Types.Float8.Options,
bounds?: Public.Types.Geometry.Options
}
}
}
export namespace StSquaregrid {
export namespace Parameters {
export namespace Size {

      export type Options = InvokeQueryOptions;
    
}
export namespace Bounds {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 size?: PgCatalog.Types.Float8.Options,
bounds?: Public.Types.Geometry.Options
}
}
}
export namespace Contains_2d_3f2a {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace IsContained_2d_3f2a {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace Overlaps_2d_3f2a {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace Overlaps_2d_4f71 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace Contains_2d_4f71 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace IsContained_2d_4f71 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Box2df.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace Contains_2d_7d4f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace IsContained_2d_7d4f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace Overlaps_2d_7d4f {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Box2df.Options
}
}
}
export namespace OverlapsNd_6173 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Gidx.Options,
argument_1?: Public.Types.Geometry.Options
}
}
}
export namespace OverlapsNd_25ba {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Gidx.Options,
argument_1?: Public.Types.Gidx.Options
}
}
}
export namespace OverlapsNd_40b7 {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: Public.Types.Gidx.Options
}
}
}
export namespace Geom2dBrinInclusionAddValue {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Internal.Options
}
}
}
export namespace Geom3dBrinInclusionAddValue {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Internal.Options
}
}
}
export namespace Geom4dBrinInclusionAddValue {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_2 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_3 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options,
argument_2?: PgCatalog.Types.Internal.Options,
argument_3?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StSimplifypolygonhull {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace VertexFraction {

      export type Options = InvokeQueryOptions;
    
}
export namespace IsOuter {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
vertexFraction?: PgCatalog.Types.Float8.Options,
isOuter?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StConcavehull {
export namespace Parameters {
export namespace ParamGeom {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParamPctconvex {

      export type Options = InvokeQueryOptions;
    
}
export namespace ParamAllowHoles {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 paramGeom?: Public.Types.Geometry.Options,
paramPctconvex?: PgCatalog.Types.Float8.Options,
paramAllowHoles?: PgCatalog.Types.Bool.Options
}
}
}
export namespace StAsx3d {
export namespace Parameters {
export namespace Geom {

      export type Options = InvokeQueryOptions;
    
}
export namespace Maxdecimaldigits {

      export type Options = InvokeQueryOptions;
    
}
export namespace Options {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom?: Public.Types.Geometry.Options,
maxdecimaldigits?: PgCatalog.Types.Int4.Options,
options?: PgCatalog.Types.Int4.Options
}
}
}
export namespace StAngle_3651 {
export namespace Parameters {
export namespace Line1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Line2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 line1?: Public.Types.Geometry.Options,
line2?: Public.Types.Geometry.Options
}
}
}
export namespace St_3dlineinterpolatepoint {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: Public.Types.Geometry.Options,
argument_1?: PgCatalog.Types.Float8.Options
}
}
}
export namespace GeometrySpgistConfig_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistChoose_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistPicksplit_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistInnerConsistent_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistLeafConsistent_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistCompress_2d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometryOverlaps_3d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryContains_3d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometryContained_3d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometrySame_3d {
export namespace Parameters {
export namespace Geom1 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Geom2 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 geom1?: Public.Types.Geometry.Options,
geom2?: Public.Types.Geometry.Options
}
}
}
export namespace GeometrySpgistConfig_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistChoose_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistPicksplit_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistInnerConsistent_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistLeafConsistent_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistCompress_3d {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistConfigNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistChooseNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistPicksplitNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistInnerConsistentNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistLeafConsistentNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeometrySpgistCompressNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistConfigNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistChooseNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistPicksplitNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistInnerConsistentNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistLeafConsistentNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export namespace Argument_1 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options,
argument_1?: PgCatalog.Types.Internal.Options
}
}
}
export namespace GeographySpgistCompressNd {
export namespace Parameters {
export namespace Argument_0 {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 argument_0?: PgCatalog.Types.Internal.Options
}
}
}
export namespace StLetters {
export namespace Parameters {
export namespace Letters {

      export type Options = InvokeQueryOptions;
    
}
export namespace Font {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 letters?: PgCatalog.Types.Text.Options,
font?: PgCatalog.Types.Json.Options
}
}
}
}
export namespace Tables {
export namespace SpatialRefSys {
}
export namespace NycCensusBlocks {
}
export namespace NycHomicides {
}
export namespace NycNeighborhoods {
}
export namespace NycStreets {
}
export namespace NycSubwayStations {
}
}
}
export namespace PgToast {
export namespace Types {
export namespace PgToast_47570Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_48328Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_48334Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1255Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1247Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2604Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2606Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2612Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2600Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2619Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3381Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3429Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2618Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2620Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3466Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2609Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_48340Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2615Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1262Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2964Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1213Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1260Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2396Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3600Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3079Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_2328Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1417Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_1418Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3118Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3256Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_6000Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_826Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3394Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3596Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3592Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3456Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_6243Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_3350Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_6106Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_6100Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_48346Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_48352Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_13658Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_13663Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_13668Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
export namespace PgToast_13673Index {
export namespace ChunkId {

      export type Options = InvokeQueryOptions;
    
}
export namespace ChunkSeq {

      export type Options = InvokeQueryOptions;
    
}
export type Options = InvokeQueryOptions & {
 chunkId?: PgCatalog.Types.Oid.Options,
chunkSeq?: PgCatalog.Types.Int4.Options
}
}
}
export namespace Procedures {
}
export namespace Tables {
}
}
export type Settings = {
allowInPlaceTablespaces: string;
allowSystemTableMods: string;
applicationName: string;
archiveCleanupCommand: string;
archiveCommand: string;
archiveLibrary: string;
archiveMode: string;
archiveTimeout: string;
arrayNulls: string;
authenticationTimeout: string;
autovacuum: string;
autovacuumAnalyzeScaleFactor: string;
autovacuumAnalyzeThreshold: string;
autovacuumFreezeMaxAge: string;
autovacuumMaxWorkers: string;
autovacuumMultixactFreezeMaxAge: string;
autovacuumNaptime: string;
autovacuumVacuumCostDelay: string;
autovacuumVacuumCostLimit: string;
autovacuumVacuumInsertScaleFactor: string;
autovacuumVacuumInsertThreshold: string;
autovacuumVacuumScaleFactor: string;
autovacuumVacuumThreshold: string;
autovacuumWorkMem: string;
backendFlushAfter: string;
backslashQuote: string;
backtraceFunctions: string;
bgwriterDelay: string;
bgwriterFlushAfter: string;
bgwriterLruMaxpages: string;
bgwriterLruMultiplier: string;
blockSize: string;
bonjour: string;
bonjourName: string;
byteaOutput: string;
checkFunctionBodies: string;
checkpointCompletionTarget: string;
checkpointFlushAfter: string;
checkpointTimeout: string;
checkpointWarning: string;
clientConnectionCheckInterval: string;
clientEncoding: string;
clientMinMessages: string;
clusterName: string;
commitDelay: string;
commitSiblings: string;
computeQueryId: string;
configFile: string;
constraintExclusion: string;
cpuIndexTupleCost: string;
cpuOperatorCost: string;
cpuTupleCost: string;
createroleSelfGrant: string;
cursorTupleFraction: string;
dataChecksums: string;
dataDirectory: string;
dataDirectoryMode: string;
dataSyncRetry: string;
dateStyle: string;
dbUserNamespace: string;
deadlockTimeout: string;
debugAssertions: string;
debugDiscardCaches: string;
debugIoDirect: string;
debugLogicalReplicationStreaming: string;
debugParallelQuery: string;
debugPrettyPrint: string;
debugPrintParse: string;
debugPrintPlan: string;
debugPrintRewritten: string;
defaultStatisticsTarget: string;
defaultTableAccessMethod: string;
defaultTablespace: string;
defaultTextSearchConfig: string;
defaultToastCompression: string;
defaultTransactionDeferrable: string;
defaultTransactionIsolation: string;
defaultTransactionReadOnly: string;
dynamicLibraryPath: string;
dynamicSharedMemoryType: string;
effectiveCacheSize: string;
effectiveIoConcurrency: string;
enableAsyncAppend: string;
enableBitmapscan: string;
enableGathermerge: string;
enableHashagg: string;
enableHashjoin: string;
enableIncrementalSort: string;
enableIndexonlyscan: string;
enableIndexscan: string;
enableMaterial: string;
enableMemoize: string;
enableMergejoin: string;
enableNestloop: string;
enableParallelAppend: string;
enableParallelHash: string;
enablePartitionPruning: string;
enablePartitionwiseAggregate: string;
enablePartitionwiseJoin: string;
enablePresortedAggregate: string;
enableSeqscan: string;
enableSort: string;
enableTidscan: string;
escapeStringWarning: string;
eventSource: string;
exitOnError: string;
externalPidFile: string;
extraFloatDigits: string;
fromCollapseLimit: string;
fsync: string;
fullPageWrites: string;
geqo: string;
geqoEffort: string;
geqoGenerations: string;
geqoPoolSize: string;
geqoSeed: string;
geqoSelectionBias: string;
geqoThreshold: string;
ginFuzzySearchLimit: string;
ginPendingListLimit: string;
gssAcceptDelegation: string;
hashMemMultiplier: string;
hbaFile: string;
hotStandby: string;
hotStandbyFeedback: string;
hugePageSize: string;
hugePages: string;
icuValidationLevel: string;
identFile: string;
idleInTransactionSessionTimeout: string;
idleSessionTimeout: string;
ignoreChecksumFailure: string;
ignoreInvalidPages: string;
ignoreSystemIndexes: string;
inHotStandby: string;
integerDatetimes: string;
intervalStyle: string;
jit: string;
jitAboveCost: string;
jitDebuggingSupport: string;
jitDumpBitcode: string;
jitExpressions: string;
jitInlineAboveCost: string;
jitOptimizeAboveCost: string;
jitProfilingSupport: string;
jitProvider: string;
jitTupleDeforming: string;
joinCollapseLimit: string;
krbCaseinsUsers: string;
krbServerKeyfile: string;
lcMessages: string;
lcMonetary: string;
lcNumeric: string;
lcTime: string;
listenAddresses: string;
loCompatPrivileges: string;
localPreloadLibraries: string;
lockTimeout: string;
logAutovacuumMinDuration: string;
logCheckpoints: string;
logConnections: string;
logDestination: string;
logDirectory: string;
logDisconnections: string;
logDuration: string;
logErrorVerbosity: string;
logExecutorStats: string;
logFileMode: string;
logFilename: string;
logHostname: string;
logLinePrefix: string;
logLockWaits: string;
logMinDurationSample: string;
logMinDurationStatement: string;
logMinErrorStatement: string;
logMinMessages: string;
logParameterMaxLength: string;
logParameterMaxLengthOnError: string;
logParserStats: string;
logPlannerStats: string;
logRecoveryConflictWaits: string;
logReplicationCommands: string;
logRotationAge: string;
logRotationSize: string;
logStartupProgressInterval: string;
logStatement: string;
logStatementSampleRate: string;
logStatementStats: string;
logTempFiles: string;
logTimezone: string;
logTransactionSampleRate: string;
logTruncateOnRotation: string;
loggingCollector: string;
logicalDecodingWorkMem: string;
maintenanceIoConcurrency: string;
maintenanceWorkMem: string;
maxConnections: string;
maxFilesPerProcess: string;
maxFunctionArgs: string;
maxIdentifierLength: string;
maxIndexKeys: string;
maxLocksPerTransaction: string;
maxLogicalReplicationWorkers: string;
maxParallelApplyWorkersPerSubscription: string;
maxParallelMaintenanceWorkers: string;
maxParallelWorkers: string;
maxParallelWorkersPerGather: string;
maxPredLocksPerPage: string;
maxPredLocksPerRelation: string;
maxPredLocksPerTransaction: string;
maxPreparedTransactions: string;
maxReplicationSlots: string;
maxSlotWalKeepSize: string;
maxStackDepth: string;
maxStandbyArchiveDelay: string;
maxStandbyStreamingDelay: string;
maxSyncWorkersPerSubscription: string;
maxWalSenders: string;
maxWalSize: string;
maxWorkerProcesses: string;
minDynamicSharedMemory: string;
minParallelIndexScanSize: string;
minParallelTableScanSize: string;
minWalSize: string;
oldSnapshotThreshold: string;
parallelLeaderParticipation: string;
parallelSetupCost: string;
parallelTupleCost: string;
passwordEncryption: string;
planCacheMode: string;
port: string;
postAuthDelay: string;
preAuthDelay: string;
primaryConninfo: string;
primarySlotName: string;
quoteAllIdentifiers: string;
randomPageCost: string;
recoveryEndCommand: string;
recoveryInitSyncMethod: string;
recoveryMinApplyDelay: string;
recoveryPrefetch: string;
recoveryTarget: string;
recoveryTargetAction: string;
recoveryTargetInclusive: string;
recoveryTargetLsn: string;
recoveryTargetName: string;
recoveryTargetTime: string;
recoveryTargetTimeline: string;
recoveryTargetXid: string;
recursiveWorktableFactor: string;
removeTempFilesAfterCrash: string;
reservedConnections: string;
restartAfterCrash: string;
restoreCommand: string;
rowSecurity: string;
scramIterations: string;
searchPath: string;
segmentSize: string;
sendAbortForCrash: string;
sendAbortForKill: string;
seqPageCost: string;
serverEncoding: string;
serverVersion: string;
serverVersionNum: string;
sessionPreloadLibraries: string;
sessionReplicationRole: string;
sharedBuffers: string;
sharedMemorySize: string;
sharedMemorySizeInHugePages: string;
sharedMemoryType: string;
sharedPreloadLibraries: string;
ssl: string;
sslCaFile: string;
sslCertFile: string;
sslCiphers: string;
sslCrlDir: string;
sslCrlFile: string;
sslDhParamsFile: string;
sslEcdhCurve: string;
sslKeyFile: string;
sslLibrary: string;
sslMaxProtocolVersion: string;
sslMinProtocolVersion: string;
sslPassphraseCommand: string;
sslPassphraseCommandSupportsReload: string;
sslPreferServerCiphers: string;
standardConformingStrings: string;
statementTimeout: string;
statsFetchConsistency: string;
superuserReservedConnections: string;
synchronizeSeqscans: string;
synchronousCommit: string;
synchronousStandbyNames: string;
syslogFacility: string;
syslogIdent: string;
syslogSequenceNumbers: string;
syslogSplitMessages: string;
tcpKeepalivesCount: string;
tcpKeepalivesIdle: string;
tcpKeepalivesInterval: string;
tcpUserTimeout: string;
tempBuffers: string;
tempFileLimit: string;
tempTablespaces: string;
timeZone: string;
timezoneAbbreviations: string;
traceNotify: string;
traceRecoveryMessages: string;
traceSort: string;
trackActivities: string;
trackActivityQuerySize: string;
trackCommitTimestamp: string;
trackCounts: string;
trackFunctions: string;
trackIoTiming: string;
trackWalIoTiming: string;
transactionDeferrable: string;
transactionIsolation: string;
transactionReadOnly: string;
transformNullEquals: string;
unixSocketDirectories: string;
unixSocketGroup: string;
unixSocketPermissions: string;
updateProcessTitle: string;
vacuumBufferUsageLimit: string;
vacuumCostDelay: string;
vacuumCostLimit: string;
vacuumCostPageDirty: string;
vacuumCostPageHit: string;
vacuumCostPageMiss: string;
vacuumFailsafeAge: string;
vacuumFreezeMinAge: string;
vacuumFreezeTableAge: string;
vacuumMultixactFailsafeAge: string;
vacuumMultixactFreezeMinAge: string;
vacuumMultixactFreezeTableAge: string;
walBlockSize: string;
walBuffers: string;
walCompression: string;
walConsistencyChecking: string;
walDecodeBufferSize: string;
walInitZero: string;
walKeepSize: string;
walLevel: string;
walLogHints: string;
walReceiverCreateTempSlot: string;
walReceiverStatusInterval: string;
walReceiverTimeout: string;
walRecycle: string;
walRetrieveRetryInterval: string;
walSegmentSize: string;
walSenderTimeout: string;
walSkipThreshold: string;
walSyncMethod: string;
walWriterDelay: string;
walWriterFlushAfter: string;
workMem: string;
xmlbinary: string;
xmloption: string;
zeroDamagedPages: string;
}
export const Metadata : DatabaseMetadata = {
  get Schemas() {
      return [
{
 name: "public",
get Procedures()   {
      return [
{
 name: "st_forcepolygoncw"},
{
 name: "spheroid_in"},
{
 name: "spheroid_out"},
{
 name: "geometry_in"},
{
 name: "geometry_out"},
{
 name: "geometry_typmod_in"},
{
 name: "geometry_typmod_out"},
{
 name: "geometry_analyze"},
{
 name: "geometry_recv"},
{
 name: "geometry_send"},
{
 name: "geometry_6564"},
{
 name: "geometry_8997"},
{
 name: "point"},
{
 name: "geometry_b0d8"},
{
 name: "path"},
{
 name: "geometry_f1be"},
{
 name: "polygon"},
{
 name: "st_x"},
{
 name: "st_y"},
{
 name: "st_z"},
{
 name: "st_m"},
{
 name: "box3d_in"},
{
 name: "box3d_out"},
{
 name: "box2d_in"},
{
 name: "box2d_out"},
{
 name: "box2df_in"},
{
 name: "box2df_out"},
{
 name: "gidx_in"},
{
 name: "gidx_out"},
{
 name: "geometry_lt"},
{
 name: "geometry_le"},
{
 name: "geometry_gt"},
{
 name: "geometry_ge"},
{
 name: "geometry_eq"},
{
 name: "geometry_cmp"},
{
 name: "geometry_sortsupport"},
{
 name: "geometry_hash"},
{
 name: "geometry_gist_distance_2d"},
{
 name: "geometry_gist_consistent_2d"},
{
 name: "geometry_gist_compress_2d"},
{
 name: "geometry_gist_penalty_2d"},
{
 name: "geometry_gist_picksplit_2d"},
{
 name: "geometry_gist_union_2d"},
{
 name: "geometry_gist_same_2d"},
{
 name: "geometry_gist_decompress_2d"},
{
 name: "geometry_gist_sortsupport_2d"},
{
 name: "st_forcerhr"},
{
 name: "postgis_noop"},
{
 name: "st_forcepolygonccw"},
{
 name: "gserialized_gist_sel_2d"},
{
 name: "gserialized_gist_sel_nd"},
{
 name: "gserialized_gist_joinsel_2d"},
{
 name: "gserialized_gist_joinsel_nd"},
{
 name: "geometry_overlaps"},
{
 name: "geometry_same"},
{
 name: "geometry_distance_centroid"},
{
 name: "geometry_distance_box"},
{
 name: "geometry_contains"},
{
 name: "geometry_within"},
{
 name: "geometry_left"},
{
 name: "geometry_overleft"},
{
 name: "geometry_below"},
{
 name: "geometry_overbelow"},
{
 name: "geometry_overright"},
{
 name: "geometry_right"},
{
 name: "geometry_overabove"},
{
 name: "geometry_above"},
{
 name: "geometry_gist_consistent_nd"},
{
 name: "geometry_gist_compress_nd"},
{
 name: "geometry_gist_penalty_nd"},
{
 name: "geometry_gist_picksplit_nd"},
{
 name: "geometry_gist_union_nd"},
{
 name: "geometry_gist_same_nd"},
{
 name: "geometry_gist_decompress_nd"},
{
 name: "geometry_overlaps_nd"},
{
 name: "geometry_contains_nd"},
{
 name: "geometry_within_nd"},
{
 name: "geometry_same_nd"},
{
 name: "geometry_distance_centroid_nd"},
{
 name: "geometry_distance_cpa"},
{
 name: "geometry_gist_distance_nd"},
{
 name: "st_shiftlongitude"},
{
 name: "st_wrapx"},
{
 name: "st_xmin"},
{
 name: "st_ymin"},
{
 name: "st_zmin"},
{
 name: "st_xmax"},
{
 name: "st_ymax"},
{
 name: "st_zmax"},
{
 name: "st_expand_269a"},
{
 name: "st_expand_96e3"},
{
 name: "postgis_getbbox"},
{
 name: "st_makebox2d"},
{
 name: "st_estimatedextent_d2f5"},
{
 name: "st_estimatedextent_27e1"},
{
 name: "st_estimatedextent_2ec2"},
{
 name: "st_findextent_27e1"},
{
 name: "st_findextent_2ec2"},
{
 name: "postgis_addbbox"},
{
 name: "postgis_dropbbox"},
{
 name: "postgis_hasbbox"},
{
 name: "st_quantizecoordinates"},
{
 name: "st_memsize"},
{
 name: "st_summary_0cdb"},
{
 name: "st_npoints"},
{
 name: "st_nrings"},
{
 name: "st_3dlength"},
{
 name: "st_length2d"},
{
 name: "st_length_0cdb"},
{
 name: "st_lengthspheroid"},
{
 name: "st_length2dspheroid"},
{
 name: "st_3dperimeter"},
{
 name: "st_perimeter2d"},
{
 name: "st_perimeter_0cdb"},
{
 name: "st_area2d"},
{
 name: "st_area_0cdb"},
{
 name: "st_ispolygoncw"},
{
 name: "st_ispolygonccw"},
{
 name: "st_distancespheroid_cd56"},
{
 name: "st_distancespheroid_3651"},
{
 name: "st_distance_3651"},
{
 name: "st_pointinsidecircle"},
{
 name: "st_azimuth_3651"},
{
 name: "st_project_d5eb"},
{
 name: "st_project_6961"},
{
 name: "st_angle_e1dd"},
{
 name: "st_lineextend"},
{
 name: "st_force2d"},
{
 name: "st_force3dz"},
{
 name: "st_force3d"},
{
 name: "st_force3dm"},
{
 name: "st_force4d"},
{
 name: "st_forcecollection"},
{
 name: "st_collectionextract_6cbe"},
{
 name: "st_collectionextract_0cdb"},
{
 name: "st_collectionhomogenize"},
{
 name: "st_multi"},
{
 name: "st_forcecurve"},
{
 name: "st_forcesfs_0cdb"},
{
 name: "st_forcesfs_88bc"},
{
 name: "st_expand_2074"},
{
 name: "st_expand_704e"},
{
 name: "st_expand_7163"},
{
 name: "st_expand_5500"},
{
 name: "st_envelope"},
{
 name: "st_boundingdiagonal"},
{
 name: "st_reverse"},
{
 name: "st_scroll"},
{
 name: "postgis_geos_noop"},
{
 name: "st_normalize"},
{
 name: "st_zmflag"},
{
 name: "st_ndims"},
{
 name: "st_asewkt_0cdb"},
{
 name: "st_asewkt_6cbe"},
{
 name: "st_astwkb_652e"},
{
 name: "st_astwkb_f3fd"},
{
 name: "st_asewkb_0cdb"},
{
 name: "st_ashexewkb_0cdb"},
{
 name: "st_ashexewkb_88bc"},
{
 name: "st_asewkb_88bc"},
{
 name: "st_aslatlontext"},
{
 name: "geomfromewkb"},
{
 name: "st_geomfromewkb"},
{
 name: "st_geomfromtwkb"},
{
 name: "geomfromewkt"},
{
 name: "st_geomfromewkt"},
{
 name: "postgis_cache_bbox"},
{
 name: "st_makepoint_0aec"},
{
 name: "st_makepoint_81ec"},
{
 name: "st_makepoint_570b"},
{
 name: "st_makepointm"},
{
 name: "st_3dmakebox"},
{
 name: "st_makeline_a4b6"},
{
 name: "st_linefrommultipoint"},
{
 name: "st_makeline_3651"},
{
 name: "st_addpoint_3651"},
{
 name: "st_scale_d5eb"},
{
 name: "st_addpoint_aa17"},
{
 name: "st_removepoint"},
{
 name: "st_setpoint"},
{
 name: "st_makeenvelope"},
{
 name: "st_tileenvelope"},
{
 name: "st_makepolygon_e2e3"},
{
 name: "st_makepolygon_0cdb"},
{
 name: "st_buildarea"},
{
 name: "st_polygonize_a4b6"},
{
 name: "st_clusterintersecting_a4b6"},
{
 name: "st_clusterwithin_0e49"},
{
 name: "st_linemerge_0cdb"},
{
 name: "st_linemerge_4ba2"},
{
 name: "st_affine_e42d"},
{
 name: "st_affine_1962"},
{
 name: "st_rotate_7163"},
{
 name: "st_rotate_8b9f"},
{
 name: "st_rotate_463e"},
{
 name: "st_rotatez"},
{
 name: "st_rotatex"},
{
 name: "st_rotatey"},
{
 name: "st_translate_8b9f"},
{
 name: "st_translate_d5eb"},
{
 name: "st_scale_3651"},
{
 name: "st_scale_1bee"},
{
 name: "st_scale_8b9f"},
{
 name: "st_transscale"},
{
 name: "st_dump"},
{
 name: "st_dumprings"},
{
 name: "st_dumppoints"},
{
 name: "st_dumpsegments"},
{
 name: "populate_geometry_columns_23fc"},
{
 name: "populate_geometry_columns_4174"},
{
 name: "addgeometrycolumn_8fbb"},
{
 name: "addgeometrycolumn_4617"},
{
 name: "addgeometrycolumn_093c"},
{
 name: "dropgeometrycolumn_0412"},
{
 name: "dropgeometrycolumn_2253"},
{
 name: "dropgeometrycolumn_f11a"},
{
 name: "dropgeometrytable_2253"},
{
 name: "st_segmentize_7163"},
{
 name: "dropgeometrytable_f11a"},
{
 name: "dropgeometrytable_bfde"},
{
 name: "updategeometrysrid_b2ee"},
{
 name: "updategeometrysrid_7b58"},
{
 name: "updategeometrysrid_11c8"},
{
 name: "find_srid"},
{
 name: "get_proj4_from_srid"},
{
 name: "st_setsrid_6cbe"},
{
 name: "st_srid_0cdb"},
{
 name: "postgis_transform_geometry"},
{
 name: "postgis_srs_codes"},
{
 name: "postgis_srs"},
{
 name: "postgis_srs_all"},
{
 name: "postgis_srs_search"},
{
 name: "st_transform_6cbe"},
{
 name: "st_transform_88bc"},
{
 name: "st_transform_655c"},
{
 name: "st_transform_5016"},
{
 name: "postgis_transform_pipeline_geometry"},
{
 name: "st_transformpipeline"},
{
 name: "st_inversetransformpipeline"},
{
 name: "postgis_version"},
{
 name: "postgis_liblwgeom_version"},
{
 name: "postgis_proj_version"},
{
 name: "postgis_wagyu_version"},
{
 name: "postgis_scripts_installed"},
{
 name: "postgis_lib_version"},
{
 name: "postgis_scripts_released"},
{
 name: "postgis_geos_version"},
{
 name: "postgis_geos_compiled_version"},
{
 name: "postgis_lib_revision"},
{
 name: "postgis_svn_version"},
{
 name: "postgis_libxml_version"},
{
 name: "postgis_scripts_build_date"},
{
 name: "postgis_lib_build_date"},
{
 name: "postgis_extensions_upgrade"},
{
 name: "st_lineinterpolatepoint_7163"},
{
 name: "st_lineinterpolatepoints_8fda"},
{
 name: "st_linesubstring_d5eb"},
{
 name: "st_linelocatepoint_3651"},
{
 name: "st_addmeasure"},
{
 name: "st_closestpointofapproach"},
{
 name: "postgis_full_version"},
{
 name: "box2d_0cdb"},
{
 name: "box3d_0cdb"},
{
 name: "box_0cdb"},
{
 name: "box2d_07e9"},
{
 name: "box3d_e505"},
{
 name: "box_07e9"},
{
 name: "text"},
{
 name: "box3dtobox"},
{
 name: "geometry_e505"},
{
 name: "geometry_07e9"},
{
 name: "geometry_e728"},
{
 name: "geometry_2d19"},
{
 name: "bytea_0cdb"},
{
 name: "st_simplify_7163"},
{
 name: "st_simplify_8fda"},
{
 name: "st_simplifyvw"},
{
 name: "st_seteffectivearea"},
{
 name: "st_filterbym"},
{
 name: "st_chaikinsmoothing"},
{
 name: "st_snaptogrid_5500"},
{
 name: "st_snaptogrid_d5eb"},
{
 name: "st_snaptogrid_7163"},
{
 name: "st_snaptogrid_7f2e"},
{
 name: "st_distancecpa"},
{
 name: "st_cpawithin"},
{
 name: "st_isvalidtrajectory"},
{
 name: "st_intersection_6961"},
{
 name: "st_buffer_bf44"},
{
 name: "st_buffer_c33e"},
{
 name: "st_minimumboundingradius"},
{
 name: "st_minimumboundingcircle"},
{
 name: "st_orientedenvelope"},
{
 name: "st_offsetcurve"},
{
 name: "st_generatepoints_6cbe"},
{
 name: "st_generatepoints_d341"},
{
 name: "st_convexhull"},
{
 name: "st_simplifypreservetopology"},
{
 name: "st_isvalidreason_0cdb"},
{
 name: "st_isvaliddetail"},
{
 name: "st_isvalidreason_6cbe"},
{
 name: "st_isvalid_6cbe"},
{
 name: "st_hausdorffdistance_3651"},
{
 name: "st_hausdorffdistance_6961"},
{
 name: "st_frechetdistance"},
{
 name: "st_maximuminscribedcircle"},
{
 name: "st_largestemptycircle"},
{
 name: "st_difference"},
{
 name: "st_boundary"},
{
 name: "st_points"},
{
 name: "st_symdifference"},
{
 name: "st_symmetricdifference"},
{
 name: "st_union_3651"},
{
 name: "st_union_6961"},
{
 name: "st_unaryunion"},
{
 name: "st_removerepeatedpoints"},
{
 name: "st_clipbybox2d"},
{
 name: "st_subdivide"},
{
 name: "st_reduceprecision"},
{
 name: "st_makevalid_0cdb"},
{
 name: "st_makevalid_88bc"},
{
 name: "st_cleangeometry"},
{
 name: "st_split"},
{
 name: "st_sharedpaths"},
{
 name: "st_snap"},
{
 name: "st_relatematch"},
{
 name: "st_node"},
{
 name: "st_delaunaytriangles"},
{
 name: "st_triangulatepolygon"},
{
 name: "st_voronoipolygons"},
{
 name: "st_voronoilines"},
{
 name: "st_combinebbox_1ee2"},
{
 name: "st_combinebbox_9d67"},
{
 name: "st_combinebbox_1a7e"},
{
 name: "st_collect_3651"},
{
 name: "st_collect_a4b6"},
{
 name: "pgis_geometry_accum_transfn_43cf"},
{
 name: "pgis_geometry_accum_transfn_7c68"},
{
 name: "pgis_geometry_accum_transfn_0b93"},
{
 name: "pgis_geometry_collect_finalfn"},
{
 name: "pgis_geometry_polygonize_finalfn"},
{
 name: "pgis_geometry_clusterintersecting_finalfn"},
{
 name: "pgis_geometry_clusterwithin_finalfn"},
{
 name: "pgis_geometry_makeline_finalfn"},
{
 name: "pgis_geometry_coverageunion_finalfn"},
{
 name: "pgis_geometry_union_parallel_transfn_43cf"},
{
 name: "pgis_geometry_union_parallel_transfn_7c68"},
{
 name: "pgis_geometry_union_parallel_combinefn"},
{
 name: "pgis_geometry_union_parallel_serialfn"},
{
 name: "pgis_geometry_union_parallel_deserialfn"},
{
 name: "pgis_geometry_union_parallel_finalfn"},
{
 name: "st_union_a4b6"},
{
 name: "st_coverageunion_a4b6"},
{
 name: "st_relate_3651"},
{
 name: "st_relate_aa17"},
{
 name: "st_relate_caf9"},
{
 name: "st_disjoint"},
{
 name: "postgis_index_supportfn"},
{
 name: "st_linecrossingdirection"},
{
 name: "st_dwithin_6961"},
{
 name: "st_touches"},
{
 name: "st_intersects_3651"},
{
 name: "st_crosses"},
{
 name: "st_contains"},
{
 name: "st_containsproperly"},
{
 name: "st_within"},
{
 name: "st_covers_3651"},
{
 name: "st_coveredby_3651"},
{
 name: "st_overlaps"},
{
 name: "st_dfullywithin"},
{
 name: "st_3ddwithin"},
{
 name: "st_3ddfullywithin"},
{
 name: "st_3dintersects"},
{
 name: "st_orderingequals"},
{
 name: "st_equals"},
{
 name: "st_isvalid_0cdb"},
{
 name: "st_minimumclearance"},
{
 name: "st_minimumclearanceline"},
{
 name: "st_centroid_0cdb"},
{
 name: "st_geometricmedian"},
{
 name: "st_isring"},
{
 name: "st_pointonsurface"},
{
 name: "st_issimple"},
{
 name: "st_iscollection"},
{
 name: "equals"},
{
 name: "st_geomfromgml_27e2"},
{
 name: "st_geomfromgml_e728"},
{
 name: "st_gmltosql_e728"},
{
 name: "st_gmltosql_27e2"},
{
 name: "st_geomfromkml"},
{
 name: "st_geomfrommarc21"},
{
 name: "st_asmarc21"},
{
 name: "st_geomfromgeojson_e728"},
{
 name: "st_geomfromgeojson_608f"},
{
 name: "st_geomfromgeojson_3c9d"},
{
 name: "postgis_libjson_version"},
{
 name: "st_linefromencodedpolyline"},
{
 name: "st_asencodedpolyline"},
{
 name: "st_assvg_d341"},
{
 name: "st_asgml_d341"},
{
 name: "st_asgml_32a0"},
{
 name: "st_askml_cce7"},
{
 name: "st_asgeojson_d341"},
{
 name: "st_asgeojson_f2c6"},
{
 name: "json"},
{
 name: "jsonb"},
{
 name: "pgis_asmvt_transfn_647f"},
{
 name: "pgis_asmvt_transfn_27f4"},
{
 name: "pgis_asmvt_transfn_f57f"},
{
 name: "pgis_asmvt_transfn_92c1"},
{
 name: "pgis_asmvt_transfn_f5be"},
{
 name: "pgis_asmvt_finalfn"},
{
 name: "pgis_asmvt_combinefn"},
{
 name: "pgis_asmvt_serialfn"},
{
 name: "pgis_asmvt_deserialfn"},
{
 name: "st_asmvtgeom"},
{
 name: "postgis_libprotobuf_version"},
{
 name: "pgis_asgeobuf_transfn_647f"},
{
 name: "pgis_asgeobuf_transfn_27f4"},
{
 name: "pgis_asgeobuf_finalfn"},
{
 name: "pgis_asflatgeobuf_transfn_647f"},
{
 name: "pgis_asflatgeobuf_transfn_9633"},
{
 name: "pgis_asflatgeobuf_transfn_521f"},
{
 name: "pgis_asflatgeobuf_finalfn"},
{
 name: "st_fromflatgeobuftotable"},
{
 name: "st_fromflatgeobuf"},
{
 name: "st_geohash_6cbe"},
{
 name: "st_box2dfromgeohash"},
{
 name: "st_pointfromgeohash"},
{
 name: "st_geomfromgeohash"},
{
 name: "st_numpoints"},
{
 name: "st_numgeometries"},
{
 name: "st_geometryn"},
{
 name: "st_dimension"},
{
 name: "st_exteriorring"},
{
 name: "st_numinteriorrings"},
{
 name: "st_numinteriorring"},
{
 name: "st_interiorringn"},
{
 name: "geometrytype_0cdb"},
{
 name: "st_geometrytype"},
{
 name: "st_pointn"},
{
 name: "st_numpatches"},
{
 name: "st_patchn"},
{
 name: "st_startpoint"},
{
 name: "st_endpoint"},
{
 name: "st_isclosed"},
{
 name: "st_isempty"},
{
 name: "st_asbinary_88bc"},
{
 name: "st_asbinary_0cdb"},
{
 name: "st_astext_0cdb"},
{
 name: "st_astext_6cbe"},
{
 name: "st_geometryfromtext_e728"},
{
 name: "st_geometryfromtext_27e2"},
{
 name: "st_geomfromtext_e728"},
{
 name: "st_geomfromtext_27e2"},
{
 name: "st_wkttosql"},
{
 name: "st_pointfromtext_e728"},
{
 name: "st_pointfromtext_27e2"},
{
 name: "st_linefromtext_e728"},
{
 name: "st_linefromtext_27e2"},
{
 name: "st_polyfromtext_e728"},
{
 name: "st_polyfromtext_27e2"},
{
 name: "st_polygonfromtext_27e2"},
{
 name: "st_polygonfromtext_e728"},
{
 name: "st_mlinefromtext_27e2"},
{
 name: "st_mlinefromtext_e728"},
{
 name: "st_multilinestringfromtext_e728"},
{
 name: "st_multilinestringfromtext_27e2"},
{
 name: "st_mpointfromtext_27e2"},
{
 name: "st_mpointfromtext_e728"},
{
 name: "st_multipointfromtext"},
{
 name: "st_mpolyfromtext_27e2"},
{
 name: "st_mpolyfromtext_e728"},
{
 name: "st_multipolygonfromtext_27e2"},
{
 name: "st_multipolygonfromtext_e728"},
{
 name: "st_geomcollfromtext_27e2"},
{
 name: "st_geomcollfromtext_e728"},
{
 name: "st_geomfromwkb_2d19"},
{
 name: "st_geomfromwkb_d8af"},
{
 name: "st_pointfromwkb_d8af"},
{
 name: "st_pointfromwkb_2d19"},
{
 name: "st_linefromwkb_d8af"},
{
 name: "st_linefromwkb_2d19"},
{
 name: "st_linestringfromwkb_d8af"},
{
 name: "st_linestringfromwkb_2d19"},
{
 name: "st_polyfromwkb_d8af"},
{
 name: "st_polyfromwkb_2d19"},
{
 name: "st_polygonfromwkb_d8af"},
{
 name: "st_polygonfromwkb_2d19"},
{
 name: "st_mpointfromwkb_d8af"},
{
 name: "st_mpointfromwkb_2d19"},
{
 name: "st_multipointfromwkb_d8af"},
{
 name: "geography_analyze"},
{
 name: "st_multipointfromwkb_2d19"},
{
 name: "st_multilinefromwkb"},
{
 name: "st_mlinefromwkb_d8af"},
{
 name: "st_mlinefromwkb_2d19"},
{
 name: "st_mpolyfromwkb_d8af"},
{
 name: "st_mpolyfromwkb_2d19"},
{
 name: "st_multipolyfromwkb_d8af"},
{
 name: "st_multipolyfromwkb_2d19"},
{
 name: "st_geomcollfromwkb_d8af"},
{
 name: "st_geomcollfromwkb_2d19"},
{
 name: "st_maxdistance"},
{
 name: "st_closestpoint_3651"},
{
 name: "st_shortestline_3651"},
{
 name: "st_longestline"},
{
 name: "st_swapordinates"},
{
 name: "st_flipcoordinates"},
{
 name: "st_bdpolyfromtext"},
{
 name: "st_bdmpolyfromtext"},
{
 name: "unlockrows"},
{
 name: "geography_28e9"},
{
 name: "geography_2d19"},
{
 name: "bytea_7902"},
{
 name: "st_astext_7902"},
{
 name: "st_astext_3181"},
{
 name: "lockrow_e9aa"},
{
 name: "lockrow_02b4"},
{
 name: "lockrow_27e1"},
{
 name: "lockrow_9a8a"},
{
 name: "addauth"},
{
 name: "checkauth_27e1"},
{
 name: "checkauth_2ec2"},
{
 name: "checkauthtrigger"},
{
 name: "gettransactionid"},
{
 name: "enablelongtransactions"},
{
 name: "longtransactionsenabled"},
{
 name: "disablelongtransactions"},
{
 name: "geography_typmod_in"},
{
 name: "geography_typmod_out"},
{
 name: "geography_in"},
{
 name: "geography_out"},
{
 name: "geography_recv"},
{
 name: "geography_send"},
{
 name: "st_astext_e728"},
{
 name: "st_geographyfromtext"},
{
 name: "st_geogfromtext"},
{
 name: "st_geogfromwkb"},
{
 name: "postgis_typmod_dims"},
{
 name: "postgis_typmod_srid"},
{
 name: "postgis_typmod_type"},
{
 name: "geography_0cdb"},
{
 name: "geometry_7902"},
{
 name: "geography_gist_consistent"},
{
 name: "geography_gist_compress"},
{
 name: "geography_gist_penalty"},
{
 name: "geography_gist_picksplit"},
{
 name: "geography_gist_union"},
{
 name: "geography_gist_same"},
{
 name: "geography_gist_decompress"},
{
 name: "geography_overlaps"},
{
 name: "geography_distance_knn"},
{
 name: "geography_gist_distance"},
{
 name: "overlaps_geog_52a8"},
{
 name: "overlaps_geog_25ba"},
{
 name: "overlaps_geog_8fd3"},
{
 name: "geog_brin_inclusion_add_value"},
{
 name: "geography_lt"},
{
 name: "geography_le"},
{
 name: "geography_gt"},
{
 name: "geography_ge"},
{
 name: "geography_eq"},
{
 name: "geography_cmp"},
{
 name: "st_assvg_6ec5"},
{
 name: "st_assvg_e728"},
{
 name: "st_project_d4ec"},
{
 name: "st_azimuth_e452"},
{
 name: "st_buffer_49f7"},
{
 name: "st_asgml_e888"},
{
 name: "st_asgml_2160"},
{
 name: "st_asgml_e728"},
{
 name: "st_askml_f40a"},
{
 name: "st_askml_e728"},
{
 name: "st_asgeojson_6ec5"},
{
 name: "st_asgeojson_e728"},
{
 name: "st_distance_8dcd"},
{
 name: "st_distance_2ec2"},
{
 name: "st_area_ecae"},
{
 name: "st_area_e728"},
{
 name: "st_length_ecae"},
{
 name: "st_length_e728"},
{
 name: "st_project_ed46"},
{
 name: "st_perimeter_ecae"},
{
 name: "st_segmentize_cadf"},
{
 name: "st_asbinary_7902"},
{
 name: "st_asbinary_734d"},
{
 name: "st_asewkt_7902"},
{
 name: "st_asewkt_3181"},
{
 name: "st_asewkt_e728"},
{
 name: "geometrytype_7902"},
{
 name: "st_summary_7902"},
{
 name: "st_geohash_3181"},
{
 name: "st_srid_7902"},
{
 name: "st_setsrid_3181"},
{
 name: "st_centroid_ecae"},
{
 name: "st_centroid_e728"},
{
 name: "st_covers_e452"},
{
 name: "st_dwithin_55df"},
{
 name: "st_coveredby_e452"},
{
 name: "st_intersects_e452"},
{
 name: "st_buffer_cadf"},
{
 name: "st_buffer_12e3"},
{
 name: "st_buffer_3aaa"},
{
 name: "st_buffer_c349"},
{
 name: "st_buffer_f7c6"},
{
 name: "st_intersection_e452"},
{
 name: "st_intersection_2ec2"},
{
 name: "st_covers_2ec2"},
{
 name: "st_coveredby_2ec2"},
{
 name: "st_dwithin_efc0"},
{
 name: "st_intersects_2ec2"},
{
 name: "st_closestpoint_8dcd"},
{
 name: "st_closestpoint_2ec2"},
{
 name: "st_shortestline_8dcd"},
{
 name: "st_shortestline_2ec2"},
{
 name: "st_linesubstring_ed46"},
{
 name: "st_linesubstring_e586"},
{
 name: "st_linelocatepoint_8dcd"},
{
 name: "st_linelocatepoint_2ec2"},
{
 name: "st_lineinterpolatepoints_8796"},
{
 name: "st_lineinterpolatepoints_c349"},
{
 name: "st_lineinterpolatepoint_612b"},
{
 name: "st_lineinterpolatepoint_c349"},
{
 name: "st_distancesphere_3651"},
{
 name: "st_distancesphere_6961"},
{
 name: "postgis_type_name"},
{
 name: "postgis_constraint_srid"},
{
 name: "postgis_constraint_dims"},
{
 name: "postgis_constraint_type"},
{
 name: "st_3ddistance"},
{
 name: "st_3dmaxdistance"},
{
 name: "st_3dclosestpoint"},
{
 name: "st_3dshortestline"},
{
 name: "st_3dlongestline"},
{
 name: "st_coorddim"},
{
 name: "st_curvetoline"},
{
 name: "st_hasarc"},
{
 name: "st_linetocurve"},
{
 name: "st_point_0aec"},
{
 name: "st_point_0b7f"},
{
 name: "st_pointz"},
{
 name: "st_pointm"},
{
 name: "st_pointzm"},
{
 name: "st_polygon"},
{
 name: "st_wkbtosql"},
{
 name: "st_locatebetween"},
{
 name: "st_locatealong"},
{
 name: "st_locatebetweenelevations"},
{
 name: "st_interpolatepoint"},
{
 name: "st_hexagon"},
{
 name: "st_square"},
{
 name: "st_hexagongrid"},
{
 name: "st_squaregrid"},
{
 name: "contains_2d_3f2a"},
{
 name: "is_contained_2d_3f2a"},
{
 name: "overlaps_2d_3f2a"},
{
 name: "overlaps_2d_4f71"},
{
 name: "contains_2d_4f71"},
{
 name: "is_contained_2d_4f71"},
{
 name: "contains_2d_7d4f"},
{
 name: "is_contained_2d_7d4f"},
{
 name: "overlaps_2d_7d4f"},
{
 name: "overlaps_nd_6173"},
{
 name: "overlaps_nd_25ba"},
{
 name: "overlaps_nd_40b7"},
{
 name: "geom2d_brin_inclusion_add_value"},
{
 name: "geom3d_brin_inclusion_add_value"},
{
 name: "geom4d_brin_inclusion_add_value"},
{
 name: "st_simplifypolygonhull"},
{
 name: "st_concavehull"},
{
 name: "st_asx3d"},
{
 name: "st_angle_3651"},
{
 name: "st_3dlineinterpolatepoint"},
{
 name: "geometry_spgist_config_2d"},
{
 name: "geometry_spgist_choose_2d"},
{
 name: "geometry_spgist_picksplit_2d"},
{
 name: "geometry_spgist_inner_consistent_2d"},
{
 name: "geometry_spgist_leaf_consistent_2d"},
{
 name: "geometry_spgist_compress_2d"},
{
 name: "geometry_overlaps_3d"},
{
 name: "geometry_contains_3d"},
{
 name: "geometry_contained_3d"},
{
 name: "geometry_same_3d"},
{
 name: "geometry_spgist_config_3d"},
{
 name: "geometry_spgist_choose_3d"},
{
 name: "geometry_spgist_picksplit_3d"},
{
 name: "geometry_spgist_inner_consistent_3d"},
{
 name: "geometry_spgist_leaf_consistent_3d"},
{
 name: "geometry_spgist_compress_3d"},
{
 name: "geometry_spgist_config_nd"},
{
 name: "geometry_spgist_choose_nd"},
{
 name: "geometry_spgist_picksplit_nd"},
{
 name: "geometry_spgist_inner_consistent_nd"},
{
 name: "geometry_spgist_leaf_consistent_nd"},
{
 name: "geometry_spgist_compress_nd"},
{
 name: "geography_spgist_config_nd"},
{
 name: "geography_spgist_choose_nd"},
{
 name: "geography_spgist_picksplit_nd"},
{
 name: "geography_spgist_inner_consistent_nd"},
{
 name: "geography_spgist_leaf_consistent_nd"},
{
 name: "geography_spgist_compress_nd"},
{
 name: "st_letters"},
];
},
get Tables() {
      return [
{
 name: "spatial_ref_sys",
 get Columns() { 
    return[{name: "srid", type: "PgCatalog.Types.Int4"},
{name: "auth_name", type: "PgCatalog.Types.Varchar"},
{name: "auth_srid", type: "PgCatalog.Types.Int4"},
{name: "srtext", type: "PgCatalog.Types.Varchar"},
{name: "proj4text", type: "PgCatalog.Types.Varchar"},];
 },
 get Indexes() { 
    return[
{
 name: "spatial_ref_sys_pkey",
 get Columns() { 
    return[{name: "srid", type: "PgCatalog.Types.Int4"},];
 },
},
];
 }
},
{
 name: "nyc_census_blocks",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},
{name: "blkid", type: "PgCatalog.Types.Varchar"},
{name: "popn_total", type: "PgCatalog.Types.Float8"},
{name: "popn_white", type: "PgCatalog.Types.Float8"},
{name: "popn_black", type: "PgCatalog.Types.Float8"},
{name: "popn_nativ", type: "PgCatalog.Types.Float8"},
{name: "popn_asian", type: "PgCatalog.Types.Float8"},
{name: "popn_other", type: "PgCatalog.Types.Float8"},
{name: "boroname", type: "PgCatalog.Types.Varchar"},
{name: "geom", type: "Public.Types.Geometry"},];
 },
 get Indexes() { 
    return[
{
 name: "nyc_census_blocks_pkey",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},];
 },
},
{
 name: "nyc_census_blocks_geom_idx",
 get Columns() { 
    return[{name: "geom", type: "Public.Types.Geometry"},];
 },
},
];
 }
},
{
 name: "nyc_homicides",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},
{name: "incident_d", type: "PgCatalog.Types.Date"},
{name: "boroname", type: "PgCatalog.Types.Varchar"},
{name: "num_victim", type: "PgCatalog.Types.Varchar"},
{name: "primary_mo", type: "PgCatalog.Types.Varchar"},
{name: "id", type: "PgCatalog.Types.Float8"},
{name: "weapon", type: "PgCatalog.Types.Varchar"},
{name: "light_dark", type: "PgCatalog.Types.Varchar"},
{name: "year", type: "PgCatalog.Types.Float8"},
{name: "geom", type: "Public.Types.Geometry"},];
 },
 get Indexes() { 
    return[
{
 name: "nyc_homicides_pkey",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},];
 },
},
{
 name: "nyc_homicides_geom_idx",
 get Columns() { 
    return[{name: "geom", type: "Public.Types.Geometry"},];
 },
},
];
 }
},
{
 name: "nyc_neighborhoods",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},
{name: "boroname", type: "PgCatalog.Types.Varchar"},
{name: "name", type: "PgCatalog.Types.Varchar"},
{name: "geom", type: "Public.Types.Geometry"},];
 },
 get Indexes() { 
    return[
{
 name: "nyc_neighborhoods_pkey",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},];
 },
},
{
 name: "nyc_neighborhoods_geom_idx",
 get Columns() { 
    return[{name: "geom", type: "Public.Types.Geometry"},];
 },
},
];
 }
},
{
 name: "nyc_streets",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},
{name: "id", type: "PgCatalog.Types.Float8"},
{name: "name", type: "PgCatalog.Types.Varchar"},
{name: "oneway", type: "PgCatalog.Types.Varchar"},
{name: "type", type: "PgCatalog.Types.Varchar"},
{name: "geom", type: "Public.Types.Geometry"},];
 },
 get Indexes() { 
    return[
{
 name: "nyc_streets_pkey",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},];
 },
},
{
 name: "nyc_streets_geom_idx",
 get Columns() { 
    return[{name: "geom", type: "Public.Types.Geometry"},];
 },
},
];
 }
},
{
 name: "nyc_subway_stations",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},
{name: "objectid", type: "PgCatalog.Types.Numeric"},
{name: "id", type: "PgCatalog.Types.Numeric"},
{name: "name", type: "PgCatalog.Types.Varchar"},
{name: "alt_name", type: "PgCatalog.Types.Varchar"},
{name: "cross_st", type: "PgCatalog.Types.Varchar"},
{name: "long_name", type: "PgCatalog.Types.Varchar"},
{name: "label", type: "PgCatalog.Types.Varchar"},
{name: "borough", type: "PgCatalog.Types.Varchar"},
{name: "nghbhd", type: "PgCatalog.Types.Varchar"},
{name: "routes", type: "PgCatalog.Types.Varchar"},
{name: "transfers", type: "PgCatalog.Types.Varchar"},
{name: "color", type: "PgCatalog.Types.Varchar"},
{name: "express", type: "PgCatalog.Types.Varchar"},
{name: "closed", type: "PgCatalog.Types.Varchar"},
{name: "geom", type: "Public.Types.Geometry"},];
 },
 get Indexes() { 
    return[
{
 name: "nyc_subway_stations_pkey",
 get Columns() { 
    return[{name: "gid", type: "PgCatalog.Types.Int4"},];
 },
},
{
 name: "nyc_subway_stations_geom_idx",
 get Columns() { 
    return[{name: "geom", type: "Public.Types.Geometry"},];
 },
},
];
 }
},
];
},
},
]; 
}
};