// ⚠️ generated - do not modify ⚠️

/**
 * BEGIN - shared types generated from schema.
 *
 * These types are node/browser isomorphic and are used by all other
 * EmbraceSQL generated code.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-empty-interface */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
/* eslint-disable @typescript-eslint/no-redundant-type-constituents */
/* @typescript-eslint/no-redundant-type-constituents */
import {
  UUID,
  JsDate,
  JSONValue,
  JSONObject,
  Empty,
  Nullable,
  NullableMembers,
  undefinedIsNull,
  nullIsUndefined,
} from "@embracesql/shared";
import type { PartiallyOptional } from "@embracesql/shared";

// begin type definitions
export namespace PgCatalog {
  export namespace Types {
    export type AclitemArray = Array<PgCatalog.Types.Aclitem>;
    export type BitArray = Array<PgCatalog.Types.Bit>;
    export type BoolArray = Array<PgCatalog.Types.Bool>;
    export type BoxArray = Array<PgCatalog.Types.Box>;
    export type BpcharArray = Array<PgCatalog.Types.Bpchar>;
    export type ByteaArray = Array<PgCatalog.Types.Bytea>;
    export type CharArray = Array<PgCatalog.Types.Char>;
    export type CidArray = Array<PgCatalog.Types.Cid>;
    export type CidrArray = Array<PgCatalog.Types.Cidr>;
    export type CircleArray = Array<PgCatalog.Types.Circle>;
    export type CstringArray = Array<PgCatalog.Types.Cstring>;
    export type DateArray = Array<PgCatalog.Types.Date>;
    export type DatemultirangeArray = Array<PgCatalog.Types.Datemultirange>;
    export type DaterangeArray = Array<PgCatalog.Types.Daterange>;
    export type Float4Array = Array<PgCatalog.Types.Float4>;
    export type Float8Array = Array<PgCatalog.Types.Float8>;
    export type GtsvectorArray = Array<PgCatalog.Types.Gtsvector>;
    export type InetArray = Array<PgCatalog.Types.Inet>;
    export type Int2Array = Array<PgCatalog.Types.Int2>;
    export type Int2vectorArray = Array<PgCatalog.Types.Int2vector>;
    export type Int4Array = Array<PgCatalog.Types.Int4>;
    export type Int4multirangeArray = Array<PgCatalog.Types.Int4multirange>;
    export type Int4rangeArray = Array<PgCatalog.Types.Int4range>;
    export type Int8Array = Array<PgCatalog.Types.Int8>;
    export type Int8multirangeArray = Array<PgCatalog.Types.Int8multirange>;
    export type Int8rangeArray = Array<PgCatalog.Types.Int8range>;
    export type IntervalArray = Array<PgCatalog.Types.Interval>;
    export type JsonArray = Array<PgCatalog.Types.Json>;
    export type JsonbArray = Array<PgCatalog.Types.Jsonb>;
    export type JsonpathArray = Array<PgCatalog.Types.Jsonpath>;
    export type LineArray = Array<PgCatalog.Types.Line>;
    export type LsegArray = Array<PgCatalog.Types.Lseg>;
    export type MacaddrArray = Array<PgCatalog.Types.Macaddr>;
    export type Macaddr8Array = Array<PgCatalog.Types.Macaddr8>;
    export type MoneyArray = Array<PgCatalog.Types.Money>;
    export type NameArray = Array<PgCatalog.Types.Name>;
    export type NumericArray = Array<PgCatalog.Types.Numeric>;
    export type NummultirangeArray = Array<PgCatalog.Types.Nummultirange>;
    export type NumrangeArray = Array<PgCatalog.Types.Numrange>;
    export type OidArray = Array<PgCatalog.Types.Oid>;
    export type OidvectorArray = Array<PgCatalog.Types.Oidvector>;
    export type PathArray = Array<PgCatalog.Types.Path>;
    export type PgAggregateArray = Array<PgCatalog.Types.PgAggregate>;
    export type PgAmArray = Array<PgCatalog.Types.PgAm>;
    export type PgAmopArray = Array<PgCatalog.Types.PgAmop>;
    export type PgAmprocArray = Array<PgCatalog.Types.PgAmproc>;
    export type PgAttrdefArray = Array<PgCatalog.Types.PgAttrdef>;
    export type PgAttributeArray = Array<PgCatalog.Types.PgAttribute>;
    export type PgAuthMembersArray = Array<PgCatalog.Types.PgAuthMembers>;
    export type PgAuthidArray = Array<PgCatalog.Types.PgAuthid>;
    export type PgAvailableExtensionVersionsArray =
      Array<PgCatalog.Types.PgAvailableExtensionVersions>;
    export type PgAvailableExtensionsArray =
      Array<PgCatalog.Types.PgAvailableExtensions>;
    export type PgBackendMemoryContextsArray =
      Array<PgCatalog.Types.PgBackendMemoryContexts>;
    export type PgCastArray = Array<PgCatalog.Types.PgCast>;
    export type PgClassArray = Array<PgCatalog.Types.PgClass>;
    export type PgCollationArray = Array<PgCatalog.Types.PgCollation>;
    export type PgConfigArray = Array<PgCatalog.Types.PgConfig>;
    export type PgConstraintArray = Array<PgCatalog.Types.PgConstraint>;
    export type PgConversionArray = Array<PgCatalog.Types.PgConversion>;
    export type PgCursorsArray = Array<PgCatalog.Types.PgCursors>;
    export type PgDatabaseArray = Array<PgCatalog.Types.PgDatabase>;
    export type PgDbRoleSettingArray = Array<PgCatalog.Types.PgDbRoleSetting>;
    export type PgDefaultAclArray = Array<PgCatalog.Types.PgDefaultAcl>;
    export type PgDependArray = Array<PgCatalog.Types.PgDepend>;
    export type PgDescriptionArray = Array<PgCatalog.Types.PgDescription>;
    export type PgEnumArray = Array<PgCatalog.Types.PgEnum>;
    export type PgEventTriggerArray = Array<PgCatalog.Types.PgEventTrigger>;
    export type PgExtensionArray = Array<PgCatalog.Types.PgExtension>;
    export type PgFileSettingsArray = Array<PgCatalog.Types.PgFileSettings>;
    export type PgForeignDataWrapperArray =
      Array<PgCatalog.Types.PgForeignDataWrapper>;
    export type PgForeignServerArray = Array<PgCatalog.Types.PgForeignServer>;
    export type PgForeignTableArray = Array<PgCatalog.Types.PgForeignTable>;
    export type PgGroupArray = Array<PgCatalog.Types.PgGroup>;
    export type PgHbaFileRulesArray = Array<PgCatalog.Types.PgHbaFileRules>;
    export type PgIdentFileMappingsArray =
      Array<PgCatalog.Types.PgIdentFileMappings>;
    export type PgIndexArray = Array<PgCatalog.Types.PgIndex>;
    export type PgIndexesArray = Array<PgCatalog.Types.PgIndexes>;
    export type PgInheritsArray = Array<PgCatalog.Types.PgInherits>;
    export type PgInitPrivsArray = Array<PgCatalog.Types.PgInitPrivs>;
    export type PgLanguageArray = Array<PgCatalog.Types.PgLanguage>;
    export type PgLargeobjectArray = Array<PgCatalog.Types.PgLargeobject>;
    export type PgLargeobjectMetadataArray =
      Array<PgCatalog.Types.PgLargeobjectMetadata>;
    export type PgLocksArray = Array<PgCatalog.Types.PgLocks>;
    export type PgLsnArray = Array<PgCatalog.Types.PgLsn>;
    export type PgMatviewsArray = Array<PgCatalog.Types.PgMatviews>;
    export type PgNamespaceArray = Array<PgCatalog.Types.PgNamespace>;
    export type PgOpclassArray = Array<PgCatalog.Types.PgOpclass>;
    export type PgOperatorArray = Array<PgCatalog.Types.PgOperator>;
    export type PgOpfamilyArray = Array<PgCatalog.Types.PgOpfamily>;
    export type PgParameterAclArray = Array<PgCatalog.Types.PgParameterAcl>;
    export type PgPartitionedTableArray =
      Array<PgCatalog.Types.PgPartitionedTable>;
    export type PgPoliciesArray = Array<PgCatalog.Types.PgPolicies>;
    export type PgPolicyArray = Array<PgCatalog.Types.PgPolicy>;
    export type PgPreparedStatementsArray =
      Array<PgCatalog.Types.PgPreparedStatements>;
    export type PgPreparedXactsArray = Array<PgCatalog.Types.PgPreparedXacts>;
    export type PgProcArray = Array<PgCatalog.Types.PgProc>;
    export type PgPublicationArray = Array<PgCatalog.Types.PgPublication>;
    export type PgPublicationNamespaceArray =
      Array<PgCatalog.Types.PgPublicationNamespace>;
    export type PgPublicationRelArray = Array<PgCatalog.Types.PgPublicationRel>;
    export type PgPublicationTablesArray =
      Array<PgCatalog.Types.PgPublicationTables>;
    export type PgRangeArray = Array<PgCatalog.Types.PgRange>;
    export type PgReplicationOriginArray =
      Array<PgCatalog.Types.PgReplicationOrigin>;
    export type PgReplicationOriginStatusArray =
      Array<PgCatalog.Types.PgReplicationOriginStatus>;
    export type PgReplicationSlotsArray =
      Array<PgCatalog.Types.PgReplicationSlots>;
    export type PgRewriteArray = Array<PgCatalog.Types.PgRewrite>;
    export type PgRolesArray = Array<PgCatalog.Types.PgRoles>;
    export type PgRulesArray = Array<PgCatalog.Types.PgRules>;
    export type PgSeclabelArray = Array<PgCatalog.Types.PgSeclabel>;
    export type PgSeclabelsArray = Array<PgCatalog.Types.PgSeclabels>;
    export type PgSequenceArray = Array<PgCatalog.Types.PgSequence>;
    export type PgSequencesArray = Array<PgCatalog.Types.PgSequences>;
    export type PgSettingsArray = Array<PgCatalog.Types.PgSettings>;
    export type PgShadowArray = Array<PgCatalog.Types.PgShadow>;
    export type PgShdependArray = Array<PgCatalog.Types.PgShdepend>;
    export type PgShdescriptionArray = Array<PgCatalog.Types.PgShdescription>;
    export type PgShmemAllocationsArray =
      Array<PgCatalog.Types.PgShmemAllocations>;
    export type PgShseclabelArray = Array<PgCatalog.Types.PgShseclabel>;
    export type PgSnapshotArray = Array<PgCatalog.Types.PgSnapshot>;
    export type PgStatActivityArray = Array<PgCatalog.Types.PgStatActivity>;
    export type PgStatAllIndexesArray = Array<PgCatalog.Types.PgStatAllIndexes>;
    export type PgStatAllTablesArray = Array<PgCatalog.Types.PgStatAllTables>;
    export type PgStatArchiverArray = Array<PgCatalog.Types.PgStatArchiver>;
    export type PgStatBgwriterArray = Array<PgCatalog.Types.PgStatBgwriter>;
    export type PgStatDatabaseArray = Array<PgCatalog.Types.PgStatDatabase>;
    export type PgStatDatabaseConflictsArray =
      Array<PgCatalog.Types.PgStatDatabaseConflicts>;
    export type PgStatGssapiArray = Array<PgCatalog.Types.PgStatGssapi>;
    export type PgStatIoArray = Array<PgCatalog.Types.PgStatIo>;
    export type PgStatProgressAnalyzeArray =
      Array<PgCatalog.Types.PgStatProgressAnalyze>;
    export type PgStatProgressBasebackupArray =
      Array<PgCatalog.Types.PgStatProgressBasebackup>;
    export type PgStatProgressClusterArray =
      Array<PgCatalog.Types.PgStatProgressCluster>;
    export type PgStatProgressCopyArray =
      Array<PgCatalog.Types.PgStatProgressCopy>;
    export type PgStatProgressCreateIndexArray =
      Array<PgCatalog.Types.PgStatProgressCreateIndex>;
    export type PgStatProgressVacuumArray =
      Array<PgCatalog.Types.PgStatProgressVacuum>;
    export type PgStatRecoveryPrefetchArray =
      Array<PgCatalog.Types.PgStatRecoveryPrefetch>;
    export type PgStatReplicationArray =
      Array<PgCatalog.Types.PgStatReplication>;
    export type PgStatReplicationSlotsArray =
      Array<PgCatalog.Types.PgStatReplicationSlots>;
    export type PgStatSlruArray = Array<PgCatalog.Types.PgStatSlru>;
    export type PgStatSslArray = Array<PgCatalog.Types.PgStatSsl>;
    export type PgStatSubscriptionArray =
      Array<PgCatalog.Types.PgStatSubscription>;
    export type PgStatSubscriptionStatsArray =
      Array<PgCatalog.Types.PgStatSubscriptionStats>;
    export type PgStatSysIndexesArray = Array<PgCatalog.Types.PgStatSysIndexes>;
    export type PgStatSysTablesArray = Array<PgCatalog.Types.PgStatSysTables>;
    export type PgStatUserFunctionsArray =
      Array<PgCatalog.Types.PgStatUserFunctions>;
    export type PgStatUserIndexesArray =
      Array<PgCatalog.Types.PgStatUserIndexes>;
    export type PgStatUserTablesArray = Array<PgCatalog.Types.PgStatUserTables>;
    export type PgStatWalArray = Array<PgCatalog.Types.PgStatWal>;
    export type PgStatWalReceiverArray =
      Array<PgCatalog.Types.PgStatWalReceiver>;
    export type PgStatXactAllTablesArray =
      Array<PgCatalog.Types.PgStatXactAllTables>;
    export type PgStatXactSysTablesArray =
      Array<PgCatalog.Types.PgStatXactSysTables>;
    export type PgStatXactUserFunctionsArray =
      Array<PgCatalog.Types.PgStatXactUserFunctions>;
    export type PgStatXactUserTablesArray =
      Array<PgCatalog.Types.PgStatXactUserTables>;
    export type PgStatioAllIndexesArray =
      Array<PgCatalog.Types.PgStatioAllIndexes>;
    export type PgStatioAllSequencesArray =
      Array<PgCatalog.Types.PgStatioAllSequences>;
    export type PgStatioAllTablesArray =
      Array<PgCatalog.Types.PgStatioAllTables>;
    export type PgStatioSysIndexesArray =
      Array<PgCatalog.Types.PgStatioSysIndexes>;
    export type PgStatioSysSequencesArray =
      Array<PgCatalog.Types.PgStatioSysSequences>;
    export type PgStatioSysTablesArray =
      Array<PgCatalog.Types.PgStatioSysTables>;
    export type PgStatioUserIndexesArray =
      Array<PgCatalog.Types.PgStatioUserIndexes>;
    export type PgStatioUserSequencesArray =
      Array<PgCatalog.Types.PgStatioUserSequences>;
    export type PgStatioUserTablesArray =
      Array<PgCatalog.Types.PgStatioUserTables>;
    export type PgStatisticArray = Array<PgCatalog.Types.PgStatistic>;
    export type PgStatisticExtArray = Array<PgCatalog.Types.PgStatisticExt>;
    export type PgStatisticExtDataArray =
      Array<PgCatalog.Types.PgStatisticExtData>;
    export type PgStatsArray = Array<PgCatalog.Types.PgStats>;
    export type PgStatsExtArray = Array<PgCatalog.Types.PgStatsExt>;
    export type PgStatsExtExprsArray = Array<PgCatalog.Types.PgStatsExtExprs>;
    export type PgSubscriptionArray = Array<PgCatalog.Types.PgSubscription>;
    export type PgSubscriptionRelArray =
      Array<PgCatalog.Types.PgSubscriptionRel>;
    export type PgTablesArray = Array<PgCatalog.Types.PgTables>;
    export type PgTablespaceArray = Array<PgCatalog.Types.PgTablespace>;
    export type PgTimezoneAbbrevsArray =
      Array<PgCatalog.Types.PgTimezoneAbbrevs>;
    export type PgTimezoneNamesArray = Array<PgCatalog.Types.PgTimezoneNames>;
    export type PgTransformArray = Array<PgCatalog.Types.PgTransform>;
    export type PgTriggerArray = Array<PgCatalog.Types.PgTrigger>;
    export type PgTsConfigArray = Array<PgCatalog.Types.PgTsConfig>;
    export type PgTsConfigMapArray = Array<PgCatalog.Types.PgTsConfigMap>;
    export type PgTsDictArray = Array<PgCatalog.Types.PgTsDict>;
    export type PgTsParserArray = Array<PgCatalog.Types.PgTsParser>;
    export type PgTsTemplateArray = Array<PgCatalog.Types.PgTsTemplate>;
    export type PgTypeArray = Array<PgCatalog.Types.PgType>;
    export type PgUserArray = Array<PgCatalog.Types.PgUser>;
    export type PgUserMappingArray = Array<PgCatalog.Types.PgUserMapping>;
    export type PgUserMappingsArray = Array<PgCatalog.Types.PgUserMappings>;
    export type PgViewsArray = Array<PgCatalog.Types.PgViews>;
    export type PointArray = Array<PgCatalog.Types.Point>;
    export type PolygonArray = Array<PgCatalog.Types.Polygon>;
    export type RecordArray = Array<PgCatalog.Types.Record>;
    export type RefcursorArray = Array<PgCatalog.Types.Refcursor>;
    export type RegclassArray = Array<PgCatalog.Types.Regclass>;
    export type RegcollationArray = Array<PgCatalog.Types.Regcollation>;
    export type RegconfigArray = Array<PgCatalog.Types.Regconfig>;
    export type RegdictionaryArray = Array<PgCatalog.Types.Regdictionary>;
    export type RegnamespaceArray = Array<PgCatalog.Types.Regnamespace>;
    export type RegoperArray = Array<PgCatalog.Types.Regoper>;
    export type RegoperatorArray = Array<PgCatalog.Types.Regoperator>;
    export type RegprocArray = Array<PgCatalog.Types.Regproc>;
    export type RegprocedureArray = Array<PgCatalog.Types.Regprocedure>;
    export type RegroleArray = Array<PgCatalog.Types.Regrole>;
    export type RegtypeArray = Array<PgCatalog.Types.Regtype>;
    export type TextArray = Array<PgCatalog.Types.Text>;
    export type TidArray = Array<PgCatalog.Types.Tid>;
    export type TimeArray = Array<PgCatalog.Types.Time>;
    export type TimestampArray = Array<PgCatalog.Types.Timestamp>;
    export type TimestamptzArray = Array<PgCatalog.Types.Timestamptz>;
    export type TimetzArray = Array<PgCatalog.Types.Timetz>;
    export type TsmultirangeArray = Array<PgCatalog.Types.Tsmultirange>;
    export type TsqueryArray = Array<PgCatalog.Types.Tsquery>;
    export type TsrangeArray = Array<PgCatalog.Types.Tsrange>;
    export type TstzmultirangeArray = Array<PgCatalog.Types.Tstzmultirange>;
    export type TstzrangeArray = Array<PgCatalog.Types.Tstzrange>;
    export type TsvectorArray = Array<PgCatalog.Types.Tsvector>;
    export type TxidSnapshotArray = Array<PgCatalog.Types.TxidSnapshot>;
    export type UuidArray = Array<PgCatalog.Types.Uuid>;
    export type VarbitArray = Array<PgCatalog.Types.Varbit>;
    export type VarcharArray = Array<PgCatalog.Types.Varchar>;
    export type XidArray = Array<PgCatalog.Types.Xid>;
    export type Xid8Array = Array<PgCatalog.Types.Xid8>;
    export type XmlArray = Array<PgCatalog.Types.Xml>;
    export type Aclitem = string;
    export type Any = unknown;
    export type Anyarray = unknown;
    export type Anycompatible = unknown;
    export type Anycompatiblearray = unknown;
    export type Anycompatiblemultirange = unknown;
    export type Anycompatiblenonarray = unknown;
    export type Anycompatiblerange = unknown;
    export type Anyelement = unknown;
    export type Anyenum = unknown;
    export type Anymultirange = unknown;
    export type Anynonarray = unknown;
    export type Anyrange = unknown;
    export type Bit = boolean;
    export type Bool = boolean;
    export type Box = {
      upperRight: Point;
      lowerLeft: Point;
    };
    export type Bpchar = string;
    export type Bytea = Uint8Array;
    export type Char = string;
    export type Cid = string;
    export type Cidr = Uint8Array;
    export type Circle = {
      center: Point;
      radius: number;
    };
    export type Cstring = unknown;
    export type Date = JsDate;
    export type Datemultirange = unknown;
    export type Daterange = [PgCatalog.Types.Date, PgCatalog.Types.Date];
    export type EventTrigger = unknown;
    export type FdwHandler = unknown;
    export type Float4 = number;
    export type Float8 = number;
    export type Gtsvector = Array<string>;
    export type IndexAmHandler = unknown;
    export type Inet = string;
    export type Int2 = number;
    export type Int2vector = Uint16Array;
    export type Int4 = number;
    export type Int4multirange = unknown;
    export type Int4range = [PgCatalog.Types.Int4, PgCatalog.Types.Int4];
    export type Int8 = number;
    export type Int8multirange = unknown;
    export type Int8range = [PgCatalog.Types.Int8, PgCatalog.Types.Int8];
    export type Internal = unknown;
    export type Interval = number;
    export type Json = JSONObject;
    export type Jsonb = JSONObject;
    export type Jsonpath = string;
    export type LanguageHandler = unknown;
    export type Line = {
      a: number;
      b: number;
      c: number;
    };
    export type Lseg = {
      from: Point;
      to: Point;
    };
    export type Macaddr = Uint8Array;
    export type Macaddr8 = Uint8Array;
    export type Money = number;
    export type Name = string;
    export type Numeric = number;
    export type Nummultirange = unknown;
    export type Numrange = [PgCatalog.Types.Numeric, PgCatalog.Types.Numeric];
    export type Oid = number;
    export type Oidvector = Array<PgCatalog.Types.Oid>;
    export type Path = Array<Point>;
    export type PgAggregate = {
      aggfnoid: PgCatalog.Types.Regproc;
      aggkind: PgCatalog.Types.Char;
      aggnumdirectargs: PgCatalog.Types.Int2;
      aggtransfn: PgCatalog.Types.Regproc;
      aggfinalfn: PgCatalog.Types.Regproc;
      aggcombinefn: PgCatalog.Types.Regproc;
      aggserialfn: PgCatalog.Types.Regproc;
      aggdeserialfn: PgCatalog.Types.Regproc;
      aggmtransfn: PgCatalog.Types.Regproc;
      aggminvtransfn: PgCatalog.Types.Regproc;
      aggmfinalfn: PgCatalog.Types.Regproc;
      aggfinalextra: PgCatalog.Types.Bool;
      aggmfinalextra: PgCatalog.Types.Bool;
      aggfinalmodify: PgCatalog.Types.Char;
      aggmfinalmodify: PgCatalog.Types.Char;
      aggsortop: PgCatalog.Types.Oid;
      aggtranstype: PgCatalog.Types.Oid;
      aggtransspace: PgCatalog.Types.Int4;
      aggmtranstype: PgCatalog.Types.Oid;
      aggmtransspace: PgCatalog.Types.Int4;
      agginitval: Nullable<PgCatalog.Types.Text>;
      aggminitval: Nullable<PgCatalog.Types.Text>;
    };
    export type PgAm = {
      oid: PgCatalog.Types.Oid;
      amname: PgCatalog.Types.Name;
      amhandler: PgCatalog.Types.Regproc;
      amtype: PgCatalog.Types.Char;
    };
    export type PgAmop = {
      oid: PgCatalog.Types.Oid;
      amopfamily: PgCatalog.Types.Oid;
      amoplefttype: PgCatalog.Types.Oid;
      amoprighttype: PgCatalog.Types.Oid;
      amopstrategy: PgCatalog.Types.Int2;
      amoppurpose: PgCatalog.Types.Char;
      amopopr: PgCatalog.Types.Oid;
      amopmethod: PgCatalog.Types.Oid;
      amopsortfamily: PgCatalog.Types.Oid;
    };
    export type PgAmproc = {
      oid: PgCatalog.Types.Oid;
      amprocfamily: PgCatalog.Types.Oid;
      amproclefttype: PgCatalog.Types.Oid;
      amprocrighttype: PgCatalog.Types.Oid;
      amprocnum: PgCatalog.Types.Int2;
      amproc: PgCatalog.Types.Regproc;
    };
    export type PgAttrdef = {
      oid: PgCatalog.Types.Oid;
      adrelid: PgCatalog.Types.Oid;
      adnum: PgCatalog.Types.Int2;
      adbin: PgCatalog.Types.PgNodeTree;
    };
    export type PgAttribute = {
      attrelid: PgCatalog.Types.Oid;
      attname: PgCatalog.Types.Name;
      atttypid: PgCatalog.Types.Oid;
      attlen: PgCatalog.Types.Int2;
      attnum: PgCatalog.Types.Int2;
      attcacheoff: PgCatalog.Types.Int4;
      atttypmod: PgCatalog.Types.Int4;
      attndims: PgCatalog.Types.Int2;
      attbyval: PgCatalog.Types.Bool;
      attalign: PgCatalog.Types.Char;
      attstorage: PgCatalog.Types.Char;
      attcompression: PgCatalog.Types.Char;
      attnotnull: PgCatalog.Types.Bool;
      atthasdef: PgCatalog.Types.Bool;
      atthasmissing: PgCatalog.Types.Bool;
      attidentity: PgCatalog.Types.Char;
      attgenerated: PgCatalog.Types.Char;
      attisdropped: PgCatalog.Types.Bool;
      attislocal: PgCatalog.Types.Bool;
      attinhcount: PgCatalog.Types.Int2;
      attstattarget: PgCatalog.Types.Int2;
      attcollation: PgCatalog.Types.Oid;
      attacl: PgCatalog.Types.AclitemArray;
      attoptions: PgCatalog.Types.TextArray;
      attfdwoptions: PgCatalog.Types.TextArray;
      attmissingval: Nullable<PgCatalog.Types.Anyarray>;
    };
    export type PgAuthMembers = {
      oid: PgCatalog.Types.Oid;
      roleid: PgCatalog.Types.Oid;
      member: PgCatalog.Types.Oid;
      grantor: PgCatalog.Types.Oid;
      adminOption: PgCatalog.Types.Bool;
      inheritOption: PgCatalog.Types.Bool;
      setOption: PgCatalog.Types.Bool;
    };
    export type PgAuthid = {
      oid: PgCatalog.Types.Oid;
      rolname: PgCatalog.Types.Name;
      rolsuper: PgCatalog.Types.Bool;
      rolinherit: PgCatalog.Types.Bool;
      rolcreaterole: PgCatalog.Types.Bool;
      rolcreatedb: PgCatalog.Types.Bool;
      rolcanlogin: PgCatalog.Types.Bool;
      rolreplication: PgCatalog.Types.Bool;
      rolbypassrls: PgCatalog.Types.Bool;
      rolconnlimit: PgCatalog.Types.Int4;
      rolpassword: Nullable<PgCatalog.Types.Text>;
      rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgAvailableExtensionVersions = {
      name: Nullable<PgCatalog.Types.Name>;
      version: Nullable<PgCatalog.Types.Text>;
      installed: Nullable<PgCatalog.Types.Bool>;
      superuser: Nullable<PgCatalog.Types.Bool>;
      trusted: Nullable<PgCatalog.Types.Bool>;
      relocatable: Nullable<PgCatalog.Types.Bool>;
      schema: Nullable<PgCatalog.Types.Name>;
      requires: PgCatalog.Types.NameArray;
      comment: Nullable<PgCatalog.Types.Text>;
    };
    export type PgAvailableExtensions = {
      name: Nullable<PgCatalog.Types.Name>;
      defaultVersion: Nullable<PgCatalog.Types.Text>;
      installedVersion: Nullable<PgCatalog.Types.Text>;
      comment: Nullable<PgCatalog.Types.Text>;
    };
    export type PgBackendMemoryContexts = {
      name: Nullable<PgCatalog.Types.Text>;
      ident: Nullable<PgCatalog.Types.Text>;
      parent: Nullable<PgCatalog.Types.Text>;
      level: Nullable<PgCatalog.Types.Int4>;
      totalBytes: Nullable<PgCatalog.Types.Int8>;
      totalNblocks: Nullable<PgCatalog.Types.Int8>;
      freeBytes: Nullable<PgCatalog.Types.Int8>;
      freeChunks: Nullable<PgCatalog.Types.Int8>;
      usedBytes: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgBrinBloomSummary = string;
    export type PgBrinMinmaxMultiSummary = string;
    export type PgCast = {
      oid: PgCatalog.Types.Oid;
      castsource: PgCatalog.Types.Oid;
      casttarget: PgCatalog.Types.Oid;
      castfunc: PgCatalog.Types.Oid;
      castcontext: PgCatalog.Types.Char;
      castmethod: PgCatalog.Types.Char;
    };
    export type PgClass = {
      oid: PgCatalog.Types.Oid;
      relname: PgCatalog.Types.Name;
      relnamespace: PgCatalog.Types.Oid;
      reltype: PgCatalog.Types.Oid;
      reloftype: PgCatalog.Types.Oid;
      relowner: PgCatalog.Types.Oid;
      relam: PgCatalog.Types.Oid;
      relfilenode: PgCatalog.Types.Oid;
      reltablespace: PgCatalog.Types.Oid;
      relpages: PgCatalog.Types.Int4;
      reltuples: PgCatalog.Types.Float4;
      relallvisible: PgCatalog.Types.Int4;
      reltoastrelid: PgCatalog.Types.Oid;
      relhasindex: PgCatalog.Types.Bool;
      relisshared: PgCatalog.Types.Bool;
      relpersistence: PgCatalog.Types.Char;
      relkind: PgCatalog.Types.Char;
      relnatts: PgCatalog.Types.Int2;
      relchecks: PgCatalog.Types.Int2;
      relhasrules: PgCatalog.Types.Bool;
      relhastriggers: PgCatalog.Types.Bool;
      relhassubclass: PgCatalog.Types.Bool;
      relrowsecurity: PgCatalog.Types.Bool;
      relforcerowsecurity: PgCatalog.Types.Bool;
      relispopulated: PgCatalog.Types.Bool;
      relreplident: PgCatalog.Types.Char;
      relispartition: PgCatalog.Types.Bool;
      relrewrite: PgCatalog.Types.Oid;
      relfrozenxid: PgCatalog.Types.Xid;
      relminmxid: PgCatalog.Types.Xid;
      relacl: PgCatalog.Types.AclitemArray;
      reloptions: PgCatalog.Types.TextArray;
      relpartbound: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgCollation = {
      oid: PgCatalog.Types.Oid;
      collname: PgCatalog.Types.Name;
      collnamespace: PgCatalog.Types.Oid;
      collowner: PgCatalog.Types.Oid;
      collprovider: PgCatalog.Types.Char;
      collisdeterministic: PgCatalog.Types.Bool;
      collencoding: PgCatalog.Types.Int4;
      collcollate: Nullable<PgCatalog.Types.Text>;
      collctype: Nullable<PgCatalog.Types.Text>;
      colliculocale: Nullable<PgCatalog.Types.Text>;
      collicurules: Nullable<PgCatalog.Types.Text>;
      collversion: Nullable<PgCatalog.Types.Text>;
    };
    export type PgConfig = {
      name: Nullable<PgCatalog.Types.Text>;
      setting: Nullable<PgCatalog.Types.Text>;
    };
    export type PgConstraint = {
      oid: PgCatalog.Types.Oid;
      conname: PgCatalog.Types.Name;
      connamespace: PgCatalog.Types.Oid;
      contype: PgCatalog.Types.Char;
      condeferrable: PgCatalog.Types.Bool;
      condeferred: PgCatalog.Types.Bool;
      convalidated: PgCatalog.Types.Bool;
      conrelid: PgCatalog.Types.Oid;
      contypid: PgCatalog.Types.Oid;
      conindid: PgCatalog.Types.Oid;
      conparentid: PgCatalog.Types.Oid;
      confrelid: PgCatalog.Types.Oid;
      confupdtype: PgCatalog.Types.Char;
      confdeltype: PgCatalog.Types.Char;
      confmatchtype: PgCatalog.Types.Char;
      conislocal: PgCatalog.Types.Bool;
      coninhcount: PgCatalog.Types.Int2;
      connoinherit: PgCatalog.Types.Bool;
      conkey: PgCatalog.Types.Int2Array;
      confkey: PgCatalog.Types.Int2Array;
      conpfeqop: PgCatalog.Types.OidArray;
      conppeqop: PgCatalog.Types.OidArray;
      conffeqop: PgCatalog.Types.OidArray;
      confdelsetcols: PgCatalog.Types.Int2Array;
      conexclop: PgCatalog.Types.OidArray;
      conbin: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgConversion = {
      oid: PgCatalog.Types.Oid;
      conname: PgCatalog.Types.Name;
      connamespace: PgCatalog.Types.Oid;
      conowner: PgCatalog.Types.Oid;
      conforencoding: PgCatalog.Types.Int4;
      contoencoding: PgCatalog.Types.Int4;
      conproc: PgCatalog.Types.Regproc;
      condefault: PgCatalog.Types.Bool;
    };
    export type PgCursors = {
      name: Nullable<PgCatalog.Types.Text>;
      statement: Nullable<PgCatalog.Types.Text>;
      isHoldable: Nullable<PgCatalog.Types.Bool>;
      isBinary: Nullable<PgCatalog.Types.Bool>;
      isScrollable: Nullable<PgCatalog.Types.Bool>;
      creationTime: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgDatabase = {
      oid: PgCatalog.Types.Oid;
      datname: PgCatalog.Types.Name;
      datdba: PgCatalog.Types.Oid;
      encoding: PgCatalog.Types.Int4;
      datlocprovider: PgCatalog.Types.Char;
      datistemplate: PgCatalog.Types.Bool;
      datallowconn: PgCatalog.Types.Bool;
      datconnlimit: PgCatalog.Types.Int4;
      datfrozenxid: PgCatalog.Types.Xid;
      datminmxid: PgCatalog.Types.Xid;
      dattablespace: PgCatalog.Types.Oid;
      datcollate: PgCatalog.Types.Text;
      datctype: PgCatalog.Types.Text;
      daticulocale: Nullable<PgCatalog.Types.Text>;
      daticurules: Nullable<PgCatalog.Types.Text>;
      datcollversion: Nullable<PgCatalog.Types.Text>;
      datacl: PgCatalog.Types.AclitemArray;
    };
    export type PgDbRoleSetting = {
      setdatabase: PgCatalog.Types.Oid;
      setrole: PgCatalog.Types.Oid;
      setconfig: PgCatalog.Types.TextArray;
    };
    export type PgDdlCommand = unknown;
    export type PgDefaultAcl = {
      oid: PgCatalog.Types.Oid;
      defaclrole: PgCatalog.Types.Oid;
      defaclnamespace: PgCatalog.Types.Oid;
      defaclobjtype: PgCatalog.Types.Char;
      defaclacl: PgCatalog.Types.AclitemArray;
    };
    export type PgDepend = {
      classid: PgCatalog.Types.Oid;
      objid: PgCatalog.Types.Oid;
      objsubid: PgCatalog.Types.Int4;
      refclassid: PgCatalog.Types.Oid;
      refobjid: PgCatalog.Types.Oid;
      refobjsubid: PgCatalog.Types.Int4;
      deptype: PgCatalog.Types.Char;
    };
    export type PgDependencies = string;
    export type PgDescription = {
      objoid: PgCatalog.Types.Oid;
      classoid: PgCatalog.Types.Oid;
      objsubid: PgCatalog.Types.Int4;
      description: PgCatalog.Types.Text;
    };
    export type PgEnum = {
      oid: PgCatalog.Types.Oid;
      enumtypid: PgCatalog.Types.Oid;
      enumsortorder: PgCatalog.Types.Float4;
      enumlabel: PgCatalog.Types.Name;
    };
    export type PgEventTrigger = {
      oid: PgCatalog.Types.Oid;
      evtname: PgCatalog.Types.Name;
      evtevent: PgCatalog.Types.Name;
      evtowner: PgCatalog.Types.Oid;
      evtfoid: PgCatalog.Types.Oid;
      evtenabled: PgCatalog.Types.Char;
      evttags: PgCatalog.Types.TextArray;
    };
    export type PgExtension = {
      oid: PgCatalog.Types.Oid;
      extname: PgCatalog.Types.Name;
      extowner: PgCatalog.Types.Oid;
      extnamespace: PgCatalog.Types.Oid;
      extrelocatable: PgCatalog.Types.Bool;
      extversion: PgCatalog.Types.Text;
      extconfig: PgCatalog.Types.OidArray;
      extcondition: PgCatalog.Types.TextArray;
    };
    export type PgFileSettings = {
      sourcefile: Nullable<PgCatalog.Types.Text>;
      sourceline: Nullable<PgCatalog.Types.Int4>;
      seqno: Nullable<PgCatalog.Types.Int4>;
      name: Nullable<PgCatalog.Types.Text>;
      setting: Nullable<PgCatalog.Types.Text>;
      applied: Nullable<PgCatalog.Types.Bool>;
      error: Nullable<PgCatalog.Types.Text>;
    };
    export type PgForeignDataWrapper = {
      oid: PgCatalog.Types.Oid;
      fdwname: PgCatalog.Types.Name;
      fdwowner: PgCatalog.Types.Oid;
      fdwhandler: PgCatalog.Types.Oid;
      fdwvalidator: PgCatalog.Types.Oid;
      fdwacl: PgCatalog.Types.AclitemArray;
      fdwoptions: PgCatalog.Types.TextArray;
    };
    export type PgForeignServer = {
      oid: PgCatalog.Types.Oid;
      srvname: PgCatalog.Types.Name;
      srvowner: PgCatalog.Types.Oid;
      srvfdw: PgCatalog.Types.Oid;
      srvtype: Nullable<PgCatalog.Types.Text>;
      srvversion: Nullable<PgCatalog.Types.Text>;
      srvacl: PgCatalog.Types.AclitemArray;
      srvoptions: PgCatalog.Types.TextArray;
    };
    export type PgForeignTable = {
      ftrelid: PgCatalog.Types.Oid;
      ftserver: PgCatalog.Types.Oid;
      ftoptions: PgCatalog.Types.TextArray;
    };
    export type PgGroup = {
      groname: Nullable<PgCatalog.Types.Name>;
      grosysid: Nullable<PgCatalog.Types.Oid>;
      grolist: PgCatalog.Types.OidArray;
    };
    export type PgHbaFileRules = {
      ruleNumber: Nullable<PgCatalog.Types.Int4>;
      fileName: Nullable<PgCatalog.Types.Text>;
      lineNumber: Nullable<PgCatalog.Types.Int4>;
      type: Nullable<PgCatalog.Types.Text>;
      database: PgCatalog.Types.TextArray;
      userName: PgCatalog.Types.TextArray;
      address: Nullable<PgCatalog.Types.Text>;
      netmask: Nullable<PgCatalog.Types.Text>;
      authMethod: Nullable<PgCatalog.Types.Text>;
      options: PgCatalog.Types.TextArray;
      error: Nullable<PgCatalog.Types.Text>;
    };
    export type PgIdentFileMappings = {
      mapNumber: Nullable<PgCatalog.Types.Int4>;
      fileName: Nullable<PgCatalog.Types.Text>;
      lineNumber: Nullable<PgCatalog.Types.Int4>;
      mapName: Nullable<PgCatalog.Types.Text>;
      sysName: Nullable<PgCatalog.Types.Text>;
      pgUsername: Nullable<PgCatalog.Types.Text>;
      error: Nullable<PgCatalog.Types.Text>;
    };
    export type PgIndex = {
      indexrelid: PgCatalog.Types.Oid;
      indrelid: PgCatalog.Types.Oid;
      indnatts: PgCatalog.Types.Int2;
      indnkeyatts: PgCatalog.Types.Int2;
      indisunique: PgCatalog.Types.Bool;
      indnullsnotdistinct: PgCatalog.Types.Bool;
      indisprimary: PgCatalog.Types.Bool;
      indisexclusion: PgCatalog.Types.Bool;
      indimmediate: PgCatalog.Types.Bool;
      indisclustered: PgCatalog.Types.Bool;
      indisvalid: PgCatalog.Types.Bool;
      indcheckxmin: PgCatalog.Types.Bool;
      indisready: PgCatalog.Types.Bool;
      indislive: PgCatalog.Types.Bool;
      indisreplident: PgCatalog.Types.Bool;
      indkey: PgCatalog.Types.Int2vector;
      indcollation: PgCatalog.Types.Oidvector;
      indclass: PgCatalog.Types.Oidvector;
      indoption: PgCatalog.Types.Int2vector;
      indexprs: Nullable<PgCatalog.Types.PgNodeTree>;
      indpred: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgIndexes = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      indexname: Nullable<PgCatalog.Types.Name>;
      tablespace: Nullable<PgCatalog.Types.Name>;
      indexdef: Nullable<PgCatalog.Types.Text>;
    };
    export type PgInherits = {
      inhrelid: PgCatalog.Types.Oid;
      inhparent: PgCatalog.Types.Oid;
      inhseqno: PgCatalog.Types.Int4;
      inhdetachpending: PgCatalog.Types.Bool;
    };
    export type PgInitPrivs = {
      objoid: PgCatalog.Types.Oid;
      classoid: PgCatalog.Types.Oid;
      objsubid: PgCatalog.Types.Int4;
      privtype: PgCatalog.Types.Char;
      initprivs: PgCatalog.Types.AclitemArray;
    };
    export type PgLanguage = {
      oid: PgCatalog.Types.Oid;
      lanname: PgCatalog.Types.Name;
      lanowner: PgCatalog.Types.Oid;
      lanispl: PgCatalog.Types.Bool;
      lanpltrusted: PgCatalog.Types.Bool;
      lanplcallfoid: PgCatalog.Types.Oid;
      laninline: PgCatalog.Types.Oid;
      lanvalidator: PgCatalog.Types.Oid;
      lanacl: PgCatalog.Types.AclitemArray;
    };
    export type PgLargeobject = {
      loid: PgCatalog.Types.Oid;
      pageno: PgCatalog.Types.Int4;
      data: PgCatalog.Types.Bytea;
    };
    export type PgLargeobjectMetadata = {
      oid: PgCatalog.Types.Oid;
      lomowner: PgCatalog.Types.Oid;
      lomacl: PgCatalog.Types.AclitemArray;
    };
    export type PgLocks = {
      locktype: Nullable<PgCatalog.Types.Text>;
      database: Nullable<PgCatalog.Types.Oid>;
      relation: Nullable<PgCatalog.Types.Oid>;
      page: Nullable<PgCatalog.Types.Int4>;
      tuple: Nullable<PgCatalog.Types.Int2>;
      virtualxid: Nullable<PgCatalog.Types.Text>;
      transactionid: Nullable<PgCatalog.Types.Xid>;
      classid: Nullable<PgCatalog.Types.Oid>;
      objid: Nullable<PgCatalog.Types.Oid>;
      objsubid: Nullable<PgCatalog.Types.Int2>;
      virtualtransaction: Nullable<PgCatalog.Types.Text>;
      pid: Nullable<PgCatalog.Types.Int4>;
      mode: Nullable<PgCatalog.Types.Text>;
      granted: Nullable<PgCatalog.Types.Bool>;
      fastpath: Nullable<PgCatalog.Types.Bool>;
      waitstart: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgLsn = bigint;
    export type PgMatviews = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      matviewname: Nullable<PgCatalog.Types.Name>;
      matviewowner: Nullable<PgCatalog.Types.Name>;
      tablespace: Nullable<PgCatalog.Types.Name>;
      hasindexes: Nullable<PgCatalog.Types.Bool>;
      ispopulated: Nullable<PgCatalog.Types.Bool>;
      definition: Nullable<PgCatalog.Types.Text>;
    };
    export type PgMcvList = string;
    export type PgNamespace = {
      oid: PgCatalog.Types.Oid;
      nspname: PgCatalog.Types.Name;
      nspowner: PgCatalog.Types.Oid;
      nspacl: PgCatalog.Types.AclitemArray;
    };
    export type PgNdistinct = string;
    export type PgNodeTree = string;
    export type PgOpclass = {
      oid: PgCatalog.Types.Oid;
      opcmethod: PgCatalog.Types.Oid;
      opcname: PgCatalog.Types.Name;
      opcnamespace: PgCatalog.Types.Oid;
      opcowner: PgCatalog.Types.Oid;
      opcfamily: PgCatalog.Types.Oid;
      opcintype: PgCatalog.Types.Oid;
      opcdefault: PgCatalog.Types.Bool;
      opckeytype: PgCatalog.Types.Oid;
    };
    export type PgOperator = {
      oid: PgCatalog.Types.Oid;
      oprname: PgCatalog.Types.Name;
      oprnamespace: PgCatalog.Types.Oid;
      oprowner: PgCatalog.Types.Oid;
      oprkind: PgCatalog.Types.Char;
      oprcanmerge: PgCatalog.Types.Bool;
      oprcanhash: PgCatalog.Types.Bool;
      oprleft: PgCatalog.Types.Oid;
      oprright: PgCatalog.Types.Oid;
      oprresult: PgCatalog.Types.Oid;
      oprcom: PgCatalog.Types.Oid;
      oprnegate: PgCatalog.Types.Oid;
      oprcode: PgCatalog.Types.Regproc;
      oprrest: PgCatalog.Types.Regproc;
      oprjoin: PgCatalog.Types.Regproc;
    };
    export type PgOpfamily = {
      oid: PgCatalog.Types.Oid;
      opfmethod: PgCatalog.Types.Oid;
      opfname: PgCatalog.Types.Name;
      opfnamespace: PgCatalog.Types.Oid;
      opfowner: PgCatalog.Types.Oid;
    };
    export type PgParameterAcl = {
      oid: PgCatalog.Types.Oid;
      parname: PgCatalog.Types.Text;
      paracl: PgCatalog.Types.AclitemArray;
    };
    export type PgPartitionedTable = {
      partrelid: PgCatalog.Types.Oid;
      partstrat: PgCatalog.Types.Char;
      partnatts: PgCatalog.Types.Int2;
      partdefid: PgCatalog.Types.Oid;
      partattrs: PgCatalog.Types.Int2vector;
      partclass: PgCatalog.Types.Oidvector;
      partcollation: PgCatalog.Types.Oidvector;
      partexprs: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgPolicies = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      policyname: Nullable<PgCatalog.Types.Name>;
      permissive: Nullable<PgCatalog.Types.Text>;
      roles: PgCatalog.Types.NameArray;
      cmd: Nullable<PgCatalog.Types.Text>;
      qual: Nullable<PgCatalog.Types.Text>;
      withCheck: Nullable<PgCatalog.Types.Text>;
    };
    export type PgPolicy = {
      oid: PgCatalog.Types.Oid;
      polname: PgCatalog.Types.Name;
      polrelid: PgCatalog.Types.Oid;
      polcmd: PgCatalog.Types.Char;
      polpermissive: PgCatalog.Types.Bool;
      polroles: PgCatalog.Types.OidArray;
      polqual: Nullable<PgCatalog.Types.PgNodeTree>;
      polwithcheck: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgPreparedStatements = {
      name: Nullable<PgCatalog.Types.Text>;
      statement: Nullable<PgCatalog.Types.Text>;
      prepareTime: Nullable<PgCatalog.Types.Timestamptz>;
      parameterTypes: PgCatalog.Types.RegtypeArray;
      resultTypes: PgCatalog.Types.RegtypeArray;
      fromSql: Nullable<PgCatalog.Types.Bool>;
      genericPlans: Nullable<PgCatalog.Types.Int8>;
      customPlans: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgPreparedXacts = {
      transaction: Nullable<PgCatalog.Types.Xid>;
      gid: Nullable<PgCatalog.Types.Text>;
      prepared: Nullable<PgCatalog.Types.Timestamptz>;
      owner: Nullable<PgCatalog.Types.Name>;
      database: Nullable<PgCatalog.Types.Name>;
    };
    export type PgProc = {
      oid: PgCatalog.Types.Oid;
      proname: PgCatalog.Types.Name;
      pronamespace: PgCatalog.Types.Oid;
      proowner: PgCatalog.Types.Oid;
      prolang: PgCatalog.Types.Oid;
      procost: PgCatalog.Types.Float4;
      prorows: PgCatalog.Types.Float4;
      provariadic: PgCatalog.Types.Oid;
      prosupport: PgCatalog.Types.Regproc;
      prokind: PgCatalog.Types.Char;
      prosecdef: PgCatalog.Types.Bool;
      proleakproof: PgCatalog.Types.Bool;
      proisstrict: PgCatalog.Types.Bool;
      proretset: PgCatalog.Types.Bool;
      provolatile: PgCatalog.Types.Char;
      proparallel: PgCatalog.Types.Char;
      pronargs: PgCatalog.Types.Int2;
      pronargdefaults: PgCatalog.Types.Int2;
      prorettype: PgCatalog.Types.Oid;
      proargtypes: PgCatalog.Types.Oidvector;
      proallargtypes: PgCatalog.Types.OidArray;
      proargmodes: PgCatalog.Types.CharArray;
      proargnames: PgCatalog.Types.TextArray;
      proargdefaults: Nullable<PgCatalog.Types.PgNodeTree>;
      protrftypes: PgCatalog.Types.OidArray;
      prosrc: PgCatalog.Types.Text;
      probin: Nullable<PgCatalog.Types.Text>;
      prosqlbody: Nullable<PgCatalog.Types.PgNodeTree>;
      proconfig: PgCatalog.Types.TextArray;
      proacl: PgCatalog.Types.AclitemArray;
    };
    export type PgPublication = {
      oid: PgCatalog.Types.Oid;
      pubname: PgCatalog.Types.Name;
      pubowner: PgCatalog.Types.Oid;
      puballtables: PgCatalog.Types.Bool;
      pubinsert: PgCatalog.Types.Bool;
      pubupdate: PgCatalog.Types.Bool;
      pubdelete: PgCatalog.Types.Bool;
      pubtruncate: PgCatalog.Types.Bool;
      pubviaroot: PgCatalog.Types.Bool;
    };
    export type PgPublicationNamespace = {
      oid: PgCatalog.Types.Oid;
      pnpubid: PgCatalog.Types.Oid;
      pnnspid: PgCatalog.Types.Oid;
    };
    export type PgPublicationRel = {
      oid: PgCatalog.Types.Oid;
      prpubid: PgCatalog.Types.Oid;
      prrelid: PgCatalog.Types.Oid;
      prqual: Nullable<PgCatalog.Types.PgNodeTree>;
      prattrs: Nullable<PgCatalog.Types.Int2vector>;
    };
    export type PgPublicationTables = {
      pubname: Nullable<PgCatalog.Types.Name>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      attnames: PgCatalog.Types.NameArray;
      rowfilter: Nullable<PgCatalog.Types.Text>;
    };
    export type PgRange = {
      rngtypid: PgCatalog.Types.Oid;
      rngsubtype: PgCatalog.Types.Oid;
      rngmultitypid: PgCatalog.Types.Oid;
      rngcollation: PgCatalog.Types.Oid;
      rngsubopc: PgCatalog.Types.Oid;
      rngcanonical: PgCatalog.Types.Regproc;
      rngsubdiff: PgCatalog.Types.Regproc;
    };
    export type PgReplicationOrigin = {
      roident: PgCatalog.Types.Oid;
      roname: PgCatalog.Types.Text;
    };
    export type PgReplicationOriginStatus = {
      localId: Nullable<PgCatalog.Types.Oid>;
      externalId: Nullable<PgCatalog.Types.Text>;
      remoteLsn: Nullable<PgCatalog.Types.PgLsn>;
      localLsn: Nullable<PgCatalog.Types.PgLsn>;
    };
    export type PgReplicationSlots = {
      slotName: Nullable<PgCatalog.Types.Name>;
      plugin: Nullable<PgCatalog.Types.Name>;
      slotType: Nullable<PgCatalog.Types.Text>;
      datoid: Nullable<PgCatalog.Types.Oid>;
      database: Nullable<PgCatalog.Types.Name>;
      temporary: Nullable<PgCatalog.Types.Bool>;
      active: Nullable<PgCatalog.Types.Bool>;
      activePid: Nullable<PgCatalog.Types.Int4>;
      xmin: Nullable<PgCatalog.Types.Xid>;
      catalogXmin: Nullable<PgCatalog.Types.Xid>;
      restartLsn: Nullable<PgCatalog.Types.PgLsn>;
      confirmedFlushLsn: Nullable<PgCatalog.Types.PgLsn>;
      walStatus: Nullable<PgCatalog.Types.Text>;
      safeWalSize: Nullable<PgCatalog.Types.Int8>;
      twoPhase: Nullable<PgCatalog.Types.Bool>;
      conflicting: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgRewrite = {
      oid: PgCatalog.Types.Oid;
      rulename: PgCatalog.Types.Name;
      evClass: PgCatalog.Types.Oid;
      evType: PgCatalog.Types.Char;
      evEnabled: PgCatalog.Types.Char;
      isInstead: PgCatalog.Types.Bool;
      evQual: PgCatalog.Types.PgNodeTree;
      evAction: PgCatalog.Types.PgNodeTree;
    };
    export type PgRoles = {
      rolname: Nullable<PgCatalog.Types.Name>;
      rolsuper: Nullable<PgCatalog.Types.Bool>;
      rolinherit: Nullable<PgCatalog.Types.Bool>;
      rolcreaterole: Nullable<PgCatalog.Types.Bool>;
      rolcreatedb: Nullable<PgCatalog.Types.Bool>;
      rolcanlogin: Nullable<PgCatalog.Types.Bool>;
      rolreplication: Nullable<PgCatalog.Types.Bool>;
      rolconnlimit: Nullable<PgCatalog.Types.Int4>;
      rolpassword: Nullable<PgCatalog.Types.Text>;
      rolvaliduntil: Nullable<PgCatalog.Types.Timestamptz>;
      rolbypassrls: Nullable<PgCatalog.Types.Bool>;
      rolconfig: PgCatalog.Types.TextArray;
      oid: Nullable<PgCatalog.Types.Oid>;
    };
    export type PgRules = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      rulename: Nullable<PgCatalog.Types.Name>;
      definition: Nullable<PgCatalog.Types.Text>;
    };
    export type PgSeclabel = {
      objoid: PgCatalog.Types.Oid;
      classoid: PgCatalog.Types.Oid;
      objsubid: PgCatalog.Types.Int4;
      provider: PgCatalog.Types.Text;
      label: PgCatalog.Types.Text;
    };
    export type PgSeclabels = {
      objoid: Nullable<PgCatalog.Types.Oid>;
      classoid: Nullable<PgCatalog.Types.Oid>;
      objsubid: Nullable<PgCatalog.Types.Int4>;
      objtype: Nullable<PgCatalog.Types.Text>;
      objnamespace: Nullable<PgCatalog.Types.Oid>;
      objname: Nullable<PgCatalog.Types.Text>;
      provider: Nullable<PgCatalog.Types.Text>;
      label: Nullable<PgCatalog.Types.Text>;
    };
    export type PgSequence = {
      seqrelid: PgCatalog.Types.Oid;
      seqtypid: PgCatalog.Types.Oid;
      seqstart: PgCatalog.Types.Int8;
      seqincrement: PgCatalog.Types.Int8;
      seqmax: PgCatalog.Types.Int8;
      seqmin: PgCatalog.Types.Int8;
      seqcache: PgCatalog.Types.Int8;
      seqcycle: PgCatalog.Types.Bool;
    };
    export type PgSequences = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      sequencename: Nullable<PgCatalog.Types.Name>;
      sequenceowner: Nullable<PgCatalog.Types.Name>;
      dataType: Nullable<PgCatalog.Types.Regtype>;
      startValue: Nullable<PgCatalog.Types.Int8>;
      minValue: Nullable<PgCatalog.Types.Int8>;
      maxValue: Nullable<PgCatalog.Types.Int8>;
      incrementBy: Nullable<PgCatalog.Types.Int8>;
      cycle: Nullable<PgCatalog.Types.Bool>;
      cacheSize: Nullable<PgCatalog.Types.Int8>;
      lastValue: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgSettings = {
      name: Nullable<PgCatalog.Types.Text>;
      setting: Nullable<PgCatalog.Types.Text>;
      unit: Nullable<PgCatalog.Types.Text>;
      category: Nullable<PgCatalog.Types.Text>;
      shortDesc: Nullable<PgCatalog.Types.Text>;
      extraDesc: Nullable<PgCatalog.Types.Text>;
      context: Nullable<PgCatalog.Types.Text>;
      vartype: Nullable<PgCatalog.Types.Text>;
      source: Nullable<PgCatalog.Types.Text>;
      minVal: Nullable<PgCatalog.Types.Text>;
      maxVal: Nullable<PgCatalog.Types.Text>;
      enumvals: PgCatalog.Types.TextArray;
      bootVal: Nullable<PgCatalog.Types.Text>;
      resetVal: Nullable<PgCatalog.Types.Text>;
      sourcefile: Nullable<PgCatalog.Types.Text>;
      sourceline: Nullable<PgCatalog.Types.Int4>;
      pendingRestart: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgShadow = {
      usename: Nullable<PgCatalog.Types.Name>;
      usesysid: Nullable<PgCatalog.Types.Oid>;
      usecreatedb: Nullable<PgCatalog.Types.Bool>;
      usesuper: Nullable<PgCatalog.Types.Bool>;
      userepl: Nullable<PgCatalog.Types.Bool>;
      usebypassrls: Nullable<PgCatalog.Types.Bool>;
      passwd: Nullable<PgCatalog.Types.Text>;
      valuntil: Nullable<PgCatalog.Types.Timestamptz>;
      useconfig: PgCatalog.Types.TextArray;
    };
    export type PgShdepend = {
      dbid: PgCatalog.Types.Oid;
      classid: PgCatalog.Types.Oid;
      objid: PgCatalog.Types.Oid;
      objsubid: PgCatalog.Types.Int4;
      refclassid: PgCatalog.Types.Oid;
      refobjid: PgCatalog.Types.Oid;
      deptype: PgCatalog.Types.Char;
    };
    export type PgShdescription = {
      objoid: PgCatalog.Types.Oid;
      classoid: PgCatalog.Types.Oid;
      description: PgCatalog.Types.Text;
    };
    export type PgShmemAllocations = {
      name: Nullable<PgCatalog.Types.Text>;
      off: Nullable<PgCatalog.Types.Int8>;
      size: Nullable<PgCatalog.Types.Int8>;
      allocatedSize: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgShseclabel = {
      objoid: PgCatalog.Types.Oid;
      classoid: PgCatalog.Types.Oid;
      provider: PgCatalog.Types.Text;
      label: PgCatalog.Types.Text;
    };
    export type PgSnapshot = string;
    export type PgStatActivity = {
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      pid: Nullable<PgCatalog.Types.Int4>;
      leaderPid: Nullable<PgCatalog.Types.Int4>;
      usesysid: Nullable<PgCatalog.Types.Oid>;
      usename: Nullable<PgCatalog.Types.Name>;
      applicationName: Nullable<PgCatalog.Types.Text>;
      clientAddr: Nullable<PgCatalog.Types.Inet>;
      clientHostname: Nullable<PgCatalog.Types.Text>;
      clientPort: Nullable<PgCatalog.Types.Int4>;
      backendStart: Nullable<PgCatalog.Types.Timestamptz>;
      xactStart: Nullable<PgCatalog.Types.Timestamptz>;
      queryStart: Nullable<PgCatalog.Types.Timestamptz>;
      stateChange: Nullable<PgCatalog.Types.Timestamptz>;
      waitEventType: Nullable<PgCatalog.Types.Text>;
      waitEvent: Nullable<PgCatalog.Types.Text>;
      state: Nullable<PgCatalog.Types.Text>;
      backendXid: Nullable<PgCatalog.Types.Xid>;
      backendXmin: Nullable<PgCatalog.Types.Xid>;
      queryId: Nullable<PgCatalog.Types.Int8>;
      query: Nullable<PgCatalog.Types.Text>;
      backendType: Nullable<PgCatalog.Types.Text>;
    };
    export type PgStatAllIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupRead: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatAllTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
      nLiveTup: Nullable<PgCatalog.Types.Int8>;
      nDeadTup: Nullable<PgCatalog.Types.Int8>;
      nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
      nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
      lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
      vacuumCount: Nullable<PgCatalog.Types.Int8>;
      autovacuumCount: Nullable<PgCatalog.Types.Int8>;
      analyzeCount: Nullable<PgCatalog.Types.Int8>;
      autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatArchiver = {
      archivedCount: Nullable<PgCatalog.Types.Int8>;
      lastArchivedWal: Nullable<PgCatalog.Types.Text>;
      lastArchivedTime: Nullable<PgCatalog.Types.Timestamptz>;
      failedCount: Nullable<PgCatalog.Types.Int8>;
      lastFailedWal: Nullable<PgCatalog.Types.Text>;
      lastFailedTime: Nullable<PgCatalog.Types.Timestamptz>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatBgwriter = {
      checkpointsTimed: Nullable<PgCatalog.Types.Int8>;
      checkpointsReq: Nullable<PgCatalog.Types.Int8>;
      checkpointWriteTime: Nullable<PgCatalog.Types.Float8>;
      checkpointSyncTime: Nullable<PgCatalog.Types.Float8>;
      buffersCheckpoint: Nullable<PgCatalog.Types.Int8>;
      buffersClean: Nullable<PgCatalog.Types.Int8>;
      maxwrittenClean: Nullable<PgCatalog.Types.Int8>;
      buffersBackend: Nullable<PgCatalog.Types.Int8>;
      buffersBackendFsync: Nullable<PgCatalog.Types.Int8>;
      buffersAlloc: Nullable<PgCatalog.Types.Int8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatDatabase = {
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      numbackends: Nullable<PgCatalog.Types.Int4>;
      xactCommit: Nullable<PgCatalog.Types.Int8>;
      xactRollback: Nullable<PgCatalog.Types.Int8>;
      blksRead: Nullable<PgCatalog.Types.Int8>;
      blksHit: Nullable<PgCatalog.Types.Int8>;
      tupReturned: Nullable<PgCatalog.Types.Int8>;
      tupFetched: Nullable<PgCatalog.Types.Int8>;
      tupInserted: Nullable<PgCatalog.Types.Int8>;
      tupUpdated: Nullable<PgCatalog.Types.Int8>;
      tupDeleted: Nullable<PgCatalog.Types.Int8>;
      conflicts: Nullable<PgCatalog.Types.Int8>;
      tempFiles: Nullable<PgCatalog.Types.Int8>;
      tempBytes: Nullable<PgCatalog.Types.Int8>;
      deadlocks: Nullable<PgCatalog.Types.Int8>;
      checksumFailures: Nullable<PgCatalog.Types.Int8>;
      checksumLastFailure: Nullable<PgCatalog.Types.Timestamptz>;
      blkReadTime: Nullable<PgCatalog.Types.Float8>;
      blkWriteTime: Nullable<PgCatalog.Types.Float8>;
      sessionTime: Nullable<PgCatalog.Types.Float8>;
      activeTime: Nullable<PgCatalog.Types.Float8>;
      idleInTransactionTime: Nullable<PgCatalog.Types.Float8>;
      sessions: Nullable<PgCatalog.Types.Int8>;
      sessionsAbandoned: Nullable<PgCatalog.Types.Int8>;
      sessionsFatal: Nullable<PgCatalog.Types.Int8>;
      sessionsKilled: Nullable<PgCatalog.Types.Int8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatDatabaseConflicts = {
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      conflTablespace: Nullable<PgCatalog.Types.Int8>;
      conflLock: Nullable<PgCatalog.Types.Int8>;
      conflSnapshot: Nullable<PgCatalog.Types.Int8>;
      conflBufferpin: Nullable<PgCatalog.Types.Int8>;
      conflDeadlock: Nullable<PgCatalog.Types.Int8>;
      conflActiveLogicalslot: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatGssapi = {
      pid: Nullable<PgCatalog.Types.Int4>;
      gssAuthenticated: Nullable<PgCatalog.Types.Bool>;
      principal: Nullable<PgCatalog.Types.Text>;
      encrypted: Nullable<PgCatalog.Types.Bool>;
      credentialsDelegated: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgStatIo = {
      backendType: Nullable<PgCatalog.Types.Text>;
      object: Nullable<PgCatalog.Types.Text>;
      context: Nullable<PgCatalog.Types.Text>;
      reads: Nullable<PgCatalog.Types.Int8>;
      readTime: Nullable<PgCatalog.Types.Float8>;
      writes: Nullable<PgCatalog.Types.Int8>;
      writeTime: Nullable<PgCatalog.Types.Float8>;
      writebacks: Nullable<PgCatalog.Types.Int8>;
      writebackTime: Nullable<PgCatalog.Types.Float8>;
      extends: Nullable<PgCatalog.Types.Int8>;
      extendTime: Nullable<PgCatalog.Types.Float8>;
      opBytes: Nullable<PgCatalog.Types.Int8>;
      hits: Nullable<PgCatalog.Types.Int8>;
      evictions: Nullable<PgCatalog.Types.Int8>;
      reuses: Nullable<PgCatalog.Types.Int8>;
      fsyncs: Nullable<PgCatalog.Types.Int8>;
      fsyncTime: Nullable<PgCatalog.Types.Float8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatProgressAnalyze = {
      pid: Nullable<PgCatalog.Types.Int4>;
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      relid: Nullable<PgCatalog.Types.Oid>;
      phase: Nullable<PgCatalog.Types.Text>;
      sampleBlksTotal: Nullable<PgCatalog.Types.Int8>;
      sampleBlksScanned: Nullable<PgCatalog.Types.Int8>;
      extStatsTotal: Nullable<PgCatalog.Types.Int8>;
      extStatsComputed: Nullable<PgCatalog.Types.Int8>;
      childTablesTotal: Nullable<PgCatalog.Types.Int8>;
      childTablesDone: Nullable<PgCatalog.Types.Int8>;
      currentChildTableRelid: Nullable<PgCatalog.Types.Oid>;
    };
    export type PgStatProgressBasebackup = {
      pid: Nullable<PgCatalog.Types.Int4>;
      phase: Nullable<PgCatalog.Types.Text>;
      backupTotal: Nullable<PgCatalog.Types.Int8>;
      backupStreamed: Nullable<PgCatalog.Types.Int8>;
      tablespacesTotal: Nullable<PgCatalog.Types.Int8>;
      tablespacesStreamed: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatProgressCluster = {
      pid: Nullable<PgCatalog.Types.Int4>;
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      relid: Nullable<PgCatalog.Types.Oid>;
      command: Nullable<PgCatalog.Types.Text>;
      phase: Nullable<PgCatalog.Types.Text>;
      clusterIndexRelid: Nullable<PgCatalog.Types.Oid>;
      heapTuplesScanned: Nullable<PgCatalog.Types.Int8>;
      heapTuplesWritten: Nullable<PgCatalog.Types.Int8>;
      heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
      heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
      indexRebuildCount: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatProgressCopy = {
      pid: Nullable<PgCatalog.Types.Int4>;
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      relid: Nullable<PgCatalog.Types.Oid>;
      command: Nullable<PgCatalog.Types.Text>;
      type: Nullable<PgCatalog.Types.Text>;
      bytesProcessed: Nullable<PgCatalog.Types.Int8>;
      bytesTotal: Nullable<PgCatalog.Types.Int8>;
      tuplesProcessed: Nullable<PgCatalog.Types.Int8>;
      tuplesExcluded: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatProgressCreateIndex = {
      pid: Nullable<PgCatalog.Types.Int4>;
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      relid: Nullable<PgCatalog.Types.Oid>;
      indexRelid: Nullable<PgCatalog.Types.Oid>;
      command: Nullable<PgCatalog.Types.Text>;
      phase: Nullable<PgCatalog.Types.Text>;
      lockersTotal: Nullable<PgCatalog.Types.Int8>;
      lockersDone: Nullable<PgCatalog.Types.Int8>;
      currentLockerPid: Nullable<PgCatalog.Types.Int8>;
      blocksTotal: Nullable<PgCatalog.Types.Int8>;
      blocksDone: Nullable<PgCatalog.Types.Int8>;
      tuplesTotal: Nullable<PgCatalog.Types.Int8>;
      tuplesDone: Nullable<PgCatalog.Types.Int8>;
      partitionsTotal: Nullable<PgCatalog.Types.Int8>;
      partitionsDone: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatProgressVacuum = {
      pid: Nullable<PgCatalog.Types.Int4>;
      datid: Nullable<PgCatalog.Types.Oid>;
      datname: Nullable<PgCatalog.Types.Name>;
      relid: Nullable<PgCatalog.Types.Oid>;
      phase: Nullable<PgCatalog.Types.Text>;
      heapBlksTotal: Nullable<PgCatalog.Types.Int8>;
      heapBlksScanned: Nullable<PgCatalog.Types.Int8>;
      heapBlksVacuumed: Nullable<PgCatalog.Types.Int8>;
      indexVacuumCount: Nullable<PgCatalog.Types.Int8>;
      maxDeadTuples: Nullable<PgCatalog.Types.Int8>;
      numDeadTuples: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatRecoveryPrefetch = {
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
      prefetch: Nullable<PgCatalog.Types.Int8>;
      hit: Nullable<PgCatalog.Types.Int8>;
      skipInit: Nullable<PgCatalog.Types.Int8>;
      skipNew: Nullable<PgCatalog.Types.Int8>;
      skipFpw: Nullable<PgCatalog.Types.Int8>;
      skipRep: Nullable<PgCatalog.Types.Int8>;
      walDistance: Nullable<PgCatalog.Types.Int4>;
      blockDistance: Nullable<PgCatalog.Types.Int4>;
      ioDepth: Nullable<PgCatalog.Types.Int4>;
    };
    export type PgStatReplication = {
      pid: Nullable<PgCatalog.Types.Int4>;
      usesysid: Nullable<PgCatalog.Types.Oid>;
      usename: Nullable<PgCatalog.Types.Name>;
      applicationName: Nullable<PgCatalog.Types.Text>;
      clientAddr: Nullable<PgCatalog.Types.Inet>;
      clientHostname: Nullable<PgCatalog.Types.Text>;
      clientPort: Nullable<PgCatalog.Types.Int4>;
      backendStart: Nullable<PgCatalog.Types.Timestamptz>;
      backendXmin: Nullable<PgCatalog.Types.Xid>;
      state: Nullable<PgCatalog.Types.Text>;
      sentLsn: Nullable<PgCatalog.Types.PgLsn>;
      writeLsn: Nullable<PgCatalog.Types.PgLsn>;
      flushLsn: Nullable<PgCatalog.Types.PgLsn>;
      replayLsn: Nullable<PgCatalog.Types.PgLsn>;
      writeLag: Nullable<PgCatalog.Types.Interval>;
      flushLag: Nullable<PgCatalog.Types.Interval>;
      replayLag: Nullable<PgCatalog.Types.Interval>;
      syncPriority: Nullable<PgCatalog.Types.Int4>;
      syncState: Nullable<PgCatalog.Types.Text>;
      replyTime: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatReplicationSlots = {
      slotName: Nullable<PgCatalog.Types.Text>;
      spillTxns: Nullable<PgCatalog.Types.Int8>;
      spillCount: Nullable<PgCatalog.Types.Int8>;
      spillBytes: Nullable<PgCatalog.Types.Int8>;
      streamTxns: Nullable<PgCatalog.Types.Int8>;
      streamCount: Nullable<PgCatalog.Types.Int8>;
      streamBytes: Nullable<PgCatalog.Types.Int8>;
      totalTxns: Nullable<PgCatalog.Types.Int8>;
      totalBytes: Nullable<PgCatalog.Types.Int8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatSlru = {
      name: Nullable<PgCatalog.Types.Text>;
      blksZeroed: Nullable<PgCatalog.Types.Int8>;
      blksHit: Nullable<PgCatalog.Types.Int8>;
      blksRead: Nullable<PgCatalog.Types.Int8>;
      blksWritten: Nullable<PgCatalog.Types.Int8>;
      blksExists: Nullable<PgCatalog.Types.Int8>;
      flushes: Nullable<PgCatalog.Types.Int8>;
      truncates: Nullable<PgCatalog.Types.Int8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatSsl = {
      pid: Nullable<PgCatalog.Types.Int4>;
      ssl: Nullable<PgCatalog.Types.Bool>;
      version: Nullable<PgCatalog.Types.Text>;
      cipher: Nullable<PgCatalog.Types.Text>;
      bits: Nullable<PgCatalog.Types.Int4>;
      clientDn: Nullable<PgCatalog.Types.Text>;
      clientSerial: Nullable<PgCatalog.Types.Numeric>;
      issuerDn: Nullable<PgCatalog.Types.Text>;
    };
    export type PgStatSubscription = {
      subid: Nullable<PgCatalog.Types.Oid>;
      subname: Nullable<PgCatalog.Types.Name>;
      pid: Nullable<PgCatalog.Types.Int4>;
      leaderPid: Nullable<PgCatalog.Types.Int4>;
      relid: Nullable<PgCatalog.Types.Oid>;
      receivedLsn: Nullable<PgCatalog.Types.PgLsn>;
      lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
      lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
      latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
      latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatSubscriptionStats = {
      subid: Nullable<PgCatalog.Types.Oid>;
      subname: Nullable<PgCatalog.Types.Name>;
      applyErrorCount: Nullable<PgCatalog.Types.Int8>;
      syncErrorCount: Nullable<PgCatalog.Types.Int8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatSysIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupRead: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatSysTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
      nLiveTup: Nullable<PgCatalog.Types.Int8>;
      nDeadTup: Nullable<PgCatalog.Types.Int8>;
      nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
      nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
      lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
      vacuumCount: Nullable<PgCatalog.Types.Int8>;
      autovacuumCount: Nullable<PgCatalog.Types.Int8>;
      analyzeCount: Nullable<PgCatalog.Types.Int8>;
      autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatUserFunctions = {
      funcid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      funcname: Nullable<PgCatalog.Types.Name>;
      calls: Nullable<PgCatalog.Types.Int8>;
      totalTime: Nullable<PgCatalog.Types.Float8>;
      selfTime: Nullable<PgCatalog.Types.Float8>;
    };
    export type PgStatUserIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupRead: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatUserTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      lastSeqScan: Nullable<PgCatalog.Types.Timestamptz>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      lastIdxScan: Nullable<PgCatalog.Types.Timestamptz>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
      nLiveTup: Nullable<PgCatalog.Types.Int8>;
      nDeadTup: Nullable<PgCatalog.Types.Int8>;
      nModSinceAnalyze: Nullable<PgCatalog.Types.Int8>;
      nInsSinceVacuum: Nullable<PgCatalog.Types.Int8>;
      lastVacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutovacuum: Nullable<PgCatalog.Types.Timestamptz>;
      lastAnalyze: Nullable<PgCatalog.Types.Timestamptz>;
      lastAutoanalyze: Nullable<PgCatalog.Types.Timestamptz>;
      vacuumCount: Nullable<PgCatalog.Types.Int8>;
      autovacuumCount: Nullable<PgCatalog.Types.Int8>;
      analyzeCount: Nullable<PgCatalog.Types.Int8>;
      autoanalyzeCount: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatWal = {
      walRecords: Nullable<PgCatalog.Types.Int8>;
      walFpi: Nullable<PgCatalog.Types.Int8>;
      walBytes: Nullable<PgCatalog.Types.Numeric>;
      walBuffersFull: Nullable<PgCatalog.Types.Int8>;
      walWrite: Nullable<PgCatalog.Types.Int8>;
      walSync: Nullable<PgCatalog.Types.Int8>;
      walWriteTime: Nullable<PgCatalog.Types.Float8>;
      walSyncTime: Nullable<PgCatalog.Types.Float8>;
      statsReset: Nullable<PgCatalog.Types.Timestamptz>;
    };
    export type PgStatWalReceiver = {
      pid: Nullable<PgCatalog.Types.Int4>;
      status: Nullable<PgCatalog.Types.Text>;
      receiveStartLsn: Nullable<PgCatalog.Types.PgLsn>;
      receiveStartTli: Nullable<PgCatalog.Types.Int4>;
      writtenLsn: Nullable<PgCatalog.Types.PgLsn>;
      flushedLsn: Nullable<PgCatalog.Types.PgLsn>;
      receivedTli: Nullable<PgCatalog.Types.Int4>;
      lastMsgSendTime: Nullable<PgCatalog.Types.Timestamptz>;
      lastMsgReceiptTime: Nullable<PgCatalog.Types.Timestamptz>;
      latestEndLsn: Nullable<PgCatalog.Types.PgLsn>;
      latestEndTime: Nullable<PgCatalog.Types.Timestamptz>;
      slotName: Nullable<PgCatalog.Types.Text>;
      senderHost: Nullable<PgCatalog.Types.Text>;
      senderPort: Nullable<PgCatalog.Types.Int4>;
      conninfo: Nullable<PgCatalog.Types.Text>;
    };
    export type PgStatXactAllTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatXactSysTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatXactUserFunctions = {
      funcid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      funcname: Nullable<PgCatalog.Types.Name>;
      calls: Nullable<PgCatalog.Types.Int8>;
      totalTime: Nullable<PgCatalog.Types.Float8>;
      selfTime: Nullable<PgCatalog.Types.Float8>;
    };
    export type PgStatXactUserTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      seqScan: Nullable<PgCatalog.Types.Int8>;
      seqTupRead: Nullable<PgCatalog.Types.Int8>;
      idxScan: Nullable<PgCatalog.Types.Int8>;
      idxTupFetch: Nullable<PgCatalog.Types.Int8>;
      nTupIns: Nullable<PgCatalog.Types.Int8>;
      nTupUpd: Nullable<PgCatalog.Types.Int8>;
      nTupDel: Nullable<PgCatalog.Types.Int8>;
      nTupHotUpd: Nullable<PgCatalog.Types.Int8>;
      nTupNewpageUpd: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioAllIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioAllSequences = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      blksRead: Nullable<PgCatalog.Types.Int8>;
      blksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioAllTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      heapBlksRead: Nullable<PgCatalog.Types.Int8>;
      heapBlksHit: Nullable<PgCatalog.Types.Int8>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
      toastBlksRead: Nullable<PgCatalog.Types.Int8>;
      toastBlksHit: Nullable<PgCatalog.Types.Int8>;
      tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
      tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioSysIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioSysSequences = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      blksRead: Nullable<PgCatalog.Types.Int8>;
      blksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioSysTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      heapBlksRead: Nullable<PgCatalog.Types.Int8>;
      heapBlksHit: Nullable<PgCatalog.Types.Int8>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
      toastBlksRead: Nullable<PgCatalog.Types.Int8>;
      toastBlksHit: Nullable<PgCatalog.Types.Int8>;
      tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
      tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioUserIndexes = {
      relid: Nullable<PgCatalog.Types.Oid>;
      indexrelid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      indexrelname: Nullable<PgCatalog.Types.Name>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioUserSequences = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      blksRead: Nullable<PgCatalog.Types.Int8>;
      blksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatioUserTables = {
      relid: Nullable<PgCatalog.Types.Oid>;
      schemaname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      heapBlksRead: Nullable<PgCatalog.Types.Int8>;
      heapBlksHit: Nullable<PgCatalog.Types.Int8>;
      idxBlksRead: Nullable<PgCatalog.Types.Int8>;
      idxBlksHit: Nullable<PgCatalog.Types.Int8>;
      toastBlksRead: Nullable<PgCatalog.Types.Int8>;
      toastBlksHit: Nullable<PgCatalog.Types.Int8>;
      tidxBlksRead: Nullable<PgCatalog.Types.Int8>;
      tidxBlksHit: Nullable<PgCatalog.Types.Int8>;
    };
    export type PgStatistic = {
      starelid: PgCatalog.Types.Oid;
      staattnum: PgCatalog.Types.Int2;
      stainherit: PgCatalog.Types.Bool;
      stanullfrac: PgCatalog.Types.Float4;
      stawidth: PgCatalog.Types.Int4;
      stadistinct: PgCatalog.Types.Float4;
      stakind1: PgCatalog.Types.Int2;
      stakind2: PgCatalog.Types.Int2;
      stakind3: PgCatalog.Types.Int2;
      stakind4: PgCatalog.Types.Int2;
      stakind5: PgCatalog.Types.Int2;
      staop1: PgCatalog.Types.Oid;
      staop2: PgCatalog.Types.Oid;
      staop3: PgCatalog.Types.Oid;
      staop4: PgCatalog.Types.Oid;
      staop5: PgCatalog.Types.Oid;
      stacoll1: PgCatalog.Types.Oid;
      stacoll2: PgCatalog.Types.Oid;
      stacoll3: PgCatalog.Types.Oid;
      stacoll4: PgCatalog.Types.Oid;
      stacoll5: PgCatalog.Types.Oid;
      stanumbers1: PgCatalog.Types.Float4Array;
      stanumbers2: PgCatalog.Types.Float4Array;
      stanumbers3: PgCatalog.Types.Float4Array;
      stanumbers4: PgCatalog.Types.Float4Array;
      stanumbers5: PgCatalog.Types.Float4Array;
      stavalues1: Nullable<PgCatalog.Types.Anyarray>;
      stavalues2: Nullable<PgCatalog.Types.Anyarray>;
      stavalues3: Nullable<PgCatalog.Types.Anyarray>;
      stavalues4: Nullable<PgCatalog.Types.Anyarray>;
      stavalues5: Nullable<PgCatalog.Types.Anyarray>;
    };
    export type PgStatisticExt = {
      oid: PgCatalog.Types.Oid;
      stxrelid: PgCatalog.Types.Oid;
      stxname: PgCatalog.Types.Name;
      stxnamespace: PgCatalog.Types.Oid;
      stxowner: PgCatalog.Types.Oid;
      stxstattarget: PgCatalog.Types.Int4;
      stxkeys: PgCatalog.Types.Int2vector;
      stxkind: PgCatalog.Types.CharArray;
      stxexprs: Nullable<PgCatalog.Types.PgNodeTree>;
    };
    export type PgStatisticExtData = {
      stxoid: PgCatalog.Types.Oid;
      stxdinherit: PgCatalog.Types.Bool;
      stxdndistinct: Nullable<PgCatalog.Types.PgNdistinct>;
      stxddependencies: Nullable<PgCatalog.Types.PgDependencies>;
      stxdmcv: Nullable<PgCatalog.Types.PgMcvList>;
      stxdexpr: PgCatalog.Types.PgStatisticArray;
    };
    export type PgStats = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      attname: Nullable<PgCatalog.Types.Name>;
      inherited: Nullable<PgCatalog.Types.Bool>;
      nullFrac: Nullable<PgCatalog.Types.Float4>;
      avgWidth: Nullable<PgCatalog.Types.Int4>;
      nDistinct: Nullable<PgCatalog.Types.Float4>;
      mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
      mostCommonFreqs: PgCatalog.Types.Float4Array;
      histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
      correlation: Nullable<PgCatalog.Types.Float4>;
      mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
      mostCommonElemFreqs: PgCatalog.Types.Float4Array;
      elemCountHistogram: PgCatalog.Types.Float4Array;
    };
    export type PgStatsExt = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
      statisticsName: Nullable<PgCatalog.Types.Name>;
      statisticsOwner: Nullable<PgCatalog.Types.Name>;
      attnames: PgCatalog.Types.NameArray;
      exprs: PgCatalog.Types.TextArray;
      kinds: PgCatalog.Types.CharArray;
      inherited: Nullable<PgCatalog.Types.Bool>;
      nDistinct: Nullable<PgCatalog.Types.PgNdistinct>;
      dependencies: Nullable<PgCatalog.Types.PgDependencies>;
      mostCommonVals: PgCatalog.Types.TextArray;
      mostCommonValNulls: PgCatalog.Types.BoolArray;
      mostCommonFreqs: PgCatalog.Types.Float8Array;
      mostCommonBaseFreqs: PgCatalog.Types.Float8Array;
    };
    export type PgStatsExtExprs = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      statisticsSchemaname: Nullable<PgCatalog.Types.Name>;
      statisticsName: Nullable<PgCatalog.Types.Name>;
      statisticsOwner: Nullable<PgCatalog.Types.Name>;
      expr: Nullable<PgCatalog.Types.Text>;
      inherited: Nullable<PgCatalog.Types.Bool>;
      nullFrac: Nullable<PgCatalog.Types.Float4>;
      avgWidth: Nullable<PgCatalog.Types.Int4>;
      nDistinct: Nullable<PgCatalog.Types.Float4>;
      mostCommonVals: Nullable<PgCatalog.Types.Anyarray>;
      mostCommonFreqs: PgCatalog.Types.Float4Array;
      histogramBounds: Nullable<PgCatalog.Types.Anyarray>;
      correlation: Nullable<PgCatalog.Types.Float4>;
      mostCommonElems: Nullable<PgCatalog.Types.Anyarray>;
      mostCommonElemFreqs: PgCatalog.Types.Float4Array;
      elemCountHistogram: PgCatalog.Types.Float4Array;
    };
    export type PgSubscription = {
      oid: PgCatalog.Types.Oid;
      subdbid: PgCatalog.Types.Oid;
      subskiplsn: PgCatalog.Types.PgLsn;
      subname: PgCatalog.Types.Name;
      subowner: PgCatalog.Types.Oid;
      subenabled: PgCatalog.Types.Bool;
      subbinary: PgCatalog.Types.Bool;
      substream: PgCatalog.Types.Char;
      subtwophasestate: PgCatalog.Types.Char;
      subdisableonerr: PgCatalog.Types.Bool;
      subpasswordrequired: PgCatalog.Types.Bool;
      subrunasowner: PgCatalog.Types.Bool;
      subconninfo: PgCatalog.Types.Text;
      subslotname: Nullable<PgCatalog.Types.Name>;
      subsynccommit: PgCatalog.Types.Text;
      subpublications: PgCatalog.Types.TextArray;
      suborigin: Nullable<PgCatalog.Types.Text>;
    };
    export type PgSubscriptionRel = {
      srsubid: PgCatalog.Types.Oid;
      srrelid: PgCatalog.Types.Oid;
      srsubstate: PgCatalog.Types.Char;
      srsublsn: Nullable<PgCatalog.Types.PgLsn>;
    };
    export type PgTables = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      tablename: Nullable<PgCatalog.Types.Name>;
      tableowner: Nullable<PgCatalog.Types.Name>;
      tablespace: Nullable<PgCatalog.Types.Name>;
      hasindexes: Nullable<PgCatalog.Types.Bool>;
      hasrules: Nullable<PgCatalog.Types.Bool>;
      hastriggers: Nullable<PgCatalog.Types.Bool>;
      rowsecurity: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgTablespace = {
      oid: PgCatalog.Types.Oid;
      spcname: PgCatalog.Types.Name;
      spcowner: PgCatalog.Types.Oid;
      spcacl: PgCatalog.Types.AclitemArray;
      spcoptions: PgCatalog.Types.TextArray;
    };
    export type PgTimezoneAbbrevs = {
      abbrev: Nullable<PgCatalog.Types.Text>;
      utcOffset: Nullable<PgCatalog.Types.Interval>;
      isDst: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgTimezoneNames = {
      name: Nullable<PgCatalog.Types.Text>;
      abbrev: Nullable<PgCatalog.Types.Text>;
      utcOffset: Nullable<PgCatalog.Types.Interval>;
      isDst: Nullable<PgCatalog.Types.Bool>;
    };
    export type PgTransform = {
      oid: PgCatalog.Types.Oid;
      trftype: PgCatalog.Types.Oid;
      trflang: PgCatalog.Types.Oid;
      trffromsql: PgCatalog.Types.Regproc;
      trftosql: PgCatalog.Types.Regproc;
    };
    export type PgTrigger = {
      oid: PgCatalog.Types.Oid;
      tgrelid: PgCatalog.Types.Oid;
      tgparentid: PgCatalog.Types.Oid;
      tgname: PgCatalog.Types.Name;
      tgfoid: PgCatalog.Types.Oid;
      tgtype: PgCatalog.Types.Int2;
      tgenabled: PgCatalog.Types.Char;
      tgisinternal: PgCatalog.Types.Bool;
      tgconstrrelid: PgCatalog.Types.Oid;
      tgconstrindid: PgCatalog.Types.Oid;
      tgconstraint: PgCatalog.Types.Oid;
      tgdeferrable: PgCatalog.Types.Bool;
      tginitdeferred: PgCatalog.Types.Bool;
      tgnargs: PgCatalog.Types.Int2;
      tgattr: PgCatalog.Types.Int2vector;
      tgargs: PgCatalog.Types.Bytea;
      tgqual: Nullable<PgCatalog.Types.PgNodeTree>;
      tgoldtable: Nullable<PgCatalog.Types.Name>;
      tgnewtable: Nullable<PgCatalog.Types.Name>;
    };
    export type PgTsConfig = {
      oid: PgCatalog.Types.Oid;
      cfgname: PgCatalog.Types.Name;
      cfgnamespace: PgCatalog.Types.Oid;
      cfgowner: PgCatalog.Types.Oid;
      cfgparser: PgCatalog.Types.Oid;
    };
    export type PgTsConfigMap = {
      mapcfg: PgCatalog.Types.Oid;
      maptokentype: PgCatalog.Types.Int4;
      mapseqno: PgCatalog.Types.Int4;
      mapdict: PgCatalog.Types.Oid;
    };
    export type PgTsDict = {
      oid: PgCatalog.Types.Oid;
      dictname: PgCatalog.Types.Name;
      dictnamespace: PgCatalog.Types.Oid;
      dictowner: PgCatalog.Types.Oid;
      dicttemplate: PgCatalog.Types.Oid;
      dictinitoption: Nullable<PgCatalog.Types.Text>;
    };
    export type PgTsParser = {
      oid: PgCatalog.Types.Oid;
      prsname: PgCatalog.Types.Name;
      prsnamespace: PgCatalog.Types.Oid;
      prsstart: PgCatalog.Types.Regproc;
      prstoken: PgCatalog.Types.Regproc;
      prsend: PgCatalog.Types.Regproc;
      prsheadline: PgCatalog.Types.Regproc;
      prslextype: PgCatalog.Types.Regproc;
    };
    export type PgTsTemplate = {
      oid: PgCatalog.Types.Oid;
      tmplname: PgCatalog.Types.Name;
      tmplnamespace: PgCatalog.Types.Oid;
      tmplinit: PgCatalog.Types.Regproc;
      tmpllexize: PgCatalog.Types.Regproc;
    };
    export type PgType = {
      oid: PgCatalog.Types.Oid;
      typname: PgCatalog.Types.Name;
      typnamespace: PgCatalog.Types.Oid;
      typowner: PgCatalog.Types.Oid;
      typlen: PgCatalog.Types.Int2;
      typbyval: PgCatalog.Types.Bool;
      typtype: PgCatalog.Types.Char;
      typcategory: PgCatalog.Types.Char;
      typispreferred: PgCatalog.Types.Bool;
      typisdefined: PgCatalog.Types.Bool;
      typdelim: PgCatalog.Types.Char;
      typrelid: PgCatalog.Types.Oid;
      typsubscript: PgCatalog.Types.Regproc;
      typelem: PgCatalog.Types.Oid;
      typarray: PgCatalog.Types.Oid;
      typinput: PgCatalog.Types.Regproc;
      typoutput: PgCatalog.Types.Regproc;
      typreceive: PgCatalog.Types.Regproc;
      typsend: PgCatalog.Types.Regproc;
      typmodin: PgCatalog.Types.Regproc;
      typmodout: PgCatalog.Types.Regproc;
      typanalyze: PgCatalog.Types.Regproc;
      typalign: PgCatalog.Types.Char;
      typstorage: PgCatalog.Types.Char;
      typnotnull: PgCatalog.Types.Bool;
      typbasetype: PgCatalog.Types.Oid;
      typtypmod: PgCatalog.Types.Int4;
      typndims: PgCatalog.Types.Int4;
      typcollation: PgCatalog.Types.Oid;
      typdefaultbin: Nullable<PgCatalog.Types.PgNodeTree>;
      typdefault: Nullable<PgCatalog.Types.Text>;
      typacl: PgCatalog.Types.AclitemArray;
    };
    export type PgUser = {
      usename: Nullable<PgCatalog.Types.Name>;
      usesysid: Nullable<PgCatalog.Types.Oid>;
      usecreatedb: Nullable<PgCatalog.Types.Bool>;
      usesuper: Nullable<PgCatalog.Types.Bool>;
      userepl: Nullable<PgCatalog.Types.Bool>;
      usebypassrls: Nullable<PgCatalog.Types.Bool>;
      passwd: Nullable<PgCatalog.Types.Text>;
      valuntil: Nullable<PgCatalog.Types.Timestamptz>;
      useconfig: PgCatalog.Types.TextArray;
    };
    export type PgUserMapping = {
      oid: PgCatalog.Types.Oid;
      umuser: PgCatalog.Types.Oid;
      umserver: PgCatalog.Types.Oid;
      umoptions: PgCatalog.Types.TextArray;
    };
    export type PgUserMappings = {
      umid: Nullable<PgCatalog.Types.Oid>;
      srvid: Nullable<PgCatalog.Types.Oid>;
      srvname: Nullable<PgCatalog.Types.Name>;
      umuser: Nullable<PgCatalog.Types.Oid>;
      usename: Nullable<PgCatalog.Types.Name>;
      umoptions: PgCatalog.Types.TextArray;
    };
    export type PgViews = {
      schemaname: Nullable<PgCatalog.Types.Name>;
      viewname: Nullable<PgCatalog.Types.Name>;
      viewowner: Nullable<PgCatalog.Types.Name>;
      definition: Nullable<PgCatalog.Types.Text>;
    };
    export type Point = {
      x: number;
      y: number;
    };
    export type Polygon = string;
    export type Record = unknown;
    export type Refcursor = string;
    export type Regclass = number;
    export type Regcollation = number;
    export type Regconfig = number;
    export type Regdictionary = number;
    export type Regnamespace = number;
    export type Regoper = number;
    export type Regoperator = number;
    export type Regproc = number;
    export type Regprocedure = number;
    export type Regrole = number;
    export type Regtype = number;
    export type TableAmHandler = unknown;
    export type Text = string;
    export type Tid = {
      blockNumber: number;
      tupleIndex: number;
    };
    export type Time = JsDate;
    export type Timestamp = JsDate;
    export type Timestamptz = JsDate;
    export type Timetz = JsDate;
    export type Trigger = unknown;
    export type TsmHandler = unknown;
    export type Tsmultirange = unknown;
    export type Tsquery = string;
    export type Tsrange = [
      PgCatalog.Types.Timestamp,
      PgCatalog.Types.Timestamp,
    ];
    export type Tstzmultirange = unknown;
    export type Tstzrange = [
      PgCatalog.Types.Timestamptz,
      PgCatalog.Types.Timestamptz,
    ];
    export type Tsvector = string;
    export type TxidSnapshot = string;
    export type Unknown = unknown;
    export type Uuid = UUID;
    export type Varbit = boolean;
    export type Varchar = string;
    export type Void = unknown;
    export type Xid = string;
    export type Xid8 = string;
    export type Xml = string;
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace PgStatistic {
      export type Record = {
        starelid: PgCatalog.Types.PgStatistic["starelid"];
        staattnum: PgCatalog.Types.PgStatistic["staattnum"];
        stainherit: PgCatalog.Types.PgStatistic["stainherit"];
        stanullfrac: PgCatalog.Types.PgStatistic["stanullfrac"];
        stawidth: PgCatalog.Types.PgStatistic["stawidth"];
        stadistinct: PgCatalog.Types.PgStatistic["stadistinct"];
        stakind1: PgCatalog.Types.PgStatistic["stakind1"];
        stakind2: PgCatalog.Types.PgStatistic["stakind2"];
        stakind3: PgCatalog.Types.PgStatistic["stakind3"];
        stakind4: PgCatalog.Types.PgStatistic["stakind4"];
        stakind5: PgCatalog.Types.PgStatistic["stakind5"];
        staop1: PgCatalog.Types.PgStatistic["staop1"];
        staop2: PgCatalog.Types.PgStatistic["staop2"];
        staop3: PgCatalog.Types.PgStatistic["staop3"];
        staop4: PgCatalog.Types.PgStatistic["staop4"];
        staop5: PgCatalog.Types.PgStatistic["staop5"];
        stacoll1: PgCatalog.Types.PgStatistic["stacoll1"];
        stacoll2: PgCatalog.Types.PgStatistic["stacoll2"];
        stacoll3: PgCatalog.Types.PgStatistic["stacoll3"];
        stacoll4: PgCatalog.Types.PgStatistic["stacoll4"];
        stacoll5: PgCatalog.Types.PgStatistic["stacoll5"];
        stanumbers1: PgCatalog.Types.PgStatistic["stanumbers1"] | null;
        stanumbers2: PgCatalog.Types.PgStatistic["stanumbers2"] | null;
        stanumbers3: PgCatalog.Types.PgStatistic["stanumbers3"] | null;
        stanumbers4: PgCatalog.Types.PgStatistic["stanumbers4"] | null;
        stanumbers5: PgCatalog.Types.PgStatistic["stanumbers5"] | null;
        stavalues1: PgCatalog.Types.PgStatistic["stavalues1"] | null;
        stavalues2: PgCatalog.Types.PgStatistic["stavalues2"] | null;
        stavalues3: PgCatalog.Types.PgStatistic["stavalues3"] | null;
        stavalues4: PgCatalog.Types.PgStatistic["stavalues4"] | null;
        stavalues5: PgCatalog.Types.PgStatistic["stavalues5"] | null;
      };
      export type ByStarelidStaattnumStainherit = {
        starelid: PgCatalog.Types.Oid;
        staattnum: PgCatalog.Types.Int2;
        stainherit: PgCatalog.Types.Bool;
      };
      export type PrimaryKey = ByStarelidStaattnumStainherit;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgType {
      export type Record = {
        oid: PgCatalog.Types.PgType["oid"];
        typname: PgCatalog.Types.PgType["typname"];
        typnamespace: PgCatalog.Types.PgType["typnamespace"];
        typowner: PgCatalog.Types.PgType["typowner"];
        typlen: PgCatalog.Types.PgType["typlen"];
        typbyval: PgCatalog.Types.PgType["typbyval"];
        typtype: PgCatalog.Types.PgType["typtype"];
        typcategory: PgCatalog.Types.PgType["typcategory"];
        typispreferred: PgCatalog.Types.PgType["typispreferred"];
        typisdefined: PgCatalog.Types.PgType["typisdefined"];
        typdelim: PgCatalog.Types.PgType["typdelim"];
        typrelid: PgCatalog.Types.PgType["typrelid"];
        typsubscript: PgCatalog.Types.PgType["typsubscript"];
        typelem: PgCatalog.Types.PgType["typelem"];
        typarray: PgCatalog.Types.PgType["typarray"];
        typinput: PgCatalog.Types.PgType["typinput"];
        typoutput: PgCatalog.Types.PgType["typoutput"];
        typreceive: PgCatalog.Types.PgType["typreceive"];
        typsend: PgCatalog.Types.PgType["typsend"];
        typmodin: PgCatalog.Types.PgType["typmodin"];
        typmodout: PgCatalog.Types.PgType["typmodout"];
        typanalyze: PgCatalog.Types.PgType["typanalyze"];
        typalign: PgCatalog.Types.PgType["typalign"];
        typstorage: PgCatalog.Types.PgType["typstorage"];
        typnotnull: PgCatalog.Types.PgType["typnotnull"];
        typbasetype: PgCatalog.Types.PgType["typbasetype"];
        typtypmod: PgCatalog.Types.PgType["typtypmod"];
        typndims: PgCatalog.Types.PgType["typndims"];
        typcollation: PgCatalog.Types.PgType["typcollation"];
        typdefaultbin: PgCatalog.Types.PgType["typdefaultbin"] | null;
        typdefault: PgCatalog.Types.PgType["typdefault"] | null;
        typacl: PgCatalog.Types.PgType["typacl"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByTypnameTypnamespace = {
        typname: PgCatalog.Types.Cstring;
        typnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgForeignTable {
      export type Record = {
        ftrelid: PgCatalog.Types.PgForeignTable["ftrelid"];
        ftserver: PgCatalog.Types.PgForeignTable["ftserver"];
        ftoptions: PgCatalog.Types.PgForeignTable["ftoptions"] | null;
      };
      export type ByFtrelid = {
        ftrelid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByFtrelid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAuthid {
      export type Record = {
        oid: PgCatalog.Types.PgAuthid["oid"];
        rolname: PgCatalog.Types.PgAuthid["rolname"];
        rolsuper: PgCatalog.Types.PgAuthid["rolsuper"];
        rolinherit: PgCatalog.Types.PgAuthid["rolinherit"];
        rolcreaterole: PgCatalog.Types.PgAuthid["rolcreaterole"];
        rolcreatedb: PgCatalog.Types.PgAuthid["rolcreatedb"];
        rolcanlogin: PgCatalog.Types.PgAuthid["rolcanlogin"];
        rolreplication: PgCatalog.Types.PgAuthid["rolreplication"];
        rolbypassrls: PgCatalog.Types.PgAuthid["rolbypassrls"];
        rolconnlimit: PgCatalog.Types.PgAuthid["rolconnlimit"];
        rolpassword: PgCatalog.Types.PgAuthid["rolpassword"] | null;
        rolvaliduntil: PgCatalog.Types.PgAuthid["rolvaliduntil"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByRolname = {
        rolname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgStatisticExtData {
      export type Record = {
        stxoid: PgCatalog.Types.PgStatisticExtData["stxoid"];
        stxdinherit: PgCatalog.Types.PgStatisticExtData["stxdinherit"];
        stxdndistinct:
          | PgCatalog.Types.PgStatisticExtData["stxdndistinct"]
          | null;
        stxddependencies:
          | PgCatalog.Types.PgStatisticExtData["stxddependencies"]
          | null;
        stxdmcv: PgCatalog.Types.PgStatisticExtData["stxdmcv"] | null;
        stxdexpr: PgCatalog.Types.PgStatisticExtData["stxdexpr"] | null;
      };
      export type ByStxoidStxdinherit = {
        stxoid: PgCatalog.Types.Oid;
        stxdinherit: PgCatalog.Types.Bool;
      };
      export type PrimaryKey = ByStxoidStxdinherit;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgUserMapping {
      export type Record = {
        oid: PgCatalog.Types.PgUserMapping["oid"];
        umuser: PgCatalog.Types.PgUserMapping["umuser"];
        umserver: PgCatalog.Types.PgUserMapping["umserver"];
        umoptions: PgCatalog.Types.PgUserMapping["umoptions"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByUmuserUmserver = {
        umuser: PgCatalog.Types.Oid;
        umserver: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgSubscription {
      export type Record = {
        oid: PgCatalog.Types.PgSubscription["oid"];
        subdbid: PgCatalog.Types.PgSubscription["subdbid"];
        subskiplsn: PgCatalog.Types.PgSubscription["subskiplsn"];
        subname: PgCatalog.Types.PgSubscription["subname"];
        subowner: PgCatalog.Types.PgSubscription["subowner"];
        subenabled: PgCatalog.Types.PgSubscription["subenabled"];
        subbinary: PgCatalog.Types.PgSubscription["subbinary"];
        substream: PgCatalog.Types.PgSubscription["substream"];
        subtwophasestate: PgCatalog.Types.PgSubscription["subtwophasestate"];
        subdisableonerr: PgCatalog.Types.PgSubscription["subdisableonerr"];
        subpasswordrequired: PgCatalog.Types.PgSubscription["subpasswordrequired"];
        subrunasowner: PgCatalog.Types.PgSubscription["subrunasowner"];
        subconninfo: PgCatalog.Types.PgSubscription["subconninfo"];
        subslotname: PgCatalog.Types.PgSubscription["subslotname"] | null;
        subsynccommit: PgCatalog.Types.PgSubscription["subsynccommit"];
        subpublications: PgCatalog.Types.PgSubscription["subpublications"];
        suborigin: PgCatalog.Types.PgSubscription["suborigin"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type BySubdbidSubname = {
        subdbid: PgCatalog.Types.Oid;
        subname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAttribute {
      export type Record = {
        attrelid: PgCatalog.Types.PgAttribute["attrelid"];
        attname: PgCatalog.Types.PgAttribute["attname"];
        atttypid: PgCatalog.Types.PgAttribute["atttypid"];
        attlen: PgCatalog.Types.PgAttribute["attlen"];
        attnum: PgCatalog.Types.PgAttribute["attnum"];
        attcacheoff: PgCatalog.Types.PgAttribute["attcacheoff"];
        atttypmod: PgCatalog.Types.PgAttribute["atttypmod"];
        attndims: PgCatalog.Types.PgAttribute["attndims"];
        attbyval: PgCatalog.Types.PgAttribute["attbyval"];
        attalign: PgCatalog.Types.PgAttribute["attalign"];
        attstorage: PgCatalog.Types.PgAttribute["attstorage"];
        attcompression: PgCatalog.Types.PgAttribute["attcompression"];
        attnotnull: PgCatalog.Types.PgAttribute["attnotnull"];
        atthasdef: PgCatalog.Types.PgAttribute["atthasdef"];
        atthasmissing: PgCatalog.Types.PgAttribute["atthasmissing"];
        attidentity: PgCatalog.Types.PgAttribute["attidentity"];
        attgenerated: PgCatalog.Types.PgAttribute["attgenerated"];
        attisdropped: PgCatalog.Types.PgAttribute["attisdropped"];
        attislocal: PgCatalog.Types.PgAttribute["attislocal"];
        attinhcount: PgCatalog.Types.PgAttribute["attinhcount"];
        attstattarget: PgCatalog.Types.PgAttribute["attstattarget"];
        attcollation: PgCatalog.Types.PgAttribute["attcollation"];
        attacl: PgCatalog.Types.PgAttribute["attacl"] | null;
        attoptions: PgCatalog.Types.PgAttribute["attoptions"] | null;
        attfdwoptions: PgCatalog.Types.PgAttribute["attfdwoptions"] | null;
        attmissingval: PgCatalog.Types.PgAttribute["attmissingval"] | null;
      };
      export type ByAttrelidAttname = {
        attrelid: PgCatalog.Types.Oid;
        attname: PgCatalog.Types.Cstring;
      };

      export type ByAttrelidAttnum = {
        attrelid: PgCatalog.Types.Oid;
        attnum: PgCatalog.Types.Int2;
      };
      export type PrimaryKey = ByAttrelidAttnum;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgProc {
      export type Record = {
        oid: PgCatalog.Types.PgProc["oid"];
        proname: PgCatalog.Types.PgProc["proname"];
        pronamespace: PgCatalog.Types.PgProc["pronamespace"];
        proowner: PgCatalog.Types.PgProc["proowner"];
        prolang: PgCatalog.Types.PgProc["prolang"];
        procost: PgCatalog.Types.PgProc["procost"];
        prorows: PgCatalog.Types.PgProc["prorows"];
        provariadic: PgCatalog.Types.PgProc["provariadic"];
        prosupport: PgCatalog.Types.PgProc["prosupport"];
        prokind: PgCatalog.Types.PgProc["prokind"];
        prosecdef: PgCatalog.Types.PgProc["prosecdef"];
        proleakproof: PgCatalog.Types.PgProc["proleakproof"];
        proisstrict: PgCatalog.Types.PgProc["proisstrict"];
        proretset: PgCatalog.Types.PgProc["proretset"];
        provolatile: PgCatalog.Types.PgProc["provolatile"];
        proparallel: PgCatalog.Types.PgProc["proparallel"];
        pronargs: PgCatalog.Types.PgProc["pronargs"];
        pronargdefaults: PgCatalog.Types.PgProc["pronargdefaults"];
        prorettype: PgCatalog.Types.PgProc["prorettype"];
        proargtypes: PgCatalog.Types.PgProc["proargtypes"];
        proallargtypes: PgCatalog.Types.PgProc["proallargtypes"] | null;
        proargmodes: PgCatalog.Types.PgProc["proargmodes"] | null;
        proargnames: PgCatalog.Types.PgProc["proargnames"] | null;
        proargdefaults: PgCatalog.Types.PgProc["proargdefaults"] | null;
        protrftypes: PgCatalog.Types.PgProc["protrftypes"] | null;
        prosrc: PgCatalog.Types.PgProc["prosrc"];
        probin: PgCatalog.Types.PgProc["probin"] | null;
        prosqlbody: PgCatalog.Types.PgProc["prosqlbody"] | null;
        proconfig: PgCatalog.Types.PgProc["proconfig"] | null;
        proacl: PgCatalog.Types.PgProc["proacl"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPronameProargtypesPronamespace = {
        proname: PgCatalog.Types.Cstring;
        proargtypes: PgCatalog.Types.Oidvector;
        pronamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgClass {
      export type Record = {
        oid: PgCatalog.Types.PgClass["oid"];
        relname: PgCatalog.Types.PgClass["relname"];
        relnamespace: PgCatalog.Types.PgClass["relnamespace"];
        reltype: PgCatalog.Types.PgClass["reltype"];
        reloftype: PgCatalog.Types.PgClass["reloftype"];
        relowner: PgCatalog.Types.PgClass["relowner"];
        relam: PgCatalog.Types.PgClass["relam"];
        relfilenode: PgCatalog.Types.PgClass["relfilenode"];
        reltablespace: PgCatalog.Types.PgClass["reltablespace"];
        relpages: PgCatalog.Types.PgClass["relpages"];
        reltuples: PgCatalog.Types.PgClass["reltuples"];
        relallvisible: PgCatalog.Types.PgClass["relallvisible"];
        reltoastrelid: PgCatalog.Types.PgClass["reltoastrelid"];
        relhasindex: PgCatalog.Types.PgClass["relhasindex"];
        relisshared: PgCatalog.Types.PgClass["relisshared"];
        relpersistence: PgCatalog.Types.PgClass["relpersistence"];
        relkind: PgCatalog.Types.PgClass["relkind"];
        relnatts: PgCatalog.Types.PgClass["relnatts"];
        relchecks: PgCatalog.Types.PgClass["relchecks"];
        relhasrules: PgCatalog.Types.PgClass["relhasrules"];
        relhastriggers: PgCatalog.Types.PgClass["relhastriggers"];
        relhassubclass: PgCatalog.Types.PgClass["relhassubclass"];
        relrowsecurity: PgCatalog.Types.PgClass["relrowsecurity"];
        relforcerowsecurity: PgCatalog.Types.PgClass["relforcerowsecurity"];
        relispopulated: PgCatalog.Types.PgClass["relispopulated"];
        relreplident: PgCatalog.Types.PgClass["relreplident"];
        relispartition: PgCatalog.Types.PgClass["relispartition"];
        relrewrite: PgCatalog.Types.PgClass["relrewrite"];
        relfrozenxid: PgCatalog.Types.PgClass["relfrozenxid"];
        relminmxid: PgCatalog.Types.PgClass["relminmxid"];
        relacl: PgCatalog.Types.PgClass["relacl"] | null;
        reloptions: PgCatalog.Types.PgClass["reloptions"] | null;
        relpartbound: PgCatalog.Types.PgClass["relpartbound"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByRelnameRelnamespace = {
        relname: PgCatalog.Types.Cstring;
        relnamespace: PgCatalog.Types.Oid;
      };

      export type ByReltablespaceRelfilenode = {
        reltablespace: PgCatalog.Types.Oid;
        relfilenode: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAttrdef {
      export type Record = {
        oid: PgCatalog.Types.PgAttrdef["oid"];
        adrelid: PgCatalog.Types.PgAttrdef["adrelid"];
        adnum: PgCatalog.Types.PgAttrdef["adnum"];
        adbin: PgCatalog.Types.PgAttrdef["adbin"];
      };
      export type ByAdrelidAdnum = {
        adrelid: PgCatalog.Types.Oid;
        adnum: PgCatalog.Types.Int2;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgConstraint {
      export type Record = {
        oid: PgCatalog.Types.PgConstraint["oid"];
        conname: PgCatalog.Types.PgConstraint["conname"];
        connamespace: PgCatalog.Types.PgConstraint["connamespace"];
        contype: PgCatalog.Types.PgConstraint["contype"];
        condeferrable: PgCatalog.Types.PgConstraint["condeferrable"];
        condeferred: PgCatalog.Types.PgConstraint["condeferred"];
        convalidated: PgCatalog.Types.PgConstraint["convalidated"];
        conrelid: PgCatalog.Types.PgConstraint["conrelid"];
        contypid: PgCatalog.Types.PgConstraint["contypid"];
        conindid: PgCatalog.Types.PgConstraint["conindid"];
        conparentid: PgCatalog.Types.PgConstraint["conparentid"];
        confrelid: PgCatalog.Types.PgConstraint["confrelid"];
        confupdtype: PgCatalog.Types.PgConstraint["confupdtype"];
        confdeltype: PgCatalog.Types.PgConstraint["confdeltype"];
        confmatchtype: PgCatalog.Types.PgConstraint["confmatchtype"];
        conislocal: PgCatalog.Types.PgConstraint["conislocal"];
        coninhcount: PgCatalog.Types.PgConstraint["coninhcount"];
        connoinherit: PgCatalog.Types.PgConstraint["connoinherit"];
        conkey: PgCatalog.Types.PgConstraint["conkey"] | null;
        confkey: PgCatalog.Types.PgConstraint["confkey"] | null;
        conpfeqop: PgCatalog.Types.PgConstraint["conpfeqop"] | null;
        conppeqop: PgCatalog.Types.PgConstraint["conppeqop"] | null;
        conffeqop: PgCatalog.Types.PgConstraint["conffeqop"] | null;
        confdelsetcols: PgCatalog.Types.PgConstraint["confdelsetcols"] | null;
        conexclop: PgCatalog.Types.PgConstraint["conexclop"] | null;
        conbin: PgCatalog.Types.PgConstraint["conbin"] | null;
      };
      export type ByConnameConnamespace = {
        conname: PgCatalog.Types.Cstring;
        connamespace: PgCatalog.Types.Oid;
      };

      export type ByConparentid = {
        conparentid: PgCatalog.Types.Oid;
      };

      export type ByConrelidContypidConname = {
        conrelid: PgCatalog.Types.Oid;
        contypid: PgCatalog.Types.Oid;
        conname: PgCatalog.Types.Cstring;
      };

      export type ByContypid = {
        contypid: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgInherits {
      export type Record = {
        inhrelid: PgCatalog.Types.PgInherits["inhrelid"];
        inhparent: PgCatalog.Types.PgInherits["inhparent"];
        inhseqno: PgCatalog.Types.PgInherits["inhseqno"];
        inhdetachpending: PgCatalog.Types.PgInherits["inhdetachpending"];
      };
      export type ByInhparent = {
        inhparent: PgCatalog.Types.Oid;
      };

      export type ByInhrelidInhseqno = {
        inhrelid: PgCatalog.Types.Oid;
        inhseqno: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByInhrelidInhseqno;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgIndex {
      export type Record = {
        indexrelid: PgCatalog.Types.PgIndex["indexrelid"];
        indrelid: PgCatalog.Types.PgIndex["indrelid"];
        indnatts: PgCatalog.Types.PgIndex["indnatts"];
        indnkeyatts: PgCatalog.Types.PgIndex["indnkeyatts"];
        indisunique: PgCatalog.Types.PgIndex["indisunique"];
        indnullsnotdistinct: PgCatalog.Types.PgIndex["indnullsnotdistinct"];
        indisprimary: PgCatalog.Types.PgIndex["indisprimary"];
        indisexclusion: PgCatalog.Types.PgIndex["indisexclusion"];
        indimmediate: PgCatalog.Types.PgIndex["indimmediate"];
        indisclustered: PgCatalog.Types.PgIndex["indisclustered"];
        indisvalid: PgCatalog.Types.PgIndex["indisvalid"];
        indcheckxmin: PgCatalog.Types.PgIndex["indcheckxmin"];
        indisready: PgCatalog.Types.PgIndex["indisready"];
        indislive: PgCatalog.Types.PgIndex["indislive"];
        indisreplident: PgCatalog.Types.PgIndex["indisreplident"];
        indkey: PgCatalog.Types.PgIndex["indkey"];
        indcollation: PgCatalog.Types.PgIndex["indcollation"];
        indclass: PgCatalog.Types.PgIndex["indclass"];
        indoption: PgCatalog.Types.PgIndex["indoption"];
        indexprs: PgCatalog.Types.PgIndex["indexprs"] | null;
        indpred: PgCatalog.Types.PgIndex["indpred"] | null;
      };
      export type ByIndexrelid = {
        indexrelid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByIndexrelid;
      export type ByIndrelid = {
        indrelid: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgOperator {
      export type Record = {
        oid: PgCatalog.Types.PgOperator["oid"];
        oprname: PgCatalog.Types.PgOperator["oprname"];
        oprnamespace: PgCatalog.Types.PgOperator["oprnamespace"];
        oprowner: PgCatalog.Types.PgOperator["oprowner"];
        oprkind: PgCatalog.Types.PgOperator["oprkind"];
        oprcanmerge: PgCatalog.Types.PgOperator["oprcanmerge"];
        oprcanhash: PgCatalog.Types.PgOperator["oprcanhash"];
        oprleft: PgCatalog.Types.PgOperator["oprleft"];
        oprright: PgCatalog.Types.PgOperator["oprright"];
        oprresult: PgCatalog.Types.PgOperator["oprresult"];
        oprcom: PgCatalog.Types.PgOperator["oprcom"];
        oprnegate: PgCatalog.Types.PgOperator["oprnegate"];
        oprcode: PgCatalog.Types.PgOperator["oprcode"];
        oprrest: PgCatalog.Types.PgOperator["oprrest"];
        oprjoin: PgCatalog.Types.PgOperator["oprjoin"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByOprnameOprleftOprrightOprnamespace = {
        oprname: PgCatalog.Types.Cstring;
        oprleft: PgCatalog.Types.Oid;
        oprright: PgCatalog.Types.Oid;
        oprnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgOpfamily {
      export type Record = {
        oid: PgCatalog.Types.PgOpfamily["oid"];
        opfmethod: PgCatalog.Types.PgOpfamily["opfmethod"];
        opfname: PgCatalog.Types.PgOpfamily["opfname"];
        opfnamespace: PgCatalog.Types.PgOpfamily["opfnamespace"];
        opfowner: PgCatalog.Types.PgOpfamily["opfowner"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByOpfmethodOpfnameOpfnamespace = {
        opfmethod: PgCatalog.Types.Oid;
        opfname: PgCatalog.Types.Cstring;
        opfnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgOpclass {
      export type Record = {
        oid: PgCatalog.Types.PgOpclass["oid"];
        opcmethod: PgCatalog.Types.PgOpclass["opcmethod"];
        opcname: PgCatalog.Types.PgOpclass["opcname"];
        opcnamespace: PgCatalog.Types.PgOpclass["opcnamespace"];
        opcowner: PgCatalog.Types.PgOpclass["opcowner"];
        opcfamily: PgCatalog.Types.PgOpclass["opcfamily"];
        opcintype: PgCatalog.Types.PgOpclass["opcintype"];
        opcdefault: PgCatalog.Types.PgOpclass["opcdefault"];
        opckeytype: PgCatalog.Types.PgOpclass["opckeytype"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByOpcmethodOpcnameOpcnamespace = {
        opcmethod: PgCatalog.Types.Oid;
        opcname: PgCatalog.Types.Cstring;
        opcnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAm {
      export type Record = {
        oid: PgCatalog.Types.PgAm["oid"];
        amname: PgCatalog.Types.PgAm["amname"];
        amhandler: PgCatalog.Types.PgAm["amhandler"];
        amtype: PgCatalog.Types.PgAm["amtype"];
      };
      export type ByAmname = {
        amname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAmop {
      export type Record = {
        oid: PgCatalog.Types.PgAmop["oid"];
        amopfamily: PgCatalog.Types.PgAmop["amopfamily"];
        amoplefttype: PgCatalog.Types.PgAmop["amoplefttype"];
        amoprighttype: PgCatalog.Types.PgAmop["amoprighttype"];
        amopstrategy: PgCatalog.Types.PgAmop["amopstrategy"];
        amoppurpose: PgCatalog.Types.PgAmop["amoppurpose"];
        amopopr: PgCatalog.Types.PgAmop["amopopr"];
        amopmethod: PgCatalog.Types.PgAmop["amopmethod"];
        amopsortfamily: PgCatalog.Types.PgAmop["amopsortfamily"];
      };
      export type ByAmopfamilyAmoplefttypeAmoprighttypeAmopstrategy = {
        amopfamily: PgCatalog.Types.Oid;
        amoplefttype: PgCatalog.Types.Oid;
        amoprighttype: PgCatalog.Types.Oid;
        amopstrategy: PgCatalog.Types.Int2;
      };

      export type ByAmopoprAmoppurposeAmopfamily = {
        amopopr: PgCatalog.Types.Oid;
        amoppurpose: PgCatalog.Types.Char;
        amopfamily: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAmproc {
      export type Record = {
        oid: PgCatalog.Types.PgAmproc["oid"];
        amprocfamily: PgCatalog.Types.PgAmproc["amprocfamily"];
        amproclefttype: PgCatalog.Types.PgAmproc["amproclefttype"];
        amprocrighttype: PgCatalog.Types.PgAmproc["amprocrighttype"];
        amprocnum: PgCatalog.Types.PgAmproc["amprocnum"];
        amproc: PgCatalog.Types.PgAmproc["amproc"];
      };
      export type ByAmprocfamilyAmproclefttypeAmprocrighttypeAmprocnum = {
        amprocfamily: PgCatalog.Types.Oid;
        amproclefttype: PgCatalog.Types.Oid;
        amprocrighttype: PgCatalog.Types.Oid;
        amprocnum: PgCatalog.Types.Int2;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgLanguage {
      export type Record = {
        oid: PgCatalog.Types.PgLanguage["oid"];
        lanname: PgCatalog.Types.PgLanguage["lanname"];
        lanowner: PgCatalog.Types.PgLanguage["lanowner"];
        lanispl: PgCatalog.Types.PgLanguage["lanispl"];
        lanpltrusted: PgCatalog.Types.PgLanguage["lanpltrusted"];
        lanplcallfoid: PgCatalog.Types.PgLanguage["lanplcallfoid"];
        laninline: PgCatalog.Types.PgLanguage["laninline"];
        lanvalidator: PgCatalog.Types.PgLanguage["lanvalidator"];
        lanacl: PgCatalog.Types.PgLanguage["lanacl"] | null;
      };
      export type ByLanname = {
        lanname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgLargeobjectMetadata {
      export type Record = {
        oid: PgCatalog.Types.PgLargeobjectMetadata["oid"];
        lomowner: PgCatalog.Types.PgLargeobjectMetadata["lomowner"];
        lomacl: PgCatalog.Types.PgLargeobjectMetadata["lomacl"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAggregate {
      export type Record = {
        aggfnoid: PgCatalog.Types.PgAggregate["aggfnoid"];
        aggkind: PgCatalog.Types.PgAggregate["aggkind"];
        aggnumdirectargs: PgCatalog.Types.PgAggregate["aggnumdirectargs"];
        aggtransfn: PgCatalog.Types.PgAggregate["aggtransfn"];
        aggfinalfn: PgCatalog.Types.PgAggregate["aggfinalfn"];
        aggcombinefn: PgCatalog.Types.PgAggregate["aggcombinefn"];
        aggserialfn: PgCatalog.Types.PgAggregate["aggserialfn"];
        aggdeserialfn: PgCatalog.Types.PgAggregate["aggdeserialfn"];
        aggmtransfn: PgCatalog.Types.PgAggregate["aggmtransfn"];
        aggminvtransfn: PgCatalog.Types.PgAggregate["aggminvtransfn"];
        aggmfinalfn: PgCatalog.Types.PgAggregate["aggmfinalfn"];
        aggfinalextra: PgCatalog.Types.PgAggregate["aggfinalextra"];
        aggmfinalextra: PgCatalog.Types.PgAggregate["aggmfinalextra"];
        aggfinalmodify: PgCatalog.Types.PgAggregate["aggfinalmodify"];
        aggmfinalmodify: PgCatalog.Types.PgAggregate["aggmfinalmodify"];
        aggsortop: PgCatalog.Types.PgAggregate["aggsortop"];
        aggtranstype: PgCatalog.Types.PgAggregate["aggtranstype"];
        aggtransspace: PgCatalog.Types.PgAggregate["aggtransspace"];
        aggmtranstype: PgCatalog.Types.PgAggregate["aggmtranstype"];
        aggmtransspace: PgCatalog.Types.PgAggregate["aggmtransspace"];
        agginitval: PgCatalog.Types.PgAggregate["agginitval"] | null;
        aggminitval: PgCatalog.Types.PgAggregate["aggminitval"] | null;
      };
      export type ByAggfnoid = {
        aggfnoid: PgCatalog.Types.Regproc;
      };
      export type PrimaryKey = ByAggfnoid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgStatisticExt {
      export type Record = {
        oid: PgCatalog.Types.PgStatisticExt["oid"];
        stxrelid: PgCatalog.Types.PgStatisticExt["stxrelid"];
        stxname: PgCatalog.Types.PgStatisticExt["stxname"];
        stxnamespace: PgCatalog.Types.PgStatisticExt["stxnamespace"];
        stxowner: PgCatalog.Types.PgStatisticExt["stxowner"];
        stxstattarget: PgCatalog.Types.PgStatisticExt["stxstattarget"];
        stxkeys: PgCatalog.Types.PgStatisticExt["stxkeys"];
        stxkind: PgCatalog.Types.PgStatisticExt["stxkind"];
        stxexprs: PgCatalog.Types.PgStatisticExt["stxexprs"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByStxnameStxnamespace = {
        stxname: PgCatalog.Types.Cstring;
        stxnamespace: PgCatalog.Types.Oid;
      };

      export type ByStxrelid = {
        stxrelid: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgRewrite {
      export type Record = {
        oid: PgCatalog.Types.PgRewrite["oid"];
        rulename: PgCatalog.Types.PgRewrite["rulename"];
        evClass: PgCatalog.Types.PgRewrite["evClass"];
        evType: PgCatalog.Types.PgRewrite["evType"];
        evEnabled: PgCatalog.Types.PgRewrite["evEnabled"];
        isInstead: PgCatalog.Types.PgRewrite["isInstead"];
        evQual: PgCatalog.Types.PgRewrite["evQual"];
        evAction: PgCatalog.Types.PgRewrite["evAction"];
      };
      export type ByEvClassRulename = {
        evClass: PgCatalog.Types.Oid;
        rulename: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTrigger {
      export type Record = {
        oid: PgCatalog.Types.PgTrigger["oid"];
        tgrelid: PgCatalog.Types.PgTrigger["tgrelid"];
        tgparentid: PgCatalog.Types.PgTrigger["tgparentid"];
        tgname: PgCatalog.Types.PgTrigger["tgname"];
        tgfoid: PgCatalog.Types.PgTrigger["tgfoid"];
        tgtype: PgCatalog.Types.PgTrigger["tgtype"];
        tgenabled: PgCatalog.Types.PgTrigger["tgenabled"];
        tgisinternal: PgCatalog.Types.PgTrigger["tgisinternal"];
        tgconstrrelid: PgCatalog.Types.PgTrigger["tgconstrrelid"];
        tgconstrindid: PgCatalog.Types.PgTrigger["tgconstrindid"];
        tgconstraint: PgCatalog.Types.PgTrigger["tgconstraint"];
        tgdeferrable: PgCatalog.Types.PgTrigger["tgdeferrable"];
        tginitdeferred: PgCatalog.Types.PgTrigger["tginitdeferred"];
        tgnargs: PgCatalog.Types.PgTrigger["tgnargs"];
        tgattr: PgCatalog.Types.PgTrigger["tgattr"];
        tgargs: PgCatalog.Types.PgTrigger["tgargs"];
        tgqual: PgCatalog.Types.PgTrigger["tgqual"] | null;
        tgoldtable: PgCatalog.Types.PgTrigger["tgoldtable"] | null;
        tgnewtable: PgCatalog.Types.PgTrigger["tgnewtable"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByTgconstraint = {
        tgconstraint: PgCatalog.Types.Oid;
      };

      export type ByTgrelidTgname = {
        tgrelid: PgCatalog.Types.Oid;
        tgname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgEventTrigger {
      export type Record = {
        oid: PgCatalog.Types.PgEventTrigger["oid"];
        evtname: PgCatalog.Types.PgEventTrigger["evtname"];
        evtevent: PgCatalog.Types.PgEventTrigger["evtevent"];
        evtowner: PgCatalog.Types.PgEventTrigger["evtowner"];
        evtfoid: PgCatalog.Types.PgEventTrigger["evtfoid"];
        evtenabled: PgCatalog.Types.PgEventTrigger["evtenabled"];
        evttags: PgCatalog.Types.PgEventTrigger["evttags"] | null;
      };
      export type ByEvtname = {
        evtname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgDescription {
      export type Record = {
        objoid: PgCatalog.Types.PgDescription["objoid"];
        classoid: PgCatalog.Types.PgDescription["classoid"];
        objsubid: PgCatalog.Types.PgDescription["objsubid"];
        description: PgCatalog.Types.PgDescription["description"];
      };
      export type ByObjoidClassoidObjsubid = {
        objoid: PgCatalog.Types.Oid;
        classoid: PgCatalog.Types.Oid;
        objsubid: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByObjoidClassoidObjsubid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgCast {
      export type Record = {
        oid: PgCatalog.Types.PgCast["oid"];
        castsource: PgCatalog.Types.PgCast["castsource"];
        casttarget: PgCatalog.Types.PgCast["casttarget"];
        castfunc: PgCatalog.Types.PgCast["castfunc"];
        castcontext: PgCatalog.Types.PgCast["castcontext"];
        castmethod: PgCatalog.Types.PgCast["castmethod"];
      };
      export type ByCastsourceCasttarget = {
        castsource: PgCatalog.Types.Oid;
        casttarget: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgEnum {
      export type Record = {
        oid: PgCatalog.Types.PgEnum["oid"];
        enumtypid: PgCatalog.Types.PgEnum["enumtypid"];
        enumsortorder: PgCatalog.Types.PgEnum["enumsortorder"];
        enumlabel: PgCatalog.Types.PgEnum["enumlabel"];
      };
      export type ByEnumtypidEnumlabel = {
        enumtypid: PgCatalog.Types.Oid;
        enumlabel: PgCatalog.Types.Cstring;
      };

      export type ByEnumtypidEnumsortorder = {
        enumtypid: PgCatalog.Types.Oid;
        enumsortorder: PgCatalog.Types.Float4;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgNamespace {
      export type Record = {
        oid: PgCatalog.Types.PgNamespace["oid"];
        nspname: PgCatalog.Types.PgNamespace["nspname"];
        nspowner: PgCatalog.Types.PgNamespace["nspowner"];
        nspacl: PgCatalog.Types.PgNamespace["nspacl"] | null;
      };
      export type ByNspname = {
        nspname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgConversion {
      export type Record = {
        oid: PgCatalog.Types.PgConversion["oid"];
        conname: PgCatalog.Types.PgConversion["conname"];
        connamespace: PgCatalog.Types.PgConversion["connamespace"];
        conowner: PgCatalog.Types.PgConversion["conowner"];
        conforencoding: PgCatalog.Types.PgConversion["conforencoding"];
        contoencoding: PgCatalog.Types.PgConversion["contoencoding"];
        conproc: PgCatalog.Types.PgConversion["conproc"];
        condefault: PgCatalog.Types.PgConversion["condefault"];
      };
      export type ByConnameConnamespace = {
        conname: PgCatalog.Types.Cstring;
        connamespace: PgCatalog.Types.Oid;
      };

      export type ByConnamespaceConforencodingContoencodingOid = {
        connamespace: PgCatalog.Types.Oid;
        conforencoding: PgCatalog.Types.Int4;
        contoencoding: PgCatalog.Types.Int4;
        oid: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgDepend {
      export type Record = {
        classid: PgCatalog.Types.PgDepend["classid"];
        objid: PgCatalog.Types.PgDepend["objid"];
        objsubid: PgCatalog.Types.PgDepend["objsubid"];
        refclassid: PgCatalog.Types.PgDepend["refclassid"];
        refobjid: PgCatalog.Types.PgDepend["refobjid"];
        refobjsubid: PgCatalog.Types.PgDepend["refobjsubid"];
        deptype: PgCatalog.Types.PgDepend["deptype"];
      };
      export type ByClassidObjidObjsubid = {
        classid: PgCatalog.Types.Oid;
        objid: PgCatalog.Types.Oid;
        objsubid: PgCatalog.Types.Int4;
      };

      export type ByRefclassidRefobjidRefobjsubid = {
        refclassid: PgCatalog.Types.Oid;
        refobjid: PgCatalog.Types.Oid;
        refobjsubid: PgCatalog.Types.Int4;
      };

      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgDatabase {
      export type Record = {
        oid: PgCatalog.Types.PgDatabase["oid"];
        datname: PgCatalog.Types.PgDatabase["datname"];
        datdba: PgCatalog.Types.PgDatabase["datdba"];
        encoding: PgCatalog.Types.PgDatabase["encoding"];
        datlocprovider: PgCatalog.Types.PgDatabase["datlocprovider"];
        datistemplate: PgCatalog.Types.PgDatabase["datistemplate"];
        datallowconn: PgCatalog.Types.PgDatabase["datallowconn"];
        datconnlimit: PgCatalog.Types.PgDatabase["datconnlimit"];
        datfrozenxid: PgCatalog.Types.PgDatabase["datfrozenxid"];
        datminmxid: PgCatalog.Types.PgDatabase["datminmxid"];
        dattablespace: PgCatalog.Types.PgDatabase["dattablespace"];
        datcollate: PgCatalog.Types.PgDatabase["datcollate"];
        datctype: PgCatalog.Types.PgDatabase["datctype"];
        daticulocale: PgCatalog.Types.PgDatabase["daticulocale"] | null;
        daticurules: PgCatalog.Types.PgDatabase["daticurules"] | null;
        datcollversion: PgCatalog.Types.PgDatabase["datcollversion"] | null;
        datacl: PgCatalog.Types.PgDatabase["datacl"] | null;
      };
      export type ByDatname = {
        datname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgDbRoleSetting {
      export type Record = {
        setdatabase: PgCatalog.Types.PgDbRoleSetting["setdatabase"];
        setrole: PgCatalog.Types.PgDbRoleSetting["setrole"];
        setconfig: PgCatalog.Types.PgDbRoleSetting["setconfig"] | null;
      };
      export type BySetdatabaseSetrole = {
        setdatabase: PgCatalog.Types.Oid;
        setrole: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = BySetdatabaseSetrole;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTablespace {
      export type Record = {
        oid: PgCatalog.Types.PgTablespace["oid"];
        spcname: PgCatalog.Types.PgTablespace["spcname"];
        spcowner: PgCatalog.Types.PgTablespace["spcowner"];
        spcacl: PgCatalog.Types.PgTablespace["spcacl"] | null;
        spcoptions: PgCatalog.Types.PgTablespace["spcoptions"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type BySpcname = {
        spcname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgAuthMembers {
      export type Record = {
        oid: PgCatalog.Types.PgAuthMembers["oid"];
        roleid: PgCatalog.Types.PgAuthMembers["roleid"];
        member: PgCatalog.Types.PgAuthMembers["member"];
        grantor: PgCatalog.Types.PgAuthMembers["grantor"];
        adminOption: PgCatalog.Types.PgAuthMembers["adminOption"];
        inheritOption: PgCatalog.Types.PgAuthMembers["inheritOption"];
        setOption: PgCatalog.Types.PgAuthMembers["setOption"];
      };
      export type ByGrantor = {
        grantor: PgCatalog.Types.Oid;
      };

      export type ByMemberRoleidGrantor = {
        member: PgCatalog.Types.Oid;
        roleid: PgCatalog.Types.Oid;
        grantor: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByRoleidMemberGrantor = {
        roleid: PgCatalog.Types.Oid;
        member: PgCatalog.Types.Oid;
        grantor: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgShdepend {
      export type Record = {
        dbid: PgCatalog.Types.PgShdepend["dbid"];
        classid: PgCatalog.Types.PgShdepend["classid"];
        objid: PgCatalog.Types.PgShdepend["objid"];
        objsubid: PgCatalog.Types.PgShdepend["objsubid"];
        refclassid: PgCatalog.Types.PgShdepend["refclassid"];
        refobjid: PgCatalog.Types.PgShdepend["refobjid"];
        deptype: PgCatalog.Types.PgShdepend["deptype"];
      };
      export type ByDbidClassidObjidObjsubid = {
        dbid: PgCatalog.Types.Oid;
        classid: PgCatalog.Types.Oid;
        objid: PgCatalog.Types.Oid;
        objsubid: PgCatalog.Types.Int4;
      };

      export type ByRefclassidRefobjid = {
        refclassid: PgCatalog.Types.Oid;
        refobjid: PgCatalog.Types.Oid;
      };

      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgShdescription {
      export type Record = {
        objoid: PgCatalog.Types.PgShdescription["objoid"];
        classoid: PgCatalog.Types.PgShdescription["classoid"];
        description: PgCatalog.Types.PgShdescription["description"];
      };
      export type ByObjoidClassoid = {
        objoid: PgCatalog.Types.Oid;
        classoid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByObjoidClassoid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTsConfig {
      export type Record = {
        oid: PgCatalog.Types.PgTsConfig["oid"];
        cfgname: PgCatalog.Types.PgTsConfig["cfgname"];
        cfgnamespace: PgCatalog.Types.PgTsConfig["cfgnamespace"];
        cfgowner: PgCatalog.Types.PgTsConfig["cfgowner"];
        cfgparser: PgCatalog.Types.PgTsConfig["cfgparser"];
      };
      export type ByCfgnameCfgnamespace = {
        cfgname: PgCatalog.Types.Cstring;
        cfgnamespace: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTsConfigMap {
      export type Record = {
        mapcfg: PgCatalog.Types.PgTsConfigMap["mapcfg"];
        maptokentype: PgCatalog.Types.PgTsConfigMap["maptokentype"];
        mapseqno: PgCatalog.Types.PgTsConfigMap["mapseqno"];
        mapdict: PgCatalog.Types.PgTsConfigMap["mapdict"];
      };
      export type ByMapcfgMaptokentypeMapseqno = {
        mapcfg: PgCatalog.Types.Oid;
        maptokentype: PgCatalog.Types.Int4;
        mapseqno: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByMapcfgMaptokentypeMapseqno;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTsDict {
      export type Record = {
        oid: PgCatalog.Types.PgTsDict["oid"];
        dictname: PgCatalog.Types.PgTsDict["dictname"];
        dictnamespace: PgCatalog.Types.PgTsDict["dictnamespace"];
        dictowner: PgCatalog.Types.PgTsDict["dictowner"];
        dicttemplate: PgCatalog.Types.PgTsDict["dicttemplate"];
        dictinitoption: PgCatalog.Types.PgTsDict["dictinitoption"] | null;
      };
      export type ByDictnameDictnamespace = {
        dictname: PgCatalog.Types.Cstring;
        dictnamespace: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTsParser {
      export type Record = {
        oid: PgCatalog.Types.PgTsParser["oid"];
        prsname: PgCatalog.Types.PgTsParser["prsname"];
        prsnamespace: PgCatalog.Types.PgTsParser["prsnamespace"];
        prsstart: PgCatalog.Types.PgTsParser["prsstart"];
        prstoken: PgCatalog.Types.PgTsParser["prstoken"];
        prsend: PgCatalog.Types.PgTsParser["prsend"];
        prsheadline: PgCatalog.Types.PgTsParser["prsheadline"];
        prslextype: PgCatalog.Types.PgTsParser["prslextype"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPrsnamePrsnamespace = {
        prsname: PgCatalog.Types.Cstring;
        prsnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTsTemplate {
      export type Record = {
        oid: PgCatalog.Types.PgTsTemplate["oid"];
        tmplname: PgCatalog.Types.PgTsTemplate["tmplname"];
        tmplnamespace: PgCatalog.Types.PgTsTemplate["tmplnamespace"];
        tmplinit: PgCatalog.Types.PgTsTemplate["tmplinit"];
        tmpllexize: PgCatalog.Types.PgTsTemplate["tmpllexize"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByTmplnameTmplnamespace = {
        tmplname: PgCatalog.Types.Cstring;
        tmplnamespace: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgExtension {
      export type Record = {
        oid: PgCatalog.Types.PgExtension["oid"];
        extname: PgCatalog.Types.PgExtension["extname"];
        extowner: PgCatalog.Types.PgExtension["extowner"];
        extnamespace: PgCatalog.Types.PgExtension["extnamespace"];
        extrelocatable: PgCatalog.Types.PgExtension["extrelocatable"];
        extversion: PgCatalog.Types.PgExtension["extversion"];
        extconfig: PgCatalog.Types.PgExtension["extconfig"] | null;
        extcondition: PgCatalog.Types.PgExtension["extcondition"] | null;
      };
      export type ByExtname = {
        extname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgForeignDataWrapper {
      export type Record = {
        oid: PgCatalog.Types.PgForeignDataWrapper["oid"];
        fdwname: PgCatalog.Types.PgForeignDataWrapper["fdwname"];
        fdwowner: PgCatalog.Types.PgForeignDataWrapper["fdwowner"];
        fdwhandler: PgCatalog.Types.PgForeignDataWrapper["fdwhandler"];
        fdwvalidator: PgCatalog.Types.PgForeignDataWrapper["fdwvalidator"];
        fdwacl: PgCatalog.Types.PgForeignDataWrapper["fdwacl"] | null;
        fdwoptions: PgCatalog.Types.PgForeignDataWrapper["fdwoptions"] | null;
      };
      export type ByFdwname = {
        fdwname: PgCatalog.Types.Cstring;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgForeignServer {
      export type Record = {
        oid: PgCatalog.Types.PgForeignServer["oid"];
        srvname: PgCatalog.Types.PgForeignServer["srvname"];
        srvowner: PgCatalog.Types.PgForeignServer["srvowner"];
        srvfdw: PgCatalog.Types.PgForeignServer["srvfdw"];
        srvtype: PgCatalog.Types.PgForeignServer["srvtype"] | null;
        srvversion: PgCatalog.Types.PgForeignServer["srvversion"] | null;
        srvacl: PgCatalog.Types.PgForeignServer["srvacl"] | null;
        srvoptions: PgCatalog.Types.PgForeignServer["srvoptions"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type BySrvname = {
        srvname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgPolicy {
      export type Record = {
        oid: PgCatalog.Types.PgPolicy["oid"];
        polname: PgCatalog.Types.PgPolicy["polname"];
        polrelid: PgCatalog.Types.PgPolicy["polrelid"];
        polcmd: PgCatalog.Types.PgPolicy["polcmd"];
        polpermissive: PgCatalog.Types.PgPolicy["polpermissive"];
        polroles: PgCatalog.Types.PgPolicy["polroles"];
        polqual: PgCatalog.Types.PgPolicy["polqual"] | null;
        polwithcheck: PgCatalog.Types.PgPolicy["polwithcheck"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPolrelidPolname = {
        polrelid: PgCatalog.Types.Oid;
        polname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgReplicationOrigin {
      export type Record = {
        roident: PgCatalog.Types.PgReplicationOrigin["roident"];
        roname: PgCatalog.Types.PgReplicationOrigin["roname"];
      };
      export type ByRoident = {
        roident: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByRoident;
      export type ByRoname = {
        roname: PgCatalog.Types.Text;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgDefaultAcl {
      export type Record = {
        oid: PgCatalog.Types.PgDefaultAcl["oid"];
        defaclrole: PgCatalog.Types.PgDefaultAcl["defaclrole"];
        defaclnamespace: PgCatalog.Types.PgDefaultAcl["defaclnamespace"];
        defaclobjtype: PgCatalog.Types.PgDefaultAcl["defaclobjtype"];
        defaclacl: PgCatalog.Types.PgDefaultAcl["defaclacl"];
      };
      export type ByDefaclroleDefaclnamespaceDefaclobjtype = {
        defaclrole: PgCatalog.Types.Oid;
        defaclnamespace: PgCatalog.Types.Oid;
        defaclobjtype: PgCatalog.Types.Char;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgInitPrivs {
      export type Record = {
        objoid: PgCatalog.Types.PgInitPrivs["objoid"];
        classoid: PgCatalog.Types.PgInitPrivs["classoid"];
        objsubid: PgCatalog.Types.PgInitPrivs["objsubid"];
        privtype: PgCatalog.Types.PgInitPrivs["privtype"];
        initprivs: PgCatalog.Types.PgInitPrivs["initprivs"];
      };
      export type ByObjoidClassoidObjsubid = {
        objoid: PgCatalog.Types.Oid;
        classoid: PgCatalog.Types.Oid;
        objsubid: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByObjoidClassoidObjsubid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgSeclabel {
      export type Record = {
        objoid: PgCatalog.Types.PgSeclabel["objoid"];
        classoid: PgCatalog.Types.PgSeclabel["classoid"];
        objsubid: PgCatalog.Types.PgSeclabel["objsubid"];
        provider: PgCatalog.Types.PgSeclabel["provider"];
        label: PgCatalog.Types.PgSeclabel["label"];
      };
      export type ByObjoidClassoidObjsubidProvider = {
        objoid: PgCatalog.Types.Oid;
        classoid: PgCatalog.Types.Oid;
        objsubid: PgCatalog.Types.Int4;
        provider: PgCatalog.Types.Text;
      };
      export type PrimaryKey = ByObjoidClassoidObjsubidProvider;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgShseclabel {
      export type Record = {
        objoid: PgCatalog.Types.PgShseclabel["objoid"];
        classoid: PgCatalog.Types.PgShseclabel["classoid"];
        provider: PgCatalog.Types.PgShseclabel["provider"];
        label: PgCatalog.Types.PgShseclabel["label"];
      };
      export type ByObjoidClassoidProvider = {
        objoid: PgCatalog.Types.Oid;
        classoid: PgCatalog.Types.Oid;
        provider: PgCatalog.Types.Text;
      };
      export type PrimaryKey = ByObjoidClassoidProvider;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgCollation {
      export type Record = {
        oid: PgCatalog.Types.PgCollation["oid"];
        collname: PgCatalog.Types.PgCollation["collname"];
        collnamespace: PgCatalog.Types.PgCollation["collnamespace"];
        collowner: PgCatalog.Types.PgCollation["collowner"];
        collprovider: PgCatalog.Types.PgCollation["collprovider"];
        collisdeterministic: PgCatalog.Types.PgCollation["collisdeterministic"];
        collencoding: PgCatalog.Types.PgCollation["collencoding"];
        collcollate: PgCatalog.Types.PgCollation["collcollate"] | null;
        collctype: PgCatalog.Types.PgCollation["collctype"] | null;
        colliculocale: PgCatalog.Types.PgCollation["colliculocale"] | null;
        collicurules: PgCatalog.Types.PgCollation["collicurules"] | null;
        collversion: PgCatalog.Types.PgCollation["collversion"] | null;
      };
      export type ByCollnameCollencodingCollnamespace = {
        collname: PgCatalog.Types.Cstring;
        collencoding: PgCatalog.Types.Int4;
        collnamespace: PgCatalog.Types.Oid;
      };

      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgParameterAcl {
      export type Record = {
        oid: PgCatalog.Types.PgParameterAcl["oid"];
        parname: PgCatalog.Types.PgParameterAcl["parname"];
        paracl: PgCatalog.Types.PgParameterAcl["paracl"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByParname = {
        parname: PgCatalog.Types.Text;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgPartitionedTable {
      export type Record = {
        partrelid: PgCatalog.Types.PgPartitionedTable["partrelid"];
        partstrat: PgCatalog.Types.PgPartitionedTable["partstrat"];
        partnatts: PgCatalog.Types.PgPartitionedTable["partnatts"];
        partdefid: PgCatalog.Types.PgPartitionedTable["partdefid"];
        partattrs: PgCatalog.Types.PgPartitionedTable["partattrs"];
        partclass: PgCatalog.Types.PgPartitionedTable["partclass"];
        partcollation: PgCatalog.Types.PgPartitionedTable["partcollation"];
        partexprs: PgCatalog.Types.PgPartitionedTable["partexprs"] | null;
      };
      export type ByPartrelid = {
        partrelid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByPartrelid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgRange {
      export type Record = {
        rngtypid: PgCatalog.Types.PgRange["rngtypid"];
        rngsubtype: PgCatalog.Types.PgRange["rngsubtype"];
        rngmultitypid: PgCatalog.Types.PgRange["rngmultitypid"];
        rngcollation: PgCatalog.Types.PgRange["rngcollation"];
        rngsubopc: PgCatalog.Types.PgRange["rngsubopc"];
        rngcanonical: PgCatalog.Types.PgRange["rngcanonical"];
        rngsubdiff: PgCatalog.Types.PgRange["rngsubdiff"];
      };
      export type ByRngmultitypid = {
        rngmultitypid: PgCatalog.Types.Oid;
      };

      export type ByRngtypid = {
        rngtypid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByRngtypid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgTransform {
      export type Record = {
        oid: PgCatalog.Types.PgTransform["oid"];
        trftype: PgCatalog.Types.PgTransform["trftype"];
        trflang: PgCatalog.Types.PgTransform["trflang"];
        trffromsql: PgCatalog.Types.PgTransform["trffromsql"];
        trftosql: PgCatalog.Types.PgTransform["trftosql"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByTrftypeTrflang = {
        trftype: PgCatalog.Types.Oid;
        trflang: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgSequence {
      export type Record = {
        seqrelid: PgCatalog.Types.PgSequence["seqrelid"];
        seqtypid: PgCatalog.Types.PgSequence["seqtypid"];
        seqstart: PgCatalog.Types.PgSequence["seqstart"];
        seqincrement: PgCatalog.Types.PgSequence["seqincrement"];
        seqmax: PgCatalog.Types.PgSequence["seqmax"];
        seqmin: PgCatalog.Types.PgSequence["seqmin"];
        seqcache: PgCatalog.Types.PgSequence["seqcache"];
        seqcycle: PgCatalog.Types.PgSequence["seqcycle"];
      };
      export type BySeqrelid = {
        seqrelid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = BySeqrelid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgPublication {
      export type Record = {
        oid: PgCatalog.Types.PgPublication["oid"];
        pubname: PgCatalog.Types.PgPublication["pubname"];
        pubowner: PgCatalog.Types.PgPublication["pubowner"];
        puballtables: PgCatalog.Types.PgPublication["puballtables"];
        pubinsert: PgCatalog.Types.PgPublication["pubinsert"];
        pubupdate: PgCatalog.Types.PgPublication["pubupdate"];
        pubdelete: PgCatalog.Types.PgPublication["pubdelete"];
        pubtruncate: PgCatalog.Types.PgPublication["pubtruncate"];
        pubviaroot: PgCatalog.Types.PgPublication["pubviaroot"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPubname = {
        pubname: PgCatalog.Types.Cstring;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgPublicationNamespace {
      export type Record = {
        oid: PgCatalog.Types.PgPublicationNamespace["oid"];
        pnpubid: PgCatalog.Types.PgPublicationNamespace["pnpubid"];
        pnnspid: PgCatalog.Types.PgPublicationNamespace["pnnspid"];
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPnnspidPnpubid = {
        pnnspid: PgCatalog.Types.Oid;
        pnpubid: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgPublicationRel {
      export type Record = {
        oid: PgCatalog.Types.PgPublicationRel["oid"];
        prpubid: PgCatalog.Types.PgPublicationRel["prpubid"];
        prrelid: PgCatalog.Types.PgPublicationRel["prrelid"];
        prqual: PgCatalog.Types.PgPublicationRel["prqual"] | null;
        prattrs: PgCatalog.Types.PgPublicationRel["prattrs"] | null;
      };
      export type ByOid = {
        oid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = ByOid;
      export type ByPrpubid = {
        prpubid: PgCatalog.Types.Oid;
      };

      export type ByPrrelidPrpubid = {
        prrelid: PgCatalog.Types.Oid;
        prpubid: PgCatalog.Types.Oid;
      };

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgSubscriptionRel {
      export type Record = {
        srsubid: PgCatalog.Types.PgSubscriptionRel["srsubid"];
        srrelid: PgCatalog.Types.PgSubscriptionRel["srrelid"];
        srsubstate: PgCatalog.Types.PgSubscriptionRel["srsubstate"];
        srsublsn: PgCatalog.Types.PgSubscriptionRel["srsublsn"] | null;
      };
      export type BySrrelidSrsubid = {
        srrelid: PgCatalog.Types.Oid;
        srsubid: PgCatalog.Types.Oid;
      };
      export type PrimaryKey = BySrrelidSrsubid;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace PgLargeobject {
      export type Record = {
        loid: PgCatalog.Types.PgLargeobject["loid"];
        pageno: PgCatalog.Types.PgLargeobject["pageno"];
        data: PgCatalog.Types.PgLargeobject["data"];
      };
      export type ByLoidPageno = {
        loid: PgCatalog.Types.Oid;
        pageno: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByLoidPageno;

      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
  }
}
export namespace Public {
  export namespace Types {
    export type ActorArray = Array<Public.Types.Actor>;
    export type ActorInfoArray = Array<Public.Types.ActorInfo>;
    export type AddressArray = Array<Public.Types.Address>;
    export type CategoryArray = Array<Public.Types.Category>;
    export type CityArray = Array<Public.Types.City>;
    export type CountryArray = Array<Public.Types.Country>;
    export type CustomerArray = Array<Public.Types.Customer>;
    export type CustomerListArray = Array<Public.Types.CustomerList>;
    export type FilmArray = Array<Public.Types.Film>;
    export type FilmActorArray = Array<Public.Types.FilmActor>;
    export type FilmCategoryArray = Array<Public.Types.FilmCategory>;
    export type FilmListArray = Array<Public.Types.FilmList>;
    export type InventoryArray = Array<Public.Types.Inventory>;
    export type LanguageArray = Array<Public.Types.Language>;
    export type MpaaRatingArray = Array<Public.Types.MpaaRating>;
    export type NicerButSlowerFilmListArray =
      Array<Public.Types.NicerButSlowerFilmList>;
    export type PaymentArray = Array<Public.Types.Payment>;
    export type RentalArray = Array<Public.Types.Rental>;
    export type SalesByFilmCategoryArray =
      Array<Public.Types.SalesByFilmCategory>;
    export type SalesByStoreArray = Array<Public.Types.SalesByStore>;
    export type StaffArray = Array<Public.Types.Staff>;
    export type StaffListArray = Array<Public.Types.StaffList>;
    export type StoreArray = Array<Public.Types.Store>;
    export type YearArray = Array<Public.Types.Year>;
    export type Actor = {
      actorId: PgCatalog.Types.Int4;
      firstName: PgCatalog.Types.Varchar;
      lastName: PgCatalog.Types.Varchar;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type ActorInfo = {
      actorId: Nullable<PgCatalog.Types.Int4>;
      firstName: Nullable<PgCatalog.Types.Varchar>;
      lastName: Nullable<PgCatalog.Types.Varchar>;
      filmInfo: Nullable<PgCatalog.Types.Text>;
    };
    export type Address = {
      addressId: PgCatalog.Types.Int4;
      address: PgCatalog.Types.Varchar;
      address2: Nullable<PgCatalog.Types.Varchar>;
      district: PgCatalog.Types.Varchar;
      cityId: PgCatalog.Types.Int2;
      postalCode: Nullable<PgCatalog.Types.Varchar>;
      phone: PgCatalog.Types.Varchar;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type Category = {
      categoryId: PgCatalog.Types.Int4;
      name: PgCatalog.Types.Varchar;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type City = {
      cityId: PgCatalog.Types.Int4;
      city: PgCatalog.Types.Varchar;
      countryId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type Country = {
      countryId: PgCatalog.Types.Int4;
      country: PgCatalog.Types.Varchar;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type Customer = {
      customerId: PgCatalog.Types.Int4;
      storeId: PgCatalog.Types.Int2;
      firstName: PgCatalog.Types.Varchar;
      lastName: PgCatalog.Types.Varchar;
      email: Nullable<PgCatalog.Types.Varchar>;
      addressId: PgCatalog.Types.Int2;
      activebool: PgCatalog.Types.Bool;
      createDate: PgCatalog.Types.Date;
      lastUpdate: Nullable<PgCatalog.Types.Timestamp>;
      active: Nullable<PgCatalog.Types.Int4>;
    };
    export type CustomerList = {
      id: Nullable<PgCatalog.Types.Int4>;
      name: Nullable<PgCatalog.Types.Text>;
      address: Nullable<PgCatalog.Types.Varchar>;
      zipCode: Nullable<PgCatalog.Types.Varchar>;
      phone: Nullable<PgCatalog.Types.Varchar>;
      city: Nullable<PgCatalog.Types.Varchar>;
      country: Nullable<PgCatalog.Types.Varchar>;
      notes: Nullable<PgCatalog.Types.Text>;
      sid: Nullable<PgCatalog.Types.Int2>;
    };
    export type Film = {
      filmId: PgCatalog.Types.Int4;
      title: PgCatalog.Types.Varchar;
      description: Nullable<PgCatalog.Types.Text>;
      releaseYear: Nullable<Public.Types.Year>;
      languageId: PgCatalog.Types.Int2;
      rentalDuration: PgCatalog.Types.Int2;
      rentalRate: PgCatalog.Types.Numeric;
      length: Nullable<PgCatalog.Types.Int2>;
      replacementCost: PgCatalog.Types.Numeric;
      rating: Nullable<Public.Types.MpaaRating>;
      lastUpdate: PgCatalog.Types.Timestamp;
      specialFeatures: PgCatalog.Types.TextArray;
      fulltext: PgCatalog.Types.Tsvector;
    };
    export type FilmActor = {
      actorId: PgCatalog.Types.Int2;
      filmId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type FilmCategory = {
      filmId: PgCatalog.Types.Int2;
      categoryId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type FilmList = {
      fid: Nullable<PgCatalog.Types.Int4>;
      title: Nullable<PgCatalog.Types.Varchar>;
      description: Nullable<PgCatalog.Types.Text>;
      category: Nullable<PgCatalog.Types.Varchar>;
      price: Nullable<PgCatalog.Types.Numeric>;
      length: Nullable<PgCatalog.Types.Int2>;
      rating: Nullable<Public.Types.MpaaRating>;
      actors: Nullable<PgCatalog.Types.Text>;
    };
    export type Inventory = {
      inventoryId: PgCatalog.Types.Int4;
      filmId: PgCatalog.Types.Int2;
      storeId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type Language = {
      languageId: PgCatalog.Types.Int4;
      name: PgCatalog.Types.Bpchar;
      lastUpdate: PgCatalog.Types.Timestamp;
    };

    export enum MpaaRating {
      G = "G",
      PG = "PG",
      PG_13 = "PG-13",
      R = "R",
      NC_17 = "NC-17",
    }

    export type NicerButSlowerFilmList = {
      fid: Nullable<PgCatalog.Types.Int4>;
      title: Nullable<PgCatalog.Types.Varchar>;
      description: Nullable<PgCatalog.Types.Text>;
      category: Nullable<PgCatalog.Types.Varchar>;
      price: Nullable<PgCatalog.Types.Numeric>;
      length: Nullable<PgCatalog.Types.Int2>;
      rating: Nullable<Public.Types.MpaaRating>;
      actors: Nullable<PgCatalog.Types.Text>;
    };
    export type Payment = {
      paymentId: PgCatalog.Types.Int4;
      customerId: PgCatalog.Types.Int2;
      staffId: PgCatalog.Types.Int2;
      rentalId: PgCatalog.Types.Int4;
      amount: PgCatalog.Types.Numeric;
      paymentDate: PgCatalog.Types.Timestamp;
    };
    export type Rental = {
      rentalId: PgCatalog.Types.Int4;
      rentalDate: PgCatalog.Types.Timestamp;
      inventoryId: PgCatalog.Types.Int4;
      customerId: PgCatalog.Types.Int2;
      returnDate: Nullable<PgCatalog.Types.Timestamp>;
      staffId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type SalesByFilmCategory = {
      category: Nullable<PgCatalog.Types.Varchar>;
      totalSales: Nullable<PgCatalog.Types.Numeric>;
    };
    export type SalesByStore = {
      store: Nullable<PgCatalog.Types.Text>;
      manager: Nullable<PgCatalog.Types.Text>;
      totalSales: Nullable<PgCatalog.Types.Numeric>;
    };
    export type Staff = {
      staffId: PgCatalog.Types.Int4;
      firstName: PgCatalog.Types.Varchar;
      lastName: PgCatalog.Types.Varchar;
      addressId: PgCatalog.Types.Int2;
      email: Nullable<PgCatalog.Types.Varchar>;
      storeId: PgCatalog.Types.Int2;
      active: PgCatalog.Types.Bool;
      username: PgCatalog.Types.Varchar;
      password: Nullable<PgCatalog.Types.Varchar>;
      lastUpdate: PgCatalog.Types.Timestamp;
      picture: Nullable<PgCatalog.Types.Bytea>;
    };
    export type StaffList = {
      id: Nullable<PgCatalog.Types.Int4>;
      name: Nullable<PgCatalog.Types.Text>;
      address: Nullable<PgCatalog.Types.Varchar>;
      zipCode: Nullable<PgCatalog.Types.Varchar>;
      phone: Nullable<PgCatalog.Types.Varchar>;
      city: Nullable<PgCatalog.Types.Varchar>;
      country: Nullable<PgCatalog.Types.Varchar>;
      sid: Nullable<PgCatalog.Types.Int2>;
    };
    export type Store = {
      storeId: PgCatalog.Types.Int4;
      managerStaffId: PgCatalog.Types.Int2;
      addressId: PgCatalog.Types.Int2;
      lastUpdate: PgCatalog.Types.Timestamp;
    };
    export type Year = PgCatalog.Types.Int4;
  }
  export namespace Procedures {
    export namespace FilmInStock {
      export type Parameters = {
        pFilmId: Nullable<PgCatalog.Types.Int4>;
        pStoreId: Nullable<PgCatalog.Types.Int4>;
      };
      export type Results = Nullable<PgCatalog.Types.Int4>;
    }
    export namespace FilmNotInStock {
      export type Parameters = {
        pFilmId: Nullable<PgCatalog.Types.Int4>;
        pStoreId: Nullable<PgCatalog.Types.Int4>;
      };
      export type Results = Nullable<PgCatalog.Types.Int4>;
    }
    export namespace GetCustomerBalance {
      export type Parameters = {
        pCustomerId: Nullable<PgCatalog.Types.Int4>;
        pEffectiveDate: Nullable<PgCatalog.Types.Timestamp>;
      };
      export type Results = Nullable<PgCatalog.Types.Numeric>;
    }
    export namespace InventoryHeldByCustomer {
      export type Parameters = { pInventoryId: Nullable<PgCatalog.Types.Int4> };
      export type Results = Nullable<PgCatalog.Types.Int4>;
    }
    export namespace InventoryInStock {
      export type Parameters = { pInventoryId: Nullable<PgCatalog.Types.Int4> };
      export type Results = Nullable<PgCatalog.Types.Bool>;
    }
    export namespace LastDay {
      export type Parameters = {
        argument_0: Nullable<PgCatalog.Types.Timestamp>;
      };
      export type Results = Nullable<PgCatalog.Types.Date>;
    }
    export namespace RewardsReport {
      export type Parameters = {
        minMonthlyPurchases: Nullable<PgCatalog.Types.Int4>;
        minDollarAmountPurchased: Nullable<PgCatalog.Types.Numeric>;
      };
      export type Results = NullableMembers<Public.Types.Customer>;
    }
  }
  export namespace Tables {
    export namespace FilmActor {
      export type Record = {
        actorId: Public.Types.FilmActor["actorId"];
        filmId: Public.Types.FilmActor["filmId"];
        lastUpdate: Public.Types.FilmActor["lastUpdate"];
      };
      export type ByActorIdFilmId = {
        actorId: PgCatalog.Types.Int2;
        filmId: PgCatalog.Types.Int2;
      };
      export type PrimaryKey = ByActorIdFilmId;
      export type ByFilmId = {
        filmId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<Record, "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Address {
      export type Record = {
        addressId: Public.Types.Address["addressId"];
        address: Public.Types.Address["address"];
        address2: Public.Types.Address["address2"] | null;
        district: Public.Types.Address["district"];
        cityId: Public.Types.Address["cityId"];
        postalCode: Public.Types.Address["postalCode"] | null;
        phone: Public.Types.Address["phone"];
        lastUpdate: Public.Types.Address["lastUpdate"];
      };
      export type ByAddressId = {
        addressId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByAddressId;
      export type ByCityId = {
        cityId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<Record, "addressId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace City {
      export type Record = {
        cityId: Public.Types.City["cityId"];
        city: Public.Types.City["city"];
        countryId: Public.Types.City["countryId"];
        lastUpdate: Public.Types.City["lastUpdate"];
      };
      export type ByCityId = {
        cityId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByCityId;
      export type ByCountryId = {
        countryId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<Record, "cityId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Customer {
      export type Record = {
        customerId: Public.Types.Customer["customerId"];
        storeId: Public.Types.Customer["storeId"];
        firstName: Public.Types.Customer["firstName"];
        lastName: Public.Types.Customer["lastName"];
        email: Public.Types.Customer["email"] | null;
        addressId: Public.Types.Customer["addressId"];
        activebool: Public.Types.Customer["activebool"];
        createDate: Public.Types.Customer["createDate"];
        lastUpdate: Public.Types.Customer["lastUpdate"] | null;
        active: Public.Types.Customer["active"] | null;
      };
      export type ByAddressId = {
        addressId: PgCatalog.Types.Int2;
      };

      export type ByCustomerId = {
        customerId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByCustomerId;
      export type ByLastName = {
        lastName: PgCatalog.Types.Varchar;
      };

      export type ByStoreId = {
        storeId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<
        Record,
        "customerId" | "activebool" | "createDate" | "lastUpdate"
      >;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Actor {
      export type Record = {
        actorId: Public.Types.Actor["actorId"];
        firstName: Public.Types.Actor["firstName"];
        lastName: Public.Types.Actor["lastName"];
        lastUpdate: Public.Types.Actor["lastUpdate"];
      };
      export type ByActorId = {
        actorId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByActorId;
      export type ByLastName = {
        lastName: PgCatalog.Types.Varchar;
      };

      export type Optional = Pick<Record, "actorId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace FilmCategory {
      export type Record = {
        filmId: Public.Types.FilmCategory["filmId"];
        categoryId: Public.Types.FilmCategory["categoryId"];
        lastUpdate: Public.Types.FilmCategory["lastUpdate"];
      };
      export type ByFilmIdCategoryId = {
        filmId: PgCatalog.Types.Int2;
        categoryId: PgCatalog.Types.Int2;
      };
      export type PrimaryKey = ByFilmIdCategoryId;

      export type Optional = Pick<Record, "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Inventory {
      export type Record = {
        inventoryId: Public.Types.Inventory["inventoryId"];
        filmId: Public.Types.Inventory["filmId"];
        storeId: Public.Types.Inventory["storeId"];
        lastUpdate: Public.Types.Inventory["lastUpdate"];
      };
      export type ByInventoryId = {
        inventoryId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByInventoryId;
      export type ByStoreIdFilmId = {
        storeId: PgCatalog.Types.Int2;
        filmId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<Record, "inventoryId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Category {
      export type Record = {
        categoryId: Public.Types.Category["categoryId"];
        name: Public.Types.Category["name"];
        lastUpdate: Public.Types.Category["lastUpdate"];
      };
      export type ByCategoryId = {
        categoryId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByCategoryId;

      export type Optional = Pick<Record, "categoryId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Country {
      export type Record = {
        countryId: Public.Types.Country["countryId"];
        country: Public.Types.Country["country"];
        lastUpdate: Public.Types.Country["lastUpdate"];
      };
      export type ByCountryId = {
        countryId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByCountryId;

      export type Optional = Pick<Record, "countryId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Language {
      export type Record = {
        languageId: Public.Types.Language["languageId"];
        name: Public.Types.Language["name"];
        lastUpdate: Public.Types.Language["lastUpdate"];
      };
      export type ByLanguageId = {
        languageId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByLanguageId;

      export type Optional = Pick<Record, "languageId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Rental {
      export type Record = {
        rentalId: Public.Types.Rental["rentalId"];
        rentalDate: Public.Types.Rental["rentalDate"];
        inventoryId: Public.Types.Rental["inventoryId"];
        customerId: Public.Types.Rental["customerId"];
        returnDate: Public.Types.Rental["returnDate"] | null;
        staffId: Public.Types.Rental["staffId"];
        lastUpdate: Public.Types.Rental["lastUpdate"];
      };
      export type ByInventoryId = {
        inventoryId: PgCatalog.Types.Int4;
      };

      export type ByRentalDateInventoryIdCustomerId = {
        rentalDate: PgCatalog.Types.Timestamp;
        inventoryId: PgCatalog.Types.Int4;
        customerId: PgCatalog.Types.Int2;
      };

      export type ByRentalId = {
        rentalId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByRentalId;

      export type Optional = Pick<Record, "rentalId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Staff {
      export type Record = {
        staffId: Public.Types.Staff["staffId"];
        firstName: Public.Types.Staff["firstName"];
        lastName: Public.Types.Staff["lastName"];
        addressId: Public.Types.Staff["addressId"];
        email: Public.Types.Staff["email"] | null;
        storeId: Public.Types.Staff["storeId"];
        active: Public.Types.Staff["active"];
        username: Public.Types.Staff["username"];
        password: Public.Types.Staff["password"] | null;
        lastUpdate: Public.Types.Staff["lastUpdate"];
        picture: Public.Types.Staff["picture"] | null;
      };
      export type ByStaffId = {
        staffId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByStaffId;

      export type Optional = Pick<Record, "staffId" | "active" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Store {
      export type Record = {
        storeId: Public.Types.Store["storeId"];
        managerStaffId: Public.Types.Store["managerStaffId"];
        addressId: Public.Types.Store["addressId"];
        lastUpdate: Public.Types.Store["lastUpdate"];
      };
      export type ByManagerStaffId = {
        managerStaffId: PgCatalog.Types.Int2;
      };

      export type ByStoreId = {
        storeId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByStoreId;

      export type Optional = Pick<Record, "storeId" | "lastUpdate">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Payment {
      export type Record = {
        paymentId: Public.Types.Payment["paymentId"];
        customerId: Public.Types.Payment["customerId"];
        staffId: Public.Types.Payment["staffId"];
        rentalId: Public.Types.Payment["rentalId"];
        amount: Public.Types.Payment["amount"];
        paymentDate: Public.Types.Payment["paymentDate"];
      };
      export type ByCustomerId = {
        customerId: PgCatalog.Types.Int2;
      };

      export type ByPaymentId = {
        paymentId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByPaymentId;
      export type ByRentalId = {
        rentalId: PgCatalog.Types.Int4;
      };

      export type ByStaffId = {
        staffId: PgCatalog.Types.Int2;
      };

      export type Optional = Pick<Record, "paymentId">;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace Film {
      export type Record = {
        filmId: Public.Types.Film["filmId"];
        title: Public.Types.Film["title"];
        description: Public.Types.Film["description"] | null;
        releaseYear: Public.Types.Film["releaseYear"] | null;
        languageId: Public.Types.Film["languageId"];
        rentalDuration: Public.Types.Film["rentalDuration"];
        rentalRate: Public.Types.Film["rentalRate"];
        length: Public.Types.Film["length"] | null;
        replacementCost: Public.Types.Film["replacementCost"];
        rating: Public.Types.Film["rating"] | null;
        lastUpdate: Public.Types.Film["lastUpdate"];
        specialFeatures: Public.Types.Film["specialFeatures"] | null;
        fulltext: Public.Types.Film["fulltext"];
      };
      export type ByFilmId = {
        filmId: PgCatalog.Types.Int4;
      };
      export type PrimaryKey = ByFilmId;
      export type ByFulltext = {
        fulltext: PgCatalog.Types.Gtsvector;
      };

      export type ByLanguageId = {
        languageId: PgCatalog.Types.Int2;
      };

      export type ByTitle = {
        title: PgCatalog.Types.Varchar;
      };

      export type Optional = Pick<
        Record,
        | "filmId"
        | "rentalDuration"
        | "rentalRate"
        | "replacementCost"
        | "rating"
        | "lastUpdate"
      >;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
  }
}
export namespace InformationSchema {
  export namespace Types {
    export type AdministrableRoleAuthorizationsArray =
      Array<InformationSchema.Types.AdministrableRoleAuthorizations>;
    export type ApplicableRolesArray =
      Array<InformationSchema.Types.ApplicableRoles>;
    export type AttributesArray = Array<InformationSchema.Types.Attributes>;
    export type CardinalNumberArray =
      Array<InformationSchema.Types.CardinalNumber>;
    export type CharacterDataArray =
      Array<InformationSchema.Types.CharacterData>;
    export type CharacterSetsArray =
      Array<InformationSchema.Types.CharacterSets>;
    export type CheckConstraintRoutineUsageArray =
      Array<InformationSchema.Types.CheckConstraintRoutineUsage>;
    export type CheckConstraintsArray =
      Array<InformationSchema.Types.CheckConstraints>;
    export type CollationCharacterSetApplicabilityArray =
      Array<InformationSchema.Types.CollationCharacterSetApplicability>;
    export type CollationsArray = Array<InformationSchema.Types.Collations>;
    export type ColumnColumnUsageArray =
      Array<InformationSchema.Types.ColumnColumnUsage>;
    export type ColumnDomainUsageArray =
      Array<InformationSchema.Types.ColumnDomainUsage>;
    export type ColumnOptionsArray =
      Array<InformationSchema.Types.ColumnOptions>;
    export type ColumnPrivilegesArray =
      Array<InformationSchema.Types.ColumnPrivileges>;
    export type ColumnUdtUsageArray =
      Array<InformationSchema.Types.ColumnUdtUsage>;
    export type ColumnsArray = Array<InformationSchema.Types.Columns>;
    export type ConstraintColumnUsageArray =
      Array<InformationSchema.Types.ConstraintColumnUsage>;
    export type ConstraintTableUsageArray =
      Array<InformationSchema.Types.ConstraintTableUsage>;
    export type DataTypePrivilegesArray =
      Array<InformationSchema.Types.DataTypePrivileges>;
    export type DomainConstraintsArray =
      Array<InformationSchema.Types.DomainConstraints>;
    export type DomainUdtUsageArray =
      Array<InformationSchema.Types.DomainUdtUsage>;
    export type DomainsArray = Array<InformationSchema.Types.Domains>;
    export type ElementTypesArray = Array<InformationSchema.Types.ElementTypes>;
    export type EnabledRolesArray = Array<InformationSchema.Types.EnabledRoles>;
    export type ForeignDataWrapperOptionsArray =
      Array<InformationSchema.Types.ForeignDataWrapperOptions>;
    export type ForeignDataWrappersArray =
      Array<InformationSchema.Types.ForeignDataWrappers>;
    export type ForeignServerOptionsArray =
      Array<InformationSchema.Types.ForeignServerOptions>;
    export type ForeignServersArray =
      Array<InformationSchema.Types.ForeignServers>;
    export type ForeignTableOptionsArray =
      Array<InformationSchema.Types.ForeignTableOptions>;
    export type ForeignTablesArray =
      Array<InformationSchema.Types.ForeignTables>;
    export type InformationSchemaCatalogNameArray =
      Array<InformationSchema.Types.InformationSchemaCatalogName>;
    export type KeyColumnUsageArray =
      Array<InformationSchema.Types.KeyColumnUsage>;
    export type ParametersArray = Array<InformationSchema.Types.Parameters>;
    export type PgForeignDataWrappers = {
      oid: Nullable<PgCatalog.Types.Oid>;
      fdwowner: Nullable<PgCatalog.Types.Oid>;
      fdwoptions: PgCatalog.Types.TextArray;
      foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type PgForeignServers = {
      oid: Nullable<PgCatalog.Types.Oid>;
      srvoptions: PgCatalog.Types.TextArray;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
      foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type PgForeignTableColumns = {
      nspname: Nullable<PgCatalog.Types.Name>;
      relname: Nullable<PgCatalog.Types.Name>;
      attname: Nullable<PgCatalog.Types.Name>;
      attfdwoptions: PgCatalog.Types.TextArray;
    };
    export type PgForeignTables = {
      foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      ftoptions: PgCatalog.Types.TextArray;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type PgUserMappings = {
      oid: Nullable<PgCatalog.Types.Oid>;
      umoptions: PgCatalog.Types.TextArray;
      umuser: Nullable<PgCatalog.Types.Oid>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      srvowner: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ReferentialConstraintsArray =
      Array<InformationSchema.Types.ReferentialConstraints>;
    export type RoleColumnGrantsArray =
      Array<InformationSchema.Types.RoleColumnGrants>;
    export type RoleRoutineGrantsArray =
      Array<InformationSchema.Types.RoleRoutineGrants>;
    export type RoleTableGrantsArray =
      Array<InformationSchema.Types.RoleTableGrants>;
    export type RoleUdtGrantsArray =
      Array<InformationSchema.Types.RoleUdtGrants>;
    export type RoleUsageGrantsArray =
      Array<InformationSchema.Types.RoleUsageGrants>;
    export type RoutineColumnUsageArray =
      Array<InformationSchema.Types.RoutineColumnUsage>;
    export type RoutinePrivilegesArray =
      Array<InformationSchema.Types.RoutinePrivileges>;
    export type RoutineRoutineUsageArray =
      Array<InformationSchema.Types.RoutineRoutineUsage>;
    export type RoutineSequenceUsageArray =
      Array<InformationSchema.Types.RoutineSequenceUsage>;
    export type RoutineTableUsageArray =
      Array<InformationSchema.Types.RoutineTableUsage>;
    export type RoutinesArray = Array<InformationSchema.Types.Routines>;
    export type SchemataArray = Array<InformationSchema.Types.Schemata>;
    export type SequencesArray = Array<InformationSchema.Types.Sequences>;
    export type SqlFeaturesArray = Array<InformationSchema.Types.SqlFeatures>;
    export type SqlIdentifierArray =
      Array<InformationSchema.Types.SqlIdentifier>;
    export type SqlImplementationInfoArray =
      Array<InformationSchema.Types.SqlImplementationInfo>;
    export type SqlPartsArray = Array<InformationSchema.Types.SqlParts>;
    export type SqlSizingArray = Array<InformationSchema.Types.SqlSizing>;
    export type TableConstraintsArray =
      Array<InformationSchema.Types.TableConstraints>;
    export type TablePrivilegesArray =
      Array<InformationSchema.Types.TablePrivileges>;
    export type TablesArray = Array<InformationSchema.Types.Tables>;
    export type TimeStampArray = Array<InformationSchema.Types.TimeStamp>;
    export type TransformsArray = Array<InformationSchema.Types.Transforms>;
    export type TriggeredUpdateColumnsArray =
      Array<InformationSchema.Types.TriggeredUpdateColumns>;
    export type TriggersArray = Array<InformationSchema.Types.Triggers>;
    export type UdtPrivilegesArray =
      Array<InformationSchema.Types.UdtPrivileges>;
    export type UsagePrivilegesArray =
      Array<InformationSchema.Types.UsagePrivileges>;
    export type UserDefinedTypesArray =
      Array<InformationSchema.Types.UserDefinedTypes>;
    export type UserMappingOptionsArray =
      Array<InformationSchema.Types.UserMappingOptions>;
    export type UserMappingsArray = Array<InformationSchema.Types.UserMappings>;
    export type ViewColumnUsageArray =
      Array<InformationSchema.Types.ViewColumnUsage>;
    export type ViewRoutineUsageArray =
      Array<InformationSchema.Types.ViewRoutineUsage>;
    export type ViewTableUsageArray =
      Array<InformationSchema.Types.ViewTableUsage>;
    export type ViewsArray = Array<InformationSchema.Types.Views>;
    export type YesOrNoArray = Array<InformationSchema.Types.YesOrNo>;
    export type AdministrableRoleAuthorizations = {
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type ApplicableRoles = {
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type Attributes = {
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      attributeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
      attributeDefault: Nullable<InformationSchema.Types.CharacterData>;
      isNullable: Nullable<InformationSchema.Types.YesOrNo>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      attributeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      attributeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      attributeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      isDerivedReferenceAttribute: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type CardinalNumber = PgCatalog.Types.Int4;
    export type CharacterData = PgCatalog.Types.Varchar;
    export type CharacterSets = {
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterRepertoire: Nullable<InformationSchema.Types.SqlIdentifier>;
      formOfUse: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCollateCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCollateSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCollateName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type CheckConstraintRoutineUsage = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type CheckConstraints = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      checkClause: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type CollationCharacterSetApplicability = {
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Collations = {
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      padAttribute: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ColumnColumnUsage = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      dependentColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ColumnDomainUsage = {
      domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ColumnOptions = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionValue: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ColumnPrivileges = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type ColumnUdtUsage = {
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Columns = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
      columnDefault: Nullable<InformationSchema.Types.CharacterData>;
      isNullable: Nullable<InformationSchema.Types.YesOrNo>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      isSelfReferencing: Nullable<InformationSchema.Types.YesOrNo>;
      isIdentity: Nullable<InformationSchema.Types.YesOrNo>;
      identityGeneration: Nullable<InformationSchema.Types.CharacterData>;
      identityStart: Nullable<InformationSchema.Types.CharacterData>;
      identityIncrement: Nullable<InformationSchema.Types.CharacterData>;
      identityMaximum: Nullable<InformationSchema.Types.CharacterData>;
      identityMinimum: Nullable<InformationSchema.Types.CharacterData>;
      identityCycle: Nullable<InformationSchema.Types.YesOrNo>;
      isGenerated: Nullable<InformationSchema.Types.CharacterData>;
      generationExpression: Nullable<InformationSchema.Types.CharacterData>;
      isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type ConstraintColumnUsage = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ConstraintTableUsage = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type DataTypePrivileges = {
      objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectType: Nullable<InformationSchema.Types.CharacterData>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type DomainConstraints = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
      isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
      initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type DomainUdtUsage = {
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Domains = {
      domainCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      domainName: Nullable<InformationSchema.Types.SqlIdentifier>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      domainDefault: Nullable<InformationSchema.Types.CharacterData>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ElementTypes = {
      objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectType: Nullable<InformationSchema.Types.CharacterData>;
      collectionTypeIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      domainDefault: Nullable<InformationSchema.Types.CharacterData>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type EnabledRoles = {
      roleName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ForeignDataWrapperOptions = {
      foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionValue: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ForeignDataWrappers = {
      foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      libraryName: Nullable<InformationSchema.Types.CharacterData>;
      foreignDataWrapperLanguage: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ForeignServerOptions = {
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionValue: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ForeignServers = {
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignDataWrapperName: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerType: Nullable<InformationSchema.Types.CharacterData>;
      foreignServerVersion: Nullable<InformationSchema.Types.CharacterData>;
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ForeignTableOptions = {
      foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionValue: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ForeignTables = {
      foreignTableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignTableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type InformationSchemaCatalogName = {
      catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type KeyColumnUsage = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
      positionInUniqueConstraint: Nullable<InformationSchema.Types.CardinalNumber>;
    };
    export type Parameters = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      ordinalPosition: Nullable<InformationSchema.Types.CardinalNumber>;
      parameterMode: Nullable<InformationSchema.Types.CharacterData>;
      isResult: Nullable<InformationSchema.Types.YesOrNo>;
      asLocator: Nullable<InformationSchema.Types.YesOrNo>;
      parameterName: Nullable<InformationSchema.Types.SqlIdentifier>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      parameterDefault: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type ReferentialConstraints = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      uniqueConstraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      uniqueConstraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      uniqueConstraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      matchOption: Nullable<InformationSchema.Types.CharacterData>;
      updateRule: Nullable<InformationSchema.Types.CharacterData>;
      deleteRule: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type RoleColumnGrants = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoleRoutineGrants = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoleTableGrants = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
      withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoleUdtGrants = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoleUsageGrants = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectType: Nullable<InformationSchema.Types.CharacterData>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoutineColumnUsage = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type RoutinePrivileges = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type RoutineRoutineUsage = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type RoutineSequenceUsage = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type RoutineTableUsage = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Routines = {
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineType: Nullable<InformationSchema.Types.CharacterData>;
      moduleCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      moduleSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      moduleName: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      typeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      typeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      typeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      scopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      maximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      dtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      routineBody: Nullable<InformationSchema.Types.CharacterData>;
      routineDefinition: Nullable<InformationSchema.Types.CharacterData>;
      externalName: Nullable<InformationSchema.Types.CharacterData>;
      externalLanguage: Nullable<InformationSchema.Types.CharacterData>;
      parameterStyle: Nullable<InformationSchema.Types.CharacterData>;
      isDeterministic: Nullable<InformationSchema.Types.YesOrNo>;
      sqlDataAccess: Nullable<InformationSchema.Types.CharacterData>;
      isNullCall: Nullable<InformationSchema.Types.YesOrNo>;
      sqlPath: Nullable<InformationSchema.Types.CharacterData>;
      schemaLevelRoutine: Nullable<InformationSchema.Types.YesOrNo>;
      maxDynamicResultSets: Nullable<InformationSchema.Types.CardinalNumber>;
      isUserDefinedCast: Nullable<InformationSchema.Types.YesOrNo>;
      isImplicitlyInvocable: Nullable<InformationSchema.Types.YesOrNo>;
      securityType: Nullable<InformationSchema.Types.CharacterData>;
      toSqlSpecificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      toSqlSpecificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      toSqlSpecificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      asLocator: Nullable<InformationSchema.Types.YesOrNo>;
      created: Nullable<InformationSchema.Types.TimeStamp>;
      lastAltered: Nullable<InformationSchema.Types.TimeStamp>;
      newSavepointLevel: Nullable<InformationSchema.Types.YesOrNo>;
      isUdtDependent: Nullable<InformationSchema.Types.YesOrNo>;
      resultCastFromDataType: Nullable<InformationSchema.Types.CharacterData>;
      resultCastAsLocator: Nullable<InformationSchema.Types.YesOrNo>;
      resultCastCharMaxLength: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastCharOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastCharSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastCharSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastCharSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastCollationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastCollationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastCollationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastNumericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastNumericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastNumericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastDatetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastIntervalType: Nullable<InformationSchema.Types.CharacterData>;
      resultCastIntervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastTypeUdtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastTypeUdtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastTypeUdtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastScopeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastScopeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastScopeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      resultCastMaximumCardinality: Nullable<InformationSchema.Types.CardinalNumber>;
      resultCastDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Schemata = {
      catalogName: Nullable<InformationSchema.Types.SqlIdentifier>;
      schemaName: Nullable<InformationSchema.Types.SqlIdentifier>;
      schemaOwner: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCharacterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCharacterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      defaultCharacterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      sqlPath: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type Sequences = {
      sequenceCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      sequenceSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      sequenceName: Nullable<InformationSchema.Types.SqlIdentifier>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      startValue: Nullable<InformationSchema.Types.CharacterData>;
      minimumValue: Nullable<InformationSchema.Types.CharacterData>;
      maximumValue: Nullable<InformationSchema.Types.CharacterData>;
      increment: Nullable<InformationSchema.Types.CharacterData>;
      cycleOption: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type SqlFeatures = {
      featureId: Nullable<InformationSchema.Types.CharacterData>;
      featureName: Nullable<InformationSchema.Types.CharacterData>;
      subFeatureId: Nullable<InformationSchema.Types.CharacterData>;
      subFeatureName: Nullable<InformationSchema.Types.CharacterData>;
      isSupported: Nullable<InformationSchema.Types.YesOrNo>;
      isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
      comments: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type SqlIdentifier = PgCatalog.Types.Name;
    export type SqlImplementationInfo = {
      implementationInfoId: Nullable<InformationSchema.Types.CharacterData>;
      implementationInfoName: Nullable<InformationSchema.Types.CharacterData>;
      integerValue: Nullable<InformationSchema.Types.CardinalNumber>;
      characterValue: Nullable<InformationSchema.Types.CharacterData>;
      comments: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type SqlParts = {
      featureId: Nullable<InformationSchema.Types.CharacterData>;
      featureName: Nullable<InformationSchema.Types.CharacterData>;
      isSupported: Nullable<InformationSchema.Types.YesOrNo>;
      isVerifiedBy: Nullable<InformationSchema.Types.CharacterData>;
      comments: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type SqlSizing = {
      sizingId: Nullable<InformationSchema.Types.CardinalNumber>;
      sizingName: Nullable<InformationSchema.Types.CharacterData>;
      supportedValue: Nullable<InformationSchema.Types.CardinalNumber>;
      comments: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type TableConstraints = {
      constraintCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      constraintType: Nullable<InformationSchema.Types.CharacterData>;
      isDeferrable: Nullable<InformationSchema.Types.YesOrNo>;
      initiallyDeferred: Nullable<InformationSchema.Types.YesOrNo>;
      enforced: Nullable<InformationSchema.Types.YesOrNo>;
      nullsDistinct: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type TablePrivileges = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
      withHierarchy: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type Tables = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableType: Nullable<InformationSchema.Types.CharacterData>;
      selfReferencingColumnName: Nullable<InformationSchema.Types.SqlIdentifier>;
      referenceGeneration: Nullable<InformationSchema.Types.CharacterData>;
      userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
      isTyped: Nullable<InformationSchema.Types.YesOrNo>;
      commitAction: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type TimeStamp = PgCatalog.Types.Timestamptz;
    export type Transforms = {
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
      groupName: Nullable<InformationSchema.Types.SqlIdentifier>;
      transformType: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type TriggeredUpdateColumns = {
      triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectColumn: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Triggers = {
      triggerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      triggerSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      triggerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventManipulation: Nullable<InformationSchema.Types.CharacterData>;
      eventObjectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      eventObjectTable: Nullable<InformationSchema.Types.SqlIdentifier>;
      actionOrder: Nullable<InformationSchema.Types.CardinalNumber>;
      actionCondition: Nullable<InformationSchema.Types.CharacterData>;
      actionStatement: Nullable<InformationSchema.Types.CharacterData>;
      actionOrientation: Nullable<InformationSchema.Types.CharacterData>;
      actionTiming: Nullable<InformationSchema.Types.CharacterData>;
      actionReferenceOldTable: Nullable<InformationSchema.Types.SqlIdentifier>;
      actionReferenceNewTable: Nullable<InformationSchema.Types.SqlIdentifier>;
      actionReferenceOldRow: Nullable<InformationSchema.Types.SqlIdentifier>;
      actionReferenceNewRow: Nullable<InformationSchema.Types.SqlIdentifier>;
      created: Nullable<InformationSchema.Types.TimeStamp>;
    };
    export type UdtPrivileges = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      udtName: Nullable<InformationSchema.Types.SqlIdentifier>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type UsagePrivileges = {
      grantor: Nullable<InformationSchema.Types.SqlIdentifier>;
      grantee: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectName: Nullable<InformationSchema.Types.SqlIdentifier>;
      objectType: Nullable<InformationSchema.Types.CharacterData>;
      privilegeType: Nullable<InformationSchema.Types.CharacterData>;
      isGrantable: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type UserDefinedTypes = {
      userDefinedTypeCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      userDefinedTypeSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      userDefinedTypeName: Nullable<InformationSchema.Types.SqlIdentifier>;
      userDefinedTypeCategory: Nullable<InformationSchema.Types.CharacterData>;
      isInstantiable: Nullable<InformationSchema.Types.YesOrNo>;
      isFinal: Nullable<InformationSchema.Types.YesOrNo>;
      orderingForm: Nullable<InformationSchema.Types.CharacterData>;
      orderingCategory: Nullable<InformationSchema.Types.CharacterData>;
      orderingRoutineCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      orderingRoutineSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      orderingRoutineName: Nullable<InformationSchema.Types.SqlIdentifier>;
      referenceType: Nullable<InformationSchema.Types.CharacterData>;
      dataType: Nullable<InformationSchema.Types.CharacterData>;
      characterMaximumLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterOctetLength: Nullable<InformationSchema.Types.CardinalNumber>;
      characterSetCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      characterSetName: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      collationName: Nullable<InformationSchema.Types.SqlIdentifier>;
      numericPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      numericPrecisionRadix: Nullable<InformationSchema.Types.CardinalNumber>;
      numericScale: Nullable<InformationSchema.Types.CardinalNumber>;
      datetimePrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      intervalType: Nullable<InformationSchema.Types.CharacterData>;
      intervalPrecision: Nullable<InformationSchema.Types.CardinalNumber>;
      sourceDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      refDtdIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type UserMappingOptions = {
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionName: Nullable<InformationSchema.Types.SqlIdentifier>;
      optionValue: Nullable<InformationSchema.Types.CharacterData>;
    };
    export type UserMappings = {
      authorizationIdentifier: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      foreignServerName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ViewColumnUsage = {
      viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      columnName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ViewRoutineUsage = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      specificName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type ViewTableUsage = {
      viewCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      viewSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      viewName: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
    };
    export type Views = {
      tableCatalog: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableSchema: Nullable<InformationSchema.Types.SqlIdentifier>;
      tableName: Nullable<InformationSchema.Types.SqlIdentifier>;
      viewDefinition: Nullable<InformationSchema.Types.CharacterData>;
      checkOption: Nullable<InformationSchema.Types.CharacterData>;
      isUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
      isInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
      isTriggerUpdatable: Nullable<InformationSchema.Types.YesOrNo>;
      isTriggerDeletable: Nullable<InformationSchema.Types.YesOrNo>;
      isTriggerInsertableInto: Nullable<InformationSchema.Types.YesOrNo>;
    };
    export type YesOrNo = PgCatalog.Types.Varchar;
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace SqlFeatures {
      export type Record = {
        featureId: InformationSchema.Types.SqlFeatures["featureId"] | null;
        featureName: InformationSchema.Types.SqlFeatures["featureName"] | null;
        subFeatureId:
          | InformationSchema.Types.SqlFeatures["subFeatureId"]
          | null;
        subFeatureName:
          | InformationSchema.Types.SqlFeatures["subFeatureName"]
          | null;
        isSupported: InformationSchema.Types.SqlFeatures["isSupported"] | null;
        isVerifiedBy:
          | InformationSchema.Types.SqlFeatures["isVerifiedBy"]
          | null;
        comments: InformationSchema.Types.SqlFeatures["comments"] | null;
      };
      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace SqlImplementationInfo {
      export type Record = {
        implementationInfoId:
          | InformationSchema.Types.SqlImplementationInfo["implementationInfoId"]
          | null;
        implementationInfoName:
          | InformationSchema.Types.SqlImplementationInfo["implementationInfoName"]
          | null;
        integerValue:
          | InformationSchema.Types.SqlImplementationInfo["integerValue"]
          | null;
        characterValue:
          | InformationSchema.Types.SqlImplementationInfo["characterValue"]
          | null;
        comments:
          | InformationSchema.Types.SqlImplementationInfo["comments"]
          | null;
      };
      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace SqlParts {
      export type Record = {
        featureId: InformationSchema.Types.SqlParts["featureId"] | null;
        featureName: InformationSchema.Types.SqlParts["featureName"] | null;
        isSupported: InformationSchema.Types.SqlParts["isSupported"] | null;
        isVerifiedBy: InformationSchema.Types.SqlParts["isVerifiedBy"] | null;
        comments: InformationSchema.Types.SqlParts["comments"] | null;
      };
      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
    export namespace SqlSizing {
      export type Record = {
        sizingId: InformationSchema.Types.SqlSizing["sizingId"] | null;
        sizingName: InformationSchema.Types.SqlSizing["sizingName"] | null;
        supportedValue:
          | InformationSchema.Types.SqlSizing["supportedValue"]
          | null;
        comments: InformationSchema.Types.SqlSizing["comments"] | null;
      };
      export type PrimaryKey = never;
      export type Optional = Pick<Record, never>;
      export type Values = PartiallyOptional<Record, Optional & PrimaryKey>;
    }
  }
}

// begin string parsers
export namespace PgCatalog {
  export namespace Types {
    export namespace AclitemArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.AclitemArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Aclitem.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace BitArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.BitArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Bit.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace BoolArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.BoolArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Bool.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace BoxArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.BoxArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Box.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace BpcharArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.BpcharArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Bpchar.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ByteaArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.ByteaArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Bytea.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CharArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.CharArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Char.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.CidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Cid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CidrArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.CidrArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Cidr.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CircleArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.CircleArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Circle.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CstringArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.CstringArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Cstring.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DateArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.DateArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Date.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DatemultirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.DatemultirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Datemultirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DaterangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.DaterangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Daterange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Float4Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Float4Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Float4.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Float8Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Float8Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Float8.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace GtsvectorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.GtsvectorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Gtsvector.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace InetArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.InetArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Inet.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int2Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int2Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int2.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int2vectorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int2vectorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int2vector.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int4Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int4Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int4.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int4multirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int4multirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int4multirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int4rangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int4rangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int4range.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int8Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int8Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int8.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int8multirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int8multirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int8multirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Int8rangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Int8rangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Int8range.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace IntervalArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.IntervalArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Interval.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace JsonArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.JsonArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Json.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace JsonbArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.JsonbArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Jsonb.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace JsonpathArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.JsonpathArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Jsonpath.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace LineArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.LineArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Line.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace LsegArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.LsegArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Lseg.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace MacaddrArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.MacaddrArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Macaddr.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Macaddr8Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Macaddr8Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Macaddr8.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace MoneyArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.MoneyArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Money.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace NameArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.NameArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Name.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace NumericArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.NumericArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Numeric.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace NummultirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.NummultirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Nummultirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace NumrangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.NumrangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Numrange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace OidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.OidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Oid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace OidvectorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.OidvectorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Oidvector.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PathArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PathArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Path.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAggregateArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAggregateArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAggregate.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAmArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAmArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAm.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAmopArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAmopArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAmop.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAmprocArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAmprocArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAmproc.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAttrdefArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAttrdefArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAttrdef.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAttributeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAttributeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAttribute.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAuthMembersArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAuthMembersArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAuthMembers.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAuthidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAuthidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAuthid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAvailableExtensionVersionsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAvailableExtensionVersionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAvailableExtensionVersions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgAvailableExtensionsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgAvailableExtensionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgAvailableExtensions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgBackendMemoryContextsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgBackendMemoryContextsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgBackendMemoryContexts.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgCastArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgCastArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgCast.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgClassArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgClassArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgClass.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgCollationArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgCollationArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgCollation.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgConfigArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgConfigArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgConfig.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgConstraintArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgConstraintArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgConstraint.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgConversionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgConversionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgConversion.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgCursorsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgCursorsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgCursors.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgDatabaseArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgDatabaseArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgDatabase.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgDbRoleSettingArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgDbRoleSettingArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgDbRoleSetting.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgDefaultAclArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgDefaultAclArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgDefaultAcl.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgDependArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgDependArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgDepend.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgDescriptionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgDescriptionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgDescription.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgEnumArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgEnumArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgEnum.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgEventTriggerArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgEventTriggerArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgEventTrigger.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgExtensionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgExtensionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgExtension.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgFileSettingsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgFileSettingsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgFileSettings.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgForeignDataWrapperArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgForeignDataWrapperArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgForeignDataWrapper.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgForeignServerArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgForeignServerArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgForeignServer.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgForeignTableArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgForeignTableArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgForeignTable.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgGroupArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgGroupArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgGroup.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgHbaFileRulesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgHbaFileRulesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgHbaFileRules.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgIdentFileMappingsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgIdentFileMappingsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgIdentFileMappings.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgIndexArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgIndexArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgIndex.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgInheritsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgInheritsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgInherits.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgInitPrivsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgInitPrivsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgInitPrivs.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgLanguageArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgLanguageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgLanguage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgLargeobjectArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgLargeobjectArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgLargeobject.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgLargeobjectMetadataArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgLargeobjectMetadataArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgLargeobjectMetadata.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgLocksArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgLocksArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgLocks.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgLsnArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgLsnArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgLsn.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgMatviewsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgMatviewsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgMatviews.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgNamespaceArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgNamespaceArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgNamespace.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgOpclassArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgOpclassArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgOpclass.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgOperatorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgOperatorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgOperator.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgOpfamilyArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgOpfamilyArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgOpfamily.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgParameterAclArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgParameterAclArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgParameterAcl.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPartitionedTableArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPartitionedTableArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPartitionedTable.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPoliciesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPoliciesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPolicies.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPolicyArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPolicyArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPolicy.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPreparedStatementsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPreparedStatementsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPreparedStatements.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPreparedXactsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPreparedXactsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPreparedXacts.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgProcArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgProcArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgProc.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPublicationArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPublicationArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPublication.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPublicationNamespaceArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPublicationNamespaceArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPublicationNamespace.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPublicationRelArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPublicationRelArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPublicationRel.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgPublicationTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgPublicationTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgPublicationTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgRangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgRangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgRange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgReplicationOriginArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgReplicationOriginArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgReplicationOrigin.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgReplicationOriginStatusArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgReplicationOriginStatusArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgReplicationOriginStatus.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgReplicationSlotsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgReplicationSlotsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgReplicationSlots.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgRewriteArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgRewriteArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgRewrite.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgRolesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgRolesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgRoles.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgRulesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgRulesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgRules.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSeclabelArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSeclabelArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSeclabel.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSeclabelsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSeclabelsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSeclabels.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSequenceArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSequenceArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSequence.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSequencesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSequencesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSequences.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSettingsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSettingsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSettings.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgShadowArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgShadowArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgShadow.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgShdependArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgShdependArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgShdepend.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgShdescriptionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgShdescriptionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgShdescription.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgShmemAllocationsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgShmemAllocationsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgShmemAllocations.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgShseclabelArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgShseclabelArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgShseclabel.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSnapshotArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSnapshotArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSnapshot.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatActivityArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatActivityArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatActivity.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatAllIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatAllIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatAllIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatAllTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatAllTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatAllTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatArchiverArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatArchiverArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatArchiver.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatBgwriterArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatBgwriterArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatBgwriter.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatDatabaseArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatDatabaseArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatDatabase.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatDatabaseConflictsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatDatabaseConflictsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatDatabaseConflicts.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatGssapiArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatGssapiArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatGssapi.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatIoArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatIoArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatIo.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressAnalyzeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressAnalyzeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressAnalyze.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressBasebackupArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressBasebackupArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressBasebackup.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressClusterArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressClusterArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressCluster.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressCopyArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressCopyArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressCopy.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressCreateIndexArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressCreateIndexArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressCreateIndex.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatProgressVacuumArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatProgressVacuumArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatProgressVacuum.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatRecoveryPrefetchArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatRecoveryPrefetchArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatRecoveryPrefetch.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatReplicationArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatReplicationArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatReplication.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatReplicationSlotsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatReplicationSlotsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatReplicationSlots.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSlruArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSlruArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSlru.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSslArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSslArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSsl.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSubscriptionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSubscriptionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSubscription.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSubscriptionStatsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSubscriptionStatsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSubscriptionStats.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSysIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSysIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSysIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatSysTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatSysTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatSysTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatUserFunctionsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatUserFunctionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatUserFunctions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatUserIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatUserIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatUserIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatUserTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatUserTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatUserTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatWalArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatWalArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatWal.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatWalReceiverArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatWalReceiverArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatWalReceiver.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatXactAllTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatXactAllTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatXactAllTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatXactSysTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatXactSysTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatXactSysTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatXactUserFunctionsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatXactUserFunctionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatXactUserFunctions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatXactUserTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatXactUserTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatXactUserTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioAllIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioAllIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioAllIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioAllSequencesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioAllSequencesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioAllSequences.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioAllTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioAllTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioAllTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioSysIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioSysIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioSysIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioSysSequencesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioSysSequencesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioSysSequences.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioSysTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioSysTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioSysTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioUserIndexesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioUserIndexesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioUserIndexes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioUserSequencesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioUserSequencesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioUserSequences.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatioUserTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatioUserTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatioUserTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatisticArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatisticArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatistic.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatisticExtArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatisticExtArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatisticExt.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatisticExtDataArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatisticExtDataArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatisticExtData.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStats.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatsExtArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatsExtArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatsExt.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgStatsExtExprsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgStatsExtExprsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgStatsExtExprs.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSubscriptionArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSubscriptionArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSubscription.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgSubscriptionRelArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgSubscriptionRelArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgSubscriptionRel.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTablesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTablespaceArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTablespaceArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTablespace.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTimezoneAbbrevsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTimezoneAbbrevsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTimezoneAbbrevs.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTimezoneNamesArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTimezoneNamesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTimezoneNames.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTransformArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTransformArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTransform.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTriggerArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTriggerArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTrigger.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTsConfigArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTsConfigArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTsConfig.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTsConfigMapArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTsConfigMapArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTsConfigMap.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTsDictArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTsDictArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTsDict.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTsParserArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTsParserArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTsParser.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTsTemplateArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTsTemplateArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgTsTemplate.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgTypeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgTypeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgType.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgUserArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgUserArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgUser.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgUserMappingArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgUserMappingArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgUserMapping.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgUserMappingsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgUserMappingsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgUserMappings.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgViewsArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PgViewsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return PgViews.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PointArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PointArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Point.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PolygonArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.PolygonArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Polygon.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RecordArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RecordArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Record.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RefcursorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RefcursorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Refcursor.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegclassArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegclassArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regclass.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegcollationArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegcollationArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regcollation.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegconfigArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegconfigArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regconfig.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegdictionaryArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegdictionaryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regdictionary.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegnamespaceArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegnamespaceArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regnamespace.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegoperArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegoperArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regoper.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegoperatorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegoperatorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regoperator.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegprocArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegprocArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regproc.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegprocedureArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegprocedureArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regprocedure.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegroleArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegroleArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regrole.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RegtypeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.RegtypeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Regtype.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TextArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TextArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Text.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TimeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TimeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Time.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TimestampArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TimestampArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Timestamp.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TimestamptzArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TimestamptzArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Timestamptz.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TimetzArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TimetzArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Timetz.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TsmultirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TsmultirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tsmultirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TsqueryArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TsqueryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tsquery.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TsrangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TsrangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tsrange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TstzmultirangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TstzmultirangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tstzmultirange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TstzrangeArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TstzrangeArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tstzrange.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TsvectorArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TsvectorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tsvector.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TxidSnapshotArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.TxidSnapshotArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return TxidSnapshot.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UuidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.UuidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Uuid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace VarbitArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.VarbitArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Varbit.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace VarcharArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.VarcharArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Varchar.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace XidArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.XidArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Xid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Xid8Array {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Xid8Array

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Xid8.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace XmlArray {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.XmlArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Xml.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Aclitem {
      export function parse(from: any) {
        // Type PgCatalog.Types.Aclitem

        return from;
      }
    }
    export namespace Any {
      export function parse(from: any) {
        // Type PgCatalog.Types.Any

        return from;
      }
    }
    export namespace Anyarray {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anyarray

        return from;
      }
    }
    export namespace Anycompatible {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anycompatible

        return from;
      }
    }
    export namespace Anycompatiblearray {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anycompatiblearray

        return from;
      }
    }
    export namespace Anycompatiblemultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anycompatiblemultirange

        return from;
      }
    }
    export namespace Anycompatiblenonarray {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anycompatiblenonarray

        return from;
      }
    }
    export namespace Anycompatiblerange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anycompatiblerange

        return from;
      }
    }
    export namespace Anyelement {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anyelement

        return from;
      }
    }
    export namespace Anyenum {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anyenum

        return from;
      }
    }
    export namespace Anymultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anymultirange

        return from;
      }
    }
    export namespace Anynonarray {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anynonarray

        return from;
      }
    }
    export namespace Anyrange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Anyrange

        return from;
      }
    }
    export namespace Bit {
      export function parse(from: any) {
        // Type PgCatalog.Types.Bit

        if (from === null) return null;
        if (["t", "T", "true", "True"].includes(from)) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
        return false;
      }
    }
    export namespace Bool {
      export function parse(from: any) {
        // Type PgCatalog.Types.Bool

        if (from === null) return null;
        if (["t", "T", "true", "True"].includes(from)) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
        return false;
      }
    }
    export namespace Box {
      export function parse(from: any) {
        // Type PgCatalog.Types.Box

        return from;
      }
    }
    export namespace Bpchar {
      export function parse(from: any) {
        // Type PgCatalog.Types.Bpchar

        return from;
      }
    }
    export namespace Bytea {
      export function parse(from: any) {
        // Type PgCatalog.Types.Bytea

        return from ? new Uint8Array(JSON.parse(from)) : null;
      }
    }
    export namespace Char {
      export function parse(from: any) {
        // Type PgCatalog.Types.Char

        return from;
      }
    }
    export namespace Cid {
      export function parse(from: any) {
        // Type PgCatalog.Types.Cid

        return from;
      }
    }
    export namespace Cidr {
      export function parse(from: any) {
        // Type PgCatalog.Types.Cidr

        return from ? new Uint8Array(JSON.parse(from)) : null;
      }
    }
    export namespace Circle {
      export function parse(from: any) {
        // Type PgCatalog.Types.Circle

        return from;
      }
    }
    export namespace Cstring {
      export function parse(from: any) {
        // Type PgCatalog.Types.Cstring

        return from;
      }
    }
    export namespace Date {
      export function parse(from: any) {
        // Type PgCatalog.Types.Date

        if (from === null) return null;
        if ((from as unknown) instanceof global.Date) return from;
        return new global.Date(from);
      }
    }
    export namespace Datemultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Datemultirange

        return from;
      }
    }
    export namespace Daterange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Daterange

        return from;
      }
    }
    export namespace EventTrigger {
      export function parse(from: any) {
        // Type PgCatalog.Types.EventTrigger

        return from;
      }
    }
    export namespace FdwHandler {
      export function parse(from: any) {
        // Type PgCatalog.Types.FdwHandler

        return from;
      }
    }
    export namespace Float4 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Float4

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Float8 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Float8

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Gtsvector {
      export function parse(from: any) {
        // Type PgCatalog.Types.Gtsvector

        return from;
      }
    }
    export namespace IndexAmHandler {
      export function parse(from: any) {
        // Type PgCatalog.Types.IndexAmHandler

        return from;
      }
    }
    export namespace Inet {
      export function parse(from: any) {
        // Type PgCatalog.Types.Inet

        return from;
      }
    }
    export namespace Int2 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int2

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Int2vector {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int2vector

        if (from === null) return null;
        const source = Array.isArray(from)
          ? new Uint16Array(from)
          : JSON.parse(from);
        return new Uint16Array(source);
      }
    }
    export namespace Int4 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int4

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Int4multirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int4multirange

        return from;
      }
    }
    export namespace Int4range {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int4range

        return from;
      }
    }
    export namespace Int8 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int8

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Int8multirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int8multirange

        return from;
      }
    }
    export namespace Int8range {
      export function parse(from: any) {
        // Type PgCatalog.Types.Int8range

        return from;
      }
    }
    export namespace Internal {
      export function parse(from: any) {
        // Type PgCatalog.Types.Internal

        return from;
      }
    }
    export namespace Interval {
      export function parse(from: any) {
        // Type PgCatalog.Types.Interval

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Json {
      export function parse(from: any) {
        // Type PgCatalog.Types.Json

        return from;
      }
    }
    export namespace Jsonb {
      export function parse(from: any) {
        // Type PgCatalog.Types.Jsonb

        return from;
      }
    }
    export namespace Jsonpath {
      export function parse(from: any) {
        // Type PgCatalog.Types.Jsonpath

        return from;
      }
    }
    export namespace LanguageHandler {
      export function parse(from: any) {
        // Type PgCatalog.Types.LanguageHandler

        return from;
      }
    }
    export namespace Line {
      export function parse(from: any) {
        // Type PgCatalog.Types.Line

        return from;
      }
    }
    export namespace Lseg {
      export function parse(from: any) {
        // Type PgCatalog.Types.Lseg

        return from;
      }
    }
    export namespace Macaddr {
      export function parse(from: any) {
        // Type PgCatalog.Types.Macaddr

        return from ? new Uint8Array(JSON.parse(from)) : null;
      }
    }
    export namespace Macaddr8 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Macaddr8

        return from ? new Uint8Array(JSON.parse(from)) : null;
      }
    }
    export namespace Money {
      export function parse(from: any) {
        // Type PgCatalog.Types.Money

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Name {
      export function parse(from: any) {
        // Type PgCatalog.Types.Name

        return from;
      }
    }
    export namespace Numeric {
      export function parse(from: any) {
        // Type PgCatalog.Types.Numeric

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Nummultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Nummultirange

        return from;
      }
    }
    export namespace Numrange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Numrange

        return from;
      }
    }
    export namespace Oid {
      export function parse(from: any) {
        // Type PgCatalog.Types.Oid

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Oidvector {
      export function parse(from: any) {
        // ArrayType PgCatalog.Types.Oidvector

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Oid.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Path {
      export function parse(from: any) {
        // Type PgCatalog.Types.Path

        return from;
      }
    }
    export namespace PgAggregate {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAggregate
        if (PgCatalog.Types.PgAggregate.is(from)) {
          return {
            aggfnoid: PgCatalog.Types.Regproc.parse(from.aggfnoid),
            aggkind: PgCatalog.Types.Char.parse(from.aggkind),
            aggnumdirectargs: PgCatalog.Types.Int2.parse(from.aggnumdirectargs),
            aggtransfn: PgCatalog.Types.Regproc.parse(from.aggtransfn),
            aggfinalfn: PgCatalog.Types.Regproc.parse(from.aggfinalfn),
            aggcombinefn: PgCatalog.Types.Regproc.parse(from.aggcombinefn),
            aggserialfn: PgCatalog.Types.Regproc.parse(from.aggserialfn),
            aggdeserialfn: PgCatalog.Types.Regproc.parse(from.aggdeserialfn),
            aggmtransfn: PgCatalog.Types.Regproc.parse(from.aggmtransfn),
            aggminvtransfn: PgCatalog.Types.Regproc.parse(from.aggminvtransfn),
            aggmfinalfn: PgCatalog.Types.Regproc.parse(from.aggmfinalfn),
            aggfinalextra: PgCatalog.Types.Bool.parse(from.aggfinalextra),
            aggmfinalextra: PgCatalog.Types.Bool.parse(from.aggmfinalextra),
            aggfinalmodify: PgCatalog.Types.Char.parse(from.aggfinalmodify),
            aggmfinalmodify: PgCatalog.Types.Char.parse(from.aggmfinalmodify),
            aggsortop: PgCatalog.Types.Oid.parse(from.aggsortop),
            aggtranstype: PgCatalog.Types.Oid.parse(from.aggtranstype),
            aggtransspace: PgCatalog.Types.Int4.parse(from.aggtransspace),
            aggmtranstype: PgCatalog.Types.Oid.parse(from.aggmtranstype),
            aggmtransspace: PgCatalog.Types.Int4.parse(from.aggmtransspace),
            agginitval: PgCatalog.Types.Text.parse(from.agginitval),
            aggminitval: PgCatalog.Types.Text.parse(from.aggminitval),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAm {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAm
        if (PgCatalog.Types.PgAm.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            amname: PgCatalog.Types.Name.parse(from.amname),
            amhandler: PgCatalog.Types.Regproc.parse(from.amhandler),
            amtype: PgCatalog.Types.Char.parse(from.amtype),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAmop {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAmop
        if (PgCatalog.Types.PgAmop.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            amopfamily: PgCatalog.Types.Oid.parse(from.amopfamily),
            amoplefttype: PgCatalog.Types.Oid.parse(from.amoplefttype),
            amoprighttype: PgCatalog.Types.Oid.parse(from.amoprighttype),
            amopstrategy: PgCatalog.Types.Int2.parse(from.amopstrategy),
            amoppurpose: PgCatalog.Types.Char.parse(from.amoppurpose),
            amopopr: PgCatalog.Types.Oid.parse(from.amopopr),
            amopmethod: PgCatalog.Types.Oid.parse(from.amopmethod),
            amopsortfamily: PgCatalog.Types.Oid.parse(from.amopsortfamily),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAmproc {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAmproc
        if (PgCatalog.Types.PgAmproc.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            amprocfamily: PgCatalog.Types.Oid.parse(from.amprocfamily),
            amproclefttype: PgCatalog.Types.Oid.parse(from.amproclefttype),
            amprocrighttype: PgCatalog.Types.Oid.parse(from.amprocrighttype),
            amprocnum: PgCatalog.Types.Int2.parse(from.amprocnum),
            amproc: PgCatalog.Types.Regproc.parse(from.amproc),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAttrdef {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAttrdef
        if (PgCatalog.Types.PgAttrdef.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            adrelid: PgCatalog.Types.Oid.parse(from.adrelid),
            adnum: PgCatalog.Types.Int2.parse(from.adnum),
            adbin: PgCatalog.Types.PgNodeTree.parse(from.adbin),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAttribute {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAttribute
        if (PgCatalog.Types.PgAttribute.is(from)) {
          return {
            attrelid: PgCatalog.Types.Oid.parse(from.attrelid),
            attname: PgCatalog.Types.Name.parse(from.attname),
            atttypid: PgCatalog.Types.Oid.parse(from.atttypid),
            attlen: PgCatalog.Types.Int2.parse(from.attlen),
            attnum: PgCatalog.Types.Int2.parse(from.attnum),
            attcacheoff: PgCatalog.Types.Int4.parse(from.attcacheoff),
            atttypmod: PgCatalog.Types.Int4.parse(from.atttypmod),
            attndims: PgCatalog.Types.Int2.parse(from.attndims),
            attbyval: PgCatalog.Types.Bool.parse(from.attbyval),
            attalign: PgCatalog.Types.Char.parse(from.attalign),
            attstorage: PgCatalog.Types.Char.parse(from.attstorage),
            attcompression: PgCatalog.Types.Char.parse(from.attcompression),
            attnotnull: PgCatalog.Types.Bool.parse(from.attnotnull),
            atthasdef: PgCatalog.Types.Bool.parse(from.atthasdef),
            atthasmissing: PgCatalog.Types.Bool.parse(from.atthasmissing),
            attidentity: PgCatalog.Types.Char.parse(from.attidentity),
            attgenerated: PgCatalog.Types.Char.parse(from.attgenerated),
            attisdropped: PgCatalog.Types.Bool.parse(from.attisdropped),
            attislocal: PgCatalog.Types.Bool.parse(from.attislocal),
            attinhcount: PgCatalog.Types.Int2.parse(from.attinhcount),
            attstattarget: PgCatalog.Types.Int2.parse(from.attstattarget),
            attcollation: PgCatalog.Types.Oid.parse(from.attcollation),
            attacl: PgCatalog.Types.AclitemArray.parse(from.attacl),
            attoptions: PgCatalog.Types.TextArray.parse(from.attoptions),
            attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
            attmissingval: PgCatalog.Types.Anyarray.parse(from.attmissingval),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAuthMembers {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAuthMembers
        if (PgCatalog.Types.PgAuthMembers.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            roleid: PgCatalog.Types.Oid.parse(from.roleid),
            member: PgCatalog.Types.Oid.parse(from.member),
            grantor: PgCatalog.Types.Oid.parse(from.grantor),
            adminOption: PgCatalog.Types.Bool.parse(from.adminOption),
            inheritOption: PgCatalog.Types.Bool.parse(from.inheritOption),
            setOption: PgCatalog.Types.Bool.parse(from.setOption),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAuthid {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAuthid
        if (PgCatalog.Types.PgAuthid.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            rolname: PgCatalog.Types.Name.parse(from.rolname),
            rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
            rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
            rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
            rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
            rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
            rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
            rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
            rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
            rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
            rolvaliduntil: PgCatalog.Types.Timestamptz.parse(
              from.rolvaliduntil,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAvailableExtensionVersions {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAvailableExtensionVersions
        if (PgCatalog.Types.PgAvailableExtensionVersions.is(from)) {
          return {
            name: PgCatalog.Types.Name.parse(from.name),
            version: PgCatalog.Types.Text.parse(from.version),
            installed: PgCatalog.Types.Bool.parse(from.installed),
            superuser: PgCatalog.Types.Bool.parse(from.superuser),
            trusted: PgCatalog.Types.Bool.parse(from.trusted),
            relocatable: PgCatalog.Types.Bool.parse(from.relocatable),
            schema: PgCatalog.Types.Name.parse(from.schema),
            requires: PgCatalog.Types.NameArray.parse(from.requires),
            comment: PgCatalog.Types.Text.parse(from.comment),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgAvailableExtensions {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgAvailableExtensions
        if (PgCatalog.Types.PgAvailableExtensions.is(from)) {
          return {
            name: PgCatalog.Types.Name.parse(from.name),
            defaultVersion: PgCatalog.Types.Text.parse(from.defaultVersion),
            installedVersion: PgCatalog.Types.Text.parse(from.installedVersion),
            comment: PgCatalog.Types.Text.parse(from.comment),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgBackendMemoryContexts {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgBackendMemoryContexts
        if (PgCatalog.Types.PgBackendMemoryContexts.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            ident: PgCatalog.Types.Text.parse(from.ident),
            parent: PgCatalog.Types.Text.parse(from.parent),
            level: PgCatalog.Types.Int4.parse(from.level),
            totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
            totalNblocks: PgCatalog.Types.Int8.parse(from.totalNblocks),
            freeBytes: PgCatalog.Types.Int8.parse(from.freeBytes),
            freeChunks: PgCatalog.Types.Int8.parse(from.freeChunks),
            usedBytes: PgCatalog.Types.Int8.parse(from.usedBytes),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgBrinBloomSummary {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgBrinBloomSummary

        return from;
      }
    }
    export namespace PgBrinMinmaxMultiSummary {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgBrinMinmaxMultiSummary

        return from;
      }
    }
    export namespace PgCast {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgCast
        if (PgCatalog.Types.PgCast.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            castsource: PgCatalog.Types.Oid.parse(from.castsource),
            casttarget: PgCatalog.Types.Oid.parse(from.casttarget),
            castfunc: PgCatalog.Types.Oid.parse(from.castfunc),
            castcontext: PgCatalog.Types.Char.parse(from.castcontext),
            castmethod: PgCatalog.Types.Char.parse(from.castmethod),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgClass {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgClass
        if (PgCatalog.Types.PgClass.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            relname: PgCatalog.Types.Name.parse(from.relname),
            relnamespace: PgCatalog.Types.Oid.parse(from.relnamespace),
            reltype: PgCatalog.Types.Oid.parse(from.reltype),
            reloftype: PgCatalog.Types.Oid.parse(from.reloftype),
            relowner: PgCatalog.Types.Oid.parse(from.relowner),
            relam: PgCatalog.Types.Oid.parse(from.relam),
            relfilenode: PgCatalog.Types.Oid.parse(from.relfilenode),
            reltablespace: PgCatalog.Types.Oid.parse(from.reltablespace),
            relpages: PgCatalog.Types.Int4.parse(from.relpages),
            reltuples: PgCatalog.Types.Float4.parse(from.reltuples),
            relallvisible: PgCatalog.Types.Int4.parse(from.relallvisible),
            reltoastrelid: PgCatalog.Types.Oid.parse(from.reltoastrelid),
            relhasindex: PgCatalog.Types.Bool.parse(from.relhasindex),
            relisshared: PgCatalog.Types.Bool.parse(from.relisshared),
            relpersistence: PgCatalog.Types.Char.parse(from.relpersistence),
            relkind: PgCatalog.Types.Char.parse(from.relkind),
            relnatts: PgCatalog.Types.Int2.parse(from.relnatts),
            relchecks: PgCatalog.Types.Int2.parse(from.relchecks),
            relhasrules: PgCatalog.Types.Bool.parse(from.relhasrules),
            relhastriggers: PgCatalog.Types.Bool.parse(from.relhastriggers),
            relhassubclass: PgCatalog.Types.Bool.parse(from.relhassubclass),
            relrowsecurity: PgCatalog.Types.Bool.parse(from.relrowsecurity),
            relforcerowsecurity: PgCatalog.Types.Bool.parse(
              from.relforcerowsecurity,
            ),
            relispopulated: PgCatalog.Types.Bool.parse(from.relispopulated),
            relreplident: PgCatalog.Types.Char.parse(from.relreplident),
            relispartition: PgCatalog.Types.Bool.parse(from.relispartition),
            relrewrite: PgCatalog.Types.Oid.parse(from.relrewrite),
            relfrozenxid: PgCatalog.Types.Xid.parse(from.relfrozenxid),
            relminmxid: PgCatalog.Types.Xid.parse(from.relminmxid),
            relacl: PgCatalog.Types.AclitemArray.parse(from.relacl),
            reloptions: PgCatalog.Types.TextArray.parse(from.reloptions),
            relpartbound: PgCatalog.Types.PgNodeTree.parse(from.relpartbound),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgCollation {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgCollation
        if (PgCatalog.Types.PgCollation.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            collname: PgCatalog.Types.Name.parse(from.collname),
            collnamespace: PgCatalog.Types.Oid.parse(from.collnamespace),
            collowner: PgCatalog.Types.Oid.parse(from.collowner),
            collprovider: PgCatalog.Types.Char.parse(from.collprovider),
            collisdeterministic: PgCatalog.Types.Bool.parse(
              from.collisdeterministic,
            ),
            collencoding: PgCatalog.Types.Int4.parse(from.collencoding),
            collcollate: PgCatalog.Types.Text.parse(from.collcollate),
            collctype: PgCatalog.Types.Text.parse(from.collctype),
            colliculocale: PgCatalog.Types.Text.parse(from.colliculocale),
            collicurules: PgCatalog.Types.Text.parse(from.collicurules),
            collversion: PgCatalog.Types.Text.parse(from.collversion),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgConfig {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgConfig
        if (PgCatalog.Types.PgConfig.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            setting: PgCatalog.Types.Text.parse(from.setting),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgConstraint {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgConstraint
        if (PgCatalog.Types.PgConstraint.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            conname: PgCatalog.Types.Name.parse(from.conname),
            connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
            contype: PgCatalog.Types.Char.parse(from.contype),
            condeferrable: PgCatalog.Types.Bool.parse(from.condeferrable),
            condeferred: PgCatalog.Types.Bool.parse(from.condeferred),
            convalidated: PgCatalog.Types.Bool.parse(from.convalidated),
            conrelid: PgCatalog.Types.Oid.parse(from.conrelid),
            contypid: PgCatalog.Types.Oid.parse(from.contypid),
            conindid: PgCatalog.Types.Oid.parse(from.conindid),
            conparentid: PgCatalog.Types.Oid.parse(from.conparentid),
            confrelid: PgCatalog.Types.Oid.parse(from.confrelid),
            confupdtype: PgCatalog.Types.Char.parse(from.confupdtype),
            confdeltype: PgCatalog.Types.Char.parse(from.confdeltype),
            confmatchtype: PgCatalog.Types.Char.parse(from.confmatchtype),
            conislocal: PgCatalog.Types.Bool.parse(from.conislocal),
            coninhcount: PgCatalog.Types.Int2.parse(from.coninhcount),
            connoinherit: PgCatalog.Types.Bool.parse(from.connoinherit),
            conkey: PgCatalog.Types.Int2Array.parse(from.conkey),
            confkey: PgCatalog.Types.Int2Array.parse(from.confkey),
            conpfeqop: PgCatalog.Types.OidArray.parse(from.conpfeqop),
            conppeqop: PgCatalog.Types.OidArray.parse(from.conppeqop),
            conffeqop: PgCatalog.Types.OidArray.parse(from.conffeqop),
            confdelsetcols: PgCatalog.Types.Int2Array.parse(
              from.confdelsetcols,
            ),
            conexclop: PgCatalog.Types.OidArray.parse(from.conexclop),
            conbin: PgCatalog.Types.PgNodeTree.parse(from.conbin),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgConversion {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgConversion
        if (PgCatalog.Types.PgConversion.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            conname: PgCatalog.Types.Name.parse(from.conname),
            connamespace: PgCatalog.Types.Oid.parse(from.connamespace),
            conowner: PgCatalog.Types.Oid.parse(from.conowner),
            conforencoding: PgCatalog.Types.Int4.parse(from.conforencoding),
            contoencoding: PgCatalog.Types.Int4.parse(from.contoencoding),
            conproc: PgCatalog.Types.Regproc.parse(from.conproc),
            condefault: PgCatalog.Types.Bool.parse(from.condefault),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgCursors {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgCursors
        if (PgCatalog.Types.PgCursors.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            statement: PgCatalog.Types.Text.parse(from.statement),
            isHoldable: PgCatalog.Types.Bool.parse(from.isHoldable),
            isBinary: PgCatalog.Types.Bool.parse(from.isBinary),
            isScrollable: PgCatalog.Types.Bool.parse(from.isScrollable),
            creationTime: PgCatalog.Types.Timestamptz.parse(from.creationTime),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgDatabase {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgDatabase
        if (PgCatalog.Types.PgDatabase.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            datdba: PgCatalog.Types.Oid.parse(from.datdba),
            encoding: PgCatalog.Types.Int4.parse(from.encoding),
            datlocprovider: PgCatalog.Types.Char.parse(from.datlocprovider),
            datistemplate: PgCatalog.Types.Bool.parse(from.datistemplate),
            datallowconn: PgCatalog.Types.Bool.parse(from.datallowconn),
            datconnlimit: PgCatalog.Types.Int4.parse(from.datconnlimit),
            datfrozenxid: PgCatalog.Types.Xid.parse(from.datfrozenxid),
            datminmxid: PgCatalog.Types.Xid.parse(from.datminmxid),
            dattablespace: PgCatalog.Types.Oid.parse(from.dattablespace),
            datcollate: PgCatalog.Types.Text.parse(from.datcollate),
            datctype: PgCatalog.Types.Text.parse(from.datctype),
            daticulocale: PgCatalog.Types.Text.parse(from.daticulocale),
            daticurules: PgCatalog.Types.Text.parse(from.daticurules),
            datcollversion: PgCatalog.Types.Text.parse(from.datcollversion),
            datacl: PgCatalog.Types.AclitemArray.parse(from.datacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgDbRoleSetting {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgDbRoleSetting
        if (PgCatalog.Types.PgDbRoleSetting.is(from)) {
          return {
            setdatabase: PgCatalog.Types.Oid.parse(from.setdatabase),
            setrole: PgCatalog.Types.Oid.parse(from.setrole),
            setconfig: PgCatalog.Types.TextArray.parse(from.setconfig),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgDdlCommand {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgDdlCommand

        return from;
      }
    }
    export namespace PgDefaultAcl {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgDefaultAcl
        if (PgCatalog.Types.PgDefaultAcl.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            defaclrole: PgCatalog.Types.Oid.parse(from.defaclrole),
            defaclnamespace: PgCatalog.Types.Oid.parse(from.defaclnamespace),
            defaclobjtype: PgCatalog.Types.Char.parse(from.defaclobjtype),
            defaclacl: PgCatalog.Types.AclitemArray.parse(from.defaclacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgDepend {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgDepend
        if (PgCatalog.Types.PgDepend.is(from)) {
          return {
            classid: PgCatalog.Types.Oid.parse(from.classid),
            objid: PgCatalog.Types.Oid.parse(from.objid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
            refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
            refobjsubid: PgCatalog.Types.Int4.parse(from.refobjsubid),
            deptype: PgCatalog.Types.Char.parse(from.deptype),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgDependencies {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgDependencies

        return from;
      }
    }
    export namespace PgDescription {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgDescription
        if (PgCatalog.Types.PgDescription.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            description: PgCatalog.Types.Text.parse(from.description),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgEnum {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgEnum
        if (PgCatalog.Types.PgEnum.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            enumtypid: PgCatalog.Types.Oid.parse(from.enumtypid),
            enumsortorder: PgCatalog.Types.Float4.parse(from.enumsortorder),
            enumlabel: PgCatalog.Types.Name.parse(from.enumlabel),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgEventTrigger {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgEventTrigger
        if (PgCatalog.Types.PgEventTrigger.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            evtname: PgCatalog.Types.Name.parse(from.evtname),
            evtevent: PgCatalog.Types.Name.parse(from.evtevent),
            evtowner: PgCatalog.Types.Oid.parse(from.evtowner),
            evtfoid: PgCatalog.Types.Oid.parse(from.evtfoid),
            evtenabled: PgCatalog.Types.Char.parse(from.evtenabled),
            evttags: PgCatalog.Types.TextArray.parse(from.evttags),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgExtension {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgExtension
        if (PgCatalog.Types.PgExtension.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            extname: PgCatalog.Types.Name.parse(from.extname),
            extowner: PgCatalog.Types.Oid.parse(from.extowner),
            extnamespace: PgCatalog.Types.Oid.parse(from.extnamespace),
            extrelocatable: PgCatalog.Types.Bool.parse(from.extrelocatable),
            extversion: PgCatalog.Types.Text.parse(from.extversion),
            extconfig: PgCatalog.Types.OidArray.parse(from.extconfig),
            extcondition: PgCatalog.Types.TextArray.parse(from.extcondition),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgFileSettings {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgFileSettings
        if (PgCatalog.Types.PgFileSettings.is(from)) {
          return {
            sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
            sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
            seqno: PgCatalog.Types.Int4.parse(from.seqno),
            name: PgCatalog.Types.Text.parse(from.name),
            setting: PgCatalog.Types.Text.parse(from.setting),
            applied: PgCatalog.Types.Bool.parse(from.applied),
            error: PgCatalog.Types.Text.parse(from.error),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignDataWrapper {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgForeignDataWrapper
        if (PgCatalog.Types.PgForeignDataWrapper.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            fdwname: PgCatalog.Types.Name.parse(from.fdwname),
            fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
            fdwhandler: PgCatalog.Types.Oid.parse(from.fdwhandler),
            fdwvalidator: PgCatalog.Types.Oid.parse(from.fdwvalidator),
            fdwacl: PgCatalog.Types.AclitemArray.parse(from.fdwacl),
            fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignServer {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgForeignServer
        if (PgCatalog.Types.PgForeignServer.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            srvname: PgCatalog.Types.Name.parse(from.srvname),
            srvowner: PgCatalog.Types.Oid.parse(from.srvowner),
            srvfdw: PgCatalog.Types.Oid.parse(from.srvfdw),
            srvtype: PgCatalog.Types.Text.parse(from.srvtype),
            srvversion: PgCatalog.Types.Text.parse(from.srvversion),
            srvacl: PgCatalog.Types.AclitemArray.parse(from.srvacl),
            srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignTable {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgForeignTable
        if (PgCatalog.Types.PgForeignTable.is(from)) {
          return {
            ftrelid: PgCatalog.Types.Oid.parse(from.ftrelid),
            ftserver: PgCatalog.Types.Oid.parse(from.ftserver),
            ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgGroup {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgGroup
        if (PgCatalog.Types.PgGroup.is(from)) {
          return {
            groname: PgCatalog.Types.Name.parse(from.groname),
            grosysid: PgCatalog.Types.Oid.parse(from.grosysid),
            grolist: PgCatalog.Types.OidArray.parse(from.grolist),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgHbaFileRules {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgHbaFileRules
        if (PgCatalog.Types.PgHbaFileRules.is(from)) {
          return {
            ruleNumber: PgCatalog.Types.Int4.parse(from.ruleNumber),
            fileName: PgCatalog.Types.Text.parse(from.fileName),
            lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
            type: PgCatalog.Types.Text.parse(from.type),
            database: PgCatalog.Types.TextArray.parse(from.database),
            userName: PgCatalog.Types.TextArray.parse(from.userName),
            address: PgCatalog.Types.Text.parse(from.address),
            netmask: PgCatalog.Types.Text.parse(from.netmask),
            authMethod: PgCatalog.Types.Text.parse(from.authMethod),
            options: PgCatalog.Types.TextArray.parse(from.options),
            error: PgCatalog.Types.Text.parse(from.error),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgIdentFileMappings {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgIdentFileMappings
        if (PgCatalog.Types.PgIdentFileMappings.is(from)) {
          return {
            mapNumber: PgCatalog.Types.Int4.parse(from.mapNumber),
            fileName: PgCatalog.Types.Text.parse(from.fileName),
            lineNumber: PgCatalog.Types.Int4.parse(from.lineNumber),
            mapName: PgCatalog.Types.Text.parse(from.mapName),
            sysName: PgCatalog.Types.Text.parse(from.sysName),
            pgUsername: PgCatalog.Types.Text.parse(from.pgUsername),
            error: PgCatalog.Types.Text.parse(from.error),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgIndex {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgIndex
        if (PgCatalog.Types.PgIndex.is(from)) {
          return {
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            indrelid: PgCatalog.Types.Oid.parse(from.indrelid),
            indnatts: PgCatalog.Types.Int2.parse(from.indnatts),
            indnkeyatts: PgCatalog.Types.Int2.parse(from.indnkeyatts),
            indisunique: PgCatalog.Types.Bool.parse(from.indisunique),
            indnullsnotdistinct: PgCatalog.Types.Bool.parse(
              from.indnullsnotdistinct,
            ),
            indisprimary: PgCatalog.Types.Bool.parse(from.indisprimary),
            indisexclusion: PgCatalog.Types.Bool.parse(from.indisexclusion),
            indimmediate: PgCatalog.Types.Bool.parse(from.indimmediate),
            indisclustered: PgCatalog.Types.Bool.parse(from.indisclustered),
            indisvalid: PgCatalog.Types.Bool.parse(from.indisvalid),
            indcheckxmin: PgCatalog.Types.Bool.parse(from.indcheckxmin),
            indisready: PgCatalog.Types.Bool.parse(from.indisready),
            indislive: PgCatalog.Types.Bool.parse(from.indislive),
            indisreplident: PgCatalog.Types.Bool.parse(from.indisreplident),
            indkey: PgCatalog.Types.Int2vector.parse(from.indkey),
            indcollation: PgCatalog.Types.Oidvector.parse(from.indcollation),
            indclass: PgCatalog.Types.Oidvector.parse(from.indclass),
            indoption: PgCatalog.Types.Int2vector.parse(from.indoption),
            indexprs: PgCatalog.Types.PgNodeTree.parse(from.indexprs),
            indpred: PgCatalog.Types.PgNodeTree.parse(from.indpred),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgIndexes
        if (PgCatalog.Types.PgIndexes.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            indexname: PgCatalog.Types.Name.parse(from.indexname),
            tablespace: PgCatalog.Types.Name.parse(from.tablespace),
            indexdef: PgCatalog.Types.Text.parse(from.indexdef),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgInherits {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgInherits
        if (PgCatalog.Types.PgInherits.is(from)) {
          return {
            inhrelid: PgCatalog.Types.Oid.parse(from.inhrelid),
            inhparent: PgCatalog.Types.Oid.parse(from.inhparent),
            inhseqno: PgCatalog.Types.Int4.parse(from.inhseqno),
            inhdetachpending: PgCatalog.Types.Bool.parse(from.inhdetachpending),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgInitPrivs {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgInitPrivs
        if (PgCatalog.Types.PgInitPrivs.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            privtype: PgCatalog.Types.Char.parse(from.privtype),
            initprivs: PgCatalog.Types.AclitemArray.parse(from.initprivs),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgLanguage {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgLanguage
        if (PgCatalog.Types.PgLanguage.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            lanname: PgCatalog.Types.Name.parse(from.lanname),
            lanowner: PgCatalog.Types.Oid.parse(from.lanowner),
            lanispl: PgCatalog.Types.Bool.parse(from.lanispl),
            lanpltrusted: PgCatalog.Types.Bool.parse(from.lanpltrusted),
            lanplcallfoid: PgCatalog.Types.Oid.parse(from.lanplcallfoid),
            laninline: PgCatalog.Types.Oid.parse(from.laninline),
            lanvalidator: PgCatalog.Types.Oid.parse(from.lanvalidator),
            lanacl: PgCatalog.Types.AclitemArray.parse(from.lanacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgLargeobject {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgLargeobject
        if (PgCatalog.Types.PgLargeobject.is(from)) {
          return {
            loid: PgCatalog.Types.Oid.parse(from.loid),
            pageno: PgCatalog.Types.Int4.parse(from.pageno),
            data: PgCatalog.Types.Bytea.parse(from.data),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgLargeobjectMetadata {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgLargeobjectMetadata
        if (PgCatalog.Types.PgLargeobjectMetadata.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            lomowner: PgCatalog.Types.Oid.parse(from.lomowner),
            lomacl: PgCatalog.Types.AclitemArray.parse(from.lomacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgLocks {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgLocks
        if (PgCatalog.Types.PgLocks.is(from)) {
          return {
            locktype: PgCatalog.Types.Text.parse(from.locktype),
            database: PgCatalog.Types.Oid.parse(from.database),
            relation: PgCatalog.Types.Oid.parse(from.relation),
            page: PgCatalog.Types.Int4.parse(from.page),
            tuple: PgCatalog.Types.Int2.parse(from.tuple),
            virtualxid: PgCatalog.Types.Text.parse(from.virtualxid),
            transactionid: PgCatalog.Types.Xid.parse(from.transactionid),
            classid: PgCatalog.Types.Oid.parse(from.classid),
            objid: PgCatalog.Types.Oid.parse(from.objid),
            objsubid: PgCatalog.Types.Int2.parse(from.objsubid),
            virtualtransaction: PgCatalog.Types.Text.parse(
              from.virtualtransaction,
            ),
            pid: PgCatalog.Types.Int4.parse(from.pid),
            mode: PgCatalog.Types.Text.parse(from.mode),
            granted: PgCatalog.Types.Bool.parse(from.granted),
            fastpath: PgCatalog.Types.Bool.parse(from.fastpath),
            waitstart: PgCatalog.Types.Timestamptz.parse(from.waitstart),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgLsn {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgLsn

        if (from === null) return null;
        if (from === "") return null;
        return BigInt(from);
      }
    }
    export namespace PgMatviews {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgMatviews
        if (PgCatalog.Types.PgMatviews.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            matviewname: PgCatalog.Types.Name.parse(from.matviewname),
            matviewowner: PgCatalog.Types.Name.parse(from.matviewowner),
            tablespace: PgCatalog.Types.Name.parse(from.tablespace),
            hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
            ispopulated: PgCatalog.Types.Bool.parse(from.ispopulated),
            definition: PgCatalog.Types.Text.parse(from.definition),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgMcvList {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgMcvList

        return from;
      }
    }
    export namespace PgNamespace {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgNamespace
        if (PgCatalog.Types.PgNamespace.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            nspname: PgCatalog.Types.Name.parse(from.nspname),
            nspowner: PgCatalog.Types.Oid.parse(from.nspowner),
            nspacl: PgCatalog.Types.AclitemArray.parse(from.nspacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgNdistinct {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgNdistinct

        return from;
      }
    }
    export namespace PgNodeTree {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgNodeTree

        return from;
      }
    }
    export namespace PgOpclass {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgOpclass
        if (PgCatalog.Types.PgOpclass.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            opcmethod: PgCatalog.Types.Oid.parse(from.opcmethod),
            opcname: PgCatalog.Types.Name.parse(from.opcname),
            opcnamespace: PgCatalog.Types.Oid.parse(from.opcnamespace),
            opcowner: PgCatalog.Types.Oid.parse(from.opcowner),
            opcfamily: PgCatalog.Types.Oid.parse(from.opcfamily),
            opcintype: PgCatalog.Types.Oid.parse(from.opcintype),
            opcdefault: PgCatalog.Types.Bool.parse(from.opcdefault),
            opckeytype: PgCatalog.Types.Oid.parse(from.opckeytype),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgOperator {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgOperator
        if (PgCatalog.Types.PgOperator.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            oprname: PgCatalog.Types.Name.parse(from.oprname),
            oprnamespace: PgCatalog.Types.Oid.parse(from.oprnamespace),
            oprowner: PgCatalog.Types.Oid.parse(from.oprowner),
            oprkind: PgCatalog.Types.Char.parse(from.oprkind),
            oprcanmerge: PgCatalog.Types.Bool.parse(from.oprcanmerge),
            oprcanhash: PgCatalog.Types.Bool.parse(from.oprcanhash),
            oprleft: PgCatalog.Types.Oid.parse(from.oprleft),
            oprright: PgCatalog.Types.Oid.parse(from.oprright),
            oprresult: PgCatalog.Types.Oid.parse(from.oprresult),
            oprcom: PgCatalog.Types.Oid.parse(from.oprcom),
            oprnegate: PgCatalog.Types.Oid.parse(from.oprnegate),
            oprcode: PgCatalog.Types.Regproc.parse(from.oprcode),
            oprrest: PgCatalog.Types.Regproc.parse(from.oprrest),
            oprjoin: PgCatalog.Types.Regproc.parse(from.oprjoin),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgOpfamily {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgOpfamily
        if (PgCatalog.Types.PgOpfamily.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            opfmethod: PgCatalog.Types.Oid.parse(from.opfmethod),
            opfname: PgCatalog.Types.Name.parse(from.opfname),
            opfnamespace: PgCatalog.Types.Oid.parse(from.opfnamespace),
            opfowner: PgCatalog.Types.Oid.parse(from.opfowner),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgParameterAcl {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgParameterAcl
        if (PgCatalog.Types.PgParameterAcl.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            parname: PgCatalog.Types.Text.parse(from.parname),
            paracl: PgCatalog.Types.AclitemArray.parse(from.paracl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPartitionedTable {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPartitionedTable
        if (PgCatalog.Types.PgPartitionedTable.is(from)) {
          return {
            partrelid: PgCatalog.Types.Oid.parse(from.partrelid),
            partstrat: PgCatalog.Types.Char.parse(from.partstrat),
            partnatts: PgCatalog.Types.Int2.parse(from.partnatts),
            partdefid: PgCatalog.Types.Oid.parse(from.partdefid),
            partattrs: PgCatalog.Types.Int2vector.parse(from.partattrs),
            partclass: PgCatalog.Types.Oidvector.parse(from.partclass),
            partcollation: PgCatalog.Types.Oidvector.parse(from.partcollation),
            partexprs: PgCatalog.Types.PgNodeTree.parse(from.partexprs),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPolicies {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPolicies
        if (PgCatalog.Types.PgPolicies.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            policyname: PgCatalog.Types.Name.parse(from.policyname),
            permissive: PgCatalog.Types.Text.parse(from.permissive),
            roles: PgCatalog.Types.NameArray.parse(from.roles),
            cmd: PgCatalog.Types.Text.parse(from.cmd),
            qual: PgCatalog.Types.Text.parse(from.qual),
            withCheck: PgCatalog.Types.Text.parse(from.withCheck),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPolicy {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPolicy
        if (PgCatalog.Types.PgPolicy.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            polname: PgCatalog.Types.Name.parse(from.polname),
            polrelid: PgCatalog.Types.Oid.parse(from.polrelid),
            polcmd: PgCatalog.Types.Char.parse(from.polcmd),
            polpermissive: PgCatalog.Types.Bool.parse(from.polpermissive),
            polroles: PgCatalog.Types.OidArray.parse(from.polroles),
            polqual: PgCatalog.Types.PgNodeTree.parse(from.polqual),
            polwithcheck: PgCatalog.Types.PgNodeTree.parse(from.polwithcheck),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPreparedStatements {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPreparedStatements
        if (PgCatalog.Types.PgPreparedStatements.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            statement: PgCatalog.Types.Text.parse(from.statement),
            prepareTime: PgCatalog.Types.Timestamptz.parse(from.prepareTime),
            parameterTypes: PgCatalog.Types.RegtypeArray.parse(
              from.parameterTypes,
            ),
            resultTypes: PgCatalog.Types.RegtypeArray.parse(from.resultTypes),
            fromSql: PgCatalog.Types.Bool.parse(from.fromSql),
            genericPlans: PgCatalog.Types.Int8.parse(from.genericPlans),
            customPlans: PgCatalog.Types.Int8.parse(from.customPlans),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPreparedXacts {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPreparedXacts
        if (PgCatalog.Types.PgPreparedXacts.is(from)) {
          return {
            transaction: PgCatalog.Types.Xid.parse(from.transaction),
            gid: PgCatalog.Types.Text.parse(from.gid),
            prepared: PgCatalog.Types.Timestamptz.parse(from.prepared),
            owner: PgCatalog.Types.Name.parse(from.owner),
            database: PgCatalog.Types.Name.parse(from.database),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgProc {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgProc
        if (PgCatalog.Types.PgProc.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            proname: PgCatalog.Types.Name.parse(from.proname),
            pronamespace: PgCatalog.Types.Oid.parse(from.pronamespace),
            proowner: PgCatalog.Types.Oid.parse(from.proowner),
            prolang: PgCatalog.Types.Oid.parse(from.prolang),
            procost: PgCatalog.Types.Float4.parse(from.procost),
            prorows: PgCatalog.Types.Float4.parse(from.prorows),
            provariadic: PgCatalog.Types.Oid.parse(from.provariadic),
            prosupport: PgCatalog.Types.Regproc.parse(from.prosupport),
            prokind: PgCatalog.Types.Char.parse(from.prokind),
            prosecdef: PgCatalog.Types.Bool.parse(from.prosecdef),
            proleakproof: PgCatalog.Types.Bool.parse(from.proleakproof),
            proisstrict: PgCatalog.Types.Bool.parse(from.proisstrict),
            proretset: PgCatalog.Types.Bool.parse(from.proretset),
            provolatile: PgCatalog.Types.Char.parse(from.provolatile),
            proparallel: PgCatalog.Types.Char.parse(from.proparallel),
            pronargs: PgCatalog.Types.Int2.parse(from.pronargs),
            pronargdefaults: PgCatalog.Types.Int2.parse(from.pronargdefaults),
            prorettype: PgCatalog.Types.Oid.parse(from.prorettype),
            proargtypes: PgCatalog.Types.Oidvector.parse(from.proargtypes),
            proallargtypes: PgCatalog.Types.OidArray.parse(from.proallargtypes),
            proargmodes: PgCatalog.Types.CharArray.parse(from.proargmodes),
            proargnames: PgCatalog.Types.TextArray.parse(from.proargnames),
            proargdefaults: PgCatalog.Types.PgNodeTree.parse(
              from.proargdefaults,
            ),
            protrftypes: PgCatalog.Types.OidArray.parse(from.protrftypes),
            prosrc: PgCatalog.Types.Text.parse(from.prosrc),
            probin: PgCatalog.Types.Text.parse(from.probin),
            prosqlbody: PgCatalog.Types.PgNodeTree.parse(from.prosqlbody),
            proconfig: PgCatalog.Types.TextArray.parse(from.proconfig),
            proacl: PgCatalog.Types.AclitemArray.parse(from.proacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPublication {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPublication
        if (PgCatalog.Types.PgPublication.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            pubname: PgCatalog.Types.Name.parse(from.pubname),
            pubowner: PgCatalog.Types.Oid.parse(from.pubowner),
            puballtables: PgCatalog.Types.Bool.parse(from.puballtables),
            pubinsert: PgCatalog.Types.Bool.parse(from.pubinsert),
            pubupdate: PgCatalog.Types.Bool.parse(from.pubupdate),
            pubdelete: PgCatalog.Types.Bool.parse(from.pubdelete),
            pubtruncate: PgCatalog.Types.Bool.parse(from.pubtruncate),
            pubviaroot: PgCatalog.Types.Bool.parse(from.pubviaroot),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPublicationNamespace {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPublicationNamespace
        if (PgCatalog.Types.PgPublicationNamespace.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            pnpubid: PgCatalog.Types.Oid.parse(from.pnpubid),
            pnnspid: PgCatalog.Types.Oid.parse(from.pnnspid),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPublicationRel {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPublicationRel
        if (PgCatalog.Types.PgPublicationRel.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            prpubid: PgCatalog.Types.Oid.parse(from.prpubid),
            prrelid: PgCatalog.Types.Oid.parse(from.prrelid),
            prqual: PgCatalog.Types.PgNodeTree.parse(from.prqual),
            prattrs: PgCatalog.Types.Int2vector.parse(from.prattrs),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgPublicationTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgPublicationTables
        if (PgCatalog.Types.PgPublicationTables.is(from)) {
          return {
            pubname: PgCatalog.Types.Name.parse(from.pubname),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            attnames: PgCatalog.Types.NameArray.parse(from.attnames),
            rowfilter: PgCatalog.Types.Text.parse(from.rowfilter),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgRange {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgRange
        if (PgCatalog.Types.PgRange.is(from)) {
          return {
            rngtypid: PgCatalog.Types.Oid.parse(from.rngtypid),
            rngsubtype: PgCatalog.Types.Oid.parse(from.rngsubtype),
            rngmultitypid: PgCatalog.Types.Oid.parse(from.rngmultitypid),
            rngcollation: PgCatalog.Types.Oid.parse(from.rngcollation),
            rngsubopc: PgCatalog.Types.Oid.parse(from.rngsubopc),
            rngcanonical: PgCatalog.Types.Regproc.parse(from.rngcanonical),
            rngsubdiff: PgCatalog.Types.Regproc.parse(from.rngsubdiff),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgReplicationOrigin {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgReplicationOrigin
        if (PgCatalog.Types.PgReplicationOrigin.is(from)) {
          return {
            roident: PgCatalog.Types.Oid.parse(from.roident),
            roname: PgCatalog.Types.Text.parse(from.roname),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgReplicationOriginStatus {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgReplicationOriginStatus
        if (PgCatalog.Types.PgReplicationOriginStatus.is(from)) {
          return {
            localId: PgCatalog.Types.Oid.parse(from.localId),
            externalId: PgCatalog.Types.Text.parse(from.externalId),
            remoteLsn: PgCatalog.Types.PgLsn.parse(from.remoteLsn),
            localLsn: PgCatalog.Types.PgLsn.parse(from.localLsn),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgReplicationSlots {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgReplicationSlots
        if (PgCatalog.Types.PgReplicationSlots.is(from)) {
          return {
            slotName: PgCatalog.Types.Name.parse(from.slotName),
            plugin: PgCatalog.Types.Name.parse(from.plugin),
            slotType: PgCatalog.Types.Text.parse(from.slotType),
            datoid: PgCatalog.Types.Oid.parse(from.datoid),
            database: PgCatalog.Types.Name.parse(from.database),
            temporary: PgCatalog.Types.Bool.parse(from.temporary),
            active: PgCatalog.Types.Bool.parse(from.active),
            activePid: PgCatalog.Types.Int4.parse(from.activePid),
            xmin: PgCatalog.Types.Xid.parse(from.xmin),
            catalogXmin: PgCatalog.Types.Xid.parse(from.catalogXmin),
            restartLsn: PgCatalog.Types.PgLsn.parse(from.restartLsn),
            confirmedFlushLsn: PgCatalog.Types.PgLsn.parse(
              from.confirmedFlushLsn,
            ),
            walStatus: PgCatalog.Types.Text.parse(from.walStatus),
            safeWalSize: PgCatalog.Types.Int8.parse(from.safeWalSize),
            twoPhase: PgCatalog.Types.Bool.parse(from.twoPhase),
            conflicting: PgCatalog.Types.Bool.parse(from.conflicting),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgRewrite {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgRewrite
        if (PgCatalog.Types.PgRewrite.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            rulename: PgCatalog.Types.Name.parse(from.rulename),
            evClass: PgCatalog.Types.Oid.parse(from.evClass),
            evType: PgCatalog.Types.Char.parse(from.evType),
            evEnabled: PgCatalog.Types.Char.parse(from.evEnabled),
            isInstead: PgCatalog.Types.Bool.parse(from.isInstead),
            evQual: PgCatalog.Types.PgNodeTree.parse(from.evQual),
            evAction: PgCatalog.Types.PgNodeTree.parse(from.evAction),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgRoles {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgRoles
        if (PgCatalog.Types.PgRoles.is(from)) {
          return {
            rolname: PgCatalog.Types.Name.parse(from.rolname),
            rolsuper: PgCatalog.Types.Bool.parse(from.rolsuper),
            rolinherit: PgCatalog.Types.Bool.parse(from.rolinherit),
            rolcreaterole: PgCatalog.Types.Bool.parse(from.rolcreaterole),
            rolcreatedb: PgCatalog.Types.Bool.parse(from.rolcreatedb),
            rolcanlogin: PgCatalog.Types.Bool.parse(from.rolcanlogin),
            rolreplication: PgCatalog.Types.Bool.parse(from.rolreplication),
            rolconnlimit: PgCatalog.Types.Int4.parse(from.rolconnlimit),
            rolpassword: PgCatalog.Types.Text.parse(from.rolpassword),
            rolvaliduntil: PgCatalog.Types.Timestamptz.parse(
              from.rolvaliduntil,
            ),
            rolbypassrls: PgCatalog.Types.Bool.parse(from.rolbypassrls),
            rolconfig: PgCatalog.Types.TextArray.parse(from.rolconfig),
            oid: PgCatalog.Types.Oid.parse(from.oid),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgRules {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgRules
        if (PgCatalog.Types.PgRules.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            rulename: PgCatalog.Types.Name.parse(from.rulename),
            definition: PgCatalog.Types.Text.parse(from.definition),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSeclabel {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSeclabel
        if (PgCatalog.Types.PgSeclabel.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            provider: PgCatalog.Types.Text.parse(from.provider),
            label: PgCatalog.Types.Text.parse(from.label),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSeclabels {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSeclabels
        if (PgCatalog.Types.PgSeclabels.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            objtype: PgCatalog.Types.Text.parse(from.objtype),
            objnamespace: PgCatalog.Types.Oid.parse(from.objnamespace),
            objname: PgCatalog.Types.Text.parse(from.objname),
            provider: PgCatalog.Types.Text.parse(from.provider),
            label: PgCatalog.Types.Text.parse(from.label),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSequence {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSequence
        if (PgCatalog.Types.PgSequence.is(from)) {
          return {
            seqrelid: PgCatalog.Types.Oid.parse(from.seqrelid),
            seqtypid: PgCatalog.Types.Oid.parse(from.seqtypid),
            seqstart: PgCatalog.Types.Int8.parse(from.seqstart),
            seqincrement: PgCatalog.Types.Int8.parse(from.seqincrement),
            seqmax: PgCatalog.Types.Int8.parse(from.seqmax),
            seqmin: PgCatalog.Types.Int8.parse(from.seqmin),
            seqcache: PgCatalog.Types.Int8.parse(from.seqcache),
            seqcycle: PgCatalog.Types.Bool.parse(from.seqcycle),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSequences {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSequences
        if (PgCatalog.Types.PgSequences.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            sequencename: PgCatalog.Types.Name.parse(from.sequencename),
            sequenceowner: PgCatalog.Types.Name.parse(from.sequenceowner),
            dataType: PgCatalog.Types.Regtype.parse(from.dataType),
            startValue: PgCatalog.Types.Int8.parse(from.startValue),
            minValue: PgCatalog.Types.Int8.parse(from.minValue),
            maxValue: PgCatalog.Types.Int8.parse(from.maxValue),
            incrementBy: PgCatalog.Types.Int8.parse(from.incrementBy),
            cycle: PgCatalog.Types.Bool.parse(from.cycle),
            cacheSize: PgCatalog.Types.Int8.parse(from.cacheSize),
            lastValue: PgCatalog.Types.Int8.parse(from.lastValue),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSettings {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSettings
        if (PgCatalog.Types.PgSettings.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            setting: PgCatalog.Types.Text.parse(from.setting),
            unit: PgCatalog.Types.Text.parse(from.unit),
            category: PgCatalog.Types.Text.parse(from.category),
            shortDesc: PgCatalog.Types.Text.parse(from.shortDesc),
            extraDesc: PgCatalog.Types.Text.parse(from.extraDesc),
            context: PgCatalog.Types.Text.parse(from.context),
            vartype: PgCatalog.Types.Text.parse(from.vartype),
            source: PgCatalog.Types.Text.parse(from.source),
            minVal: PgCatalog.Types.Text.parse(from.minVal),
            maxVal: PgCatalog.Types.Text.parse(from.maxVal),
            enumvals: PgCatalog.Types.TextArray.parse(from.enumvals),
            bootVal: PgCatalog.Types.Text.parse(from.bootVal),
            resetVal: PgCatalog.Types.Text.parse(from.resetVal),
            sourcefile: PgCatalog.Types.Text.parse(from.sourcefile),
            sourceline: PgCatalog.Types.Int4.parse(from.sourceline),
            pendingRestart: PgCatalog.Types.Bool.parse(from.pendingRestart),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgShadow {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgShadow
        if (PgCatalog.Types.PgShadow.is(from)) {
          return {
            usename: PgCatalog.Types.Name.parse(from.usename),
            usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
            usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
            usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
            userepl: PgCatalog.Types.Bool.parse(from.userepl),
            usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
            passwd: PgCatalog.Types.Text.parse(from.passwd),
            valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
            useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgShdepend {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgShdepend
        if (PgCatalog.Types.PgShdepend.is(from)) {
          return {
            dbid: PgCatalog.Types.Oid.parse(from.dbid),
            classid: PgCatalog.Types.Oid.parse(from.classid),
            objid: PgCatalog.Types.Oid.parse(from.objid),
            objsubid: PgCatalog.Types.Int4.parse(from.objsubid),
            refclassid: PgCatalog.Types.Oid.parse(from.refclassid),
            refobjid: PgCatalog.Types.Oid.parse(from.refobjid),
            deptype: PgCatalog.Types.Char.parse(from.deptype),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgShdescription {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgShdescription
        if (PgCatalog.Types.PgShdescription.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            description: PgCatalog.Types.Text.parse(from.description),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgShmemAllocations {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgShmemAllocations
        if (PgCatalog.Types.PgShmemAllocations.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            off: PgCatalog.Types.Int8.parse(from.off),
            size: PgCatalog.Types.Int8.parse(from.size),
            allocatedSize: PgCatalog.Types.Int8.parse(from.allocatedSize),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgShseclabel {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgShseclabel
        if (PgCatalog.Types.PgShseclabel.is(from)) {
          return {
            objoid: PgCatalog.Types.Oid.parse(from.objoid),
            classoid: PgCatalog.Types.Oid.parse(from.classoid),
            provider: PgCatalog.Types.Text.parse(from.provider),
            label: PgCatalog.Types.Text.parse(from.label),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSnapshot {
      export function parse(from: any) {
        // Type PgCatalog.Types.PgSnapshot

        return from;
      }
    }
    export namespace PgStatActivity {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatActivity
        if (PgCatalog.Types.PgStatActivity.is(from)) {
          return {
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            pid: PgCatalog.Types.Int4.parse(from.pid),
            leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
            usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
            usename: PgCatalog.Types.Name.parse(from.usename),
            applicationName: PgCatalog.Types.Text.parse(from.applicationName),
            clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
            clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
            clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
            backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
            xactStart: PgCatalog.Types.Timestamptz.parse(from.xactStart),
            queryStart: PgCatalog.Types.Timestamptz.parse(from.queryStart),
            stateChange: PgCatalog.Types.Timestamptz.parse(from.stateChange),
            waitEventType: PgCatalog.Types.Text.parse(from.waitEventType),
            waitEvent: PgCatalog.Types.Text.parse(from.waitEvent),
            state: PgCatalog.Types.Text.parse(from.state),
            backendXid: PgCatalog.Types.Xid.parse(from.backendXid),
            backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
            queryId: PgCatalog.Types.Int8.parse(from.queryId),
            query: PgCatalog.Types.Text.parse(from.query),
            backendType: PgCatalog.Types.Text.parse(from.backendType),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatAllIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatAllIndexes
        if (PgCatalog.Types.PgStatAllIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatAllTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatAllTables
        if (PgCatalog.Types.PgStatAllTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
            nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
            nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
            nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
            nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
            lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
            lastAutovacuum: PgCatalog.Types.Timestamptz.parse(
              from.lastAutovacuum,
            ),
            lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
            lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(
              from.lastAutoanalyze,
            ),
            vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
            autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
            analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
            autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatArchiver {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatArchiver
        if (PgCatalog.Types.PgStatArchiver.is(from)) {
          return {
            archivedCount: PgCatalog.Types.Int8.parse(from.archivedCount),
            lastArchivedWal: PgCatalog.Types.Text.parse(from.lastArchivedWal),
            lastArchivedTime: PgCatalog.Types.Timestamptz.parse(
              from.lastArchivedTime,
            ),
            failedCount: PgCatalog.Types.Int8.parse(from.failedCount),
            lastFailedWal: PgCatalog.Types.Text.parse(from.lastFailedWal),
            lastFailedTime: PgCatalog.Types.Timestamptz.parse(
              from.lastFailedTime,
            ),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatBgwriter {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatBgwriter
        if (PgCatalog.Types.PgStatBgwriter.is(from)) {
          return {
            checkpointsTimed: PgCatalog.Types.Int8.parse(from.checkpointsTimed),
            checkpointsReq: PgCatalog.Types.Int8.parse(from.checkpointsReq),
            checkpointWriteTime: PgCatalog.Types.Float8.parse(
              from.checkpointWriteTime,
            ),
            checkpointSyncTime: PgCatalog.Types.Float8.parse(
              from.checkpointSyncTime,
            ),
            buffersCheckpoint: PgCatalog.Types.Int8.parse(
              from.buffersCheckpoint,
            ),
            buffersClean: PgCatalog.Types.Int8.parse(from.buffersClean),
            maxwrittenClean: PgCatalog.Types.Int8.parse(from.maxwrittenClean),
            buffersBackend: PgCatalog.Types.Int8.parse(from.buffersBackend),
            buffersBackendFsync: PgCatalog.Types.Int8.parse(
              from.buffersBackendFsync,
            ),
            buffersAlloc: PgCatalog.Types.Int8.parse(from.buffersAlloc),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatDatabase {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatDatabase
        if (PgCatalog.Types.PgStatDatabase.is(from)) {
          return {
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            numbackends: PgCatalog.Types.Int4.parse(from.numbackends),
            xactCommit: PgCatalog.Types.Int8.parse(from.xactCommit),
            xactRollback: PgCatalog.Types.Int8.parse(from.xactRollback),
            blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
            blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
            tupReturned: PgCatalog.Types.Int8.parse(from.tupReturned),
            tupFetched: PgCatalog.Types.Int8.parse(from.tupFetched),
            tupInserted: PgCatalog.Types.Int8.parse(from.tupInserted),
            tupUpdated: PgCatalog.Types.Int8.parse(from.tupUpdated),
            tupDeleted: PgCatalog.Types.Int8.parse(from.tupDeleted),
            conflicts: PgCatalog.Types.Int8.parse(from.conflicts),
            tempFiles: PgCatalog.Types.Int8.parse(from.tempFiles),
            tempBytes: PgCatalog.Types.Int8.parse(from.tempBytes),
            deadlocks: PgCatalog.Types.Int8.parse(from.deadlocks),
            checksumFailures: PgCatalog.Types.Int8.parse(from.checksumFailures),
            checksumLastFailure: PgCatalog.Types.Timestamptz.parse(
              from.checksumLastFailure,
            ),
            blkReadTime: PgCatalog.Types.Float8.parse(from.blkReadTime),
            blkWriteTime: PgCatalog.Types.Float8.parse(from.blkWriteTime),
            sessionTime: PgCatalog.Types.Float8.parse(from.sessionTime),
            activeTime: PgCatalog.Types.Float8.parse(from.activeTime),
            idleInTransactionTime: PgCatalog.Types.Float8.parse(
              from.idleInTransactionTime,
            ),
            sessions: PgCatalog.Types.Int8.parse(from.sessions),
            sessionsAbandoned: PgCatalog.Types.Int8.parse(
              from.sessionsAbandoned,
            ),
            sessionsFatal: PgCatalog.Types.Int8.parse(from.sessionsFatal),
            sessionsKilled: PgCatalog.Types.Int8.parse(from.sessionsKilled),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatDatabaseConflicts {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatDatabaseConflicts
        if (PgCatalog.Types.PgStatDatabaseConflicts.is(from)) {
          return {
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            conflTablespace: PgCatalog.Types.Int8.parse(from.conflTablespace),
            conflLock: PgCatalog.Types.Int8.parse(from.conflLock),
            conflSnapshot: PgCatalog.Types.Int8.parse(from.conflSnapshot),
            conflBufferpin: PgCatalog.Types.Int8.parse(from.conflBufferpin),
            conflDeadlock: PgCatalog.Types.Int8.parse(from.conflDeadlock),
            conflActiveLogicalslot: PgCatalog.Types.Int8.parse(
              from.conflActiveLogicalslot,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatGssapi {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatGssapi
        if (PgCatalog.Types.PgStatGssapi.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            gssAuthenticated: PgCatalog.Types.Bool.parse(from.gssAuthenticated),
            principal: PgCatalog.Types.Text.parse(from.principal),
            encrypted: PgCatalog.Types.Bool.parse(from.encrypted),
            credentialsDelegated: PgCatalog.Types.Bool.parse(
              from.credentialsDelegated,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatIo {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatIo
        if (PgCatalog.Types.PgStatIo.is(from)) {
          return {
            backendType: PgCatalog.Types.Text.parse(from.backendType),
            object: PgCatalog.Types.Text.parse(from.object),
            context: PgCatalog.Types.Text.parse(from.context),
            reads: PgCatalog.Types.Int8.parse(from.reads),
            readTime: PgCatalog.Types.Float8.parse(from.readTime),
            writes: PgCatalog.Types.Int8.parse(from.writes),
            writeTime: PgCatalog.Types.Float8.parse(from.writeTime),
            writebacks: PgCatalog.Types.Int8.parse(from.writebacks),
            writebackTime: PgCatalog.Types.Float8.parse(from.writebackTime),
            extends: PgCatalog.Types.Int8.parse(from.extends),
            extendTime: PgCatalog.Types.Float8.parse(from.extendTime),
            opBytes: PgCatalog.Types.Int8.parse(from.opBytes),
            hits: PgCatalog.Types.Int8.parse(from.hits),
            evictions: PgCatalog.Types.Int8.parse(from.evictions),
            reuses: PgCatalog.Types.Int8.parse(from.reuses),
            fsyncs: PgCatalog.Types.Int8.parse(from.fsyncs),
            fsyncTime: PgCatalog.Types.Float8.parse(from.fsyncTime),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressAnalyze {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressAnalyze
        if (PgCatalog.Types.PgStatProgressAnalyze.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            phase: PgCatalog.Types.Text.parse(from.phase),
            sampleBlksTotal: PgCatalog.Types.Int8.parse(from.sampleBlksTotal),
            sampleBlksScanned: PgCatalog.Types.Int8.parse(
              from.sampleBlksScanned,
            ),
            extStatsTotal: PgCatalog.Types.Int8.parse(from.extStatsTotal),
            extStatsComputed: PgCatalog.Types.Int8.parse(from.extStatsComputed),
            childTablesTotal: PgCatalog.Types.Int8.parse(from.childTablesTotal),
            childTablesDone: PgCatalog.Types.Int8.parse(from.childTablesDone),
            currentChildTableRelid: PgCatalog.Types.Oid.parse(
              from.currentChildTableRelid,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressBasebackup {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressBasebackup
        if (PgCatalog.Types.PgStatProgressBasebackup.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            phase: PgCatalog.Types.Text.parse(from.phase),
            backupTotal: PgCatalog.Types.Int8.parse(from.backupTotal),
            backupStreamed: PgCatalog.Types.Int8.parse(from.backupStreamed),
            tablespacesTotal: PgCatalog.Types.Int8.parse(from.tablespacesTotal),
            tablespacesStreamed: PgCatalog.Types.Int8.parse(
              from.tablespacesStreamed,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressCluster {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressCluster
        if (PgCatalog.Types.PgStatProgressCluster.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            command: PgCatalog.Types.Text.parse(from.command),
            phase: PgCatalog.Types.Text.parse(from.phase),
            clusterIndexRelid: PgCatalog.Types.Oid.parse(
              from.clusterIndexRelid,
            ),
            heapTuplesScanned: PgCatalog.Types.Int8.parse(
              from.heapTuplesScanned,
            ),
            heapTuplesWritten: PgCatalog.Types.Int8.parse(
              from.heapTuplesWritten,
            ),
            heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
            heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
            indexRebuildCount: PgCatalog.Types.Int8.parse(
              from.indexRebuildCount,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressCopy {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressCopy
        if (PgCatalog.Types.PgStatProgressCopy.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            command: PgCatalog.Types.Text.parse(from.command),
            type: PgCatalog.Types.Text.parse(from.type),
            bytesProcessed: PgCatalog.Types.Int8.parse(from.bytesProcessed),
            bytesTotal: PgCatalog.Types.Int8.parse(from.bytesTotal),
            tuplesProcessed: PgCatalog.Types.Int8.parse(from.tuplesProcessed),
            tuplesExcluded: PgCatalog.Types.Int8.parse(from.tuplesExcluded),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressCreateIndex {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressCreateIndex
        if (PgCatalog.Types.PgStatProgressCreateIndex.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexRelid: PgCatalog.Types.Oid.parse(from.indexRelid),
            command: PgCatalog.Types.Text.parse(from.command),
            phase: PgCatalog.Types.Text.parse(from.phase),
            lockersTotal: PgCatalog.Types.Int8.parse(from.lockersTotal),
            lockersDone: PgCatalog.Types.Int8.parse(from.lockersDone),
            currentLockerPid: PgCatalog.Types.Int8.parse(from.currentLockerPid),
            blocksTotal: PgCatalog.Types.Int8.parse(from.blocksTotal),
            blocksDone: PgCatalog.Types.Int8.parse(from.blocksDone),
            tuplesTotal: PgCatalog.Types.Int8.parse(from.tuplesTotal),
            tuplesDone: PgCatalog.Types.Int8.parse(from.tuplesDone),
            partitionsTotal: PgCatalog.Types.Int8.parse(from.partitionsTotal),
            partitionsDone: PgCatalog.Types.Int8.parse(from.partitionsDone),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatProgressVacuum {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatProgressVacuum
        if (PgCatalog.Types.PgStatProgressVacuum.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            datid: PgCatalog.Types.Oid.parse(from.datid),
            datname: PgCatalog.Types.Name.parse(from.datname),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            phase: PgCatalog.Types.Text.parse(from.phase),
            heapBlksTotal: PgCatalog.Types.Int8.parse(from.heapBlksTotal),
            heapBlksScanned: PgCatalog.Types.Int8.parse(from.heapBlksScanned),
            heapBlksVacuumed: PgCatalog.Types.Int8.parse(from.heapBlksVacuumed),
            indexVacuumCount: PgCatalog.Types.Int8.parse(from.indexVacuumCount),
            maxDeadTuples: PgCatalog.Types.Int8.parse(from.maxDeadTuples),
            numDeadTuples: PgCatalog.Types.Int8.parse(from.numDeadTuples),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatRecoveryPrefetch {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatRecoveryPrefetch
        if (PgCatalog.Types.PgStatRecoveryPrefetch.is(from)) {
          return {
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
            prefetch: PgCatalog.Types.Int8.parse(from.prefetch),
            hit: PgCatalog.Types.Int8.parse(from.hit),
            skipInit: PgCatalog.Types.Int8.parse(from.skipInit),
            skipNew: PgCatalog.Types.Int8.parse(from.skipNew),
            skipFpw: PgCatalog.Types.Int8.parse(from.skipFpw),
            skipRep: PgCatalog.Types.Int8.parse(from.skipRep),
            walDistance: PgCatalog.Types.Int4.parse(from.walDistance),
            blockDistance: PgCatalog.Types.Int4.parse(from.blockDistance),
            ioDepth: PgCatalog.Types.Int4.parse(from.ioDepth),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatReplication {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatReplication
        if (PgCatalog.Types.PgStatReplication.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
            usename: PgCatalog.Types.Name.parse(from.usename),
            applicationName: PgCatalog.Types.Text.parse(from.applicationName),
            clientAddr: PgCatalog.Types.Inet.parse(from.clientAddr),
            clientHostname: PgCatalog.Types.Text.parse(from.clientHostname),
            clientPort: PgCatalog.Types.Int4.parse(from.clientPort),
            backendStart: PgCatalog.Types.Timestamptz.parse(from.backendStart),
            backendXmin: PgCatalog.Types.Xid.parse(from.backendXmin),
            state: PgCatalog.Types.Text.parse(from.state),
            sentLsn: PgCatalog.Types.PgLsn.parse(from.sentLsn),
            writeLsn: PgCatalog.Types.PgLsn.parse(from.writeLsn),
            flushLsn: PgCatalog.Types.PgLsn.parse(from.flushLsn),
            replayLsn: PgCatalog.Types.PgLsn.parse(from.replayLsn),
            writeLag: PgCatalog.Types.Interval.parse(from.writeLag),
            flushLag: PgCatalog.Types.Interval.parse(from.flushLag),
            replayLag: PgCatalog.Types.Interval.parse(from.replayLag),
            syncPriority: PgCatalog.Types.Int4.parse(from.syncPriority),
            syncState: PgCatalog.Types.Text.parse(from.syncState),
            replyTime: PgCatalog.Types.Timestamptz.parse(from.replyTime),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatReplicationSlots {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatReplicationSlots
        if (PgCatalog.Types.PgStatReplicationSlots.is(from)) {
          return {
            slotName: PgCatalog.Types.Text.parse(from.slotName),
            spillTxns: PgCatalog.Types.Int8.parse(from.spillTxns),
            spillCount: PgCatalog.Types.Int8.parse(from.spillCount),
            spillBytes: PgCatalog.Types.Int8.parse(from.spillBytes),
            streamTxns: PgCatalog.Types.Int8.parse(from.streamTxns),
            streamCount: PgCatalog.Types.Int8.parse(from.streamCount),
            streamBytes: PgCatalog.Types.Int8.parse(from.streamBytes),
            totalTxns: PgCatalog.Types.Int8.parse(from.totalTxns),
            totalBytes: PgCatalog.Types.Int8.parse(from.totalBytes),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSlru {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSlru
        if (PgCatalog.Types.PgStatSlru.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            blksZeroed: PgCatalog.Types.Int8.parse(from.blksZeroed),
            blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
            blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
            blksWritten: PgCatalog.Types.Int8.parse(from.blksWritten),
            blksExists: PgCatalog.Types.Int8.parse(from.blksExists),
            flushes: PgCatalog.Types.Int8.parse(from.flushes),
            truncates: PgCatalog.Types.Int8.parse(from.truncates),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSsl {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSsl
        if (PgCatalog.Types.PgStatSsl.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            ssl: PgCatalog.Types.Bool.parse(from.ssl),
            version: PgCatalog.Types.Text.parse(from.version),
            cipher: PgCatalog.Types.Text.parse(from.cipher),
            bits: PgCatalog.Types.Int4.parse(from.bits),
            clientDn: PgCatalog.Types.Text.parse(from.clientDn),
            clientSerial: PgCatalog.Types.Numeric.parse(from.clientSerial),
            issuerDn: PgCatalog.Types.Text.parse(from.issuerDn),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSubscription {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSubscription
        if (PgCatalog.Types.PgStatSubscription.is(from)) {
          return {
            subid: PgCatalog.Types.Oid.parse(from.subid),
            subname: PgCatalog.Types.Name.parse(from.subname),
            pid: PgCatalog.Types.Int4.parse(from.pid),
            leaderPid: PgCatalog.Types.Int4.parse(from.leaderPid),
            relid: PgCatalog.Types.Oid.parse(from.relid),
            receivedLsn: PgCatalog.Types.PgLsn.parse(from.receivedLsn),
            lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(
              from.lastMsgSendTime,
            ),
            lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(
              from.lastMsgReceiptTime,
            ),
            latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
            latestEndTime: PgCatalog.Types.Timestamptz.parse(
              from.latestEndTime,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSubscriptionStats {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSubscriptionStats
        if (PgCatalog.Types.PgStatSubscriptionStats.is(from)) {
          return {
            subid: PgCatalog.Types.Oid.parse(from.subid),
            subname: PgCatalog.Types.Name.parse(from.subname),
            applyErrorCount: PgCatalog.Types.Int8.parse(from.applyErrorCount),
            syncErrorCount: PgCatalog.Types.Int8.parse(from.syncErrorCount),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSysIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSysIndexes
        if (PgCatalog.Types.PgStatSysIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatSysTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatSysTables
        if (PgCatalog.Types.PgStatSysTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
            nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
            nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
            nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
            nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
            lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
            lastAutovacuum: PgCatalog.Types.Timestamptz.parse(
              from.lastAutovacuum,
            ),
            lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
            lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(
              from.lastAutoanalyze,
            ),
            vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
            autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
            analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
            autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatUserFunctions {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatUserFunctions
        if (PgCatalog.Types.PgStatUserFunctions.is(from)) {
          return {
            funcid: PgCatalog.Types.Oid.parse(from.funcid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            funcname: PgCatalog.Types.Name.parse(from.funcname),
            calls: PgCatalog.Types.Int8.parse(from.calls),
            totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
            selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatUserIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatUserIndexes
        if (PgCatalog.Types.PgStatUserIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupRead: PgCatalog.Types.Int8.parse(from.idxTupRead),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatUserTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatUserTables
        if (PgCatalog.Types.PgStatUserTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            lastSeqScan: PgCatalog.Types.Timestamptz.parse(from.lastSeqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            lastIdxScan: PgCatalog.Types.Timestamptz.parse(from.lastIdxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
            nLiveTup: PgCatalog.Types.Int8.parse(from.nLiveTup),
            nDeadTup: PgCatalog.Types.Int8.parse(from.nDeadTup),
            nModSinceAnalyze: PgCatalog.Types.Int8.parse(from.nModSinceAnalyze),
            nInsSinceVacuum: PgCatalog.Types.Int8.parse(from.nInsSinceVacuum),
            lastVacuum: PgCatalog.Types.Timestamptz.parse(from.lastVacuum),
            lastAutovacuum: PgCatalog.Types.Timestamptz.parse(
              from.lastAutovacuum,
            ),
            lastAnalyze: PgCatalog.Types.Timestamptz.parse(from.lastAnalyze),
            lastAutoanalyze: PgCatalog.Types.Timestamptz.parse(
              from.lastAutoanalyze,
            ),
            vacuumCount: PgCatalog.Types.Int8.parse(from.vacuumCount),
            autovacuumCount: PgCatalog.Types.Int8.parse(from.autovacuumCount),
            analyzeCount: PgCatalog.Types.Int8.parse(from.analyzeCount),
            autoanalyzeCount: PgCatalog.Types.Int8.parse(from.autoanalyzeCount),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatWal {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatWal
        if (PgCatalog.Types.PgStatWal.is(from)) {
          return {
            walRecords: PgCatalog.Types.Int8.parse(from.walRecords),
            walFpi: PgCatalog.Types.Int8.parse(from.walFpi),
            walBytes: PgCatalog.Types.Numeric.parse(from.walBytes),
            walBuffersFull: PgCatalog.Types.Int8.parse(from.walBuffersFull),
            walWrite: PgCatalog.Types.Int8.parse(from.walWrite),
            walSync: PgCatalog.Types.Int8.parse(from.walSync),
            walWriteTime: PgCatalog.Types.Float8.parse(from.walWriteTime),
            walSyncTime: PgCatalog.Types.Float8.parse(from.walSyncTime),
            statsReset: PgCatalog.Types.Timestamptz.parse(from.statsReset),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatWalReceiver {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatWalReceiver
        if (PgCatalog.Types.PgStatWalReceiver.is(from)) {
          return {
            pid: PgCatalog.Types.Int4.parse(from.pid),
            status: PgCatalog.Types.Text.parse(from.status),
            receiveStartLsn: PgCatalog.Types.PgLsn.parse(from.receiveStartLsn),
            receiveStartTli: PgCatalog.Types.Int4.parse(from.receiveStartTli),
            writtenLsn: PgCatalog.Types.PgLsn.parse(from.writtenLsn),
            flushedLsn: PgCatalog.Types.PgLsn.parse(from.flushedLsn),
            receivedTli: PgCatalog.Types.Int4.parse(from.receivedTli),
            lastMsgSendTime: PgCatalog.Types.Timestamptz.parse(
              from.lastMsgSendTime,
            ),
            lastMsgReceiptTime: PgCatalog.Types.Timestamptz.parse(
              from.lastMsgReceiptTime,
            ),
            latestEndLsn: PgCatalog.Types.PgLsn.parse(from.latestEndLsn),
            latestEndTime: PgCatalog.Types.Timestamptz.parse(
              from.latestEndTime,
            ),
            slotName: PgCatalog.Types.Text.parse(from.slotName),
            senderHost: PgCatalog.Types.Text.parse(from.senderHost),
            senderPort: PgCatalog.Types.Int4.parse(from.senderPort),
            conninfo: PgCatalog.Types.Text.parse(from.conninfo),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatXactAllTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatXactAllTables
        if (PgCatalog.Types.PgStatXactAllTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatXactSysTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatXactSysTables
        if (PgCatalog.Types.PgStatXactSysTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatXactUserFunctions {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatXactUserFunctions
        if (PgCatalog.Types.PgStatXactUserFunctions.is(from)) {
          return {
            funcid: PgCatalog.Types.Oid.parse(from.funcid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            funcname: PgCatalog.Types.Name.parse(from.funcname),
            calls: PgCatalog.Types.Int8.parse(from.calls),
            totalTime: PgCatalog.Types.Float8.parse(from.totalTime),
            selfTime: PgCatalog.Types.Float8.parse(from.selfTime),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatXactUserTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatXactUserTables
        if (PgCatalog.Types.PgStatXactUserTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            seqScan: PgCatalog.Types.Int8.parse(from.seqScan),
            seqTupRead: PgCatalog.Types.Int8.parse(from.seqTupRead),
            idxScan: PgCatalog.Types.Int8.parse(from.idxScan),
            idxTupFetch: PgCatalog.Types.Int8.parse(from.idxTupFetch),
            nTupIns: PgCatalog.Types.Int8.parse(from.nTupIns),
            nTupUpd: PgCatalog.Types.Int8.parse(from.nTupUpd),
            nTupDel: PgCatalog.Types.Int8.parse(from.nTupDel),
            nTupHotUpd: PgCatalog.Types.Int8.parse(from.nTupHotUpd),
            nTupNewpageUpd: PgCatalog.Types.Int8.parse(from.nTupNewpageUpd),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioAllIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioAllIndexes
        if (PgCatalog.Types.PgStatioAllIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioAllSequences {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioAllSequences
        if (PgCatalog.Types.PgStatioAllSequences.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
            blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioAllTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioAllTables
        if (PgCatalog.Types.PgStatioAllTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
            heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
            toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
            toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
            tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
            tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioSysIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioSysIndexes
        if (PgCatalog.Types.PgStatioSysIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioSysSequences {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioSysSequences
        if (PgCatalog.Types.PgStatioSysSequences.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
            blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioSysTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioSysTables
        if (PgCatalog.Types.PgStatioSysTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
            heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
            toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
            toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
            tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
            tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioUserIndexes {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioUserIndexes
        if (PgCatalog.Types.PgStatioUserIndexes.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            indexrelid: PgCatalog.Types.Oid.parse(from.indexrelid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            indexrelname: PgCatalog.Types.Name.parse(from.indexrelname),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioUserSequences {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioUserSequences
        if (PgCatalog.Types.PgStatioUserSequences.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            blksRead: PgCatalog.Types.Int8.parse(from.blksRead),
            blksHit: PgCatalog.Types.Int8.parse(from.blksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatioUserTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatioUserTables
        if (PgCatalog.Types.PgStatioUserTables.is(from)) {
          return {
            relid: PgCatalog.Types.Oid.parse(from.relid),
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            heapBlksRead: PgCatalog.Types.Int8.parse(from.heapBlksRead),
            heapBlksHit: PgCatalog.Types.Int8.parse(from.heapBlksHit),
            idxBlksRead: PgCatalog.Types.Int8.parse(from.idxBlksRead),
            idxBlksHit: PgCatalog.Types.Int8.parse(from.idxBlksHit),
            toastBlksRead: PgCatalog.Types.Int8.parse(from.toastBlksRead),
            toastBlksHit: PgCatalog.Types.Int8.parse(from.toastBlksHit),
            tidxBlksRead: PgCatalog.Types.Int8.parse(from.tidxBlksRead),
            tidxBlksHit: PgCatalog.Types.Int8.parse(from.tidxBlksHit),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatistic {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatistic
        if (PgCatalog.Types.PgStatistic.is(from)) {
          return {
            starelid: PgCatalog.Types.Oid.parse(from.starelid),
            staattnum: PgCatalog.Types.Int2.parse(from.staattnum),
            stainherit: PgCatalog.Types.Bool.parse(from.stainherit),
            stanullfrac: PgCatalog.Types.Float4.parse(from.stanullfrac),
            stawidth: PgCatalog.Types.Int4.parse(from.stawidth),
            stadistinct: PgCatalog.Types.Float4.parse(from.stadistinct),
            stakind1: PgCatalog.Types.Int2.parse(from.stakind1),
            stakind2: PgCatalog.Types.Int2.parse(from.stakind2),
            stakind3: PgCatalog.Types.Int2.parse(from.stakind3),
            stakind4: PgCatalog.Types.Int2.parse(from.stakind4),
            stakind5: PgCatalog.Types.Int2.parse(from.stakind5),
            staop1: PgCatalog.Types.Oid.parse(from.staop1),
            staop2: PgCatalog.Types.Oid.parse(from.staop2),
            staop3: PgCatalog.Types.Oid.parse(from.staop3),
            staop4: PgCatalog.Types.Oid.parse(from.staop4),
            staop5: PgCatalog.Types.Oid.parse(from.staop5),
            stacoll1: PgCatalog.Types.Oid.parse(from.stacoll1),
            stacoll2: PgCatalog.Types.Oid.parse(from.stacoll2),
            stacoll3: PgCatalog.Types.Oid.parse(from.stacoll3),
            stacoll4: PgCatalog.Types.Oid.parse(from.stacoll4),
            stacoll5: PgCatalog.Types.Oid.parse(from.stacoll5),
            stanumbers1: PgCatalog.Types.Float4Array.parse(from.stanumbers1),
            stanumbers2: PgCatalog.Types.Float4Array.parse(from.stanumbers2),
            stanumbers3: PgCatalog.Types.Float4Array.parse(from.stanumbers3),
            stanumbers4: PgCatalog.Types.Float4Array.parse(from.stanumbers4),
            stanumbers5: PgCatalog.Types.Float4Array.parse(from.stanumbers5),
            stavalues1: PgCatalog.Types.Anyarray.parse(from.stavalues1),
            stavalues2: PgCatalog.Types.Anyarray.parse(from.stavalues2),
            stavalues3: PgCatalog.Types.Anyarray.parse(from.stavalues3),
            stavalues4: PgCatalog.Types.Anyarray.parse(from.stavalues4),
            stavalues5: PgCatalog.Types.Anyarray.parse(from.stavalues5),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatisticExt {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatisticExt
        if (PgCatalog.Types.PgStatisticExt.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            stxrelid: PgCatalog.Types.Oid.parse(from.stxrelid),
            stxname: PgCatalog.Types.Name.parse(from.stxname),
            stxnamespace: PgCatalog.Types.Oid.parse(from.stxnamespace),
            stxowner: PgCatalog.Types.Oid.parse(from.stxowner),
            stxstattarget: PgCatalog.Types.Int4.parse(from.stxstattarget),
            stxkeys: PgCatalog.Types.Int2vector.parse(from.stxkeys),
            stxkind: PgCatalog.Types.CharArray.parse(from.stxkind),
            stxexprs: PgCatalog.Types.PgNodeTree.parse(from.stxexprs),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatisticExtData {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatisticExtData
        if (PgCatalog.Types.PgStatisticExtData.is(from)) {
          return {
            stxoid: PgCatalog.Types.Oid.parse(from.stxoid),
            stxdinherit: PgCatalog.Types.Bool.parse(from.stxdinherit),
            stxdndistinct: PgCatalog.Types.PgNdistinct.parse(
              from.stxdndistinct,
            ),
            stxddependencies: PgCatalog.Types.PgDependencies.parse(
              from.stxddependencies,
            ),
            stxdmcv: PgCatalog.Types.PgMcvList.parse(from.stxdmcv),
            stxdexpr: PgCatalog.Types.PgStatisticArray.parse(from.stxdexpr),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStats {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStats
        if (PgCatalog.Types.PgStats.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            attname: PgCatalog.Types.Name.parse(from.attname),
            inherited: PgCatalog.Types.Bool.parse(from.inherited),
            nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
            avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
            nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
            mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
            mostCommonFreqs: PgCatalog.Types.Float4Array.parse(
              from.mostCommonFreqs,
            ),
            histogramBounds: PgCatalog.Types.Anyarray.parse(
              from.histogramBounds,
            ),
            correlation: PgCatalog.Types.Float4.parse(from.correlation),
            mostCommonElems: PgCatalog.Types.Anyarray.parse(
              from.mostCommonElems,
            ),
            mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(
              from.mostCommonElemFreqs,
            ),
            elemCountHistogram: PgCatalog.Types.Float4Array.parse(
              from.elemCountHistogram,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatsExt {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatsExt
        if (PgCatalog.Types.PgStatsExt.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            statisticsSchemaname: PgCatalog.Types.Name.parse(
              from.statisticsSchemaname,
            ),
            statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
            statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
            attnames: PgCatalog.Types.NameArray.parse(from.attnames),
            exprs: PgCatalog.Types.TextArray.parse(from.exprs),
            kinds: PgCatalog.Types.CharArray.parse(from.kinds),
            inherited: PgCatalog.Types.Bool.parse(from.inherited),
            nDistinct: PgCatalog.Types.PgNdistinct.parse(from.nDistinct),
            dependencies: PgCatalog.Types.PgDependencies.parse(
              from.dependencies,
            ),
            mostCommonVals: PgCatalog.Types.TextArray.parse(
              from.mostCommonVals,
            ),
            mostCommonValNulls: PgCatalog.Types.BoolArray.parse(
              from.mostCommonValNulls,
            ),
            mostCommonFreqs: PgCatalog.Types.Float8Array.parse(
              from.mostCommonFreqs,
            ),
            mostCommonBaseFreqs: PgCatalog.Types.Float8Array.parse(
              from.mostCommonBaseFreqs,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgStatsExtExprs {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgStatsExtExprs
        if (PgCatalog.Types.PgStatsExtExprs.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            statisticsSchemaname: PgCatalog.Types.Name.parse(
              from.statisticsSchemaname,
            ),
            statisticsName: PgCatalog.Types.Name.parse(from.statisticsName),
            statisticsOwner: PgCatalog.Types.Name.parse(from.statisticsOwner),
            expr: PgCatalog.Types.Text.parse(from.expr),
            inherited: PgCatalog.Types.Bool.parse(from.inherited),
            nullFrac: PgCatalog.Types.Float4.parse(from.nullFrac),
            avgWidth: PgCatalog.Types.Int4.parse(from.avgWidth),
            nDistinct: PgCatalog.Types.Float4.parse(from.nDistinct),
            mostCommonVals: PgCatalog.Types.Anyarray.parse(from.mostCommonVals),
            mostCommonFreqs: PgCatalog.Types.Float4Array.parse(
              from.mostCommonFreqs,
            ),
            histogramBounds: PgCatalog.Types.Anyarray.parse(
              from.histogramBounds,
            ),
            correlation: PgCatalog.Types.Float4.parse(from.correlation),
            mostCommonElems: PgCatalog.Types.Anyarray.parse(
              from.mostCommonElems,
            ),
            mostCommonElemFreqs: PgCatalog.Types.Float4Array.parse(
              from.mostCommonElemFreqs,
            ),
            elemCountHistogram: PgCatalog.Types.Float4Array.parse(
              from.elemCountHistogram,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSubscription {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSubscription
        if (PgCatalog.Types.PgSubscription.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            subdbid: PgCatalog.Types.Oid.parse(from.subdbid),
            subskiplsn: PgCatalog.Types.PgLsn.parse(from.subskiplsn),
            subname: PgCatalog.Types.Name.parse(from.subname),
            subowner: PgCatalog.Types.Oid.parse(from.subowner),
            subenabled: PgCatalog.Types.Bool.parse(from.subenabled),
            subbinary: PgCatalog.Types.Bool.parse(from.subbinary),
            substream: PgCatalog.Types.Char.parse(from.substream),
            subtwophasestate: PgCatalog.Types.Char.parse(from.subtwophasestate),
            subdisableonerr: PgCatalog.Types.Bool.parse(from.subdisableonerr),
            subpasswordrequired: PgCatalog.Types.Bool.parse(
              from.subpasswordrequired,
            ),
            subrunasowner: PgCatalog.Types.Bool.parse(from.subrunasowner),
            subconninfo: PgCatalog.Types.Text.parse(from.subconninfo),
            subslotname: PgCatalog.Types.Name.parse(from.subslotname),
            subsynccommit: PgCatalog.Types.Text.parse(from.subsynccommit),
            subpublications: PgCatalog.Types.TextArray.parse(
              from.subpublications,
            ),
            suborigin: PgCatalog.Types.Text.parse(from.suborigin),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgSubscriptionRel {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgSubscriptionRel
        if (PgCatalog.Types.PgSubscriptionRel.is(from)) {
          return {
            srsubid: PgCatalog.Types.Oid.parse(from.srsubid),
            srrelid: PgCatalog.Types.Oid.parse(from.srrelid),
            srsubstate: PgCatalog.Types.Char.parse(from.srsubstate),
            srsublsn: PgCatalog.Types.PgLsn.parse(from.srsublsn),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTables {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTables
        if (PgCatalog.Types.PgTables.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            tablename: PgCatalog.Types.Name.parse(from.tablename),
            tableowner: PgCatalog.Types.Name.parse(from.tableowner),
            tablespace: PgCatalog.Types.Name.parse(from.tablespace),
            hasindexes: PgCatalog.Types.Bool.parse(from.hasindexes),
            hasrules: PgCatalog.Types.Bool.parse(from.hasrules),
            hastriggers: PgCatalog.Types.Bool.parse(from.hastriggers),
            rowsecurity: PgCatalog.Types.Bool.parse(from.rowsecurity),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTablespace {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTablespace
        if (PgCatalog.Types.PgTablespace.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            spcname: PgCatalog.Types.Name.parse(from.spcname),
            spcowner: PgCatalog.Types.Oid.parse(from.spcowner),
            spcacl: PgCatalog.Types.AclitemArray.parse(from.spcacl),
            spcoptions: PgCatalog.Types.TextArray.parse(from.spcoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTimezoneAbbrevs {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTimezoneAbbrevs
        if (PgCatalog.Types.PgTimezoneAbbrevs.is(from)) {
          return {
            abbrev: PgCatalog.Types.Text.parse(from.abbrev),
            utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
            isDst: PgCatalog.Types.Bool.parse(from.isDst),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTimezoneNames {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTimezoneNames
        if (PgCatalog.Types.PgTimezoneNames.is(from)) {
          return {
            name: PgCatalog.Types.Text.parse(from.name),
            abbrev: PgCatalog.Types.Text.parse(from.abbrev),
            utcOffset: PgCatalog.Types.Interval.parse(from.utcOffset),
            isDst: PgCatalog.Types.Bool.parse(from.isDst),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTransform {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTransform
        if (PgCatalog.Types.PgTransform.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            trftype: PgCatalog.Types.Oid.parse(from.trftype),
            trflang: PgCatalog.Types.Oid.parse(from.trflang),
            trffromsql: PgCatalog.Types.Regproc.parse(from.trffromsql),
            trftosql: PgCatalog.Types.Regproc.parse(from.trftosql),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTrigger {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTrigger
        if (PgCatalog.Types.PgTrigger.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            tgrelid: PgCatalog.Types.Oid.parse(from.tgrelid),
            tgparentid: PgCatalog.Types.Oid.parse(from.tgparentid),
            tgname: PgCatalog.Types.Name.parse(from.tgname),
            tgfoid: PgCatalog.Types.Oid.parse(from.tgfoid),
            tgtype: PgCatalog.Types.Int2.parse(from.tgtype),
            tgenabled: PgCatalog.Types.Char.parse(from.tgenabled),
            tgisinternal: PgCatalog.Types.Bool.parse(from.tgisinternal),
            tgconstrrelid: PgCatalog.Types.Oid.parse(from.tgconstrrelid),
            tgconstrindid: PgCatalog.Types.Oid.parse(from.tgconstrindid),
            tgconstraint: PgCatalog.Types.Oid.parse(from.tgconstraint),
            tgdeferrable: PgCatalog.Types.Bool.parse(from.tgdeferrable),
            tginitdeferred: PgCatalog.Types.Bool.parse(from.tginitdeferred),
            tgnargs: PgCatalog.Types.Int2.parse(from.tgnargs),
            tgattr: PgCatalog.Types.Int2vector.parse(from.tgattr),
            tgargs: PgCatalog.Types.Bytea.parse(from.tgargs),
            tgqual: PgCatalog.Types.PgNodeTree.parse(from.tgqual),
            tgoldtable: PgCatalog.Types.Name.parse(from.tgoldtable),
            tgnewtable: PgCatalog.Types.Name.parse(from.tgnewtable),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTsConfig {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTsConfig
        if (PgCatalog.Types.PgTsConfig.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            cfgname: PgCatalog.Types.Name.parse(from.cfgname),
            cfgnamespace: PgCatalog.Types.Oid.parse(from.cfgnamespace),
            cfgowner: PgCatalog.Types.Oid.parse(from.cfgowner),
            cfgparser: PgCatalog.Types.Oid.parse(from.cfgparser),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTsConfigMap {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTsConfigMap
        if (PgCatalog.Types.PgTsConfigMap.is(from)) {
          return {
            mapcfg: PgCatalog.Types.Oid.parse(from.mapcfg),
            maptokentype: PgCatalog.Types.Int4.parse(from.maptokentype),
            mapseqno: PgCatalog.Types.Int4.parse(from.mapseqno),
            mapdict: PgCatalog.Types.Oid.parse(from.mapdict),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTsDict {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTsDict
        if (PgCatalog.Types.PgTsDict.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            dictname: PgCatalog.Types.Name.parse(from.dictname),
            dictnamespace: PgCatalog.Types.Oid.parse(from.dictnamespace),
            dictowner: PgCatalog.Types.Oid.parse(from.dictowner),
            dicttemplate: PgCatalog.Types.Oid.parse(from.dicttemplate),
            dictinitoption: PgCatalog.Types.Text.parse(from.dictinitoption),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTsParser {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTsParser
        if (PgCatalog.Types.PgTsParser.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            prsname: PgCatalog.Types.Name.parse(from.prsname),
            prsnamespace: PgCatalog.Types.Oid.parse(from.prsnamespace),
            prsstart: PgCatalog.Types.Regproc.parse(from.prsstart),
            prstoken: PgCatalog.Types.Regproc.parse(from.prstoken),
            prsend: PgCatalog.Types.Regproc.parse(from.prsend),
            prsheadline: PgCatalog.Types.Regproc.parse(from.prsheadline),
            prslextype: PgCatalog.Types.Regproc.parse(from.prslextype),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgTsTemplate {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgTsTemplate
        if (PgCatalog.Types.PgTsTemplate.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            tmplname: PgCatalog.Types.Name.parse(from.tmplname),
            tmplnamespace: PgCatalog.Types.Oid.parse(from.tmplnamespace),
            tmplinit: PgCatalog.Types.Regproc.parse(from.tmplinit),
            tmpllexize: PgCatalog.Types.Regproc.parse(from.tmpllexize),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgType {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgType
        if (PgCatalog.Types.PgType.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            typname: PgCatalog.Types.Name.parse(from.typname),
            typnamespace: PgCatalog.Types.Oid.parse(from.typnamespace),
            typowner: PgCatalog.Types.Oid.parse(from.typowner),
            typlen: PgCatalog.Types.Int2.parse(from.typlen),
            typbyval: PgCatalog.Types.Bool.parse(from.typbyval),
            typtype: PgCatalog.Types.Char.parse(from.typtype),
            typcategory: PgCatalog.Types.Char.parse(from.typcategory),
            typispreferred: PgCatalog.Types.Bool.parse(from.typispreferred),
            typisdefined: PgCatalog.Types.Bool.parse(from.typisdefined),
            typdelim: PgCatalog.Types.Char.parse(from.typdelim),
            typrelid: PgCatalog.Types.Oid.parse(from.typrelid),
            typsubscript: PgCatalog.Types.Regproc.parse(from.typsubscript),
            typelem: PgCatalog.Types.Oid.parse(from.typelem),
            typarray: PgCatalog.Types.Oid.parse(from.typarray),
            typinput: PgCatalog.Types.Regproc.parse(from.typinput),
            typoutput: PgCatalog.Types.Regproc.parse(from.typoutput),
            typreceive: PgCatalog.Types.Regproc.parse(from.typreceive),
            typsend: PgCatalog.Types.Regproc.parse(from.typsend),
            typmodin: PgCatalog.Types.Regproc.parse(from.typmodin),
            typmodout: PgCatalog.Types.Regproc.parse(from.typmodout),
            typanalyze: PgCatalog.Types.Regproc.parse(from.typanalyze),
            typalign: PgCatalog.Types.Char.parse(from.typalign),
            typstorage: PgCatalog.Types.Char.parse(from.typstorage),
            typnotnull: PgCatalog.Types.Bool.parse(from.typnotnull),
            typbasetype: PgCatalog.Types.Oid.parse(from.typbasetype),
            typtypmod: PgCatalog.Types.Int4.parse(from.typtypmod),
            typndims: PgCatalog.Types.Int4.parse(from.typndims),
            typcollation: PgCatalog.Types.Oid.parse(from.typcollation),
            typdefaultbin: PgCatalog.Types.PgNodeTree.parse(from.typdefaultbin),
            typdefault: PgCatalog.Types.Text.parse(from.typdefault),
            typacl: PgCatalog.Types.AclitemArray.parse(from.typacl),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgUser {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgUser
        if (PgCatalog.Types.PgUser.is(from)) {
          return {
            usename: PgCatalog.Types.Name.parse(from.usename),
            usesysid: PgCatalog.Types.Oid.parse(from.usesysid),
            usecreatedb: PgCatalog.Types.Bool.parse(from.usecreatedb),
            usesuper: PgCatalog.Types.Bool.parse(from.usesuper),
            userepl: PgCatalog.Types.Bool.parse(from.userepl),
            usebypassrls: PgCatalog.Types.Bool.parse(from.usebypassrls),
            passwd: PgCatalog.Types.Text.parse(from.passwd),
            valuntil: PgCatalog.Types.Timestamptz.parse(from.valuntil),
            useconfig: PgCatalog.Types.TextArray.parse(from.useconfig),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgUserMapping {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgUserMapping
        if (PgCatalog.Types.PgUserMapping.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            umuser: PgCatalog.Types.Oid.parse(from.umuser),
            umserver: PgCatalog.Types.Oid.parse(from.umserver),
            umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgUserMappings {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgUserMappings
        if (PgCatalog.Types.PgUserMappings.is(from)) {
          return {
            umid: PgCatalog.Types.Oid.parse(from.umid),
            srvid: PgCatalog.Types.Oid.parse(from.srvid),
            srvname: PgCatalog.Types.Name.parse(from.srvname),
            umuser: PgCatalog.Types.Oid.parse(from.umuser),
            usename: PgCatalog.Types.Name.parse(from.usename),
            umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgViews {
      export function parse(from: any) {
        // CompositeType PgCatalog.Types.PgViews
        if (PgCatalog.Types.PgViews.is(from)) {
          return {
            schemaname: PgCatalog.Types.Name.parse(from.schemaname),
            viewname: PgCatalog.Types.Name.parse(from.viewname),
            viewowner: PgCatalog.Types.Name.parse(from.viewowner),
            definition: PgCatalog.Types.Text.parse(from.definition),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Point {
      export function parse(from: any) {
        // Type PgCatalog.Types.Point

        return from;
      }
    }
    export namespace Polygon {
      export function parse(from: any) {
        // Type PgCatalog.Types.Polygon

        return from;
      }
    }
    export namespace Record {
      export function parse(from: any) {
        // Type PgCatalog.Types.Record

        return from;
      }
    }
    export namespace Refcursor {
      export function parse(from: any) {
        // Type PgCatalog.Types.Refcursor

        return from;
      }
    }
    export namespace Regclass {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regclass

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regcollation {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regcollation

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regconfig {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regconfig

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regdictionary {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regdictionary

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regnamespace {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regnamespace

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regoper {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regoper

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regoperator {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regoperator

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regproc {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regproc

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regprocedure {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regprocedure

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regrole {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regrole

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace Regtype {
      export function parse(from: any) {
        // Type PgCatalog.Types.Regtype

        if (from === null) return null;
        return Number.parseFloat(from);
      }
    }
    export namespace TableAmHandler {
      export function parse(from: any) {
        // Type PgCatalog.Types.TableAmHandler

        return from;
      }
    }
    export namespace Text {
      export function parse(from: any) {
        // Type PgCatalog.Types.Text

        return from;
      }
    }
    export namespace Tid {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tid

        return from;
      }
    }
    export namespace Time {
      export function parse(from: any) {
        // Type PgCatalog.Types.Time

        if (from === null) return null;
        if ((from as unknown) instanceof global.Date) return from;
        return new global.Date(from);
      }
    }
    export namespace Timestamp {
      export function parse(from: any) {
        // Type PgCatalog.Types.Timestamp

        if (from === null) return null;
        if ((from as unknown) instanceof global.Date) return from;
        return new global.Date(from);
      }
    }
    export namespace Timestamptz {
      export function parse(from: any) {
        // Type PgCatalog.Types.Timestamptz

        if (from === null) return null;
        if ((from as unknown) instanceof global.Date) return from;
        return new global.Date(from);
      }
    }
    export namespace Timetz {
      export function parse(from: any) {
        // Type PgCatalog.Types.Timetz

        if (from === null) return null;
        if ((from as unknown) instanceof global.Date) return from;
        return new global.Date(from);
      }
    }
    export namespace Trigger {
      export function parse(from: any) {
        // Type PgCatalog.Types.Trigger

        return from;
      }
    }
    export namespace TsmHandler {
      export function parse(from: any) {
        // Type PgCatalog.Types.TsmHandler

        return from;
      }
    }
    export namespace Tsmultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tsmultirange

        return from;
      }
    }
    export namespace Tsquery {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tsquery

        return from;
      }
    }
    export namespace Tsrange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tsrange

        return from;
      }
    }
    export namespace Tstzmultirange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tstzmultirange

        return from;
      }
    }
    export namespace Tstzrange {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tstzrange

        return from;
      }
    }
    export namespace Tsvector {
      export function parse(from: any) {
        // Type PgCatalog.Types.Tsvector

        return from;
      }
    }
    export namespace TxidSnapshot {
      export function parse(from: any) {
        // Type PgCatalog.Types.TxidSnapshot

        return from;
      }
    }
    export namespace Unknown {
      export function parse(from: any) {
        // Type PgCatalog.Types.Unknown

        return from;
      }
    }
    export namespace Uuid {
      export function parse(from: any) {
        // Type PgCatalog.Types.Uuid

        return from ? new UUID(from) : null;
      }
    }
    export namespace Varbit {
      export function parse(from: any) {
        // Type PgCatalog.Types.Varbit

        if (from === null) return null;
        if (["t", "T", "true", "True"].includes(from)) return true;
        try {
          if (Number.parseFloat(from) > 0) return true;
        } catch (e) {
          // eat
        }
        return false;
      }
    }
    export namespace Varchar {
      export function parse(from: any) {
        // Type PgCatalog.Types.Varchar

        return from;
      }
    }
    export namespace Void {
      export function parse(from: any) {
        // Type PgCatalog.Types.Void

        return from;
      }
    }
    export namespace Xid {
      export function parse(from: any) {
        // Type PgCatalog.Types.Xid

        return from;
      }
    }
    export namespace Xid8 {
      export function parse(from: any) {
        // Type PgCatalog.Types.Xid8

        return from;
      }
    }
    export namespace Xml {
      export function parse(from: any) {
        // Type PgCatalog.Types.Xml

        return from;
      }
    }
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace PgStatistic {
      export namespace Create {}
    }
    export namespace PgType {
      export namespace Create {}
    }
    export namespace PgForeignTable {
      export namespace Create {}
    }
    export namespace PgAuthid {
      export namespace Create {}
    }
    export namespace PgStatisticExtData {
      export namespace Create {}
    }
    export namespace PgUserMapping {
      export namespace Create {}
    }
    export namespace PgSubscription {
      export namespace Create {}
    }
    export namespace PgAttribute {
      export namespace Create {}
    }
    export namespace PgProc {
      export namespace Create {}
    }
    export namespace PgClass {
      export namespace Create {}
    }
    export namespace PgAttrdef {
      export namespace Create {}
    }
    export namespace PgConstraint {
      export namespace Create {}
    }
    export namespace PgInherits {
      export namespace Create {}
    }
    export namespace PgIndex {
      export namespace Create {}
    }
    export namespace PgOperator {
      export namespace Create {}
    }
    export namespace PgOpfamily {
      export namespace Create {}
    }
    export namespace PgOpclass {
      export namespace Create {}
    }
    export namespace PgAm {
      export namespace Create {}
    }
    export namespace PgAmop {
      export namespace Create {}
    }
    export namespace PgAmproc {
      export namespace Create {}
    }
    export namespace PgLanguage {
      export namespace Create {}
    }
    export namespace PgLargeobjectMetadata {
      export namespace Create {}
    }
    export namespace PgAggregate {
      export namespace Create {}
    }
    export namespace PgStatisticExt {
      export namespace Create {}
    }
    export namespace PgRewrite {
      export namespace Create {}
    }
    export namespace PgTrigger {
      export namespace Create {}
    }
    export namespace PgEventTrigger {
      export namespace Create {}
    }
    export namespace PgDescription {
      export namespace Create {}
    }
    export namespace PgCast {
      export namespace Create {}
    }
    export namespace PgEnum {
      export namespace Create {}
    }
    export namespace PgNamespace {
      export namespace Create {}
    }
    export namespace PgConversion {
      export namespace Create {}
    }
    export namespace PgDepend {
      export namespace Create {}
    }
    export namespace PgDatabase {
      export namespace Create {}
    }
    export namespace PgDbRoleSetting {
      export namespace Create {}
    }
    export namespace PgTablespace {
      export namespace Create {}
    }
    export namespace PgAuthMembers {
      export namespace Create {}
    }
    export namespace PgShdepend {
      export namespace Create {}
    }
    export namespace PgShdescription {
      export namespace Create {}
    }
    export namespace PgTsConfig {
      export namespace Create {}
    }
    export namespace PgTsConfigMap {
      export namespace Create {}
    }
    export namespace PgTsDict {
      export namespace Create {}
    }
    export namespace PgTsParser {
      export namespace Create {}
    }
    export namespace PgTsTemplate {
      export namespace Create {}
    }
    export namespace PgExtension {
      export namespace Create {}
    }
    export namespace PgForeignDataWrapper {
      export namespace Create {}
    }
    export namespace PgForeignServer {
      export namespace Create {}
    }
    export namespace PgPolicy {
      export namespace Create {}
    }
    export namespace PgReplicationOrigin {
      export namespace Create {}
    }
    export namespace PgDefaultAcl {
      export namespace Create {}
    }
    export namespace PgInitPrivs {
      export namespace Create {}
    }
    export namespace PgSeclabel {
      export namespace Create {}
    }
    export namespace PgShseclabel {
      export namespace Create {}
    }
    export namespace PgCollation {
      export namespace Create {}
    }
    export namespace PgParameterAcl {
      export namespace Create {}
    }
    export namespace PgPartitionedTable {
      export namespace Create {}
    }
    export namespace PgRange {
      export namespace Create {}
    }
    export namespace PgTransform {
      export namespace Create {}
    }
    export namespace PgSequence {
      export namespace Create {}
    }
    export namespace PgPublication {
      export namespace Create {}
    }
    export namespace PgPublicationNamespace {
      export namespace Create {}
    }
    export namespace PgPublicationRel {
      export namespace Create {}
    }
    export namespace PgSubscriptionRel {
      export namespace Create {}
    }
    export namespace PgLargeobject {
      export namespace Create {}
    }
  }
}
export namespace Public {
  export namespace Types {
    export namespace ActorArray {
      export function parse(from: any) {
        // ArrayType Public.Types.ActorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Actor.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ActorInfoArray {
      export function parse(from: any) {
        // ArrayType Public.Types.ActorInfoArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ActorInfo.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace AddressArray {
      export function parse(from: any) {
        // ArrayType Public.Types.AddressArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Address.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CategoryArray {
      export function parse(from: any) {
        // ArrayType Public.Types.CategoryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Category.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CityArray {
      export function parse(from: any) {
        // ArrayType Public.Types.CityArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return City.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CountryArray {
      export function parse(from: any) {
        // ArrayType Public.Types.CountryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Country.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CustomerArray {
      export function parse(from: any) {
        // ArrayType Public.Types.CustomerArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Customer.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CustomerListArray {
      export function parse(from: any) {
        // ArrayType Public.Types.CustomerListArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CustomerList.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace FilmArray {
      export function parse(from: any) {
        // ArrayType Public.Types.FilmArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Film.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace FilmActorArray {
      export function parse(from: any) {
        // ArrayType Public.Types.FilmActorArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return FilmActor.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace FilmCategoryArray {
      export function parse(from: any) {
        // ArrayType Public.Types.FilmCategoryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return FilmCategory.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace FilmListArray {
      export function parse(from: any) {
        // ArrayType Public.Types.FilmListArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return FilmList.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace InventoryArray {
      export function parse(from: any) {
        // ArrayType Public.Types.InventoryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Inventory.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace LanguageArray {
      export function parse(from: any) {
        // ArrayType Public.Types.LanguageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Language.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace MpaaRatingArray {
      export function parse(from: any) {
        // ArrayType Public.Types.MpaaRatingArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return MpaaRating.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace NicerButSlowerFilmListArray {
      export function parse(from: any) {
        // ArrayType Public.Types.NicerButSlowerFilmListArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return NicerButSlowerFilmList.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PaymentArray {
      export function parse(from: any) {
        // ArrayType Public.Types.PaymentArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Payment.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RentalArray {
      export function parse(from: any) {
        // ArrayType Public.Types.RentalArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Rental.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SalesByFilmCategoryArray {
      export function parse(from: any) {
        // ArrayType Public.Types.SalesByFilmCategoryArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SalesByFilmCategory.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SalesByStoreArray {
      export function parse(from: any) {
        // ArrayType Public.Types.SalesByStoreArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SalesByStore.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace StaffArray {
      export function parse(from: any) {
        // ArrayType Public.Types.StaffArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Staff.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace StaffListArray {
      export function parse(from: any) {
        // ArrayType Public.Types.StaffListArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return StaffList.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace StoreArray {
      export function parse(from: any) {
        // ArrayType Public.Types.StoreArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Store.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace YearArray {
      export function parse(from: any) {
        // ArrayType Public.Types.YearArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Year.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace Actor {
      export function parse(from: any) {
        // CompositeType Public.Types.Actor
        if (Public.Types.Actor.is(from)) {
          return {
            actorId: PgCatalog.Types.Int4.parse(from.actorId),
            firstName: PgCatalog.Types.Varchar.parse(from.firstName),
            lastName: PgCatalog.Types.Varchar.parse(from.lastName),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ActorInfo {
      export function parse(from: any) {
        // CompositeType Public.Types.ActorInfo
        if (Public.Types.ActorInfo.is(from)) {
          return {
            actorId: PgCatalog.Types.Int4.parse(from.actorId),
            firstName: PgCatalog.Types.Varchar.parse(from.firstName),
            lastName: PgCatalog.Types.Varchar.parse(from.lastName),
            filmInfo: PgCatalog.Types.Text.parse(from.filmInfo),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Address {
      export function parse(from: any) {
        // CompositeType Public.Types.Address
        if (Public.Types.Address.is(from)) {
          return {
            addressId: PgCatalog.Types.Int4.parse(from.addressId),
            address: PgCatalog.Types.Varchar.parse(from.address),
            address2: PgCatalog.Types.Varchar.parse(from.address2),
            district: PgCatalog.Types.Varchar.parse(from.district),
            cityId: PgCatalog.Types.Int2.parse(from.cityId),
            postalCode: PgCatalog.Types.Varchar.parse(from.postalCode),
            phone: PgCatalog.Types.Varchar.parse(from.phone),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Category {
      export function parse(from: any) {
        // CompositeType Public.Types.Category
        if (Public.Types.Category.is(from)) {
          return {
            categoryId: PgCatalog.Types.Int4.parse(from.categoryId),
            name: PgCatalog.Types.Varchar.parse(from.name),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace City {
      export function parse(from: any) {
        // CompositeType Public.Types.City
        if (Public.Types.City.is(from)) {
          return {
            cityId: PgCatalog.Types.Int4.parse(from.cityId),
            city: PgCatalog.Types.Varchar.parse(from.city),
            countryId: PgCatalog.Types.Int2.parse(from.countryId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Country {
      export function parse(from: any) {
        // CompositeType Public.Types.Country
        if (Public.Types.Country.is(from)) {
          return {
            countryId: PgCatalog.Types.Int4.parse(from.countryId),
            country: PgCatalog.Types.Varchar.parse(from.country),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Customer {
      export function parse(from: any) {
        // CompositeType Public.Types.Customer
        if (Public.Types.Customer.is(from)) {
          return {
            customerId: PgCatalog.Types.Int4.parse(from.customerId),
            storeId: PgCatalog.Types.Int2.parse(from.storeId),
            firstName: PgCatalog.Types.Varchar.parse(from.firstName),
            lastName: PgCatalog.Types.Varchar.parse(from.lastName),
            email: PgCatalog.Types.Varchar.parse(from.email),
            addressId: PgCatalog.Types.Int2.parse(from.addressId),
            activebool: PgCatalog.Types.Bool.parse(from.activebool),
            createDate: PgCatalog.Types.Date.parse(from.createDate),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
            active: PgCatalog.Types.Int4.parse(from.active),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace CustomerList {
      export function parse(from: any) {
        // CompositeType Public.Types.CustomerList
        if (Public.Types.CustomerList.is(from)) {
          return {
            id: PgCatalog.Types.Int4.parse(from.id),
            name: PgCatalog.Types.Text.parse(from.name),
            address: PgCatalog.Types.Varchar.parse(from.address),
            zipCode: PgCatalog.Types.Varchar.parse(from.zipCode),
            phone: PgCatalog.Types.Varchar.parse(from.phone),
            city: PgCatalog.Types.Varchar.parse(from.city),
            country: PgCatalog.Types.Varchar.parse(from.country),
            notes: PgCatalog.Types.Text.parse(from.notes),
            sid: PgCatalog.Types.Int2.parse(from.sid),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Film {
      export function parse(from: any) {
        // CompositeType Public.Types.Film
        if (Public.Types.Film.is(from)) {
          return {
            filmId: PgCatalog.Types.Int4.parse(from.filmId),
            title: PgCatalog.Types.Varchar.parse(from.title),
            description: PgCatalog.Types.Text.parse(from.description),
            releaseYear: Public.Types.Year.parse(from.releaseYear),
            languageId: PgCatalog.Types.Int2.parse(from.languageId),
            rentalDuration: PgCatalog.Types.Int2.parse(from.rentalDuration),
            rentalRate: PgCatalog.Types.Numeric.parse(from.rentalRate),
            length: PgCatalog.Types.Int2.parse(from.length),
            replacementCost: PgCatalog.Types.Numeric.parse(
              from.replacementCost,
            ),
            rating: Public.Types.MpaaRating.parse(from.rating),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
            specialFeatures: PgCatalog.Types.TextArray.parse(
              from.specialFeatures,
            ),
            fulltext: PgCatalog.Types.Tsvector.parse(from.fulltext),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace FilmActor {
      export function parse(from: any) {
        // CompositeType Public.Types.FilmActor
        if (Public.Types.FilmActor.is(from)) {
          return {
            actorId: PgCatalog.Types.Int2.parse(from.actorId),
            filmId: PgCatalog.Types.Int2.parse(from.filmId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace FilmCategory {
      export function parse(from: any) {
        // CompositeType Public.Types.FilmCategory
        if (Public.Types.FilmCategory.is(from)) {
          return {
            filmId: PgCatalog.Types.Int2.parse(from.filmId),
            categoryId: PgCatalog.Types.Int2.parse(from.categoryId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace FilmList {
      export function parse(from: any) {
        // CompositeType Public.Types.FilmList
        if (Public.Types.FilmList.is(from)) {
          return {
            fid: PgCatalog.Types.Int4.parse(from.fid),
            title: PgCatalog.Types.Varchar.parse(from.title),
            description: PgCatalog.Types.Text.parse(from.description),
            category: PgCatalog.Types.Varchar.parse(from.category),
            price: PgCatalog.Types.Numeric.parse(from.price),
            length: PgCatalog.Types.Int2.parse(from.length),
            rating: Public.Types.MpaaRating.parse(from.rating),
            actors: PgCatalog.Types.Text.parse(from.actors),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Inventory {
      export function parse(from: any) {
        // CompositeType Public.Types.Inventory
        if (Public.Types.Inventory.is(from)) {
          return {
            inventoryId: PgCatalog.Types.Int4.parse(from.inventoryId),
            filmId: PgCatalog.Types.Int2.parse(from.filmId),
            storeId: PgCatalog.Types.Int2.parse(from.storeId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Language {
      export function parse(from: any) {
        // CompositeType Public.Types.Language
        if (Public.Types.Language.is(from)) {
          return {
            languageId: PgCatalog.Types.Int4.parse(from.languageId),
            name: PgCatalog.Types.Bpchar.parse(from.name),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace MpaaRating {
      export function parse(from: any) {
        // Enum Public.Types.MpaaRating

        return from;
      }
    }
    export namespace NicerButSlowerFilmList {
      export function parse(from: any) {
        // CompositeType Public.Types.NicerButSlowerFilmList
        if (Public.Types.NicerButSlowerFilmList.is(from)) {
          return {
            fid: PgCatalog.Types.Int4.parse(from.fid),
            title: PgCatalog.Types.Varchar.parse(from.title),
            description: PgCatalog.Types.Text.parse(from.description),
            category: PgCatalog.Types.Varchar.parse(from.category),
            price: PgCatalog.Types.Numeric.parse(from.price),
            length: PgCatalog.Types.Int2.parse(from.length),
            rating: Public.Types.MpaaRating.parse(from.rating),
            actors: PgCatalog.Types.Text.parse(from.actors),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Payment {
      export function parse(from: any) {
        // CompositeType Public.Types.Payment
        if (Public.Types.Payment.is(from)) {
          return {
            paymentId: PgCatalog.Types.Int4.parse(from.paymentId),
            customerId: PgCatalog.Types.Int2.parse(from.customerId),
            staffId: PgCatalog.Types.Int2.parse(from.staffId),
            rentalId: PgCatalog.Types.Int4.parse(from.rentalId),
            amount: PgCatalog.Types.Numeric.parse(from.amount),
            paymentDate: PgCatalog.Types.Timestamp.parse(from.paymentDate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Rental {
      export function parse(from: any) {
        // CompositeType Public.Types.Rental
        if (Public.Types.Rental.is(from)) {
          return {
            rentalId: PgCatalog.Types.Int4.parse(from.rentalId),
            rentalDate: PgCatalog.Types.Timestamp.parse(from.rentalDate),
            inventoryId: PgCatalog.Types.Int4.parse(from.inventoryId),
            customerId: PgCatalog.Types.Int2.parse(from.customerId),
            returnDate: PgCatalog.Types.Timestamp.parse(from.returnDate),
            staffId: PgCatalog.Types.Int2.parse(from.staffId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SalesByFilmCategory {
      export function parse(from: any) {
        // CompositeType Public.Types.SalesByFilmCategory
        if (Public.Types.SalesByFilmCategory.is(from)) {
          return {
            category: PgCatalog.Types.Varchar.parse(from.category),
            totalSales: PgCatalog.Types.Numeric.parse(from.totalSales),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SalesByStore {
      export function parse(from: any) {
        // CompositeType Public.Types.SalesByStore
        if (Public.Types.SalesByStore.is(from)) {
          return {
            store: PgCatalog.Types.Text.parse(from.store),
            manager: PgCatalog.Types.Text.parse(from.manager),
            totalSales: PgCatalog.Types.Numeric.parse(from.totalSales),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Staff {
      export function parse(from: any) {
        // CompositeType Public.Types.Staff
        if (Public.Types.Staff.is(from)) {
          return {
            staffId: PgCatalog.Types.Int4.parse(from.staffId),
            firstName: PgCatalog.Types.Varchar.parse(from.firstName),
            lastName: PgCatalog.Types.Varchar.parse(from.lastName),
            addressId: PgCatalog.Types.Int2.parse(from.addressId),
            email: PgCatalog.Types.Varchar.parse(from.email),
            storeId: PgCatalog.Types.Int2.parse(from.storeId),
            active: PgCatalog.Types.Bool.parse(from.active),
            username: PgCatalog.Types.Varchar.parse(from.username),
            password: PgCatalog.Types.Varchar.parse(from.password),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
            picture: PgCatalog.Types.Bytea.parse(from.picture),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace StaffList {
      export function parse(from: any) {
        // CompositeType Public.Types.StaffList
        if (Public.Types.StaffList.is(from)) {
          return {
            id: PgCatalog.Types.Int4.parse(from.id),
            name: PgCatalog.Types.Text.parse(from.name),
            address: PgCatalog.Types.Varchar.parse(from.address),
            zipCode: PgCatalog.Types.Varchar.parse(from.zipCode),
            phone: PgCatalog.Types.Varchar.parse(from.phone),
            city: PgCatalog.Types.Varchar.parse(from.city),
            country: PgCatalog.Types.Varchar.parse(from.country),
            sid: PgCatalog.Types.Int2.parse(from.sid),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Store {
      export function parse(from: any) {
        // CompositeType Public.Types.Store
        if (Public.Types.Store.is(from)) {
          return {
            storeId: PgCatalog.Types.Int4.parse(from.storeId),
            managerStaffId: PgCatalog.Types.Int2.parse(from.managerStaffId),
            addressId: PgCatalog.Types.Int2.parse(from.addressId),
            lastUpdate: PgCatalog.Types.Timestamp.parse(from.lastUpdate),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Year {
      export function parse(from: any) {
        // DomainType Public.Types.Year
        return PgCatalog.Types.Int4.parse(from);
      }
    }
  }
  export namespace Procedures {
    export namespace FilmInStock {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.FilmInStock.Parameters
          if (Public.Procedures.FilmInStock.Parameters.is(from)) {
            return {
              pFilmId: PgCatalog.Types.Int4.parse(from.pFilmId),
              pStoreId: PgCatalog.Types.Int4.parse(from.pStoreId),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.FilmInStock.Results
          return PgCatalog.Types.Int4.parse(from);
        }
      }
    }
    export namespace FilmNotInStock {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.FilmNotInStock.Parameters
          if (Public.Procedures.FilmNotInStock.Parameters.is(from)) {
            return {
              pFilmId: PgCatalog.Types.Int4.parse(from.pFilmId),
              pStoreId: PgCatalog.Types.Int4.parse(from.pStoreId),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.FilmNotInStock.Results
          return PgCatalog.Types.Int4.parse(from);
        }
      }
    }
    export namespace GetCustomerBalance {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.GetCustomerBalance.Parameters
          if (Public.Procedures.GetCustomerBalance.Parameters.is(from)) {
            return {
              pCustomerId: PgCatalog.Types.Int4.parse(from.pCustomerId),
              pEffectiveDate: PgCatalog.Types.Timestamp.parse(
                from.pEffectiveDate,
              ),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.GetCustomerBalance.Results
          return PgCatalog.Types.Numeric.parse(from);
        }
      }
    }
    export namespace InventoryHeldByCustomer {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.InventoryHeldByCustomer.Parameters
          if (Public.Procedures.InventoryHeldByCustomer.Parameters.is(from)) {
            return {
              pInventoryId: PgCatalog.Types.Int4.parse(from.pInventoryId),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.InventoryHeldByCustomer.Results
          return PgCatalog.Types.Int4.parse(from);
        }
      }
    }
    export namespace InventoryInStock {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.InventoryInStock.Parameters
          if (Public.Procedures.InventoryInStock.Parameters.is(from)) {
            return {
              pInventoryId: PgCatalog.Types.Int4.parse(from.pInventoryId),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.InventoryInStock.Results
          return PgCatalog.Types.Bool.parse(from);
        }
      }
    }
    export namespace LastDay {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.LastDay.Parameters
          if (Public.Procedures.LastDay.Parameters.is(from)) {
            return {
              argument_0: PgCatalog.Types.Timestamp.parse(from.argument_0),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.LastDay.Results
          return PgCatalog.Types.Date.parse(from);
        }
      }
    }
    export namespace RewardsReport {
      export namespace Parameters {
        export function parse(from: any) {
          // CompositeType Public.Procedures.RewardsReport.Parameters
          if (Public.Procedures.RewardsReport.Parameters.is(from)) {
            return {
              minMonthlyPurchases: PgCatalog.Types.Int4.parse(
                from.minMonthlyPurchases,
              ),
              minDollarAmountPurchased: PgCatalog.Types.Numeric.parse(
                from.minDollarAmountPurchased,
              ),
            };
          }
          throw new Error(JSON.stringify(from));
        }
      }
      export namespace Results {
        export function parse(from: any) {
          // AliasType Public.Procedures.RewardsReport.Results
          return Public.Types.Customer.parse(from);
        }
      }
    }
  }
  export namespace Tables {
    export namespace FilmActor {
      export namespace Create {}
    }
    export namespace Address {
      export namespace Create {}
    }
    export namespace City {
      export namespace Create {}
    }
    export namespace Customer {
      export namespace Create {}
    }
    export namespace Actor {
      export namespace Create {}
    }
    export namespace FilmCategory {
      export namespace Create {}
    }
    export namespace Inventory {
      export namespace Create {}
    }
    export namespace Category {
      export namespace Create {}
    }
    export namespace Country {
      export namespace Create {}
    }
    export namespace Language {
      export namespace Create {}
    }
    export namespace Rental {
      export namespace Create {}
    }
    export namespace Staff {
      export namespace Create {}
    }
    export namespace Store {
      export namespace Create {}
    }
    export namespace Payment {
      export namespace Create {}
    }
    export namespace Film {
      export namespace Create {}
    }
  }
}
export namespace InformationSchema {
  export namespace Types {
    export namespace AdministrableRoleAuthorizationsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.AdministrableRoleAuthorizationsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return AdministrableRoleAuthorizations.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ApplicableRolesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ApplicableRolesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ApplicableRoles.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace AttributesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.AttributesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Attributes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CardinalNumberArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CardinalNumberArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CardinalNumber.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CharacterDataArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CharacterDataArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CharacterData.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CharacterSetsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CharacterSetsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CharacterSets.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CheckConstraintRoutineUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CheckConstraintRoutineUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CheckConstraintRoutineUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CheckConstraintsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CheckConstraintsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CheckConstraints.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CollationCharacterSetApplicabilityArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CollationCharacterSetApplicabilityArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return CollationCharacterSetApplicability.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace CollationsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.CollationsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Collations.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnColumnUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnColumnUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ColumnColumnUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnDomainUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnDomainUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ColumnDomainUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnOptionsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnOptionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ColumnOptions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnPrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnPrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ColumnPrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnUdtUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnUdtUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ColumnUdtUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ColumnsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ColumnsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Columns.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ConstraintColumnUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ConstraintColumnUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ConstraintColumnUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ConstraintTableUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ConstraintTableUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ConstraintTableUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DataTypePrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.DataTypePrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return DataTypePrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DomainConstraintsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.DomainConstraintsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return DomainConstraints.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DomainUdtUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.DomainUdtUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return DomainUdtUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace DomainsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.DomainsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Domains.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ElementTypesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ElementTypesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ElementTypes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace EnabledRolesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.EnabledRolesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return EnabledRoles.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignDataWrapperOptionsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignDataWrapperOptionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignDataWrapperOptions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignDataWrappersArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignDataWrappersArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignDataWrappers.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignServerOptionsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignServerOptionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignServerOptions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignServersArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignServersArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignServers.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignTableOptionsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignTableOptionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignTableOptions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ForeignTablesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ForeignTablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ForeignTables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace InformationSchemaCatalogNameArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.InformationSchemaCatalogNameArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return InformationSchemaCatalogName.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace KeyColumnUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.KeyColumnUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return KeyColumnUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ParametersArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ParametersArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Parameters.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace PgForeignDataWrappers {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.PgForeignDataWrappers
        if (InformationSchema.Types.PgForeignDataWrappers.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            fdwowner: PgCatalog.Types.Oid.parse(from.fdwowner),
            fdwoptions: PgCatalog.Types.TextArray.parse(from.fdwoptions),
            foreignDataWrapperCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.foreignDataWrapperCatalog,
              ),
            foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignDataWrapperName,
            ),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
            foreignDataWrapperLanguage:
              InformationSchema.Types.CharacterData.parse(
                from.foreignDataWrapperLanguage,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignServers {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.PgForeignServers
        if (InformationSchema.Types.PgForeignServers.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            srvoptions: PgCatalog.Types.TextArray.parse(from.srvoptions),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            foreignDataWrapperCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.foreignDataWrapperCatalog,
              ),
            foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignDataWrapperName,
            ),
            foreignServerType: InformationSchema.Types.CharacterData.parse(
              from.foreignServerType,
            ),
            foreignServerVersion: InformationSchema.Types.CharacterData.parse(
              from.foreignServerVersion,
            ),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignTableColumns {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.PgForeignTableColumns
        if (InformationSchema.Types.PgForeignTableColumns.is(from)) {
          return {
            nspname: PgCatalog.Types.Name.parse(from.nspname),
            relname: PgCatalog.Types.Name.parse(from.relname),
            attname: PgCatalog.Types.Name.parse(from.attname),
            attfdwoptions: PgCatalog.Types.TextArray.parse(from.attfdwoptions),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgForeignTables {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.PgForeignTables
        if (InformationSchema.Types.PgForeignTables.is(from)) {
          return {
            foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableCatalog,
            ),
            foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableSchema,
            ),
            foreignTableName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableName,
            ),
            ftoptions: PgCatalog.Types.TextArray.parse(from.ftoptions),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace PgUserMappings {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.PgUserMappings
        if (InformationSchema.Types.PgUserMappings.is(from)) {
          return {
            oid: PgCatalog.Types.Oid.parse(from.oid),
            umoptions: PgCatalog.Types.TextArray.parse(from.umoptions),
            umuser: PgCatalog.Types.Oid.parse(from.umuser),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            srvowner: InformationSchema.Types.SqlIdentifier.parse(
              from.srvowner,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ReferentialConstraintsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ReferentialConstraintsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ReferentialConstraints.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoleColumnGrantsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoleColumnGrantsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoleColumnGrants.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoleRoutineGrantsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoleRoutineGrantsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoleRoutineGrants.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoleTableGrantsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoleTableGrantsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoleTableGrants.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoleUdtGrantsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoleUdtGrantsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoleUdtGrants.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoleUsageGrantsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoleUsageGrantsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoleUsageGrants.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutineColumnUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutineColumnUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoutineColumnUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutinePrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutinePrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoutinePrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutineRoutineUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutineRoutineUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoutineRoutineUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutineSequenceUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutineSequenceUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoutineSequenceUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutineTableUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutineTableUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return RoutineTableUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace RoutinesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.RoutinesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Routines.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SchemataArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SchemataArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Schemata.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SequencesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SequencesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Sequences.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SqlFeaturesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SqlFeaturesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SqlFeatures.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SqlIdentifierArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SqlIdentifierArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SqlIdentifier.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SqlImplementationInfoArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SqlImplementationInfoArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SqlImplementationInfo.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SqlPartsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SqlPartsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SqlParts.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace SqlSizingArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.SqlSizingArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return SqlSizing.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TableConstraintsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TableConstraintsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return TableConstraints.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TablePrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TablePrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return TablePrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TablesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TablesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Tables.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TimeStampArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TimeStampArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return TimeStamp.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TransformsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TransformsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Transforms.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TriggeredUpdateColumnsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TriggeredUpdateColumnsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return TriggeredUpdateColumns.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace TriggersArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.TriggersArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Triggers.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UdtPrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.UdtPrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return UdtPrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UsagePrivilegesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.UsagePrivilegesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return UsagePrivileges.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UserDefinedTypesArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.UserDefinedTypesArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return UserDefinedTypes.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UserMappingOptionsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.UserMappingOptionsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return UserMappingOptions.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace UserMappingsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.UserMappingsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return UserMappings.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ViewColumnUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ViewColumnUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ViewColumnUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ViewRoutineUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ViewRoutineUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ViewRoutineUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ViewTableUsageArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ViewTableUsageArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return ViewTableUsage.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace ViewsArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.ViewsArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return Views.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace YesOrNoArray {
      export function parse(from: any) {
        // ArrayType InformationSchema.Types.YesOrNoArray

        if (from === null) return null;
        const rawArray = JSON.parse(from);
        return rawArray.map((e: unknown) => {
          return YesOrNo.parse(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${e}`,
          );
        });
      }
    }
    export namespace AdministrableRoleAuthorizations {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.AdministrableRoleAuthorizations
        if (InformationSchema.Types.AdministrableRoleAuthorizations.is(from)) {
          return {
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            roleName: InformationSchema.Types.SqlIdentifier.parse(
              from.roleName,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ApplicableRoles {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ApplicableRoles
        if (InformationSchema.Types.ApplicableRoles.is(from)) {
          return {
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            roleName: InformationSchema.Types.SqlIdentifier.parse(
              from.roleName,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Attributes {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Attributes
        if (InformationSchema.Types.Attributes.is(from)) {
          return {
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            attributeName: InformationSchema.Types.SqlIdentifier.parse(
              from.attributeName,
            ),
            ordinalPosition: InformationSchema.Types.CardinalNumber.parse(
              from.ordinalPosition,
            ),
            attributeDefault: InformationSchema.Types.CharacterData.parse(
              from.attributeDefault,
            ),
            isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            attributeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.attributeUdtCatalog,
            ),
            attributeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.attributeUdtSchema,
            ),
            attributeUdtName: InformationSchema.Types.SqlIdentifier.parse(
              from.attributeUdtName,
            ),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
            isDerivedReferenceAttribute: InformationSchema.Types.YesOrNo.parse(
              from.isDerivedReferenceAttribute,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace CardinalNumber {
      export function parse(from: any) {
        // DomainType InformationSchema.Types.CardinalNumber
        return PgCatalog.Types.Int4.parse(from);
      }
    }
    export namespace CharacterData {
      export function parse(from: any) {
        // DomainType InformationSchema.Types.CharacterData
        return PgCatalog.Types.Varchar.parse(from);
      }
    }
    export namespace CharacterSets {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.CharacterSets
        if (InformationSchema.Types.CharacterSets.is(from)) {
          return {
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            characterRepertoire: InformationSchema.Types.SqlIdentifier.parse(
              from.characterRepertoire,
            ),
            formOfUse: InformationSchema.Types.SqlIdentifier.parse(
              from.formOfUse,
            ),
            defaultCollateCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.defaultCollateCatalog,
            ),
            defaultCollateSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.defaultCollateSchema,
            ),
            defaultCollateName: InformationSchema.Types.SqlIdentifier.parse(
              from.defaultCollateName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace CheckConstraintRoutineUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.CheckConstraintRoutineUsage
        if (InformationSchema.Types.CheckConstraintRoutineUsage.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace CheckConstraints {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.CheckConstraints
        if (InformationSchema.Types.CheckConstraints.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            checkClause: InformationSchema.Types.CharacterData.parse(
              from.checkClause,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace CollationCharacterSetApplicability {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.CollationCharacterSetApplicability
        if (
          InformationSchema.Types.CollationCharacterSetApplicability.is(from)
        ) {
          return {
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Collations {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Collations
        if (InformationSchema.Types.Collations.is(from)) {
          return {
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            padAttribute: InformationSchema.Types.CharacterData.parse(
              from.padAttribute,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ColumnColumnUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ColumnColumnUsage
        if (InformationSchema.Types.ColumnColumnUsage.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            dependentColumn: InformationSchema.Types.SqlIdentifier.parse(
              from.dependentColumn,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ColumnDomainUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ColumnDomainUsage
        if (InformationSchema.Types.ColumnDomainUsage.is(from)) {
          return {
            domainCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.domainCatalog,
            ),
            domainSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.domainSchema,
            ),
            domainName: InformationSchema.Types.SqlIdentifier.parse(
              from.domainName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ColumnOptions {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ColumnOptions
        if (InformationSchema.Types.ColumnOptions.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            optionName: InformationSchema.Types.SqlIdentifier.parse(
              from.optionName,
            ),
            optionValue: InformationSchema.Types.CharacterData.parse(
              from.optionValue,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ColumnPrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ColumnPrivileges
        if (InformationSchema.Types.ColumnPrivileges.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ColumnUdtUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ColumnUdtUsage
        if (InformationSchema.Types.ColumnUdtUsage.is(from)) {
          return {
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Columns {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Columns
        if (InformationSchema.Types.Columns.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            ordinalPosition: InformationSchema.Types.CardinalNumber.parse(
              from.ordinalPosition,
            ),
            columnDefault: InformationSchema.Types.CharacterData.parse(
              from.columnDefault,
            ),
            isNullable: InformationSchema.Types.YesOrNo.parse(from.isNullable),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            domainCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.domainCatalog,
            ),
            domainSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.domainSchema,
            ),
            domainName: InformationSchema.Types.SqlIdentifier.parse(
              from.domainName,
            ),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
            isSelfReferencing: InformationSchema.Types.YesOrNo.parse(
              from.isSelfReferencing,
            ),
            isIdentity: InformationSchema.Types.YesOrNo.parse(from.isIdentity),
            identityGeneration: InformationSchema.Types.CharacterData.parse(
              from.identityGeneration,
            ),
            identityStart: InformationSchema.Types.CharacterData.parse(
              from.identityStart,
            ),
            identityIncrement: InformationSchema.Types.CharacterData.parse(
              from.identityIncrement,
            ),
            identityMaximum: InformationSchema.Types.CharacterData.parse(
              from.identityMaximum,
            ),
            identityMinimum: InformationSchema.Types.CharacterData.parse(
              from.identityMinimum,
            ),
            identityCycle: InformationSchema.Types.YesOrNo.parse(
              from.identityCycle,
            ),
            isGenerated: InformationSchema.Types.CharacterData.parse(
              from.isGenerated,
            ),
            generationExpression: InformationSchema.Types.CharacterData.parse(
              from.generationExpression,
            ),
            isUpdatable: InformationSchema.Types.YesOrNo.parse(
              from.isUpdatable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ConstraintColumnUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ConstraintColumnUsage
        if (InformationSchema.Types.ConstraintColumnUsage.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ConstraintTableUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ConstraintTableUsage
        if (InformationSchema.Types.ConstraintTableUsage.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace DataTypePrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.DataTypePrivileges
        if (InformationSchema.Types.DataTypePrivileges.is(from)) {
          return {
            objectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.objectCatalog,
            ),
            objectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.objectSchema,
            ),
            objectName: InformationSchema.Types.SqlIdentifier.parse(
              from.objectName,
            ),
            objectType: InformationSchema.Types.CharacterData.parse(
              from.objectType,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace DomainConstraints {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.DomainConstraints
        if (InformationSchema.Types.DomainConstraints.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            domainCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.domainCatalog,
            ),
            domainSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.domainSchema,
            ),
            domainName: InformationSchema.Types.SqlIdentifier.parse(
              from.domainName,
            ),
            isDeferrable: InformationSchema.Types.YesOrNo.parse(
              from.isDeferrable,
            ),
            initiallyDeferred: InformationSchema.Types.YesOrNo.parse(
              from.initiallyDeferred,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace DomainUdtUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.DomainUdtUsage
        if (InformationSchema.Types.DomainUdtUsage.is(from)) {
          return {
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            domainCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.domainCatalog,
            ),
            domainSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.domainSchema,
            ),
            domainName: InformationSchema.Types.SqlIdentifier.parse(
              from.domainName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Domains {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Domains
        if (InformationSchema.Types.Domains.is(from)) {
          return {
            domainCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.domainCatalog,
            ),
            domainSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.domainSchema,
            ),
            domainName: InformationSchema.Types.SqlIdentifier.parse(
              from.domainName,
            ),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            domainDefault: InformationSchema.Types.CharacterData.parse(
              from.domainDefault,
            ),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ElementTypes {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ElementTypes
        if (InformationSchema.Types.ElementTypes.is(from)) {
          return {
            objectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.objectCatalog,
            ),
            objectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.objectSchema,
            ),
            objectName: InformationSchema.Types.SqlIdentifier.parse(
              from.objectName,
            ),
            objectType: InformationSchema.Types.CharacterData.parse(
              from.objectType,
            ),
            collectionTypeIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.collectionTypeIdentifier,
              ),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            domainDefault: InformationSchema.Types.CharacterData.parse(
              from.domainDefault,
            ),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace EnabledRoles {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.EnabledRoles
        if (InformationSchema.Types.EnabledRoles.is(from)) {
          return {
            roleName: InformationSchema.Types.SqlIdentifier.parse(
              from.roleName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignDataWrapperOptions {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignDataWrapperOptions
        if (InformationSchema.Types.ForeignDataWrapperOptions.is(from)) {
          return {
            foreignDataWrapperCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.foreignDataWrapperCatalog,
              ),
            foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignDataWrapperName,
            ),
            optionName: InformationSchema.Types.SqlIdentifier.parse(
              from.optionName,
            ),
            optionValue: InformationSchema.Types.CharacterData.parse(
              from.optionValue,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignDataWrappers {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignDataWrappers
        if (InformationSchema.Types.ForeignDataWrappers.is(from)) {
          return {
            foreignDataWrapperCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.foreignDataWrapperCatalog,
              ),
            foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignDataWrapperName,
            ),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
            libraryName: InformationSchema.Types.CharacterData.parse(
              from.libraryName,
            ),
            foreignDataWrapperLanguage:
              InformationSchema.Types.CharacterData.parse(
                from.foreignDataWrapperLanguage,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignServerOptions {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignServerOptions
        if (InformationSchema.Types.ForeignServerOptions.is(from)) {
          return {
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            optionName: InformationSchema.Types.SqlIdentifier.parse(
              from.optionName,
            ),
            optionValue: InformationSchema.Types.CharacterData.parse(
              from.optionValue,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignServers {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignServers
        if (InformationSchema.Types.ForeignServers.is(from)) {
          return {
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            foreignDataWrapperCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.foreignDataWrapperCatalog,
              ),
            foreignDataWrapperName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignDataWrapperName,
            ),
            foreignServerType: InformationSchema.Types.CharacterData.parse(
              from.foreignServerType,
            ),
            foreignServerVersion: InformationSchema.Types.CharacterData.parse(
              from.foreignServerVersion,
            ),
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignTableOptions {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignTableOptions
        if (InformationSchema.Types.ForeignTableOptions.is(from)) {
          return {
            foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableCatalog,
            ),
            foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableSchema,
            ),
            foreignTableName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableName,
            ),
            optionName: InformationSchema.Types.SqlIdentifier.parse(
              from.optionName,
            ),
            optionValue: InformationSchema.Types.CharacterData.parse(
              from.optionValue,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ForeignTables {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ForeignTables
        if (InformationSchema.Types.ForeignTables.is(from)) {
          return {
            foreignTableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableCatalog,
            ),
            foreignTableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableSchema,
            ),
            foreignTableName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignTableName,
            ),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace InformationSchemaCatalogName {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.InformationSchemaCatalogName
        if (InformationSchema.Types.InformationSchemaCatalogName.is(from)) {
          return {
            catalogName: InformationSchema.Types.SqlIdentifier.parse(
              from.catalogName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace KeyColumnUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.KeyColumnUsage
        if (InformationSchema.Types.KeyColumnUsage.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            ordinalPosition: InformationSchema.Types.CardinalNumber.parse(
              from.ordinalPosition,
            ),
            positionInUniqueConstraint:
              InformationSchema.Types.CardinalNumber.parse(
                from.positionInUniqueConstraint,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Parameters {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Parameters
        if (InformationSchema.Types.Parameters.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            ordinalPosition: InformationSchema.Types.CardinalNumber.parse(
              from.ordinalPosition,
            ),
            parameterMode: InformationSchema.Types.CharacterData.parse(
              from.parameterMode,
            ),
            isResult: InformationSchema.Types.YesOrNo.parse(from.isResult),
            asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
            parameterName: InformationSchema.Types.SqlIdentifier.parse(
              from.parameterName,
            ),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
            parameterDefault: InformationSchema.Types.CharacterData.parse(
              from.parameterDefault,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ReferentialConstraints {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ReferentialConstraints
        if (InformationSchema.Types.ReferentialConstraints.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            uniqueConstraintCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.uniqueConstraintCatalog,
              ),
            uniqueConstraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.uniqueConstraintSchema,
            ),
            uniqueConstraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.uniqueConstraintName,
            ),
            matchOption: InformationSchema.Types.CharacterData.parse(
              from.matchOption,
            ),
            updateRule: InformationSchema.Types.CharacterData.parse(
              from.updateRule,
            ),
            deleteRule: InformationSchema.Types.CharacterData.parse(
              from.deleteRule,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoleColumnGrants {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoleColumnGrants
        if (InformationSchema.Types.RoleColumnGrants.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoleRoutineGrants {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoleRoutineGrants
        if (InformationSchema.Types.RoleRoutineGrants.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoleTableGrants {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoleTableGrants
        if (InformationSchema.Types.RoleTableGrants.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
            withHierarchy: InformationSchema.Types.YesOrNo.parse(
              from.withHierarchy,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoleUdtGrants {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoleUdtGrants
        if (InformationSchema.Types.RoleUdtGrants.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoleUsageGrants {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoleUsageGrants
        if (InformationSchema.Types.RoleUsageGrants.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            objectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.objectCatalog,
            ),
            objectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.objectSchema,
            ),
            objectName: InformationSchema.Types.SqlIdentifier.parse(
              from.objectName,
            ),
            objectType: InformationSchema.Types.CharacterData.parse(
              from.objectType,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoutineColumnUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoutineColumnUsage
        if (InformationSchema.Types.RoutineColumnUsage.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoutinePrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoutinePrivileges
        if (InformationSchema.Types.RoutinePrivileges.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoutineRoutineUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoutineRoutineUsage
        if (InformationSchema.Types.RoutineRoutineUsage.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoutineSequenceUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoutineSequenceUsage
        if (InformationSchema.Types.RoutineSequenceUsage.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceCatalog,
            ),
            sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceSchema,
            ),
            sequenceName: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace RoutineTableUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.RoutineTableUsage
        if (InformationSchema.Types.RoutineTableUsage.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Routines {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Routines
        if (InformationSchema.Types.Routines.is(from)) {
          return {
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            routineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.routineCatalog,
            ),
            routineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.routineSchema,
            ),
            routineName: InformationSchema.Types.SqlIdentifier.parse(
              from.routineName,
            ),
            routineType: InformationSchema.Types.CharacterData.parse(
              from.routineType,
            ),
            moduleCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.moduleCatalog,
            ),
            moduleSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.moduleSchema,
            ),
            moduleName: InformationSchema.Types.SqlIdentifier.parse(
              from.moduleName,
            ),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            typeUdtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.typeUdtCatalog,
            ),
            typeUdtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.typeUdtSchema,
            ),
            typeUdtName: InformationSchema.Types.SqlIdentifier.parse(
              from.typeUdtName,
            ),
            scopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeCatalog,
            ),
            scopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeSchema,
            ),
            scopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.scopeName,
            ),
            maximumCardinality: InformationSchema.Types.CardinalNumber.parse(
              from.maximumCardinality,
            ),
            dtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.dtdIdentifier,
            ),
            routineBody: InformationSchema.Types.CharacterData.parse(
              from.routineBody,
            ),
            routineDefinition: InformationSchema.Types.CharacterData.parse(
              from.routineDefinition,
            ),
            externalName: InformationSchema.Types.CharacterData.parse(
              from.externalName,
            ),
            externalLanguage: InformationSchema.Types.CharacterData.parse(
              from.externalLanguage,
            ),
            parameterStyle: InformationSchema.Types.CharacterData.parse(
              from.parameterStyle,
            ),
            isDeterministic: InformationSchema.Types.YesOrNo.parse(
              from.isDeterministic,
            ),
            sqlDataAccess: InformationSchema.Types.CharacterData.parse(
              from.sqlDataAccess,
            ),
            isNullCall: InformationSchema.Types.YesOrNo.parse(from.isNullCall),
            sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
            schemaLevelRoutine: InformationSchema.Types.YesOrNo.parse(
              from.schemaLevelRoutine,
            ),
            maxDynamicResultSets: InformationSchema.Types.CardinalNumber.parse(
              from.maxDynamicResultSets,
            ),
            isUserDefinedCast: InformationSchema.Types.YesOrNo.parse(
              from.isUserDefinedCast,
            ),
            isImplicitlyInvocable: InformationSchema.Types.YesOrNo.parse(
              from.isImplicitlyInvocable,
            ),
            securityType: InformationSchema.Types.CharacterData.parse(
              from.securityType,
            ),
            toSqlSpecificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.toSqlSpecificCatalog,
            ),
            toSqlSpecificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.toSqlSpecificSchema,
            ),
            toSqlSpecificName: InformationSchema.Types.SqlIdentifier.parse(
              from.toSqlSpecificName,
            ),
            asLocator: InformationSchema.Types.YesOrNo.parse(from.asLocator),
            created: InformationSchema.Types.TimeStamp.parse(from.created),
            lastAltered: InformationSchema.Types.TimeStamp.parse(
              from.lastAltered,
            ),
            newSavepointLevel: InformationSchema.Types.YesOrNo.parse(
              from.newSavepointLevel,
            ),
            isUdtDependent: InformationSchema.Types.YesOrNo.parse(
              from.isUdtDependent,
            ),
            resultCastFromDataType: InformationSchema.Types.CharacterData.parse(
              from.resultCastFromDataType,
            ),
            resultCastAsLocator: InformationSchema.Types.YesOrNo.parse(
              from.resultCastAsLocator,
            ),
            resultCastCharMaxLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastCharMaxLength,
              ),
            resultCastCharOctetLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastCharOctetLength,
              ),
            resultCastCharSetCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastCharSetCatalog,
              ),
            resultCastCharSetSchema:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastCharSetSchema,
              ),
            resultCastCharSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.resultCastCharSetName,
            ),
            resultCastCollationCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastCollationCatalog,
              ),
            resultCastCollationSchema:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastCollationSchema,
              ),
            resultCastCollationName:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastCollationName,
              ),
            resultCastNumericPrecision:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastNumericPrecision,
              ),
            resultCastNumericPrecisionRadix:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastNumericPrecisionRadix,
              ),
            resultCastNumericScale:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastNumericScale,
              ),
            resultCastDatetimePrecision:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastDatetimePrecision,
              ),
            resultCastIntervalType: InformationSchema.Types.CharacterData.parse(
              from.resultCastIntervalType,
            ),
            resultCastIntervalPrecision:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastIntervalPrecision,
              ),
            resultCastTypeUdtCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastTypeUdtCatalog,
              ),
            resultCastTypeUdtSchema:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastTypeUdtSchema,
              ),
            resultCastTypeUdtName: InformationSchema.Types.SqlIdentifier.parse(
              from.resultCastTypeUdtName,
            ),
            resultCastScopeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.resultCastScopeCatalog,
            ),
            resultCastScopeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.resultCastScopeSchema,
            ),
            resultCastScopeName: InformationSchema.Types.SqlIdentifier.parse(
              from.resultCastScopeName,
            ),
            resultCastMaximumCardinality:
              InformationSchema.Types.CardinalNumber.parse(
                from.resultCastMaximumCardinality,
              ),
            resultCastDtdIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.resultCastDtdIdentifier,
              ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Schemata {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Schemata
        if (InformationSchema.Types.Schemata.is(from)) {
          return {
            catalogName: InformationSchema.Types.SqlIdentifier.parse(
              from.catalogName,
            ),
            schemaName: InformationSchema.Types.SqlIdentifier.parse(
              from.schemaName,
            ),
            schemaOwner: InformationSchema.Types.SqlIdentifier.parse(
              from.schemaOwner,
            ),
            defaultCharacterSetCatalog:
              InformationSchema.Types.SqlIdentifier.parse(
                from.defaultCharacterSetCatalog,
              ),
            defaultCharacterSetSchema:
              InformationSchema.Types.SqlIdentifier.parse(
                from.defaultCharacterSetSchema,
              ),
            defaultCharacterSetName:
              InformationSchema.Types.SqlIdentifier.parse(
                from.defaultCharacterSetName,
              ),
            sqlPath: InformationSchema.Types.CharacterData.parse(from.sqlPath),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Sequences {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Sequences
        if (InformationSchema.Types.Sequences.is(from)) {
          return {
            sequenceCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceCatalog,
            ),
            sequenceSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceSchema,
            ),
            sequenceName: InformationSchema.Types.SqlIdentifier.parse(
              from.sequenceName,
            ),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            startValue: InformationSchema.Types.CharacterData.parse(
              from.startValue,
            ),
            minimumValue: InformationSchema.Types.CharacterData.parse(
              from.minimumValue,
            ),
            maximumValue: InformationSchema.Types.CharacterData.parse(
              from.maximumValue,
            ),
            increment: InformationSchema.Types.CharacterData.parse(
              from.increment,
            ),
            cycleOption: InformationSchema.Types.YesOrNo.parse(
              from.cycleOption,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SqlFeatures {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.SqlFeatures
        if (InformationSchema.Types.SqlFeatures.is(from)) {
          return {
            featureId: InformationSchema.Types.CharacterData.parse(
              from.featureId,
            ),
            featureName: InformationSchema.Types.CharacterData.parse(
              from.featureName,
            ),
            subFeatureId: InformationSchema.Types.CharacterData.parse(
              from.subFeatureId,
            ),
            subFeatureName: InformationSchema.Types.CharacterData.parse(
              from.subFeatureName,
            ),
            isSupported: InformationSchema.Types.YesOrNo.parse(
              from.isSupported,
            ),
            isVerifiedBy: InformationSchema.Types.CharacterData.parse(
              from.isVerifiedBy,
            ),
            comments: InformationSchema.Types.CharacterData.parse(
              from.comments,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SqlIdentifier {
      export function parse(from: any) {
        // DomainType InformationSchema.Types.SqlIdentifier
        return PgCatalog.Types.Name.parse(from);
      }
    }
    export namespace SqlImplementationInfo {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.SqlImplementationInfo
        if (InformationSchema.Types.SqlImplementationInfo.is(from)) {
          return {
            implementationInfoId: InformationSchema.Types.CharacterData.parse(
              from.implementationInfoId,
            ),
            implementationInfoName: InformationSchema.Types.CharacterData.parse(
              from.implementationInfoName,
            ),
            integerValue: InformationSchema.Types.CardinalNumber.parse(
              from.integerValue,
            ),
            characterValue: InformationSchema.Types.CharacterData.parse(
              from.characterValue,
            ),
            comments: InformationSchema.Types.CharacterData.parse(
              from.comments,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SqlParts {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.SqlParts
        if (InformationSchema.Types.SqlParts.is(from)) {
          return {
            featureId: InformationSchema.Types.CharacterData.parse(
              from.featureId,
            ),
            featureName: InformationSchema.Types.CharacterData.parse(
              from.featureName,
            ),
            isSupported: InformationSchema.Types.YesOrNo.parse(
              from.isSupported,
            ),
            isVerifiedBy: InformationSchema.Types.CharacterData.parse(
              from.isVerifiedBy,
            ),
            comments: InformationSchema.Types.CharacterData.parse(
              from.comments,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace SqlSizing {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.SqlSizing
        if (InformationSchema.Types.SqlSizing.is(from)) {
          return {
            sizingId: InformationSchema.Types.CardinalNumber.parse(
              from.sizingId,
            ),
            sizingName: InformationSchema.Types.CharacterData.parse(
              from.sizingName,
            ),
            supportedValue: InformationSchema.Types.CardinalNumber.parse(
              from.supportedValue,
            ),
            comments: InformationSchema.Types.CharacterData.parse(
              from.comments,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace TableConstraints {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.TableConstraints
        if (InformationSchema.Types.TableConstraints.is(from)) {
          return {
            constraintCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintCatalog,
            ),
            constraintSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintSchema,
            ),
            constraintName: InformationSchema.Types.SqlIdentifier.parse(
              from.constraintName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            constraintType: InformationSchema.Types.CharacterData.parse(
              from.constraintType,
            ),
            isDeferrable: InformationSchema.Types.YesOrNo.parse(
              from.isDeferrable,
            ),
            initiallyDeferred: InformationSchema.Types.YesOrNo.parse(
              from.initiallyDeferred,
            ),
            enforced: InformationSchema.Types.YesOrNo.parse(from.enforced),
            nullsDistinct: InformationSchema.Types.YesOrNo.parse(
              from.nullsDistinct,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace TablePrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.TablePrivileges
        if (InformationSchema.Types.TablePrivileges.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
            withHierarchy: InformationSchema.Types.YesOrNo.parse(
              from.withHierarchy,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Tables {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Tables
        if (InformationSchema.Types.Tables.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            tableType: InformationSchema.Types.CharacterData.parse(
              from.tableType,
            ),
            selfReferencingColumnName:
              InformationSchema.Types.SqlIdentifier.parse(
                from.selfReferencingColumnName,
              ),
            referenceGeneration: InformationSchema.Types.CharacterData.parse(
              from.referenceGeneration,
            ),
            userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeCatalog,
            ),
            userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeSchema,
            ),
            userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeName,
            ),
            isInsertableInto: InformationSchema.Types.YesOrNo.parse(
              from.isInsertableInto,
            ),
            isTyped: InformationSchema.Types.YesOrNo.parse(from.isTyped),
            commitAction: InformationSchema.Types.CharacterData.parse(
              from.commitAction,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace TimeStamp {
      export function parse(from: any) {
        // DomainType InformationSchema.Types.TimeStamp
        return PgCatalog.Types.Timestamptz.parse(from);
      }
    }
    export namespace Transforms {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Transforms
        if (InformationSchema.Types.Transforms.is(from)) {
          return {
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
            groupName: InformationSchema.Types.SqlIdentifier.parse(
              from.groupName,
            ),
            transformType: InformationSchema.Types.CharacterData.parse(
              from.transformType,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace TriggeredUpdateColumns {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.TriggeredUpdateColumns
        if (InformationSchema.Types.TriggeredUpdateColumns.is(from)) {
          return {
            triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerCatalog,
            ),
            triggerSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerSchema,
            ),
            triggerName: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerName,
            ),
            eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectCatalog,
            ),
            eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectSchema,
            ),
            eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectTable,
            ),
            eventObjectColumn: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectColumn,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Triggers {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Triggers
        if (InformationSchema.Types.Triggers.is(from)) {
          return {
            triggerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerCatalog,
            ),
            triggerSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerSchema,
            ),
            triggerName: InformationSchema.Types.SqlIdentifier.parse(
              from.triggerName,
            ),
            eventManipulation: InformationSchema.Types.CharacterData.parse(
              from.eventManipulation,
            ),
            eventObjectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectCatalog,
            ),
            eventObjectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectSchema,
            ),
            eventObjectTable: InformationSchema.Types.SqlIdentifier.parse(
              from.eventObjectTable,
            ),
            actionOrder: InformationSchema.Types.CardinalNumber.parse(
              from.actionOrder,
            ),
            actionCondition: InformationSchema.Types.CharacterData.parse(
              from.actionCondition,
            ),
            actionStatement: InformationSchema.Types.CharacterData.parse(
              from.actionStatement,
            ),
            actionOrientation: InformationSchema.Types.CharacterData.parse(
              from.actionOrientation,
            ),
            actionTiming: InformationSchema.Types.CharacterData.parse(
              from.actionTiming,
            ),
            actionReferenceOldTable:
              InformationSchema.Types.SqlIdentifier.parse(
                from.actionReferenceOldTable,
              ),
            actionReferenceNewTable:
              InformationSchema.Types.SqlIdentifier.parse(
                from.actionReferenceNewTable,
              ),
            actionReferenceOldRow: InformationSchema.Types.SqlIdentifier.parse(
              from.actionReferenceOldRow,
            ),
            actionReferenceNewRow: InformationSchema.Types.SqlIdentifier.parse(
              from.actionReferenceNewRow,
            ),
            created: InformationSchema.Types.TimeStamp.parse(from.created),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace UdtPrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.UdtPrivileges
        if (InformationSchema.Types.UdtPrivileges.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            udtCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.udtCatalog,
            ),
            udtSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.udtSchema,
            ),
            udtName: InformationSchema.Types.SqlIdentifier.parse(from.udtName),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace UsagePrivileges {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.UsagePrivileges
        if (InformationSchema.Types.UsagePrivileges.is(from)) {
          return {
            grantor: InformationSchema.Types.SqlIdentifier.parse(from.grantor),
            grantee: InformationSchema.Types.SqlIdentifier.parse(from.grantee),
            objectCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.objectCatalog,
            ),
            objectSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.objectSchema,
            ),
            objectName: InformationSchema.Types.SqlIdentifier.parse(
              from.objectName,
            ),
            objectType: InformationSchema.Types.CharacterData.parse(
              from.objectType,
            ),
            privilegeType: InformationSchema.Types.CharacterData.parse(
              from.privilegeType,
            ),
            isGrantable: InformationSchema.Types.YesOrNo.parse(
              from.isGrantable,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace UserDefinedTypes {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.UserDefinedTypes
        if (InformationSchema.Types.UserDefinedTypes.is(from)) {
          return {
            userDefinedTypeCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeCatalog,
            ),
            userDefinedTypeSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeSchema,
            ),
            userDefinedTypeName: InformationSchema.Types.SqlIdentifier.parse(
              from.userDefinedTypeName,
            ),
            userDefinedTypeCategory:
              InformationSchema.Types.CharacterData.parse(
                from.userDefinedTypeCategory,
              ),
            isInstantiable: InformationSchema.Types.YesOrNo.parse(
              from.isInstantiable,
            ),
            isFinal: InformationSchema.Types.YesOrNo.parse(from.isFinal),
            orderingForm: InformationSchema.Types.CharacterData.parse(
              from.orderingForm,
            ),
            orderingCategory: InformationSchema.Types.CharacterData.parse(
              from.orderingCategory,
            ),
            orderingRoutineCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.orderingRoutineCatalog,
            ),
            orderingRoutineSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.orderingRoutineSchema,
            ),
            orderingRoutineName: InformationSchema.Types.SqlIdentifier.parse(
              from.orderingRoutineName,
            ),
            referenceType: InformationSchema.Types.CharacterData.parse(
              from.referenceType,
            ),
            dataType: InformationSchema.Types.CharacterData.parse(
              from.dataType,
            ),
            characterMaximumLength:
              InformationSchema.Types.CardinalNumber.parse(
                from.characterMaximumLength,
              ),
            characterOctetLength: InformationSchema.Types.CardinalNumber.parse(
              from.characterOctetLength,
            ),
            characterSetCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetCatalog,
            ),
            characterSetSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetSchema,
            ),
            characterSetName: InformationSchema.Types.SqlIdentifier.parse(
              from.characterSetName,
            ),
            collationCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.collationCatalog,
            ),
            collationSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.collationSchema,
            ),
            collationName: InformationSchema.Types.SqlIdentifier.parse(
              from.collationName,
            ),
            numericPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecision,
            ),
            numericPrecisionRadix: InformationSchema.Types.CardinalNumber.parse(
              from.numericPrecisionRadix,
            ),
            numericScale: InformationSchema.Types.CardinalNumber.parse(
              from.numericScale,
            ),
            datetimePrecision: InformationSchema.Types.CardinalNumber.parse(
              from.datetimePrecision,
            ),
            intervalType: InformationSchema.Types.CharacterData.parse(
              from.intervalType,
            ),
            intervalPrecision: InformationSchema.Types.CardinalNumber.parse(
              from.intervalPrecision,
            ),
            sourceDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.sourceDtdIdentifier,
            ),
            refDtdIdentifier: InformationSchema.Types.SqlIdentifier.parse(
              from.refDtdIdentifier,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace UserMappingOptions {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.UserMappingOptions
        if (InformationSchema.Types.UserMappingOptions.is(from)) {
          return {
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
            optionName: InformationSchema.Types.SqlIdentifier.parse(
              from.optionName,
            ),
            optionValue: InformationSchema.Types.CharacterData.parse(
              from.optionValue,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace UserMappings {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.UserMappings
        if (InformationSchema.Types.UserMappings.is(from)) {
          return {
            authorizationIdentifier:
              InformationSchema.Types.SqlIdentifier.parse(
                from.authorizationIdentifier,
              ),
            foreignServerCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerCatalog,
            ),
            foreignServerName: InformationSchema.Types.SqlIdentifier.parse(
              from.foreignServerName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ViewColumnUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ViewColumnUsage
        if (InformationSchema.Types.ViewColumnUsage.is(from)) {
          return {
            viewCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.viewCatalog,
            ),
            viewSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.viewSchema,
            ),
            viewName: InformationSchema.Types.SqlIdentifier.parse(
              from.viewName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            columnName: InformationSchema.Types.SqlIdentifier.parse(
              from.columnName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ViewRoutineUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ViewRoutineUsage
        if (InformationSchema.Types.ViewRoutineUsage.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            specificCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.specificCatalog,
            ),
            specificSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.specificSchema,
            ),
            specificName: InformationSchema.Types.SqlIdentifier.parse(
              from.specificName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace ViewTableUsage {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.ViewTableUsage
        if (InformationSchema.Types.ViewTableUsage.is(from)) {
          return {
            viewCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.viewCatalog,
            ),
            viewSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.viewSchema,
            ),
            viewName: InformationSchema.Types.SqlIdentifier.parse(
              from.viewName,
            ),
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace Views {
      export function parse(from: any) {
        // CompositeType InformationSchema.Types.Views
        if (InformationSchema.Types.Views.is(from)) {
          return {
            tableCatalog: InformationSchema.Types.SqlIdentifier.parse(
              from.tableCatalog,
            ),
            tableSchema: InformationSchema.Types.SqlIdentifier.parse(
              from.tableSchema,
            ),
            tableName: InformationSchema.Types.SqlIdentifier.parse(
              from.tableName,
            ),
            viewDefinition: InformationSchema.Types.CharacterData.parse(
              from.viewDefinition,
            ),
            checkOption: InformationSchema.Types.CharacterData.parse(
              from.checkOption,
            ),
            isUpdatable: InformationSchema.Types.YesOrNo.parse(
              from.isUpdatable,
            ),
            isInsertableInto: InformationSchema.Types.YesOrNo.parse(
              from.isInsertableInto,
            ),
            isTriggerUpdatable: InformationSchema.Types.YesOrNo.parse(
              from.isTriggerUpdatable,
            ),
            isTriggerDeletable: InformationSchema.Types.YesOrNo.parse(
              from.isTriggerDeletable,
            ),
            isTriggerInsertableInto: InformationSchema.Types.YesOrNo.parse(
              from.isTriggerInsertableInto,
            ),
          };
        }
        throw new Error(JSON.stringify(from));
      }
    }
    export namespace YesOrNo {
      export function parse(from: any) {
        // DomainType InformationSchema.Types.YesOrNo
        return PgCatalog.Types.Varchar.parse(from);
      }
    }
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace SqlFeatures {
      export namespace Create {}
    }
    export namespace SqlImplementationInfo {
      export namespace Create {}
    }
    export namespace SqlParts {
      export namespace Create {}
    }
    export namespace SqlSizing {
      export namespace Create {}
    }
  }
}
// begin table column parser mapping
export namespace PgCatalog {
  export namespace Tables {
    export namespace PgStatistic {
      export namespace Starelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Staattnum {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Stainherit {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Stanullfrac {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Stawidth {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Stadistinct {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Stakind1 {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Stakind2 {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Stakind3 {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Stakind4 {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Stakind5 {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Staop1 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Staop2 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Staop3 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Staop4 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Staop5 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stacoll1 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stacoll2 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stacoll3 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stacoll4 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stacoll5 {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stanumbers1 {
        export const parse = PgCatalog.Types.Float4Array.parse;
      }
      export namespace Stanumbers2 {
        export const parse = PgCatalog.Types.Float4Array.parse;
      }
      export namespace Stanumbers3 {
        export const parse = PgCatalog.Types.Float4Array.parse;
      }
      export namespace Stanumbers4 {
        export const parse = PgCatalog.Types.Float4Array.parse;
      }
      export namespace Stanumbers5 {
        export const parse = PgCatalog.Types.Float4Array.parse;
      }
      export namespace Stavalues1 {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
      export namespace Stavalues2 {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
      export namespace Stavalues3 {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
      export namespace Stavalues4 {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
      export namespace Stavalues5 {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
    }
    export namespace PgType {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Typnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typlen {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Typbyval {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Typtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Typcategory {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Typispreferred {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Typisdefined {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Typdelim {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Typrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typsubscript {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typelem {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typarray {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typinput {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typoutput {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typreceive {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typsend {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typmodin {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typmodout {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typanalyze {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Typalign {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Typstorage {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Typnotnull {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Typbasetype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typtypmod {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Typndims {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Typcollation {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Typdefaultbin {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Typdefault {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Typacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgForeignTable {
      export namespace Ftrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Ftserver {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Ftoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgAuthid {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rolname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Rolsuper {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolinherit {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolcreaterole {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolcreatedb {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolcanlogin {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolreplication {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolbypassrls {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Rolconnlimit {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Rolpassword {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Rolvaliduntil {
        export const parse = PgCatalog.Types.Timestamptz.parse;
      }
    }
    export namespace PgStatisticExtData {
      export namespace Stxoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stxdinherit {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Stxdndistinct {
        export const parse = PgCatalog.Types.PgNdistinct.parse;
      }
      export namespace Stxddependencies {
        export const parse = PgCatalog.Types.PgDependencies.parse;
      }
      export namespace Stxdmcv {
        export const parse = PgCatalog.Types.PgMcvList.parse;
      }
      export namespace Stxdexpr {
        export const parse = PgCatalog.Types.PgStatisticArray.parse;
      }
    }
    export namespace PgUserMapping {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Umuser {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Umserver {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Umoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgSubscription {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Subdbid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Subskiplsn {
        export const parse = PgCatalog.Types.PgLsn.parse;
      }
      export namespace Subname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Subowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Subenabled {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Subbinary {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Substream {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Subtwophasestate {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Subdisableonerr {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Subpasswordrequired {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Subrunasowner {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Subconninfo {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Subslotname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Subsynccommit {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Subpublications {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Suborigin {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgAttribute {
      export namespace Attrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Attname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Atttypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Attlen {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Attnum {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Attcacheoff {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Atttypmod {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Attndims {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Attbyval {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Attalign {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Attstorage {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Attcompression {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Attnotnull {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Atthasdef {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Atthasmissing {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Attidentity {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Attgenerated {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Attisdropped {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Attislocal {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Attinhcount {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Attstattarget {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Attcollation {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Attacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
      export namespace Attoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Attfdwoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Attmissingval {
        export const parse = PgCatalog.Types.Anyarray.parse;
      }
    }
    export namespace PgProc {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Proname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Pronamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Proowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prolang {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Procost {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Prorows {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Provariadic {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prosupport {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Prokind {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Prosecdef {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Proleakproof {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Proisstrict {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Proretset {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Provolatile {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Proparallel {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Pronargs {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Pronargdefaults {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Prorettype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Proargtypes {
        export const parse = PgCatalog.Types.Oidvector.parse;
      }
      export namespace Proallargtypes {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Proargmodes {
        export const parse = PgCatalog.Types.CharArray.parse;
      }
      export namespace Proargnames {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Proargdefaults {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Protrftypes {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Prosrc {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Probin {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Prosqlbody {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Proconfig {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Proacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgClass {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Relnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Reltype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Reloftype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relam {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relfilenode {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Reltablespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relpages {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Reltuples {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Relallvisible {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Reltoastrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relhasindex {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relisshared {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relpersistence {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Relkind {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Relnatts {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Relchecks {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Relhasrules {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relhastriggers {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relhassubclass {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relrowsecurity {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relforcerowsecurity {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relispopulated {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relreplident {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Relispartition {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Relrewrite {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Relfrozenxid {
        export const parse = PgCatalog.Types.Xid.parse;
      }
      export namespace Relminmxid {
        export const parse = PgCatalog.Types.Xid.parse;
      }
      export namespace Relacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
      export namespace Reloptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Relpartbound {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgAttrdef {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Adrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Adnum {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Adbin {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgConstraint {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Connamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Contype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Condeferrable {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Condeferred {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Convalidated {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Conrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Contypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conindid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conparentid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Confrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Confupdtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Confdeltype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Confmatchtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Conislocal {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Coninhcount {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Connoinherit {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Conkey {
        export const parse = PgCatalog.Types.Int2Array.parse;
      }
      export namespace Confkey {
        export const parse = PgCatalog.Types.Int2Array.parse;
      }
      export namespace Conpfeqop {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Conppeqop {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Conffeqop {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Confdelsetcols {
        export const parse = PgCatalog.Types.Int2Array.parse;
      }
      export namespace Conexclop {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Conbin {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgInherits {
      export namespace Inhrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Inhparent {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Inhseqno {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Inhdetachpending {
        export const parse = PgCatalog.Types.Bool.parse;
      }
    }
    export namespace PgIndex {
      export namespace Indexrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Indrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Indnatts {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Indnkeyatts {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Indisunique {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indnullsnotdistinct {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisprimary {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisexclusion {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indimmediate {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisclustered {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisvalid {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indcheckxmin {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisready {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indislive {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indisreplident {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Indkey {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
      export namespace Indcollation {
        export const parse = PgCatalog.Types.Oidvector.parse;
      }
      export namespace Indclass {
        export const parse = PgCatalog.Types.Oidvector.parse;
      }
      export namespace Indoption {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
      export namespace Indexprs {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Indpred {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgOperator {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Oprnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprkind {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Oprcanmerge {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Oprcanhash {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Oprleft {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprright {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprresult {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprcom {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprnegate {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Oprcode {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Oprrest {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Oprjoin {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgOpfamily {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opfmethod {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opfname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Opfnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opfowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgOpclass {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcmethod {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Opcnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcfamily {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcintype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Opcdefault {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Opckeytype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgAm {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Amhandler {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Amtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
    }
    export namespace PgAmop {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amopfamily {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amoplefttype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amoprighttype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amopstrategy {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Amoppurpose {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Amopopr {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amopmethod {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amopsortfamily {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgAmproc {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amprocfamily {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amproclefttype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amprocrighttype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Amprocnum {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Amproc {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgLanguage {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lanname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Lanowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lanispl {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Lanpltrusted {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Lanplcallfoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Laninline {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lanvalidator {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lanacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgLargeobjectMetadata {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lomowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Lomacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgAggregate {
      export namespace Aggfnoid {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggkind {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Aggnumdirectargs {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Aggtransfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggfinalfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggcombinefn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggserialfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggdeserialfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggmtransfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggminvtransfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggmfinalfn {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Aggfinalextra {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Aggmfinalextra {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Aggfinalmodify {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Aggmfinalmodify {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Aggsortop {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Aggtranstype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Aggtransspace {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Aggmtranstype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Aggmtransspace {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Agginitval {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Aggminitval {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgStatisticExt {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stxrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stxname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Stxnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stxowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Stxstattarget {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Stxkeys {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
      export namespace Stxkind {
        export const parse = PgCatalog.Types.CharArray.parse;
      }
      export namespace Stxexprs {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgRewrite {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rulename {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace EvClass {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace EvType {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace EvEnabled {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace IsInstead {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace EvQual {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace EvAction {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgTrigger {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgparentid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Tgfoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgtype {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Tgenabled {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Tgisinternal {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Tgconstrrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgconstrindid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgconstraint {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tgdeferrable {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Tginitdeferred {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Tgnargs {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Tgattr {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
      export namespace Tgargs {
        export const parse = PgCatalog.Types.Bytea.parse;
      }
      export namespace Tgqual {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Tgoldtable {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Tgnewtable {
        export const parse = PgCatalog.Types.Name.parse;
      }
    }
    export namespace PgEventTrigger {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Evtname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Evtevent {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Evtowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Evtfoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Evtenabled {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Evttags {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgDescription {
      export namespace Objoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Description {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgCast {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Castsource {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Casttarget {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Castfunc {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Castcontext {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Castmethod {
        export const parse = PgCatalog.Types.Char.parse;
      }
    }
    export namespace PgEnum {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Enumtypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Enumsortorder {
        export const parse = PgCatalog.Types.Float4.parse;
      }
      export namespace Enumlabel {
        export const parse = PgCatalog.Types.Name.parse;
      }
    }
    export namespace PgNamespace {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Nspname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Nspowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Nspacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgConversion {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Connamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Conforencoding {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Contoencoding {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Conproc {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Condefault {
        export const parse = PgCatalog.Types.Bool.parse;
      }
    }
    export namespace PgDepend {
      export namespace Classid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Refclassid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Refobjid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Refobjsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Deptype {
        export const parse = PgCatalog.Types.Char.parse;
      }
    }
    export namespace PgDatabase {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Datname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Datdba {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Encoding {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Datlocprovider {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Datistemplate {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Datallowconn {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Datconnlimit {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Datfrozenxid {
        export const parse = PgCatalog.Types.Xid.parse;
      }
      export namespace Datminmxid {
        export const parse = PgCatalog.Types.Xid.parse;
      }
      export namespace Dattablespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Datcollate {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Datctype {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Daticulocale {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Daticurules {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Datcollversion {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Datacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgDbRoleSetting {
      export namespace Setdatabase {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Setrole {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Setconfig {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgTablespace {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Spcname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Spcowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Spcacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
      export namespace Spcoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgAuthMembers {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Roleid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Member {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Grantor {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace AdminOption {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace InheritOption {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace SetOption {
        export const parse = PgCatalog.Types.Bool.parse;
      }
    }
    export namespace PgShdepend {
      export namespace Dbid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Refclassid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Refobjid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Deptype {
        export const parse = PgCatalog.Types.Char.parse;
      }
    }
    export namespace PgShdescription {
      export namespace Objoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Description {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgTsConfig {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Cfgname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Cfgnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Cfgowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Cfgparser {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgTsConfigMap {
      export namespace Mapcfg {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Maptokentype {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Mapseqno {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Mapdict {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgTsDict {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Dictname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Dictnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Dictowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Dicttemplate {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Dictinitoption {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgTsParser {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prsname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Prsnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prsstart {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Prstoken {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Prsend {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Prsheadline {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Prslextype {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgTsTemplate {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tmplname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Tmplnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Tmplinit {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Tmpllexize {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgExtension {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Extname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Extowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Extnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Extrelocatable {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Extversion {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Extconfig {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Extcondition {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgForeignDataWrapper {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Fdwname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Fdwowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Fdwhandler {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Fdwvalidator {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Fdwacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
      export namespace Fdwoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgForeignServer {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Srvname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Srvowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Srvfdw {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Srvtype {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Srvversion {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Srvacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
      export namespace Srvoptions {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
    }
    export namespace PgPolicy {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Polname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Polrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Polcmd {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Polpermissive {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Polroles {
        export const parse = PgCatalog.Types.OidArray.parse;
      }
      export namespace Polqual {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Polwithcheck {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgReplicationOrigin {
      export namespace Roident {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Roname {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgDefaultAcl {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Defaclrole {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Defaclnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Defaclobjtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Defaclacl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgInitPrivs {
      export namespace Objoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Privtype {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Initprivs {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgSeclabel {
      export namespace Objoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Objsubid {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Provider {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Label {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgShseclabel {
      export namespace Objoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Classoid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Provider {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Label {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgCollation {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Collname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Collnamespace {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Collowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Collprovider {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Collisdeterministic {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Collencoding {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Collcollate {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Collctype {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Colliculocale {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Collicurules {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Collversion {
        export const parse = PgCatalog.Types.Text.parse;
      }
    }
    export namespace PgParameterAcl {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Parname {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace Paracl {
        export const parse = PgCatalog.Types.AclitemArray.parse;
      }
    }
    export namespace PgPartitionedTable {
      export namespace Partrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Partstrat {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Partnatts {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Partdefid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Partattrs {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
      export namespace Partclass {
        export const parse = PgCatalog.Types.Oidvector.parse;
      }
      export namespace Partcollation {
        export const parse = PgCatalog.Types.Oidvector.parse;
      }
      export namespace Partexprs {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
    }
    export namespace PgRange {
      export namespace Rngtypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rngsubtype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rngmultitypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rngcollation {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rngsubopc {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Rngcanonical {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Rngsubdiff {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgTransform {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Trftype {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Trflang {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Trffromsql {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
      export namespace Trftosql {
        export const parse = PgCatalog.Types.Regproc.parse;
      }
    }
    export namespace PgSequence {
      export namespace Seqrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Seqtypid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Seqstart {
        export const parse = PgCatalog.Types.Int8.parse;
      }
      export namespace Seqincrement {
        export const parse = PgCatalog.Types.Int8.parse;
      }
      export namespace Seqmax {
        export const parse = PgCatalog.Types.Int8.parse;
      }
      export namespace Seqmin {
        export const parse = PgCatalog.Types.Int8.parse;
      }
      export namespace Seqcache {
        export const parse = PgCatalog.Types.Int8.parse;
      }
      export namespace Seqcycle {
        export const parse = PgCatalog.Types.Bool.parse;
      }
    }
    export namespace PgPublication {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Pubname {
        export const parse = PgCatalog.Types.Name.parse;
      }
      export namespace Pubowner {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Puballtables {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Pubinsert {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Pubupdate {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Pubdelete {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Pubtruncate {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Pubviaroot {
        export const parse = PgCatalog.Types.Bool.parse;
      }
    }
    export namespace PgPublicationNamespace {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Pnpubid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Pnnspid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
    }
    export namespace PgPublicationRel {
      export namespace Oid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prpubid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Prqual {
        export const parse = PgCatalog.Types.PgNodeTree.parse;
      }
      export namespace Prattrs {
        export const parse = PgCatalog.Types.Int2vector.parse;
      }
    }
    export namespace PgSubscriptionRel {
      export namespace Srsubid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Srrelid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Srsubstate {
        export const parse = PgCatalog.Types.Char.parse;
      }
      export namespace Srsublsn {
        export const parse = PgCatalog.Types.PgLsn.parse;
      }
    }
    export namespace PgLargeobject {
      export namespace Loid {
        export const parse = PgCatalog.Types.Oid.parse;
      }
      export namespace Pageno {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Data {
        export const parse = PgCatalog.Types.Bytea.parse;
      }
    }
  }
}
export namespace Public {
  export namespace Tables {
    export namespace FilmActor {
      export namespace ActorId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace FilmId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Address {
      export namespace AddressId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Address {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace Address2 {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace District {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace CityId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace PostalCode {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace Phone {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace City {
      export namespace CityId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace City {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace CountryId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Customer {
      export namespace CustomerId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace StoreId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace FirstName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace Email {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace AddressId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Activebool {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace CreateDate {
        export const parse = PgCatalog.Types.Date.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
      export namespace Active {
        export const parse = PgCatalog.Types.Int4.parse;
      }
    }
    export namespace Actor {
      export namespace ActorId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace FirstName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace FilmCategory {
      export namespace FilmId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace CategoryId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Inventory {
      export namespace InventoryId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace FilmId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace StoreId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Category {
      export namespace CategoryId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Name {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Country {
      export namespace CountryId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Country {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Language {
      export namespace LanguageId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Name {
        export const parse = PgCatalog.Types.Bpchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Rental {
      export namespace RentalId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace RentalDate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
      export namespace InventoryId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace CustomerId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace ReturnDate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
      export namespace StaffId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Staff {
      export namespace StaffId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace FirstName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastName {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace AddressId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Email {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace StoreId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace Active {
        export const parse = PgCatalog.Types.Bool.parse;
      }
      export namespace Username {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace Password {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
      export namespace Picture {
        export const parse = PgCatalog.Types.Bytea.parse;
      }
    }
    export namespace Store {
      export namespace StoreId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace ManagerStaffId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace AddressId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Payment {
      export namespace PaymentId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace CustomerId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace StaffId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace RentalId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Amount {
        export const parse = PgCatalog.Types.Numeric.parse;
      }
      export namespace PaymentDate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
    }
    export namespace Film {
      export namespace FilmId {
        export const parse = PgCatalog.Types.Int4.parse;
      }
      export namespace Title {
        export const parse = PgCatalog.Types.Varchar.parse;
      }
      export namespace Description {
        export const parse = PgCatalog.Types.Text.parse;
      }
      export namespace ReleaseYear {
        export const parse = Public.Types.Year.parse;
      }
      export namespace LanguageId {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace RentalDuration {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace RentalRate {
        export const parse = PgCatalog.Types.Numeric.parse;
      }
      export namespace Length {
        export const parse = PgCatalog.Types.Int2.parse;
      }
      export namespace ReplacementCost {
        export const parse = PgCatalog.Types.Numeric.parse;
      }
      export namespace Rating {
        export const parse = Public.Types.MpaaRating.parse;
      }
      export namespace LastUpdate {
        export const parse = PgCatalog.Types.Timestamp.parse;
      }
      export namespace SpecialFeatures {
        export const parse = PgCatalog.Types.TextArray.parse;
      }
      export namespace Fulltext {
        export const parse = PgCatalog.Types.Tsvector.parse;
      }
    }
  }
}
export namespace InformationSchema {
  export namespace Tables {
    export namespace SqlFeatures {
      export namespace FeatureId {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace FeatureName {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace SubFeatureId {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace SubFeatureName {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace IsSupported {
        export const parse = InformationSchema.Types.YesOrNo.parse;
      }
      export namespace IsVerifiedBy {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace Comments {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
    }
    export namespace SqlImplementationInfo {
      export namespace ImplementationInfoId {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace ImplementationInfoName {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace IntegerValue {
        export const parse = InformationSchema.Types.CardinalNumber.parse;
      }
      export namespace CharacterValue {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace Comments {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
    }
    export namespace SqlParts {
      export namespace FeatureId {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace FeatureName {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace IsSupported {
        export const parse = InformationSchema.Types.YesOrNo.parse;
      }
      export namespace IsVerifiedBy {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace Comments {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
    }
    export namespace SqlSizing {
      export namespace SizingId {
        export const parse = InformationSchema.Types.CardinalNumber.parse;
      }
      export namespace SizingName {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
      export namespace SupportedValue {
        export const parse = InformationSchema.Types.CardinalNumber.parse;
      }
      export namespace Comments {
        export const parse = InformationSchema.Types.CharacterData.parse;
      }
    }
  }
}

// begin primary key pickers
export namespace Public {
  export namespace Tables {
    export namespace FilmActor {
      export function primaryKeyFrom(
        value: Public.Tables.FilmActor.Record,
      ): string {
        return JSON.stringify({
          actorId: value.actorId,
          filmId: value.filmId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.actorId !== undefined && value.filmId !== undefined;
      }
    }
    export namespace Address {
      export function primaryKeyFrom(
        value: Public.Tables.Address.Record,
      ): string {
        return JSON.stringify({
          addressId: value.addressId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.addressId !== undefined;
      }
    }
    export namespace City {
      export function primaryKeyFrom(value: Public.Tables.City.Record): string {
        return JSON.stringify({
          cityId: value.cityId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.cityId !== undefined;
      }
    }
    export namespace Customer {
      export function primaryKeyFrom(
        value: Public.Tables.Customer.Record,
      ): string {
        return JSON.stringify({
          customerId: value.customerId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.customerId !== undefined;
      }
    }
    export namespace Actor {
      export function primaryKeyFrom(
        value: Public.Tables.Actor.Record,
      ): string {
        return JSON.stringify({
          actorId: value.actorId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.actorId !== undefined;
      }
    }
    export namespace FilmCategory {
      export function primaryKeyFrom(
        value: Public.Tables.FilmCategory.Record,
      ): string {
        return JSON.stringify({
          filmId: value.filmId,
          categoryId: value.categoryId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.filmId !== undefined && value.categoryId !== undefined;
      }
    }
    export namespace Inventory {
      export function primaryKeyFrom(
        value: Public.Tables.Inventory.Record,
      ): string {
        return JSON.stringify({
          inventoryId: value.inventoryId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.inventoryId !== undefined;
      }
    }
    export namespace Category {
      export function primaryKeyFrom(
        value: Public.Tables.Category.Record,
      ): string {
        return JSON.stringify({
          categoryId: value.categoryId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.categoryId !== undefined;
      }
    }
    export namespace Country {
      export function primaryKeyFrom(
        value: Public.Tables.Country.Record,
      ): string {
        return JSON.stringify({
          countryId: value.countryId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.countryId !== undefined;
      }
    }
    export namespace Language {
      export function primaryKeyFrom(
        value: Public.Tables.Language.Record,
      ): string {
        return JSON.stringify({
          languageId: value.languageId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.languageId !== undefined;
      }
    }
    export namespace Rental {
      export function primaryKeyFrom(
        value: Public.Tables.Rental.Record,
      ): string {
        return JSON.stringify({
          rentalId: value.rentalId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.rentalId !== undefined;
      }
    }
    export namespace Staff {
      export function primaryKeyFrom(
        value: Public.Tables.Staff.Record,
      ): string {
        return JSON.stringify({
          staffId: value.staffId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.staffId !== undefined;
      }
    }
    export namespace Store {
      export function primaryKeyFrom(
        value: Public.Tables.Store.Record,
      ): string {
        return JSON.stringify({
          storeId: value.storeId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.storeId !== undefined;
      }
    }
    export namespace Payment {
      export function primaryKeyFrom(
        value: Public.Tables.Payment.Record,
      ): string {
        return JSON.stringify({
          paymentId: value.paymentId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.paymentId !== undefined;
      }
    }
    export namespace Film {
      export function primaryKeyFrom(value: Public.Tables.Film.Record): string {
        return JSON.stringify({
          filmId: value.filmId,
        });
      }

      export function includesPrimaryKey(value: Partial<Record>) {
        return value.filmId !== undefined;
      }
    }
  }
}

// begin type guards
export namespace PgCatalog {
  export namespace Types {
    export namespace PgAggregate {
      export function is(value: any): value is PgCatalog.Types.PgAggregate {
        if (
          value.aggfnoid !== undefined &&
          value.aggkind !== undefined &&
          value.aggnumdirectargs !== undefined &&
          value.aggtransfn !== undefined &&
          value.aggfinalfn !== undefined &&
          value.aggcombinefn !== undefined &&
          value.aggserialfn !== undefined &&
          value.aggdeserialfn !== undefined &&
          value.aggmtransfn !== undefined &&
          value.aggminvtransfn !== undefined &&
          value.aggmfinalfn !== undefined &&
          value.aggfinalextra !== undefined &&
          value.aggmfinalextra !== undefined &&
          value.aggfinalmodify !== undefined &&
          value.aggmfinalmodify !== undefined &&
          value.aggsortop !== undefined &&
          value.aggtranstype !== undefined &&
          value.aggtransspace !== undefined &&
          value.aggmtranstype !== undefined &&
          value.aggmtransspace !== undefined &&
          value.agginitval !== undefined &&
          value.aggminitval !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAm {
      export function is(value: any): value is PgCatalog.Types.PgAm {
        if (
          value.oid !== undefined &&
          value.amname !== undefined &&
          value.amhandler !== undefined &&
          value.amtype !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAmop {
      export function is(value: any): value is PgCatalog.Types.PgAmop {
        if (
          value.oid !== undefined &&
          value.amopfamily !== undefined &&
          value.amoplefttype !== undefined &&
          value.amoprighttype !== undefined &&
          value.amopstrategy !== undefined &&
          value.amoppurpose !== undefined &&
          value.amopopr !== undefined &&
          value.amopmethod !== undefined &&
          value.amopsortfamily !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAmproc {
      export function is(value: any): value is PgCatalog.Types.PgAmproc {
        if (
          value.oid !== undefined &&
          value.amprocfamily !== undefined &&
          value.amproclefttype !== undefined &&
          value.amprocrighttype !== undefined &&
          value.amprocnum !== undefined &&
          value.amproc !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAttrdef {
      export function is(value: any): value is PgCatalog.Types.PgAttrdef {
        if (
          value.oid !== undefined &&
          value.adrelid !== undefined &&
          value.adnum !== undefined &&
          value.adbin !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAttribute {
      export function is(value: any): value is PgCatalog.Types.PgAttribute {
        if (
          value.attrelid !== undefined &&
          value.attname !== undefined &&
          value.atttypid !== undefined &&
          value.attlen !== undefined &&
          value.attnum !== undefined &&
          value.attcacheoff !== undefined &&
          value.atttypmod !== undefined &&
          value.attndims !== undefined &&
          value.attbyval !== undefined &&
          value.attalign !== undefined &&
          value.attstorage !== undefined &&
          value.attcompression !== undefined &&
          value.attnotnull !== undefined &&
          value.atthasdef !== undefined &&
          value.atthasmissing !== undefined &&
          value.attidentity !== undefined &&
          value.attgenerated !== undefined &&
          value.attisdropped !== undefined &&
          value.attislocal !== undefined &&
          value.attinhcount !== undefined &&
          value.attstattarget !== undefined &&
          value.attcollation !== undefined &&
          value.attacl !== undefined &&
          value.attoptions !== undefined &&
          value.attfdwoptions !== undefined &&
          value.attmissingval !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAuthMembers {
      export function is(value: any): value is PgCatalog.Types.PgAuthMembers {
        if (
          value.oid !== undefined &&
          value.roleid !== undefined &&
          value.member !== undefined &&
          value.grantor !== undefined &&
          value.adminOption !== undefined &&
          value.inheritOption !== undefined &&
          value.setOption !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAuthid {
      export function is(value: any): value is PgCatalog.Types.PgAuthid {
        if (
          value.oid !== undefined &&
          value.rolname !== undefined &&
          value.rolsuper !== undefined &&
          value.rolinherit !== undefined &&
          value.rolcreaterole !== undefined &&
          value.rolcreatedb !== undefined &&
          value.rolcanlogin !== undefined &&
          value.rolreplication !== undefined &&
          value.rolbypassrls !== undefined &&
          value.rolconnlimit !== undefined &&
          value.rolpassword !== undefined &&
          value.rolvaliduntil !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAvailableExtensionVersions {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgAvailableExtensionVersions {
        if (
          value.name !== undefined &&
          value.version !== undefined &&
          value.installed !== undefined &&
          value.superuser !== undefined &&
          value.trusted !== undefined &&
          value.relocatable !== undefined &&
          value.schema !== undefined &&
          value.requires !== undefined &&
          value.comment !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgAvailableExtensions {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgAvailableExtensions {
        if (
          value.name !== undefined &&
          value.defaultVersion !== undefined &&
          value.installedVersion !== undefined &&
          value.comment !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgBackendMemoryContexts {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgBackendMemoryContexts {
        if (
          value.name !== undefined &&
          value.ident !== undefined &&
          value.parent !== undefined &&
          value.level !== undefined &&
          value.totalBytes !== undefined &&
          value.totalNblocks !== undefined &&
          value.freeBytes !== undefined &&
          value.freeChunks !== undefined &&
          value.usedBytes !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgCast {
      export function is(value: any): value is PgCatalog.Types.PgCast {
        if (
          value.oid !== undefined &&
          value.castsource !== undefined &&
          value.casttarget !== undefined &&
          value.castfunc !== undefined &&
          value.castcontext !== undefined &&
          value.castmethod !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgClass {
      export function is(value: any): value is PgCatalog.Types.PgClass {
        if (
          value.oid !== undefined &&
          value.relname !== undefined &&
          value.relnamespace !== undefined &&
          value.reltype !== undefined &&
          value.reloftype !== undefined &&
          value.relowner !== undefined &&
          value.relam !== undefined &&
          value.relfilenode !== undefined &&
          value.reltablespace !== undefined &&
          value.relpages !== undefined &&
          value.reltuples !== undefined &&
          value.relallvisible !== undefined &&
          value.reltoastrelid !== undefined &&
          value.relhasindex !== undefined &&
          value.relisshared !== undefined &&
          value.relpersistence !== undefined &&
          value.relkind !== undefined &&
          value.relnatts !== undefined &&
          value.relchecks !== undefined &&
          value.relhasrules !== undefined &&
          value.relhastriggers !== undefined &&
          value.relhassubclass !== undefined &&
          value.relrowsecurity !== undefined &&
          value.relforcerowsecurity !== undefined &&
          value.relispopulated !== undefined &&
          value.relreplident !== undefined &&
          value.relispartition !== undefined &&
          value.relrewrite !== undefined &&
          value.relfrozenxid !== undefined &&
          value.relminmxid !== undefined &&
          value.relacl !== undefined &&
          value.reloptions !== undefined &&
          value.relpartbound !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgCollation {
      export function is(value: any): value is PgCatalog.Types.PgCollation {
        if (
          value.oid !== undefined &&
          value.collname !== undefined &&
          value.collnamespace !== undefined &&
          value.collowner !== undefined &&
          value.collprovider !== undefined &&
          value.collisdeterministic !== undefined &&
          value.collencoding !== undefined &&
          value.collcollate !== undefined &&
          value.collctype !== undefined &&
          value.colliculocale !== undefined &&
          value.collicurules !== undefined &&
          value.collversion !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgConfig {
      export function is(value: any): value is PgCatalog.Types.PgConfig {
        if (value.name !== undefined && value.setting !== undefined)
          return true;
        return false;
      }
    }
    export namespace PgConstraint {
      export function is(value: any): value is PgCatalog.Types.PgConstraint {
        if (
          value.oid !== undefined &&
          value.conname !== undefined &&
          value.connamespace !== undefined &&
          value.contype !== undefined &&
          value.condeferrable !== undefined &&
          value.condeferred !== undefined &&
          value.convalidated !== undefined &&
          value.conrelid !== undefined &&
          value.contypid !== undefined &&
          value.conindid !== undefined &&
          value.conparentid !== undefined &&
          value.confrelid !== undefined &&
          value.confupdtype !== undefined &&
          value.confdeltype !== undefined &&
          value.confmatchtype !== undefined &&
          value.conislocal !== undefined &&
          value.coninhcount !== undefined &&
          value.connoinherit !== undefined &&
          value.conkey !== undefined &&
          value.confkey !== undefined &&
          value.conpfeqop !== undefined &&
          value.conppeqop !== undefined &&
          value.conffeqop !== undefined &&
          value.confdelsetcols !== undefined &&
          value.conexclop !== undefined &&
          value.conbin !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgConversion {
      export function is(value: any): value is PgCatalog.Types.PgConversion {
        if (
          value.oid !== undefined &&
          value.conname !== undefined &&
          value.connamespace !== undefined &&
          value.conowner !== undefined &&
          value.conforencoding !== undefined &&
          value.contoencoding !== undefined &&
          value.conproc !== undefined &&
          value.condefault !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgCursors {
      export function is(value: any): value is PgCatalog.Types.PgCursors {
        if (
          value.name !== undefined &&
          value.statement !== undefined &&
          value.isHoldable !== undefined &&
          value.isBinary !== undefined &&
          value.isScrollable !== undefined &&
          value.creationTime !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgDatabase {
      export function is(value: any): value is PgCatalog.Types.PgDatabase {
        if (
          value.oid !== undefined &&
          value.datname !== undefined &&
          value.datdba !== undefined &&
          value.encoding !== undefined &&
          value.datlocprovider !== undefined &&
          value.datistemplate !== undefined &&
          value.datallowconn !== undefined &&
          value.datconnlimit !== undefined &&
          value.datfrozenxid !== undefined &&
          value.datminmxid !== undefined &&
          value.dattablespace !== undefined &&
          value.datcollate !== undefined &&
          value.datctype !== undefined &&
          value.daticulocale !== undefined &&
          value.daticurules !== undefined &&
          value.datcollversion !== undefined &&
          value.datacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgDbRoleSetting {
      export function is(value: any): value is PgCatalog.Types.PgDbRoleSetting {
        if (
          value.setdatabase !== undefined &&
          value.setrole !== undefined &&
          value.setconfig !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgDefaultAcl {
      export function is(value: any): value is PgCatalog.Types.PgDefaultAcl {
        if (
          value.oid !== undefined &&
          value.defaclrole !== undefined &&
          value.defaclnamespace !== undefined &&
          value.defaclobjtype !== undefined &&
          value.defaclacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgDepend {
      export function is(value: any): value is PgCatalog.Types.PgDepend {
        if (
          value.classid !== undefined &&
          value.objid !== undefined &&
          value.objsubid !== undefined &&
          value.refclassid !== undefined &&
          value.refobjid !== undefined &&
          value.refobjsubid !== undefined &&
          value.deptype !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgDescription {
      export function is(value: any): value is PgCatalog.Types.PgDescription {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.objsubid !== undefined &&
          value.description !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgEnum {
      export function is(value: any): value is PgCatalog.Types.PgEnum {
        if (
          value.oid !== undefined &&
          value.enumtypid !== undefined &&
          value.enumsortorder !== undefined &&
          value.enumlabel !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgEventTrigger {
      export function is(value: any): value is PgCatalog.Types.PgEventTrigger {
        if (
          value.oid !== undefined &&
          value.evtname !== undefined &&
          value.evtevent !== undefined &&
          value.evtowner !== undefined &&
          value.evtfoid !== undefined &&
          value.evtenabled !== undefined &&
          value.evttags !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgExtension {
      export function is(value: any): value is PgCatalog.Types.PgExtension {
        if (
          value.oid !== undefined &&
          value.extname !== undefined &&
          value.extowner !== undefined &&
          value.extnamespace !== undefined &&
          value.extrelocatable !== undefined &&
          value.extversion !== undefined &&
          value.extconfig !== undefined &&
          value.extcondition !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgFileSettings {
      export function is(value: any): value is PgCatalog.Types.PgFileSettings {
        if (
          value.sourcefile !== undefined &&
          value.sourceline !== undefined &&
          value.seqno !== undefined &&
          value.name !== undefined &&
          value.setting !== undefined &&
          value.applied !== undefined &&
          value.error !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignDataWrapper {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgForeignDataWrapper {
        if (
          value.oid !== undefined &&
          value.fdwname !== undefined &&
          value.fdwowner !== undefined &&
          value.fdwhandler !== undefined &&
          value.fdwvalidator !== undefined &&
          value.fdwacl !== undefined &&
          value.fdwoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignServer {
      export function is(value: any): value is PgCatalog.Types.PgForeignServer {
        if (
          value.oid !== undefined &&
          value.srvname !== undefined &&
          value.srvowner !== undefined &&
          value.srvfdw !== undefined &&
          value.srvtype !== undefined &&
          value.srvversion !== undefined &&
          value.srvacl !== undefined &&
          value.srvoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignTable {
      export function is(value: any): value is PgCatalog.Types.PgForeignTable {
        if (
          value.ftrelid !== undefined &&
          value.ftserver !== undefined &&
          value.ftoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgGroup {
      export function is(value: any): value is PgCatalog.Types.PgGroup {
        if (
          value.groname !== undefined &&
          value.grosysid !== undefined &&
          value.grolist !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgHbaFileRules {
      export function is(value: any): value is PgCatalog.Types.PgHbaFileRules {
        if (
          value.ruleNumber !== undefined &&
          value.fileName !== undefined &&
          value.lineNumber !== undefined &&
          value.type !== undefined &&
          value.database !== undefined &&
          value.userName !== undefined &&
          value.address !== undefined &&
          value.netmask !== undefined &&
          value.authMethod !== undefined &&
          value.options !== undefined &&
          value.error !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgIdentFileMappings {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgIdentFileMappings {
        if (
          value.mapNumber !== undefined &&
          value.fileName !== undefined &&
          value.lineNumber !== undefined &&
          value.mapName !== undefined &&
          value.sysName !== undefined &&
          value.pgUsername !== undefined &&
          value.error !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgIndex {
      export function is(value: any): value is PgCatalog.Types.PgIndex {
        if (
          value.indexrelid !== undefined &&
          value.indrelid !== undefined &&
          value.indnatts !== undefined &&
          value.indnkeyatts !== undefined &&
          value.indisunique !== undefined &&
          value.indnullsnotdistinct !== undefined &&
          value.indisprimary !== undefined &&
          value.indisexclusion !== undefined &&
          value.indimmediate !== undefined &&
          value.indisclustered !== undefined &&
          value.indisvalid !== undefined &&
          value.indcheckxmin !== undefined &&
          value.indisready !== undefined &&
          value.indislive !== undefined &&
          value.indisreplident !== undefined &&
          value.indkey !== undefined &&
          value.indcollation !== undefined &&
          value.indclass !== undefined &&
          value.indoption !== undefined &&
          value.indexprs !== undefined &&
          value.indpred !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgIndexes {
      export function is(value: any): value is PgCatalog.Types.PgIndexes {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.indexname !== undefined &&
          value.tablespace !== undefined &&
          value.indexdef !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgInherits {
      export function is(value: any): value is PgCatalog.Types.PgInherits {
        if (
          value.inhrelid !== undefined &&
          value.inhparent !== undefined &&
          value.inhseqno !== undefined &&
          value.inhdetachpending !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgInitPrivs {
      export function is(value: any): value is PgCatalog.Types.PgInitPrivs {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.objsubid !== undefined &&
          value.privtype !== undefined &&
          value.initprivs !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgLanguage {
      export function is(value: any): value is PgCatalog.Types.PgLanguage {
        if (
          value.oid !== undefined &&
          value.lanname !== undefined &&
          value.lanowner !== undefined &&
          value.lanispl !== undefined &&
          value.lanpltrusted !== undefined &&
          value.lanplcallfoid !== undefined &&
          value.laninline !== undefined &&
          value.lanvalidator !== undefined &&
          value.lanacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgLargeobject {
      export function is(value: any): value is PgCatalog.Types.PgLargeobject {
        if (
          value.loid !== undefined &&
          value.pageno !== undefined &&
          value.data !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgLargeobjectMetadata {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgLargeobjectMetadata {
        if (
          value.oid !== undefined &&
          value.lomowner !== undefined &&
          value.lomacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgLocks {
      export function is(value: any): value is PgCatalog.Types.PgLocks {
        if (
          value.locktype !== undefined &&
          value.database !== undefined &&
          value.relation !== undefined &&
          value.page !== undefined &&
          value.tuple !== undefined &&
          value.virtualxid !== undefined &&
          value.transactionid !== undefined &&
          value.classid !== undefined &&
          value.objid !== undefined &&
          value.objsubid !== undefined &&
          value.virtualtransaction !== undefined &&
          value.pid !== undefined &&
          value.mode !== undefined &&
          value.granted !== undefined &&
          value.fastpath !== undefined &&
          value.waitstart !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgMatviews {
      export function is(value: any): value is PgCatalog.Types.PgMatviews {
        if (
          value.schemaname !== undefined &&
          value.matviewname !== undefined &&
          value.matviewowner !== undefined &&
          value.tablespace !== undefined &&
          value.hasindexes !== undefined &&
          value.ispopulated !== undefined &&
          value.definition !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgNamespace {
      export function is(value: any): value is PgCatalog.Types.PgNamespace {
        if (
          value.oid !== undefined &&
          value.nspname !== undefined &&
          value.nspowner !== undefined &&
          value.nspacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgOpclass {
      export function is(value: any): value is PgCatalog.Types.PgOpclass {
        if (
          value.oid !== undefined &&
          value.opcmethod !== undefined &&
          value.opcname !== undefined &&
          value.opcnamespace !== undefined &&
          value.opcowner !== undefined &&
          value.opcfamily !== undefined &&
          value.opcintype !== undefined &&
          value.opcdefault !== undefined &&
          value.opckeytype !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgOperator {
      export function is(value: any): value is PgCatalog.Types.PgOperator {
        if (
          value.oid !== undefined &&
          value.oprname !== undefined &&
          value.oprnamespace !== undefined &&
          value.oprowner !== undefined &&
          value.oprkind !== undefined &&
          value.oprcanmerge !== undefined &&
          value.oprcanhash !== undefined &&
          value.oprleft !== undefined &&
          value.oprright !== undefined &&
          value.oprresult !== undefined &&
          value.oprcom !== undefined &&
          value.oprnegate !== undefined &&
          value.oprcode !== undefined &&
          value.oprrest !== undefined &&
          value.oprjoin !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgOpfamily {
      export function is(value: any): value is PgCatalog.Types.PgOpfamily {
        if (
          value.oid !== undefined &&
          value.opfmethod !== undefined &&
          value.opfname !== undefined &&
          value.opfnamespace !== undefined &&
          value.opfowner !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgParameterAcl {
      export function is(value: any): value is PgCatalog.Types.PgParameterAcl {
        if (
          value.oid !== undefined &&
          value.parname !== undefined &&
          value.paracl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPartitionedTable {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgPartitionedTable {
        if (
          value.partrelid !== undefined &&
          value.partstrat !== undefined &&
          value.partnatts !== undefined &&
          value.partdefid !== undefined &&
          value.partattrs !== undefined &&
          value.partclass !== undefined &&
          value.partcollation !== undefined &&
          value.partexprs !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPolicies {
      export function is(value: any): value is PgCatalog.Types.PgPolicies {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.policyname !== undefined &&
          value.permissive !== undefined &&
          value.roles !== undefined &&
          value.cmd !== undefined &&
          value.qual !== undefined &&
          value.withCheck !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPolicy {
      export function is(value: any): value is PgCatalog.Types.PgPolicy {
        if (
          value.oid !== undefined &&
          value.polname !== undefined &&
          value.polrelid !== undefined &&
          value.polcmd !== undefined &&
          value.polpermissive !== undefined &&
          value.polroles !== undefined &&
          value.polqual !== undefined &&
          value.polwithcheck !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPreparedStatements {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgPreparedStatements {
        if (
          value.name !== undefined &&
          value.statement !== undefined &&
          value.prepareTime !== undefined &&
          value.parameterTypes !== undefined &&
          value.resultTypes !== undefined &&
          value.fromSql !== undefined &&
          value.genericPlans !== undefined &&
          value.customPlans !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPreparedXacts {
      export function is(value: any): value is PgCatalog.Types.PgPreparedXacts {
        if (
          value.transaction !== undefined &&
          value.gid !== undefined &&
          value.prepared !== undefined &&
          value.owner !== undefined &&
          value.database !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgProc {
      export function is(value: any): value is PgCatalog.Types.PgProc {
        if (
          value.oid !== undefined &&
          value.proname !== undefined &&
          value.pronamespace !== undefined &&
          value.proowner !== undefined &&
          value.prolang !== undefined &&
          value.procost !== undefined &&
          value.prorows !== undefined &&
          value.provariadic !== undefined &&
          value.prosupport !== undefined &&
          value.prokind !== undefined &&
          value.prosecdef !== undefined &&
          value.proleakproof !== undefined &&
          value.proisstrict !== undefined &&
          value.proretset !== undefined &&
          value.provolatile !== undefined &&
          value.proparallel !== undefined &&
          value.pronargs !== undefined &&
          value.pronargdefaults !== undefined &&
          value.prorettype !== undefined &&
          value.proargtypes !== undefined &&
          value.proallargtypes !== undefined &&
          value.proargmodes !== undefined &&
          value.proargnames !== undefined &&
          value.proargdefaults !== undefined &&
          value.protrftypes !== undefined &&
          value.prosrc !== undefined &&
          value.probin !== undefined &&
          value.prosqlbody !== undefined &&
          value.proconfig !== undefined &&
          value.proacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPublication {
      export function is(value: any): value is PgCatalog.Types.PgPublication {
        if (
          value.oid !== undefined &&
          value.pubname !== undefined &&
          value.pubowner !== undefined &&
          value.puballtables !== undefined &&
          value.pubinsert !== undefined &&
          value.pubupdate !== undefined &&
          value.pubdelete !== undefined &&
          value.pubtruncate !== undefined &&
          value.pubviaroot !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPublicationNamespace {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgPublicationNamespace {
        if (
          value.oid !== undefined &&
          value.pnpubid !== undefined &&
          value.pnnspid !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPublicationRel {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgPublicationRel {
        if (
          value.oid !== undefined &&
          value.prpubid !== undefined &&
          value.prrelid !== undefined &&
          value.prqual !== undefined &&
          value.prattrs !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgPublicationTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgPublicationTables {
        if (
          value.pubname !== undefined &&
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.attnames !== undefined &&
          value.rowfilter !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgRange {
      export function is(value: any): value is PgCatalog.Types.PgRange {
        if (
          value.rngtypid !== undefined &&
          value.rngsubtype !== undefined &&
          value.rngmultitypid !== undefined &&
          value.rngcollation !== undefined &&
          value.rngsubopc !== undefined &&
          value.rngcanonical !== undefined &&
          value.rngsubdiff !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgReplicationOrigin {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgReplicationOrigin {
        if (value.roident !== undefined && value.roname !== undefined)
          return true;
        return false;
      }
    }
    export namespace PgReplicationOriginStatus {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgReplicationOriginStatus {
        if (
          value.localId !== undefined &&
          value.externalId !== undefined &&
          value.remoteLsn !== undefined &&
          value.localLsn !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgReplicationSlots {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgReplicationSlots {
        if (
          value.slotName !== undefined &&
          value.plugin !== undefined &&
          value.slotType !== undefined &&
          value.datoid !== undefined &&
          value.database !== undefined &&
          value.temporary !== undefined &&
          value.active !== undefined &&
          value.activePid !== undefined &&
          value.xmin !== undefined &&
          value.catalogXmin !== undefined &&
          value.restartLsn !== undefined &&
          value.confirmedFlushLsn !== undefined &&
          value.walStatus !== undefined &&
          value.safeWalSize !== undefined &&
          value.twoPhase !== undefined &&
          value.conflicting !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgRewrite {
      export function is(value: any): value is PgCatalog.Types.PgRewrite {
        if (
          value.oid !== undefined &&
          value.rulename !== undefined &&
          value.evClass !== undefined &&
          value.evType !== undefined &&
          value.evEnabled !== undefined &&
          value.isInstead !== undefined &&
          value.evQual !== undefined &&
          value.evAction !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgRoles {
      export function is(value: any): value is PgCatalog.Types.PgRoles {
        if (
          value.rolname !== undefined &&
          value.rolsuper !== undefined &&
          value.rolinherit !== undefined &&
          value.rolcreaterole !== undefined &&
          value.rolcreatedb !== undefined &&
          value.rolcanlogin !== undefined &&
          value.rolreplication !== undefined &&
          value.rolconnlimit !== undefined &&
          value.rolpassword !== undefined &&
          value.rolvaliduntil !== undefined &&
          value.rolbypassrls !== undefined &&
          value.rolconfig !== undefined &&
          value.oid !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgRules {
      export function is(value: any): value is PgCatalog.Types.PgRules {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.rulename !== undefined &&
          value.definition !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSeclabel {
      export function is(value: any): value is PgCatalog.Types.PgSeclabel {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.objsubid !== undefined &&
          value.provider !== undefined &&
          value.label !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSeclabels {
      export function is(value: any): value is PgCatalog.Types.PgSeclabels {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.objsubid !== undefined &&
          value.objtype !== undefined &&
          value.objnamespace !== undefined &&
          value.objname !== undefined &&
          value.provider !== undefined &&
          value.label !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSequence {
      export function is(value: any): value is PgCatalog.Types.PgSequence {
        if (
          value.seqrelid !== undefined &&
          value.seqtypid !== undefined &&
          value.seqstart !== undefined &&
          value.seqincrement !== undefined &&
          value.seqmax !== undefined &&
          value.seqmin !== undefined &&
          value.seqcache !== undefined &&
          value.seqcycle !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSequences {
      export function is(value: any): value is PgCatalog.Types.PgSequences {
        if (
          value.schemaname !== undefined &&
          value.sequencename !== undefined &&
          value.sequenceowner !== undefined &&
          value.dataType !== undefined &&
          value.startValue !== undefined &&
          value.minValue !== undefined &&
          value.maxValue !== undefined &&
          value.incrementBy !== undefined &&
          value.cycle !== undefined &&
          value.cacheSize !== undefined &&
          value.lastValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSettings {
      export function is(value: any): value is PgCatalog.Types.PgSettings {
        if (
          value.name !== undefined &&
          value.setting !== undefined &&
          value.unit !== undefined &&
          value.category !== undefined &&
          value.shortDesc !== undefined &&
          value.extraDesc !== undefined &&
          value.context !== undefined &&
          value.vartype !== undefined &&
          value.source !== undefined &&
          value.minVal !== undefined &&
          value.maxVal !== undefined &&
          value.enumvals !== undefined &&
          value.bootVal !== undefined &&
          value.resetVal !== undefined &&
          value.sourcefile !== undefined &&
          value.sourceline !== undefined &&
          value.pendingRestart !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgShadow {
      export function is(value: any): value is PgCatalog.Types.PgShadow {
        if (
          value.usename !== undefined &&
          value.usesysid !== undefined &&
          value.usecreatedb !== undefined &&
          value.usesuper !== undefined &&
          value.userepl !== undefined &&
          value.usebypassrls !== undefined &&
          value.passwd !== undefined &&
          value.valuntil !== undefined &&
          value.useconfig !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgShdepend {
      export function is(value: any): value is PgCatalog.Types.PgShdepend {
        if (
          value.dbid !== undefined &&
          value.classid !== undefined &&
          value.objid !== undefined &&
          value.objsubid !== undefined &&
          value.refclassid !== undefined &&
          value.refobjid !== undefined &&
          value.deptype !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgShdescription {
      export function is(value: any): value is PgCatalog.Types.PgShdescription {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.description !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgShmemAllocations {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgShmemAllocations {
        if (
          value.name !== undefined &&
          value.off !== undefined &&
          value.size !== undefined &&
          value.allocatedSize !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgShseclabel {
      export function is(value: any): value is PgCatalog.Types.PgShseclabel {
        if (
          value.objoid !== undefined &&
          value.classoid !== undefined &&
          value.provider !== undefined &&
          value.label !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatActivity {
      export function is(value: any): value is PgCatalog.Types.PgStatActivity {
        if (
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.pid !== undefined &&
          value.leaderPid !== undefined &&
          value.usesysid !== undefined &&
          value.usename !== undefined &&
          value.applicationName !== undefined &&
          value.clientAddr !== undefined &&
          value.clientHostname !== undefined &&
          value.clientPort !== undefined &&
          value.backendStart !== undefined &&
          value.xactStart !== undefined &&
          value.queryStart !== undefined &&
          value.stateChange !== undefined &&
          value.waitEventType !== undefined &&
          value.waitEvent !== undefined &&
          value.state !== undefined &&
          value.backendXid !== undefined &&
          value.backendXmin !== undefined &&
          value.queryId !== undefined &&
          value.query !== undefined &&
          value.backendType !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatAllIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatAllIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupRead !== undefined &&
          value.idxTupFetch !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatAllTables {
      export function is(value: any): value is PgCatalog.Types.PgStatAllTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.lastSeqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined &&
          value.nLiveTup !== undefined &&
          value.nDeadTup !== undefined &&
          value.nModSinceAnalyze !== undefined &&
          value.nInsSinceVacuum !== undefined &&
          value.lastVacuum !== undefined &&
          value.lastAutovacuum !== undefined &&
          value.lastAnalyze !== undefined &&
          value.lastAutoanalyze !== undefined &&
          value.vacuumCount !== undefined &&
          value.autovacuumCount !== undefined &&
          value.analyzeCount !== undefined &&
          value.autoanalyzeCount !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatArchiver {
      export function is(value: any): value is PgCatalog.Types.PgStatArchiver {
        if (
          value.archivedCount !== undefined &&
          value.lastArchivedWal !== undefined &&
          value.lastArchivedTime !== undefined &&
          value.failedCount !== undefined &&
          value.lastFailedWal !== undefined &&
          value.lastFailedTime !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatBgwriter {
      export function is(value: any): value is PgCatalog.Types.PgStatBgwriter {
        if (
          value.checkpointsTimed !== undefined &&
          value.checkpointsReq !== undefined &&
          value.checkpointWriteTime !== undefined &&
          value.checkpointSyncTime !== undefined &&
          value.buffersCheckpoint !== undefined &&
          value.buffersClean !== undefined &&
          value.maxwrittenClean !== undefined &&
          value.buffersBackend !== undefined &&
          value.buffersBackendFsync !== undefined &&
          value.buffersAlloc !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatDatabase {
      export function is(value: any): value is PgCatalog.Types.PgStatDatabase {
        if (
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.numbackends !== undefined &&
          value.xactCommit !== undefined &&
          value.xactRollback !== undefined &&
          value.blksRead !== undefined &&
          value.blksHit !== undefined &&
          value.tupReturned !== undefined &&
          value.tupFetched !== undefined &&
          value.tupInserted !== undefined &&
          value.tupUpdated !== undefined &&
          value.tupDeleted !== undefined &&
          value.conflicts !== undefined &&
          value.tempFiles !== undefined &&
          value.tempBytes !== undefined &&
          value.deadlocks !== undefined &&
          value.checksumFailures !== undefined &&
          value.checksumLastFailure !== undefined &&
          value.blkReadTime !== undefined &&
          value.blkWriteTime !== undefined &&
          value.sessionTime !== undefined &&
          value.activeTime !== undefined &&
          value.idleInTransactionTime !== undefined &&
          value.sessions !== undefined &&
          value.sessionsAbandoned !== undefined &&
          value.sessionsFatal !== undefined &&
          value.sessionsKilled !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatDatabaseConflicts {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatDatabaseConflicts {
        if (
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.conflTablespace !== undefined &&
          value.conflLock !== undefined &&
          value.conflSnapshot !== undefined &&
          value.conflBufferpin !== undefined &&
          value.conflDeadlock !== undefined &&
          value.conflActiveLogicalslot !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatGssapi {
      export function is(value: any): value is PgCatalog.Types.PgStatGssapi {
        if (
          value.pid !== undefined &&
          value.gssAuthenticated !== undefined &&
          value.principal !== undefined &&
          value.encrypted !== undefined &&
          value.credentialsDelegated !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatIo {
      export function is(value: any): value is PgCatalog.Types.PgStatIo {
        if (
          value.backendType !== undefined &&
          value.object !== undefined &&
          value.context !== undefined &&
          value.reads !== undefined &&
          value.readTime !== undefined &&
          value.writes !== undefined &&
          value.writeTime !== undefined &&
          value.writebacks !== undefined &&
          value.writebackTime !== undefined &&
          value.extends !== undefined &&
          value.extendTime !== undefined &&
          value.opBytes !== undefined &&
          value.hits !== undefined &&
          value.evictions !== undefined &&
          value.reuses !== undefined &&
          value.fsyncs !== undefined &&
          value.fsyncTime !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressAnalyze {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressAnalyze {
        if (
          value.pid !== undefined &&
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.relid !== undefined &&
          value.phase !== undefined &&
          value.sampleBlksTotal !== undefined &&
          value.sampleBlksScanned !== undefined &&
          value.extStatsTotal !== undefined &&
          value.extStatsComputed !== undefined &&
          value.childTablesTotal !== undefined &&
          value.childTablesDone !== undefined &&
          value.currentChildTableRelid !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressBasebackup {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressBasebackup {
        if (
          value.pid !== undefined &&
          value.phase !== undefined &&
          value.backupTotal !== undefined &&
          value.backupStreamed !== undefined &&
          value.tablespacesTotal !== undefined &&
          value.tablespacesStreamed !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressCluster {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressCluster {
        if (
          value.pid !== undefined &&
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.relid !== undefined &&
          value.command !== undefined &&
          value.phase !== undefined &&
          value.clusterIndexRelid !== undefined &&
          value.heapTuplesScanned !== undefined &&
          value.heapTuplesWritten !== undefined &&
          value.heapBlksTotal !== undefined &&
          value.heapBlksScanned !== undefined &&
          value.indexRebuildCount !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressCopy {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressCopy {
        if (
          value.pid !== undefined &&
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.relid !== undefined &&
          value.command !== undefined &&
          value.type !== undefined &&
          value.bytesProcessed !== undefined &&
          value.bytesTotal !== undefined &&
          value.tuplesProcessed !== undefined &&
          value.tuplesExcluded !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressCreateIndex {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressCreateIndex {
        if (
          value.pid !== undefined &&
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.relid !== undefined &&
          value.indexRelid !== undefined &&
          value.command !== undefined &&
          value.phase !== undefined &&
          value.lockersTotal !== undefined &&
          value.lockersDone !== undefined &&
          value.currentLockerPid !== undefined &&
          value.blocksTotal !== undefined &&
          value.blocksDone !== undefined &&
          value.tuplesTotal !== undefined &&
          value.tuplesDone !== undefined &&
          value.partitionsTotal !== undefined &&
          value.partitionsDone !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatProgressVacuum {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatProgressVacuum {
        if (
          value.pid !== undefined &&
          value.datid !== undefined &&
          value.datname !== undefined &&
          value.relid !== undefined &&
          value.phase !== undefined &&
          value.heapBlksTotal !== undefined &&
          value.heapBlksScanned !== undefined &&
          value.heapBlksVacuumed !== undefined &&
          value.indexVacuumCount !== undefined &&
          value.maxDeadTuples !== undefined &&
          value.numDeadTuples !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatRecoveryPrefetch {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatRecoveryPrefetch {
        if (
          value.statsReset !== undefined &&
          value.prefetch !== undefined &&
          value.hit !== undefined &&
          value.skipInit !== undefined &&
          value.skipNew !== undefined &&
          value.skipFpw !== undefined &&
          value.skipRep !== undefined &&
          value.walDistance !== undefined &&
          value.blockDistance !== undefined &&
          value.ioDepth !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatReplication {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatReplication {
        if (
          value.pid !== undefined &&
          value.usesysid !== undefined &&
          value.usename !== undefined &&
          value.applicationName !== undefined &&
          value.clientAddr !== undefined &&
          value.clientHostname !== undefined &&
          value.clientPort !== undefined &&
          value.backendStart !== undefined &&
          value.backendXmin !== undefined &&
          value.state !== undefined &&
          value.sentLsn !== undefined &&
          value.writeLsn !== undefined &&
          value.flushLsn !== undefined &&
          value.replayLsn !== undefined &&
          value.writeLag !== undefined &&
          value.flushLag !== undefined &&
          value.replayLag !== undefined &&
          value.syncPriority !== undefined &&
          value.syncState !== undefined &&
          value.replyTime !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatReplicationSlots {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatReplicationSlots {
        if (
          value.slotName !== undefined &&
          value.spillTxns !== undefined &&
          value.spillCount !== undefined &&
          value.spillBytes !== undefined &&
          value.streamTxns !== undefined &&
          value.streamCount !== undefined &&
          value.streamBytes !== undefined &&
          value.totalTxns !== undefined &&
          value.totalBytes !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSlru {
      export function is(value: any): value is PgCatalog.Types.PgStatSlru {
        if (
          value.name !== undefined &&
          value.blksZeroed !== undefined &&
          value.blksHit !== undefined &&
          value.blksRead !== undefined &&
          value.blksWritten !== undefined &&
          value.blksExists !== undefined &&
          value.flushes !== undefined &&
          value.truncates !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSsl {
      export function is(value: any): value is PgCatalog.Types.PgStatSsl {
        if (
          value.pid !== undefined &&
          value.ssl !== undefined &&
          value.version !== undefined &&
          value.cipher !== undefined &&
          value.bits !== undefined &&
          value.clientDn !== undefined &&
          value.clientSerial !== undefined &&
          value.issuerDn !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSubscription {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatSubscription {
        if (
          value.subid !== undefined &&
          value.subname !== undefined &&
          value.pid !== undefined &&
          value.leaderPid !== undefined &&
          value.relid !== undefined &&
          value.receivedLsn !== undefined &&
          value.lastMsgSendTime !== undefined &&
          value.lastMsgReceiptTime !== undefined &&
          value.latestEndLsn !== undefined &&
          value.latestEndTime !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSubscriptionStats {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatSubscriptionStats {
        if (
          value.subid !== undefined &&
          value.subname !== undefined &&
          value.applyErrorCount !== undefined &&
          value.syncErrorCount !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSysIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatSysIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupRead !== undefined &&
          value.idxTupFetch !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatSysTables {
      export function is(value: any): value is PgCatalog.Types.PgStatSysTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.lastSeqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined &&
          value.nLiveTup !== undefined &&
          value.nDeadTup !== undefined &&
          value.nModSinceAnalyze !== undefined &&
          value.nInsSinceVacuum !== undefined &&
          value.lastVacuum !== undefined &&
          value.lastAutovacuum !== undefined &&
          value.lastAnalyze !== undefined &&
          value.lastAutoanalyze !== undefined &&
          value.vacuumCount !== undefined &&
          value.autovacuumCount !== undefined &&
          value.analyzeCount !== undefined &&
          value.autoanalyzeCount !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatUserFunctions {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatUserFunctions {
        if (
          value.funcid !== undefined &&
          value.schemaname !== undefined &&
          value.funcname !== undefined &&
          value.calls !== undefined &&
          value.totalTime !== undefined &&
          value.selfTime !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatUserIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatUserIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupRead !== undefined &&
          value.idxTupFetch !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatUserTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatUserTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.lastSeqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.lastIdxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined &&
          value.nLiveTup !== undefined &&
          value.nDeadTup !== undefined &&
          value.nModSinceAnalyze !== undefined &&
          value.nInsSinceVacuum !== undefined &&
          value.lastVacuum !== undefined &&
          value.lastAutovacuum !== undefined &&
          value.lastAnalyze !== undefined &&
          value.lastAutoanalyze !== undefined &&
          value.vacuumCount !== undefined &&
          value.autovacuumCount !== undefined &&
          value.analyzeCount !== undefined &&
          value.autoanalyzeCount !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatWal {
      export function is(value: any): value is PgCatalog.Types.PgStatWal {
        if (
          value.walRecords !== undefined &&
          value.walFpi !== undefined &&
          value.walBytes !== undefined &&
          value.walBuffersFull !== undefined &&
          value.walWrite !== undefined &&
          value.walSync !== undefined &&
          value.walWriteTime !== undefined &&
          value.walSyncTime !== undefined &&
          value.statsReset !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatWalReceiver {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatWalReceiver {
        if (
          value.pid !== undefined &&
          value.status !== undefined &&
          value.receiveStartLsn !== undefined &&
          value.receiveStartTli !== undefined &&
          value.writtenLsn !== undefined &&
          value.flushedLsn !== undefined &&
          value.receivedTli !== undefined &&
          value.lastMsgSendTime !== undefined &&
          value.lastMsgReceiptTime !== undefined &&
          value.latestEndLsn !== undefined &&
          value.latestEndTime !== undefined &&
          value.slotName !== undefined &&
          value.senderHost !== undefined &&
          value.senderPort !== undefined &&
          value.conninfo !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatXactAllTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatXactAllTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatXactSysTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatXactSysTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatXactUserFunctions {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatXactUserFunctions {
        if (
          value.funcid !== undefined &&
          value.schemaname !== undefined &&
          value.funcname !== undefined &&
          value.calls !== undefined &&
          value.totalTime !== undefined &&
          value.selfTime !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatXactUserTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatXactUserTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.seqScan !== undefined &&
          value.seqTupRead !== undefined &&
          value.idxScan !== undefined &&
          value.idxTupFetch !== undefined &&
          value.nTupIns !== undefined &&
          value.nTupUpd !== undefined &&
          value.nTupDel !== undefined &&
          value.nTupHotUpd !== undefined &&
          value.nTupNewpageUpd !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioAllIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioAllIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioAllSequences {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioAllSequences {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.blksRead !== undefined &&
          value.blksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioAllTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioAllTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.heapBlksRead !== undefined &&
          value.heapBlksHit !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined &&
          value.toastBlksRead !== undefined &&
          value.toastBlksHit !== undefined &&
          value.tidxBlksRead !== undefined &&
          value.tidxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioSysIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioSysIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioSysSequences {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioSysSequences {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.blksRead !== undefined &&
          value.blksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioSysTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioSysTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.heapBlksRead !== undefined &&
          value.heapBlksHit !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined &&
          value.toastBlksRead !== undefined &&
          value.toastBlksHit !== undefined &&
          value.tidxBlksRead !== undefined &&
          value.tidxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioUserIndexes {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioUserIndexes {
        if (
          value.relid !== undefined &&
          value.indexrelid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.indexrelname !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioUserSequences {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioUserSequences {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.blksRead !== undefined &&
          value.blksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatioUserTables {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatioUserTables {
        if (
          value.relid !== undefined &&
          value.schemaname !== undefined &&
          value.relname !== undefined &&
          value.heapBlksRead !== undefined &&
          value.heapBlksHit !== undefined &&
          value.idxBlksRead !== undefined &&
          value.idxBlksHit !== undefined &&
          value.toastBlksRead !== undefined &&
          value.toastBlksHit !== undefined &&
          value.tidxBlksRead !== undefined &&
          value.tidxBlksHit !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatistic {
      export function is(value: any): value is PgCatalog.Types.PgStatistic {
        if (
          value.starelid !== undefined &&
          value.staattnum !== undefined &&
          value.stainherit !== undefined &&
          value.stanullfrac !== undefined &&
          value.stawidth !== undefined &&
          value.stadistinct !== undefined &&
          value.stakind1 !== undefined &&
          value.stakind2 !== undefined &&
          value.stakind3 !== undefined &&
          value.stakind4 !== undefined &&
          value.stakind5 !== undefined &&
          value.staop1 !== undefined &&
          value.staop2 !== undefined &&
          value.staop3 !== undefined &&
          value.staop4 !== undefined &&
          value.staop5 !== undefined &&
          value.stacoll1 !== undefined &&
          value.stacoll2 !== undefined &&
          value.stacoll3 !== undefined &&
          value.stacoll4 !== undefined &&
          value.stacoll5 !== undefined &&
          value.stanumbers1 !== undefined &&
          value.stanumbers2 !== undefined &&
          value.stanumbers3 !== undefined &&
          value.stanumbers4 !== undefined &&
          value.stanumbers5 !== undefined &&
          value.stavalues1 !== undefined &&
          value.stavalues2 !== undefined &&
          value.stavalues3 !== undefined &&
          value.stavalues4 !== undefined &&
          value.stavalues5 !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatisticExt {
      export function is(value: any): value is PgCatalog.Types.PgStatisticExt {
        if (
          value.oid !== undefined &&
          value.stxrelid !== undefined &&
          value.stxname !== undefined &&
          value.stxnamespace !== undefined &&
          value.stxowner !== undefined &&
          value.stxstattarget !== undefined &&
          value.stxkeys !== undefined &&
          value.stxkind !== undefined &&
          value.stxexprs !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatisticExtData {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgStatisticExtData {
        if (
          value.stxoid !== undefined &&
          value.stxdinherit !== undefined &&
          value.stxdndistinct !== undefined &&
          value.stxddependencies !== undefined &&
          value.stxdmcv !== undefined &&
          value.stxdexpr !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStats {
      export function is(value: any): value is PgCatalog.Types.PgStats {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.attname !== undefined &&
          value.inherited !== undefined &&
          value.nullFrac !== undefined &&
          value.avgWidth !== undefined &&
          value.nDistinct !== undefined &&
          value.mostCommonVals !== undefined &&
          value.mostCommonFreqs !== undefined &&
          value.histogramBounds !== undefined &&
          value.correlation !== undefined &&
          value.mostCommonElems !== undefined &&
          value.mostCommonElemFreqs !== undefined &&
          value.elemCountHistogram !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatsExt {
      export function is(value: any): value is PgCatalog.Types.PgStatsExt {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.statisticsSchemaname !== undefined &&
          value.statisticsName !== undefined &&
          value.statisticsOwner !== undefined &&
          value.attnames !== undefined &&
          value.exprs !== undefined &&
          value.kinds !== undefined &&
          value.inherited !== undefined &&
          value.nDistinct !== undefined &&
          value.dependencies !== undefined &&
          value.mostCommonVals !== undefined &&
          value.mostCommonValNulls !== undefined &&
          value.mostCommonFreqs !== undefined &&
          value.mostCommonBaseFreqs !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgStatsExtExprs {
      export function is(value: any): value is PgCatalog.Types.PgStatsExtExprs {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.statisticsSchemaname !== undefined &&
          value.statisticsName !== undefined &&
          value.statisticsOwner !== undefined &&
          value.expr !== undefined &&
          value.inherited !== undefined &&
          value.nullFrac !== undefined &&
          value.avgWidth !== undefined &&
          value.nDistinct !== undefined &&
          value.mostCommonVals !== undefined &&
          value.mostCommonFreqs !== undefined &&
          value.histogramBounds !== undefined &&
          value.correlation !== undefined &&
          value.mostCommonElems !== undefined &&
          value.mostCommonElemFreqs !== undefined &&
          value.elemCountHistogram !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSubscription {
      export function is(value: any): value is PgCatalog.Types.PgSubscription {
        if (
          value.oid !== undefined &&
          value.subdbid !== undefined &&
          value.subskiplsn !== undefined &&
          value.subname !== undefined &&
          value.subowner !== undefined &&
          value.subenabled !== undefined &&
          value.subbinary !== undefined &&
          value.substream !== undefined &&
          value.subtwophasestate !== undefined &&
          value.subdisableonerr !== undefined &&
          value.subpasswordrequired !== undefined &&
          value.subrunasowner !== undefined &&
          value.subconninfo !== undefined &&
          value.subslotname !== undefined &&
          value.subsynccommit !== undefined &&
          value.subpublications !== undefined &&
          value.suborigin !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgSubscriptionRel {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgSubscriptionRel {
        if (
          value.srsubid !== undefined &&
          value.srrelid !== undefined &&
          value.srsubstate !== undefined &&
          value.srsublsn !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTables {
      export function is(value: any): value is PgCatalog.Types.PgTables {
        if (
          value.schemaname !== undefined &&
          value.tablename !== undefined &&
          value.tableowner !== undefined &&
          value.tablespace !== undefined &&
          value.hasindexes !== undefined &&
          value.hasrules !== undefined &&
          value.hastriggers !== undefined &&
          value.rowsecurity !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTablespace {
      export function is(value: any): value is PgCatalog.Types.PgTablespace {
        if (
          value.oid !== undefined &&
          value.spcname !== undefined &&
          value.spcowner !== undefined &&
          value.spcacl !== undefined &&
          value.spcoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTimezoneAbbrevs {
      export function is(
        value: any,
      ): value is PgCatalog.Types.PgTimezoneAbbrevs {
        if (
          value.abbrev !== undefined &&
          value.utcOffset !== undefined &&
          value.isDst !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTimezoneNames {
      export function is(value: any): value is PgCatalog.Types.PgTimezoneNames {
        if (
          value.name !== undefined &&
          value.abbrev !== undefined &&
          value.utcOffset !== undefined &&
          value.isDst !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTransform {
      export function is(value: any): value is PgCatalog.Types.PgTransform {
        if (
          value.oid !== undefined &&
          value.trftype !== undefined &&
          value.trflang !== undefined &&
          value.trffromsql !== undefined &&
          value.trftosql !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTrigger {
      export function is(value: any): value is PgCatalog.Types.PgTrigger {
        if (
          value.oid !== undefined &&
          value.tgrelid !== undefined &&
          value.tgparentid !== undefined &&
          value.tgname !== undefined &&
          value.tgfoid !== undefined &&
          value.tgtype !== undefined &&
          value.tgenabled !== undefined &&
          value.tgisinternal !== undefined &&
          value.tgconstrrelid !== undefined &&
          value.tgconstrindid !== undefined &&
          value.tgconstraint !== undefined &&
          value.tgdeferrable !== undefined &&
          value.tginitdeferred !== undefined &&
          value.tgnargs !== undefined &&
          value.tgattr !== undefined &&
          value.tgargs !== undefined &&
          value.tgqual !== undefined &&
          value.tgoldtable !== undefined &&
          value.tgnewtable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTsConfig {
      export function is(value: any): value is PgCatalog.Types.PgTsConfig {
        if (
          value.oid !== undefined &&
          value.cfgname !== undefined &&
          value.cfgnamespace !== undefined &&
          value.cfgowner !== undefined &&
          value.cfgparser !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTsConfigMap {
      export function is(value: any): value is PgCatalog.Types.PgTsConfigMap {
        if (
          value.mapcfg !== undefined &&
          value.maptokentype !== undefined &&
          value.mapseqno !== undefined &&
          value.mapdict !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTsDict {
      export function is(value: any): value is PgCatalog.Types.PgTsDict {
        if (
          value.oid !== undefined &&
          value.dictname !== undefined &&
          value.dictnamespace !== undefined &&
          value.dictowner !== undefined &&
          value.dicttemplate !== undefined &&
          value.dictinitoption !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTsParser {
      export function is(value: any): value is PgCatalog.Types.PgTsParser {
        if (
          value.oid !== undefined &&
          value.prsname !== undefined &&
          value.prsnamespace !== undefined &&
          value.prsstart !== undefined &&
          value.prstoken !== undefined &&
          value.prsend !== undefined &&
          value.prsheadline !== undefined &&
          value.prslextype !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgTsTemplate {
      export function is(value: any): value is PgCatalog.Types.PgTsTemplate {
        if (
          value.oid !== undefined &&
          value.tmplname !== undefined &&
          value.tmplnamespace !== undefined &&
          value.tmplinit !== undefined &&
          value.tmpllexize !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgType {
      export function is(value: any): value is PgCatalog.Types.PgType {
        if (
          value.oid !== undefined &&
          value.typname !== undefined &&
          value.typnamespace !== undefined &&
          value.typowner !== undefined &&
          value.typlen !== undefined &&
          value.typbyval !== undefined &&
          value.typtype !== undefined &&
          value.typcategory !== undefined &&
          value.typispreferred !== undefined &&
          value.typisdefined !== undefined &&
          value.typdelim !== undefined &&
          value.typrelid !== undefined &&
          value.typsubscript !== undefined &&
          value.typelem !== undefined &&
          value.typarray !== undefined &&
          value.typinput !== undefined &&
          value.typoutput !== undefined &&
          value.typreceive !== undefined &&
          value.typsend !== undefined &&
          value.typmodin !== undefined &&
          value.typmodout !== undefined &&
          value.typanalyze !== undefined &&
          value.typalign !== undefined &&
          value.typstorage !== undefined &&
          value.typnotnull !== undefined &&
          value.typbasetype !== undefined &&
          value.typtypmod !== undefined &&
          value.typndims !== undefined &&
          value.typcollation !== undefined &&
          value.typdefaultbin !== undefined &&
          value.typdefault !== undefined &&
          value.typacl !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgUser {
      export function is(value: any): value is PgCatalog.Types.PgUser {
        if (
          value.usename !== undefined &&
          value.usesysid !== undefined &&
          value.usecreatedb !== undefined &&
          value.usesuper !== undefined &&
          value.userepl !== undefined &&
          value.usebypassrls !== undefined &&
          value.passwd !== undefined &&
          value.valuntil !== undefined &&
          value.useconfig !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgUserMapping {
      export function is(value: any): value is PgCatalog.Types.PgUserMapping {
        if (
          value.oid !== undefined &&
          value.umuser !== undefined &&
          value.umserver !== undefined &&
          value.umoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgUserMappings {
      export function is(value: any): value is PgCatalog.Types.PgUserMappings {
        if (
          value.umid !== undefined &&
          value.srvid !== undefined &&
          value.srvname !== undefined &&
          value.umuser !== undefined &&
          value.usename !== undefined &&
          value.umoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgViews {
      export function is(value: any): value is PgCatalog.Types.PgViews {
        if (
          value.schemaname !== undefined &&
          value.viewname !== undefined &&
          value.viewowner !== undefined &&
          value.definition !== undefined
        )
          return true;
        return false;
      }
    }
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace PgStatistic {}
    export namespace PgType {}
    export namespace PgForeignTable {}
    export namespace PgAuthid {}
    export namespace PgStatisticExtData {}
    export namespace PgUserMapping {}
    export namespace PgSubscription {}
    export namespace PgAttribute {}
    export namespace PgProc {}
    export namespace PgClass {}
    export namespace PgAttrdef {}
    export namespace PgConstraint {}
    export namespace PgInherits {}
    export namespace PgIndex {}
    export namespace PgOperator {}
    export namespace PgOpfamily {}
    export namespace PgOpclass {}
    export namespace PgAm {}
    export namespace PgAmop {}
    export namespace PgAmproc {}
    export namespace PgLanguage {}
    export namespace PgLargeobjectMetadata {}
    export namespace PgAggregate {}
    export namespace PgStatisticExt {}
    export namespace PgRewrite {}
    export namespace PgTrigger {}
    export namespace PgEventTrigger {}
    export namespace PgDescription {}
    export namespace PgCast {}
    export namespace PgEnum {}
    export namespace PgNamespace {}
    export namespace PgConversion {}
    export namespace PgDepend {}
    export namespace PgDatabase {}
    export namespace PgDbRoleSetting {}
    export namespace PgTablespace {}
    export namespace PgAuthMembers {}
    export namespace PgShdepend {}
    export namespace PgShdescription {}
    export namespace PgTsConfig {}
    export namespace PgTsConfigMap {}
    export namespace PgTsDict {}
    export namespace PgTsParser {}
    export namespace PgTsTemplate {}
    export namespace PgExtension {}
    export namespace PgForeignDataWrapper {}
    export namespace PgForeignServer {}
    export namespace PgPolicy {}
    export namespace PgReplicationOrigin {}
    export namespace PgDefaultAcl {}
    export namespace PgInitPrivs {}
    export namespace PgSeclabel {}
    export namespace PgShseclabel {}
    export namespace PgCollation {}
    export namespace PgParameterAcl {}
    export namespace PgPartitionedTable {}
    export namespace PgRange {}
    export namespace PgTransform {}
    export namespace PgSequence {}
    export namespace PgPublication {}
    export namespace PgPublicationNamespace {}
    export namespace PgPublicationRel {}
    export namespace PgSubscriptionRel {}
    export namespace PgLargeobject {}
  }
}
export namespace Public {
  export namespace Types {
    export namespace Actor {
      export function is(value: any): value is Public.Types.Actor {
        if (
          value.actorId !== undefined &&
          value.firstName !== undefined &&
          value.lastName !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ActorInfo {
      export function is(value: any): value is Public.Types.ActorInfo {
        if (
          value.actorId !== undefined &&
          value.firstName !== undefined &&
          value.lastName !== undefined &&
          value.filmInfo !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Address {
      export function is(value: any): value is Public.Types.Address {
        if (
          value.addressId !== undefined &&
          value.address !== undefined &&
          value.address2 !== undefined &&
          value.district !== undefined &&
          value.cityId !== undefined &&
          value.postalCode !== undefined &&
          value.phone !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Category {
      export function is(value: any): value is Public.Types.Category {
        if (
          value.categoryId !== undefined &&
          value.name !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace City {
      export function is(value: any): value is Public.Types.City {
        if (
          value.cityId !== undefined &&
          value.city !== undefined &&
          value.countryId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Country {
      export function is(value: any): value is Public.Types.Country {
        if (
          value.countryId !== undefined &&
          value.country !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Customer {
      export function is(value: any): value is Public.Types.Customer {
        if (
          value.customerId !== undefined &&
          value.storeId !== undefined &&
          value.firstName !== undefined &&
          value.lastName !== undefined &&
          value.email !== undefined &&
          value.addressId !== undefined &&
          value.activebool !== undefined &&
          value.createDate !== undefined &&
          value.lastUpdate !== undefined &&
          value.active !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace CustomerList {
      export function is(value: any): value is Public.Types.CustomerList {
        if (
          value.id !== undefined &&
          value.name !== undefined &&
          value.address !== undefined &&
          value.zipCode !== undefined &&
          value.phone !== undefined &&
          value.city !== undefined &&
          value.country !== undefined &&
          value.notes !== undefined &&
          value.sid !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Film {
      export function is(value: any): value is Public.Types.Film {
        if (
          value.filmId !== undefined &&
          value.title !== undefined &&
          value.description !== undefined &&
          value.releaseYear !== undefined &&
          value.languageId !== undefined &&
          value.rentalDuration !== undefined &&
          value.rentalRate !== undefined &&
          value.length !== undefined &&
          value.replacementCost !== undefined &&
          value.rating !== undefined &&
          value.lastUpdate !== undefined &&
          value.specialFeatures !== undefined &&
          value.fulltext !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace FilmActor {
      export function is(value: any): value is Public.Types.FilmActor {
        if (
          value.actorId !== undefined &&
          value.filmId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace FilmCategory {
      export function is(value: any): value is Public.Types.FilmCategory {
        if (
          value.filmId !== undefined &&
          value.categoryId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace FilmList {
      export function is(value: any): value is Public.Types.FilmList {
        if (
          value.fid !== undefined &&
          value.title !== undefined &&
          value.description !== undefined &&
          value.category !== undefined &&
          value.price !== undefined &&
          value.length !== undefined &&
          value.rating !== undefined &&
          value.actors !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Inventory {
      export function is(value: any): value is Public.Types.Inventory {
        if (
          value.inventoryId !== undefined &&
          value.filmId !== undefined &&
          value.storeId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Language {
      export function is(value: any): value is Public.Types.Language {
        if (
          value.languageId !== undefined &&
          value.name !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace NicerButSlowerFilmList {
      export function is(
        value: any,
      ): value is Public.Types.NicerButSlowerFilmList {
        if (
          value.fid !== undefined &&
          value.title !== undefined &&
          value.description !== undefined &&
          value.category !== undefined &&
          value.price !== undefined &&
          value.length !== undefined &&
          value.rating !== undefined &&
          value.actors !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Payment {
      export function is(value: any): value is Public.Types.Payment {
        if (
          value.paymentId !== undefined &&
          value.customerId !== undefined &&
          value.staffId !== undefined &&
          value.rentalId !== undefined &&
          value.amount !== undefined &&
          value.paymentDate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Rental {
      export function is(value: any): value is Public.Types.Rental {
        if (
          value.rentalId !== undefined &&
          value.rentalDate !== undefined &&
          value.inventoryId !== undefined &&
          value.customerId !== undefined &&
          value.returnDate !== undefined &&
          value.staffId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace SalesByFilmCategory {
      export function is(
        value: any,
      ): value is Public.Types.SalesByFilmCategory {
        if (value.category !== undefined && value.totalSales !== undefined)
          return true;
        return false;
      }
    }
    export namespace SalesByStore {
      export function is(value: any): value is Public.Types.SalesByStore {
        if (
          value.store !== undefined &&
          value.manager !== undefined &&
          value.totalSales !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Staff {
      export function is(value: any): value is Public.Types.Staff {
        if (
          value.staffId !== undefined &&
          value.firstName !== undefined &&
          value.lastName !== undefined &&
          value.addressId !== undefined &&
          value.email !== undefined &&
          value.storeId !== undefined &&
          value.active !== undefined &&
          value.username !== undefined &&
          value.password !== undefined &&
          value.lastUpdate !== undefined &&
          value.picture !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace StaffList {
      export function is(value: any): value is Public.Types.StaffList {
        if (
          value.id !== undefined &&
          value.name !== undefined &&
          value.address !== undefined &&
          value.zipCode !== undefined &&
          value.phone !== undefined &&
          value.city !== undefined &&
          value.country !== undefined &&
          value.sid !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Store {
      export function is(value: any): value is Public.Types.Store {
        if (
          value.storeId !== undefined &&
          value.managerStaffId !== undefined &&
          value.addressId !== undefined &&
          value.lastUpdate !== undefined
        )
          return true;
        return false;
      }
    }
  }
  export namespace Procedures {
    export namespace FilmInStock {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.FilmInStock.Parameters {
          if (value.pFilmId !== undefined && value.pStoreId !== undefined)
            return true;
          return false;
        }
      }
    }
    export namespace FilmNotInStock {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.FilmNotInStock.Parameters {
          if (value.pFilmId !== undefined && value.pStoreId !== undefined)
            return true;
          return false;
        }
      }
    }
    export namespace GetCustomerBalance {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.GetCustomerBalance.Parameters {
          if (
            value.pCustomerId !== undefined &&
            value.pEffectiveDate !== undefined
          )
            return true;
          return false;
        }
      }
    }
    export namespace InventoryHeldByCustomer {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.InventoryHeldByCustomer.Parameters {
          if (value.pInventoryId !== undefined) return true;
          return false;
        }
      }
    }
    export namespace InventoryInStock {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.InventoryInStock.Parameters {
          if (value.pInventoryId !== undefined) return true;
          return false;
        }
      }
    }
    export namespace LastDay {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.LastDay.Parameters {
          if (value.argument_0 !== undefined) return true;
          return false;
        }
      }
    }
    export namespace RewardsReport {
      export namespace Parameters {
        export function is(
          value: any,
        ): value is Public.Procedures.RewardsReport.Parameters {
          if (
            value.minMonthlyPurchases !== undefined &&
            value.minDollarAmountPurchased !== undefined
          )
            return true;
          return false;
        }
      }
    }
  }
  export namespace Tables {
    export namespace FilmActor {}
    export namespace Address {}
    export namespace City {}
    export namespace Customer {}
    export namespace Actor {}
    export namespace FilmCategory {}
    export namespace Inventory {}
    export namespace Category {}
    export namespace Country {}
    export namespace Language {}
    export namespace Rental {}
    export namespace Staff {}
    export namespace Store {}
    export namespace Payment {}
    export namespace Film {}
  }
}
export namespace InformationSchema {
  export namespace Types {
    export namespace PgForeignDataWrappers {
      export function is(
        value: any,
      ): value is InformationSchema.Types.PgForeignDataWrappers {
        if (
          value.oid !== undefined &&
          value.fdwowner !== undefined &&
          value.fdwoptions !== undefined &&
          value.foreignDataWrapperCatalog !== undefined &&
          value.foreignDataWrapperName !== undefined &&
          value.authorizationIdentifier !== undefined &&
          value.foreignDataWrapperLanguage !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignServers {
      export function is(
        value: any,
      ): value is InformationSchema.Types.PgForeignServers {
        if (
          value.oid !== undefined &&
          value.srvoptions !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.foreignDataWrapperCatalog !== undefined &&
          value.foreignDataWrapperName !== undefined &&
          value.foreignServerType !== undefined &&
          value.foreignServerVersion !== undefined &&
          value.authorizationIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignTableColumns {
      export function is(
        value: any,
      ): value is InformationSchema.Types.PgForeignTableColumns {
        if (
          value.nspname !== undefined &&
          value.relname !== undefined &&
          value.attname !== undefined &&
          value.attfdwoptions !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgForeignTables {
      export function is(
        value: any,
      ): value is InformationSchema.Types.PgForeignTables {
        if (
          value.foreignTableCatalog !== undefined &&
          value.foreignTableSchema !== undefined &&
          value.foreignTableName !== undefined &&
          value.ftoptions !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.authorizationIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace PgUserMappings {
      export function is(
        value: any,
      ): value is InformationSchema.Types.PgUserMappings {
        if (
          value.oid !== undefined &&
          value.umoptions !== undefined &&
          value.umuser !== undefined &&
          value.authorizationIdentifier !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.srvowner !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace AdministrableRoleAuthorizations {
      export function is(
        value: any,
      ): value is InformationSchema.Types.AdministrableRoleAuthorizations {
        if (
          value.grantee !== undefined &&
          value.roleName !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ApplicableRoles {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ApplicableRoles {
        if (
          value.grantee !== undefined &&
          value.roleName !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Attributes {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Attributes {
        if (
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.attributeName !== undefined &&
          value.ordinalPosition !== undefined &&
          value.attributeDefault !== undefined &&
          value.isNullable !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.attributeUdtCatalog !== undefined &&
          value.attributeUdtSchema !== undefined &&
          value.attributeUdtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined &&
          value.isDerivedReferenceAttribute !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace CharacterSets {
      export function is(
        value: any,
      ): value is InformationSchema.Types.CharacterSets {
        if (
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.characterRepertoire !== undefined &&
          value.formOfUse !== undefined &&
          value.defaultCollateCatalog !== undefined &&
          value.defaultCollateSchema !== undefined &&
          value.defaultCollateName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace CheckConstraintRoutineUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.CheckConstraintRoutineUsage {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace CheckConstraints {
      export function is(
        value: any,
      ): value is InformationSchema.Types.CheckConstraints {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.checkClause !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace CollationCharacterSetApplicability {
      export function is(
        value: any,
      ): value is InformationSchema.Types.CollationCharacterSetApplicability {
        if (
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Collations {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Collations {
        if (
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.padAttribute !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ColumnColumnUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ColumnColumnUsage {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.dependentColumn !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ColumnDomainUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ColumnDomainUsage {
        if (
          value.domainCatalog !== undefined &&
          value.domainSchema !== undefined &&
          value.domainName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ColumnOptions {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ColumnOptions {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.optionName !== undefined &&
          value.optionValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ColumnPrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ColumnPrivileges {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ColumnUdtUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ColumnUdtUsage {
        if (
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Columns {
      export function is(value: any): value is InformationSchema.Types.Columns {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.ordinalPosition !== undefined &&
          value.columnDefault !== undefined &&
          value.isNullable !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.domainCatalog !== undefined &&
          value.domainSchema !== undefined &&
          value.domainName !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined &&
          value.isSelfReferencing !== undefined &&
          value.isIdentity !== undefined &&
          value.identityGeneration !== undefined &&
          value.identityStart !== undefined &&
          value.identityIncrement !== undefined &&
          value.identityMaximum !== undefined &&
          value.identityMinimum !== undefined &&
          value.identityCycle !== undefined &&
          value.isGenerated !== undefined &&
          value.generationExpression !== undefined &&
          value.isUpdatable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ConstraintColumnUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ConstraintColumnUsage {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ConstraintTableUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ConstraintTableUsage {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace DataTypePrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.DataTypePrivileges {
        if (
          value.objectCatalog !== undefined &&
          value.objectSchema !== undefined &&
          value.objectName !== undefined &&
          value.objectType !== undefined &&
          value.dtdIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace DomainConstraints {
      export function is(
        value: any,
      ): value is InformationSchema.Types.DomainConstraints {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.domainCatalog !== undefined &&
          value.domainSchema !== undefined &&
          value.domainName !== undefined &&
          value.isDeferrable !== undefined &&
          value.initiallyDeferred !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace DomainUdtUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.DomainUdtUsage {
        if (
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.domainCatalog !== undefined &&
          value.domainSchema !== undefined &&
          value.domainName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Domains {
      export function is(value: any): value is InformationSchema.Types.Domains {
        if (
          value.domainCatalog !== undefined &&
          value.domainSchema !== undefined &&
          value.domainName !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.domainDefault !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ElementTypes {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ElementTypes {
        if (
          value.objectCatalog !== undefined &&
          value.objectSchema !== undefined &&
          value.objectName !== undefined &&
          value.objectType !== undefined &&
          value.collectionTypeIdentifier !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.domainDefault !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace EnabledRoles {
      export function is(
        value: any,
      ): value is InformationSchema.Types.EnabledRoles {
        if (value.roleName !== undefined) return true;
        return false;
      }
    }
    export namespace ForeignDataWrapperOptions {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignDataWrapperOptions {
        if (
          value.foreignDataWrapperCatalog !== undefined &&
          value.foreignDataWrapperName !== undefined &&
          value.optionName !== undefined &&
          value.optionValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ForeignDataWrappers {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignDataWrappers {
        if (
          value.foreignDataWrapperCatalog !== undefined &&
          value.foreignDataWrapperName !== undefined &&
          value.authorizationIdentifier !== undefined &&
          value.libraryName !== undefined &&
          value.foreignDataWrapperLanguage !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ForeignServerOptions {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignServerOptions {
        if (
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.optionName !== undefined &&
          value.optionValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ForeignServers {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignServers {
        if (
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.foreignDataWrapperCatalog !== undefined &&
          value.foreignDataWrapperName !== undefined &&
          value.foreignServerType !== undefined &&
          value.foreignServerVersion !== undefined &&
          value.authorizationIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ForeignTableOptions {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignTableOptions {
        if (
          value.foreignTableCatalog !== undefined &&
          value.foreignTableSchema !== undefined &&
          value.foreignTableName !== undefined &&
          value.optionName !== undefined &&
          value.optionValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ForeignTables {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ForeignTables {
        if (
          value.foreignTableCatalog !== undefined &&
          value.foreignTableSchema !== undefined &&
          value.foreignTableName !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace InformationSchemaCatalogName {
      export function is(
        value: any,
      ): value is InformationSchema.Types.InformationSchemaCatalogName {
        if (value.catalogName !== undefined) return true;
        return false;
      }
    }
    export namespace KeyColumnUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.KeyColumnUsage {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.ordinalPosition !== undefined &&
          value.positionInUniqueConstraint !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Parameters {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Parameters {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.ordinalPosition !== undefined &&
          value.parameterMode !== undefined &&
          value.isResult !== undefined &&
          value.asLocator !== undefined &&
          value.parameterName !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined &&
          value.parameterDefault !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ReferentialConstraints {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ReferentialConstraints {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.uniqueConstraintCatalog !== undefined &&
          value.uniqueConstraintSchema !== undefined &&
          value.uniqueConstraintName !== undefined &&
          value.matchOption !== undefined &&
          value.updateRule !== undefined &&
          value.deleteRule !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoleColumnGrants {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoleColumnGrants {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoleRoutineGrants {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoleRoutineGrants {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoleTableGrants {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoleTableGrants {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined &&
          value.withHierarchy !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoleUdtGrants {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoleUdtGrants {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoleUsageGrants {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoleUsageGrants {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.objectCatalog !== undefined &&
          value.objectSchema !== undefined &&
          value.objectName !== undefined &&
          value.objectType !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoutineColumnUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoutineColumnUsage {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoutinePrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoutinePrivileges {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoutineRoutineUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoutineRoutineUsage {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoutineSequenceUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoutineSequenceUsage {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.sequenceCatalog !== undefined &&
          value.sequenceSchema !== undefined &&
          value.sequenceName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace RoutineTableUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.RoutineTableUsage {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Routines {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Routines {
        if (
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.routineCatalog !== undefined &&
          value.routineSchema !== undefined &&
          value.routineName !== undefined &&
          value.routineType !== undefined &&
          value.moduleCatalog !== undefined &&
          value.moduleSchema !== undefined &&
          value.moduleName !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.typeUdtCatalog !== undefined &&
          value.typeUdtSchema !== undefined &&
          value.typeUdtName !== undefined &&
          value.scopeCatalog !== undefined &&
          value.scopeSchema !== undefined &&
          value.scopeName !== undefined &&
          value.maximumCardinality !== undefined &&
          value.dtdIdentifier !== undefined &&
          value.routineBody !== undefined &&
          value.routineDefinition !== undefined &&
          value.externalName !== undefined &&
          value.externalLanguage !== undefined &&
          value.parameterStyle !== undefined &&
          value.isDeterministic !== undefined &&
          value.sqlDataAccess !== undefined &&
          value.isNullCall !== undefined &&
          value.sqlPath !== undefined &&
          value.schemaLevelRoutine !== undefined &&
          value.maxDynamicResultSets !== undefined &&
          value.isUserDefinedCast !== undefined &&
          value.isImplicitlyInvocable !== undefined &&
          value.securityType !== undefined &&
          value.toSqlSpecificCatalog !== undefined &&
          value.toSqlSpecificSchema !== undefined &&
          value.toSqlSpecificName !== undefined &&
          value.asLocator !== undefined &&
          value.created !== undefined &&
          value.lastAltered !== undefined &&
          value.newSavepointLevel !== undefined &&
          value.isUdtDependent !== undefined &&
          value.resultCastFromDataType !== undefined &&
          value.resultCastAsLocator !== undefined &&
          value.resultCastCharMaxLength !== undefined &&
          value.resultCastCharOctetLength !== undefined &&
          value.resultCastCharSetCatalog !== undefined &&
          value.resultCastCharSetSchema !== undefined &&
          value.resultCastCharSetName !== undefined &&
          value.resultCastCollationCatalog !== undefined &&
          value.resultCastCollationSchema !== undefined &&
          value.resultCastCollationName !== undefined &&
          value.resultCastNumericPrecision !== undefined &&
          value.resultCastNumericPrecisionRadix !== undefined &&
          value.resultCastNumericScale !== undefined &&
          value.resultCastDatetimePrecision !== undefined &&
          value.resultCastIntervalType !== undefined &&
          value.resultCastIntervalPrecision !== undefined &&
          value.resultCastTypeUdtCatalog !== undefined &&
          value.resultCastTypeUdtSchema !== undefined &&
          value.resultCastTypeUdtName !== undefined &&
          value.resultCastScopeCatalog !== undefined &&
          value.resultCastScopeSchema !== undefined &&
          value.resultCastScopeName !== undefined &&
          value.resultCastMaximumCardinality !== undefined &&
          value.resultCastDtdIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Schemata {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Schemata {
        if (
          value.catalogName !== undefined &&
          value.schemaName !== undefined &&
          value.schemaOwner !== undefined &&
          value.defaultCharacterSetCatalog !== undefined &&
          value.defaultCharacterSetSchema !== undefined &&
          value.defaultCharacterSetName !== undefined &&
          value.sqlPath !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Sequences {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Sequences {
        if (
          value.sequenceCatalog !== undefined &&
          value.sequenceSchema !== undefined &&
          value.sequenceName !== undefined &&
          value.dataType !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.startValue !== undefined &&
          value.minimumValue !== undefined &&
          value.maximumValue !== undefined &&
          value.increment !== undefined &&
          value.cycleOption !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace SqlFeatures {
      export function is(
        value: any,
      ): value is InformationSchema.Types.SqlFeatures {
        if (
          value.featureId !== undefined &&
          value.featureName !== undefined &&
          value.subFeatureId !== undefined &&
          value.subFeatureName !== undefined &&
          value.isSupported !== undefined &&
          value.isVerifiedBy !== undefined &&
          value.comments !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace SqlImplementationInfo {
      export function is(
        value: any,
      ): value is InformationSchema.Types.SqlImplementationInfo {
        if (
          value.implementationInfoId !== undefined &&
          value.implementationInfoName !== undefined &&
          value.integerValue !== undefined &&
          value.characterValue !== undefined &&
          value.comments !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace SqlParts {
      export function is(
        value: any,
      ): value is InformationSchema.Types.SqlParts {
        if (
          value.featureId !== undefined &&
          value.featureName !== undefined &&
          value.isSupported !== undefined &&
          value.isVerifiedBy !== undefined &&
          value.comments !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace SqlSizing {
      export function is(
        value: any,
      ): value is InformationSchema.Types.SqlSizing {
        if (
          value.sizingId !== undefined &&
          value.sizingName !== undefined &&
          value.supportedValue !== undefined &&
          value.comments !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace TableConstraints {
      export function is(
        value: any,
      ): value is InformationSchema.Types.TableConstraints {
        if (
          value.constraintCatalog !== undefined &&
          value.constraintSchema !== undefined &&
          value.constraintName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.constraintType !== undefined &&
          value.isDeferrable !== undefined &&
          value.initiallyDeferred !== undefined &&
          value.enforced !== undefined &&
          value.nullsDistinct !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace TablePrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.TablePrivileges {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined &&
          value.withHierarchy !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Tables {
      export function is(value: any): value is InformationSchema.Types.Tables {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.tableType !== undefined &&
          value.selfReferencingColumnName !== undefined &&
          value.referenceGeneration !== undefined &&
          value.userDefinedTypeCatalog !== undefined &&
          value.userDefinedTypeSchema !== undefined &&
          value.userDefinedTypeName !== undefined &&
          value.isInsertableInto !== undefined &&
          value.isTyped !== undefined &&
          value.commitAction !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Transforms {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Transforms {
        if (
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined &&
          value.groupName !== undefined &&
          value.transformType !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace TriggeredUpdateColumns {
      export function is(
        value: any,
      ): value is InformationSchema.Types.TriggeredUpdateColumns {
        if (
          value.triggerCatalog !== undefined &&
          value.triggerSchema !== undefined &&
          value.triggerName !== undefined &&
          value.eventObjectCatalog !== undefined &&
          value.eventObjectSchema !== undefined &&
          value.eventObjectTable !== undefined &&
          value.eventObjectColumn !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Triggers {
      export function is(
        value: any,
      ): value is InformationSchema.Types.Triggers {
        if (
          value.triggerCatalog !== undefined &&
          value.triggerSchema !== undefined &&
          value.triggerName !== undefined &&
          value.eventManipulation !== undefined &&
          value.eventObjectCatalog !== undefined &&
          value.eventObjectSchema !== undefined &&
          value.eventObjectTable !== undefined &&
          value.actionOrder !== undefined &&
          value.actionCondition !== undefined &&
          value.actionStatement !== undefined &&
          value.actionOrientation !== undefined &&
          value.actionTiming !== undefined &&
          value.actionReferenceOldTable !== undefined &&
          value.actionReferenceNewTable !== undefined &&
          value.actionReferenceOldRow !== undefined &&
          value.actionReferenceNewRow !== undefined &&
          value.created !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace UdtPrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.UdtPrivileges {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.udtCatalog !== undefined &&
          value.udtSchema !== undefined &&
          value.udtName !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace UsagePrivileges {
      export function is(
        value: any,
      ): value is InformationSchema.Types.UsagePrivileges {
        if (
          value.grantor !== undefined &&
          value.grantee !== undefined &&
          value.objectCatalog !== undefined &&
          value.objectSchema !== undefined &&
          value.objectName !== undefined &&
          value.objectType !== undefined &&
          value.privilegeType !== undefined &&
          value.isGrantable !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace UserDefinedTypes {
      export function is(
        value: any,
      ): value is InformationSchema.Types.UserDefinedTypes {
        if (
          value.userDefinedTypeCatalog !== undefined &&
          value.userDefinedTypeSchema !== undefined &&
          value.userDefinedTypeName !== undefined &&
          value.userDefinedTypeCategory !== undefined &&
          value.isInstantiable !== undefined &&
          value.isFinal !== undefined &&
          value.orderingForm !== undefined &&
          value.orderingCategory !== undefined &&
          value.orderingRoutineCatalog !== undefined &&
          value.orderingRoutineSchema !== undefined &&
          value.orderingRoutineName !== undefined &&
          value.referenceType !== undefined &&
          value.dataType !== undefined &&
          value.characterMaximumLength !== undefined &&
          value.characterOctetLength !== undefined &&
          value.characterSetCatalog !== undefined &&
          value.characterSetSchema !== undefined &&
          value.characterSetName !== undefined &&
          value.collationCatalog !== undefined &&
          value.collationSchema !== undefined &&
          value.collationName !== undefined &&
          value.numericPrecision !== undefined &&
          value.numericPrecisionRadix !== undefined &&
          value.numericScale !== undefined &&
          value.datetimePrecision !== undefined &&
          value.intervalType !== undefined &&
          value.intervalPrecision !== undefined &&
          value.sourceDtdIdentifier !== undefined &&
          value.refDtdIdentifier !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace UserMappingOptions {
      export function is(
        value: any,
      ): value is InformationSchema.Types.UserMappingOptions {
        if (
          value.authorizationIdentifier !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined &&
          value.optionName !== undefined &&
          value.optionValue !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace UserMappings {
      export function is(
        value: any,
      ): value is InformationSchema.Types.UserMappings {
        if (
          value.authorizationIdentifier !== undefined &&
          value.foreignServerCatalog !== undefined &&
          value.foreignServerName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ViewColumnUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ViewColumnUsage {
        if (
          value.viewCatalog !== undefined &&
          value.viewSchema !== undefined &&
          value.viewName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.columnName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ViewRoutineUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ViewRoutineUsage {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.specificCatalog !== undefined &&
          value.specificSchema !== undefined &&
          value.specificName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace ViewTableUsage {
      export function is(
        value: any,
      ): value is InformationSchema.Types.ViewTableUsage {
        if (
          value.viewCatalog !== undefined &&
          value.viewSchema !== undefined &&
          value.viewName !== undefined &&
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined
        )
          return true;
        return false;
      }
    }
    export namespace Views {
      export function is(value: any): value is InformationSchema.Types.Views {
        if (
          value.tableCatalog !== undefined &&
          value.tableSchema !== undefined &&
          value.tableName !== undefined &&
          value.viewDefinition !== undefined &&
          value.checkOption !== undefined &&
          value.isUpdatable !== undefined &&
          value.isInsertableInto !== undefined &&
          value.isTriggerUpdatable !== undefined &&
          value.isTriggerDeletable !== undefined &&
          value.isTriggerInsertableInto !== undefined
        )
          return true;
        return false;
      }
    }
  }
  export namespace Procedures {}
  export namespace Tables {
    export namespace SqlFeatures {}
    export namespace SqlImplementationInfo {}
    export namespace SqlParts {}
    export namespace SqlSizing {}
  }
}

// BEGIN - Node side database connectivity layer
import {
  Context,
  initializeContext,
  PostgresDatabase,
} from "@embracesql/postgres";
import postgres from "postgres";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ArgumentToPostgres = any;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type ArgumentFromPostgres = any;
type Typecast = (x: ArgumentToPostgres) => ArgumentFromPostgres;
export interface PostgresTypecasts {
  [1034]: Typecast;
  ["PgCatalog.Types.AclitemArray"]: Typecast;
  [1561]: Typecast;
  ["PgCatalog.Types.BitArray"]: Typecast;
  [1000]: Typecast;
  ["PgCatalog.Types.BoolArray"]: Typecast;
  [1020]: Typecast;
  ["PgCatalog.Types.BoxArray"]: Typecast;
  [1014]: Typecast;
  ["PgCatalog.Types.BpcharArray"]: Typecast;
  [1001]: Typecast;
  ["PgCatalog.Types.ByteaArray"]: Typecast;
  [1002]: Typecast;
  ["PgCatalog.Types.CharArray"]: Typecast;
  [1012]: Typecast;
  ["PgCatalog.Types.CidArray"]: Typecast;
  [651]: Typecast;
  ["PgCatalog.Types.CidrArray"]: Typecast;
  [719]: Typecast;
  ["PgCatalog.Types.CircleArray"]: Typecast;
  [1263]: Typecast;
  ["PgCatalog.Types.CstringArray"]: Typecast;
  [1182]: Typecast;
  ["PgCatalog.Types.DateArray"]: Typecast;
  [6155]: Typecast;
  ["PgCatalog.Types.DatemultirangeArray"]: Typecast;
  [3913]: Typecast;
  ["PgCatalog.Types.DaterangeArray"]: Typecast;
  [1021]: Typecast;
  ["PgCatalog.Types.Float4Array"]: Typecast;
  [1022]: Typecast;
  ["PgCatalog.Types.Float8Array"]: Typecast;
  [3644]: Typecast;
  ["PgCatalog.Types.GtsvectorArray"]: Typecast;
  [1041]: Typecast;
  ["PgCatalog.Types.InetArray"]: Typecast;
  [1005]: Typecast;
  ["PgCatalog.Types.Int2Array"]: Typecast;
  [1006]: Typecast;
  ["PgCatalog.Types.Int2vectorArray"]: Typecast;
  [1007]: Typecast;
  ["PgCatalog.Types.Int4Array"]: Typecast;
  [6150]: Typecast;
  ["PgCatalog.Types.Int4multirangeArray"]: Typecast;
  [3905]: Typecast;
  ["PgCatalog.Types.Int4rangeArray"]: Typecast;
  [1016]: Typecast;
  ["PgCatalog.Types.Int8Array"]: Typecast;
  [6157]: Typecast;
  ["PgCatalog.Types.Int8multirangeArray"]: Typecast;
  [3927]: Typecast;
  ["PgCatalog.Types.Int8rangeArray"]: Typecast;
  [1187]: Typecast;
  ["PgCatalog.Types.IntervalArray"]: Typecast;
  [199]: Typecast;
  ["PgCatalog.Types.JsonArray"]: Typecast;
  [3807]: Typecast;
  ["PgCatalog.Types.JsonbArray"]: Typecast;
  [4073]: Typecast;
  ["PgCatalog.Types.JsonpathArray"]: Typecast;
  [629]: Typecast;
  ["PgCatalog.Types.LineArray"]: Typecast;
  [1018]: Typecast;
  ["PgCatalog.Types.LsegArray"]: Typecast;
  [1040]: Typecast;
  ["PgCatalog.Types.MacaddrArray"]: Typecast;
  [775]: Typecast;
  ["PgCatalog.Types.Macaddr8Array"]: Typecast;
  [791]: Typecast;
  ["PgCatalog.Types.MoneyArray"]: Typecast;
  [1003]: Typecast;
  ["PgCatalog.Types.NameArray"]: Typecast;
  [1231]: Typecast;
  ["PgCatalog.Types.NumericArray"]: Typecast;
  [6151]: Typecast;
  ["PgCatalog.Types.NummultirangeArray"]: Typecast;
  [3907]: Typecast;
  ["PgCatalog.Types.NumrangeArray"]: Typecast;
  [1028]: Typecast;
  ["PgCatalog.Types.OidArray"]: Typecast;
  [1013]: Typecast;
  ["PgCatalog.Types.OidvectorArray"]: Typecast;
  [1019]: Typecast;
  ["PgCatalog.Types.PathArray"]: Typecast;
  [10026]: Typecast;
  ["PgCatalog.Types.PgAggregateArray"]: Typecast;
  [10014]: Typecast;
  ["PgCatalog.Types.PgAmArray"]: Typecast;
  [10016]: Typecast;
  ["PgCatalog.Types.PgAmopArray"]: Typecast;
  [10018]: Typecast;
  ["PgCatalog.Types.PgAmprocArray"]: Typecast;
  [10000]: Typecast;
  ["PgCatalog.Types.PgAttrdefArray"]: Typecast;
  [270]: Typecast;
  ["PgCatalog.Types.PgAttributeArray"]: Typecast;
  [10058]: Typecast;
  ["PgCatalog.Types.PgAuthMembersArray"]: Typecast;
  [10057]: Typecast;
  ["PgCatalog.Types.PgAuthidArray"]: Typecast;
  [12086]: Typecast;
  ["PgCatalog.Types.PgAvailableExtensionVersionsArray"]: Typecast;
  [12082]: Typecast;
  ["PgCatalog.Types.PgAvailableExtensionsArray"]: Typecast;
  [12139]: Typecast;
  ["PgCatalog.Types.PgBackendMemoryContextsArray"]: Typecast;
  [10042]: Typecast;
  ["PgCatalog.Types.PgCastArray"]: Typecast;
  [273]: Typecast;
  ["PgCatalog.Types.PgClassArray"]: Typecast;
  [10094]: Typecast;
  ["PgCatalog.Types.PgCollationArray"]: Typecast;
  [12131]: Typecast;
  ["PgCatalog.Types.PgConfigArray"]: Typecast;
  [10002]: Typecast;
  ["PgCatalog.Types.PgConstraintArray"]: Typecast;
  [10048]: Typecast;
  ["PgCatalog.Types.PgConversionArray"]: Typecast;
  [12078]: Typecast;
  ["PgCatalog.Types.PgCursorsArray"]: Typecast;
  [10052]: Typecast;
  ["PgCatalog.Types.PgDatabaseArray"]: Typecast;
  [10053]: Typecast;
  ["PgCatalog.Types.PgDbRoleSettingArray"]: Typecast;
  [10087]: Typecast;
  ["PgCatalog.Types.PgDefaultAclArray"]: Typecast;
  [10050]: Typecast;
  ["PgCatalog.Types.PgDependArray"]: Typecast;
  [10040]: Typecast;
  ["PgCatalog.Types.PgDescriptionArray"]: Typecast;
  [10044]: Typecast;
  ["PgCatalog.Types.PgEnumArray"]: Typecast;
  [10038]: Typecast;
  ["PgCatalog.Types.PgEventTriggerArray"]: Typecast;
  [10073]: Typecast;
  ["PgCatalog.Types.PgExtensionArray"]: Typecast;
  [12111]: Typecast;
  ["PgCatalog.Types.PgFileSettingsArray"]: Typecast;
  [10075]: Typecast;
  ["PgCatalog.Types.PgForeignDataWrapperArray"]: Typecast;
  [10077]: Typecast;
  ["PgCatalog.Types.PgForeignServerArray"]: Typecast;
  [10081]: Typecast;
  ["PgCatalog.Types.PgForeignTableArray"]: Typecast;
  [12011]: Typecast;
  ["PgCatalog.Types.PgGroupArray"]: Typecast;
  [12115]: Typecast;
  ["PgCatalog.Types.PgHbaFileRulesArray"]: Typecast;
  [12119]: Typecast;
  ["PgCatalog.Types.PgIdentFileMappingsArray"]: Typecast;
  [10006]: Typecast;
  ["PgCatalog.Types.PgIndexArray"]: Typecast;
  [12044]: Typecast;
  ["PgCatalog.Types.PgIndexesArray"]: Typecast;
  [10004]: Typecast;
  ["PgCatalog.Types.PgInheritsArray"]: Typecast;
  [10089]: Typecast;
  ["PgCatalog.Types.PgInitPrivsArray"]: Typecast;
  [10020]: Typecast;
  ["PgCatalog.Types.PgLanguageArray"]: Typecast;
  [10024]: Typecast;
  ["PgCatalog.Types.PgLargeobjectArray"]: Typecast;
  [10022]: Typecast;
  ["PgCatalog.Types.PgLargeobjectMetadataArray"]: Typecast;
  [12074]: Typecast;
  ["PgCatalog.Types.PgLocksArray"]: Typecast;
  [3221]: Typecast;
  ["PgCatalog.Types.PgLsnArray"]: Typecast;
  [12039]: Typecast;
  ["PgCatalog.Types.PgMatviewsArray"]: Typecast;
  [10046]: Typecast;
  ["PgCatalog.Types.PgNamespaceArray"]: Typecast;
  [10012]: Typecast;
  ["PgCatalog.Types.PgOpclassArray"]: Typecast;
  [10008]: Typecast;
  ["PgCatalog.Types.PgOperatorArray"]: Typecast;
  [10010]: Typecast;
  ["PgCatalog.Types.PgOpfamilyArray"]: Typecast;
  [10096]: Typecast;
  ["PgCatalog.Types.PgParameterAclArray"]: Typecast;
  [10098]: Typecast;
  ["PgCatalog.Types.PgPartitionedTableArray"]: Typecast;
  [12019]: Typecast;
  ["PgCatalog.Types.PgPoliciesArray"]: Typecast;
  [10083]: Typecast;
  ["PgCatalog.Types.PgPolicyArray"]: Typecast;
  [12096]: Typecast;
  ["PgCatalog.Types.PgPreparedStatementsArray"]: Typecast;
  [12091]: Typecast;
  ["PgCatalog.Types.PgPreparedXactsArray"]: Typecast;
  [272]: Typecast;
  ["PgCatalog.Types.PgProcArray"]: Typecast;
  [10106]: Typecast;
  ["PgCatalog.Types.PgPublicationArray"]: Typecast;
  [10108]: Typecast;
  ["PgCatalog.Types.PgPublicationNamespaceArray"]: Typecast;
  [10110]: Typecast;
  ["PgCatalog.Types.PgPublicationRelArray"]: Typecast;
  [12069]: Typecast;
  ["PgCatalog.Types.PgPublicationTablesArray"]: Typecast;
  [10100]: Typecast;
  ["PgCatalog.Types.PgRangeArray"]: Typecast;
  [10085]: Typecast;
  ["PgCatalog.Types.PgReplicationOriginArray"]: Typecast;
  [12337]: Typecast;
  ["PgCatalog.Types.PgReplicationOriginStatusArray"]: Typecast;
  [12258]: Typecast;
  ["PgCatalog.Types.PgReplicationSlotsArray"]: Typecast;
  [10034]: Typecast;
  ["PgCatalog.Types.PgRewriteArray"]: Typecast;
  [12001]: Typecast;
  ["PgCatalog.Types.PgRolesArray"]: Typecast;
  [12024]: Typecast;
  ["PgCatalog.Types.PgRulesArray"]: Typecast;
  [10091]: Typecast;
  ["PgCatalog.Types.PgSeclabelArray"]: Typecast;
  [12100]: Typecast;
  ["PgCatalog.Types.PgSeclabelsArray"]: Typecast;
  [10104]: Typecast;
  ["PgCatalog.Types.PgSequenceArray"]: Typecast;
  [12049]: Typecast;
  ["PgCatalog.Types.PgSequencesArray"]: Typecast;
  [12105]: Typecast;
  ["PgCatalog.Types.PgSettingsArray"]: Typecast;
  [12006]: Typecast;
  ["PgCatalog.Types.PgShadowArray"]: Typecast;
  [10059]: Typecast;
  ["PgCatalog.Types.PgShdependArray"]: Typecast;
  [10061]: Typecast;
  ["PgCatalog.Types.PgShdescriptionArray"]: Typecast;
  [12135]: Typecast;
  ["PgCatalog.Types.PgShmemAllocationsArray"]: Typecast;
  [10093]: Typecast;
  ["PgCatalog.Types.PgShseclabelArray"]: Typecast;
  [5039]: Typecast;
  ["PgCatalog.Types.PgSnapshotArray"]: Typecast;
  [12223]: Typecast;
  ["PgCatalog.Types.PgStatActivityArray"]: Typecast;
  [12184]: Typecast;
  ["PgCatalog.Types.PgStatAllIndexesArray"]: Typecast;
  [12143]: Typecast;
  ["PgCatalog.Types.PgStatAllTablesArray"]: Typecast;
  [12286]: Typecast;
  ["PgCatalog.Types.PgStatArchiverArray"]: Typecast;
  [12290]: Typecast;
  ["PgCatalog.Types.PgStatBgwriterArray"]: Typecast;
  [12267]: Typecast;
  ["PgCatalog.Types.PgStatDatabaseArray"]: Typecast;
  [12272]: Typecast;
  ["PgCatalog.Types.PgStatDatabaseConflictsArray"]: Typecast;
  [12254]: Typecast;
  ["PgCatalog.Types.PgStatGssapiArray"]: Typecast;
  [12294]: Typecast;
  ["PgCatalog.Types.PgStatIoArray"]: Typecast;
  [12302]: Typecast;
  ["PgCatalog.Types.PgStatProgressAnalyzeArray"]: Typecast;
  [12322]: Typecast;
  ["PgCatalog.Types.PgStatProgressBasebackupArray"]: Typecast;
  [12312]: Typecast;
  ["PgCatalog.Types.PgStatProgressClusterArray"]: Typecast;
  [12327]: Typecast;
  ["PgCatalog.Types.PgStatProgressCopyArray"]: Typecast;
  [12317]: Typecast;
  ["PgCatalog.Types.PgStatProgressCreateIndexArray"]: Typecast;
  [12307]: Typecast;
  ["PgCatalog.Types.PgStatProgressVacuumArray"]: Typecast;
  [12241]: Typecast;
  ["PgCatalog.Types.PgStatRecoveryPrefetchArray"]: Typecast;
  [12228]: Typecast;
  ["PgCatalog.Types.PgStatReplicationArray"]: Typecast;
  [12263]: Typecast;
  ["PgCatalog.Types.PgStatReplicationSlotsArray"]: Typecast;
  [12233]: Typecast;
  ["PgCatalog.Types.PgStatSlruArray"]: Typecast;
  [12250]: Typecast;
  ["PgCatalog.Types.PgStatSslArray"]: Typecast;
  [12245]: Typecast;
  ["PgCatalog.Types.PgStatSubscriptionArray"]: Typecast;
  [12341]: Typecast;
  ["PgCatalog.Types.PgStatSubscriptionStatsArray"]: Typecast;
  [12189]: Typecast;
  ["PgCatalog.Types.PgStatSysIndexesArray"]: Typecast;
  [12153]: Typecast;
  ["PgCatalog.Types.PgStatSysTablesArray"]: Typecast;
  [12276]: Typecast;
  ["PgCatalog.Types.PgStatUserFunctionsArray"]: Typecast;
  [12193]: Typecast;
  ["PgCatalog.Types.PgStatUserIndexesArray"]: Typecast;
  [12162]: Typecast;
  ["PgCatalog.Types.PgStatUserTablesArray"]: Typecast;
  [12298]: Typecast;
  ["PgCatalog.Types.PgStatWalArray"]: Typecast;
  [12237]: Typecast;
  ["PgCatalog.Types.PgStatWalReceiverArray"]: Typecast;
  [12148]: Typecast;
  ["PgCatalog.Types.PgStatXactAllTablesArray"]: Typecast;
  [12158]: Typecast;
  ["PgCatalog.Types.PgStatXactSysTablesArray"]: Typecast;
  [12281]: Typecast;
  ["PgCatalog.Types.PgStatXactUserFunctionsArray"]: Typecast;
  [12167]: Typecast;
  ["PgCatalog.Types.PgStatXactUserTablesArray"]: Typecast;
  [12197]: Typecast;
  ["PgCatalog.Types.PgStatioAllIndexesArray"]: Typecast;
  [12210]: Typecast;
  ["PgCatalog.Types.PgStatioAllSequencesArray"]: Typecast;
  [12171]: Typecast;
  ["PgCatalog.Types.PgStatioAllTablesArray"]: Typecast;
  [12202]: Typecast;
  ["PgCatalog.Types.PgStatioSysIndexesArray"]: Typecast;
  [12215]: Typecast;
  ["PgCatalog.Types.PgStatioSysSequencesArray"]: Typecast;
  [12176]: Typecast;
  ["PgCatalog.Types.PgStatioSysTablesArray"]: Typecast;
  [12206]: Typecast;
  ["PgCatalog.Types.PgStatioUserIndexesArray"]: Typecast;
  [12219]: Typecast;
  ["PgCatalog.Types.PgStatioUserSequencesArray"]: Typecast;
  [12180]: Typecast;
  ["PgCatalog.Types.PgStatioUserTablesArray"]: Typecast;
  [10028]: Typecast;
  ["PgCatalog.Types.PgStatisticArray"]: Typecast;
  [10030]: Typecast;
  ["PgCatalog.Types.PgStatisticExtArray"]: Typecast;
  [10032]: Typecast;
  ["PgCatalog.Types.PgStatisticExtDataArray"]: Typecast;
  [12054]: Typecast;
  ["PgCatalog.Types.PgStatsArray"]: Typecast;
  [12059]: Typecast;
  ["PgCatalog.Types.PgStatsExtArray"]: Typecast;
  [12064]: Typecast;
  ["PgCatalog.Types.PgStatsExtExprsArray"]: Typecast;
  [10112]: Typecast;
  ["PgCatalog.Types.PgSubscriptionArray"]: Typecast;
  [10113]: Typecast;
  ["PgCatalog.Types.PgSubscriptionRelArray"]: Typecast;
  [12034]: Typecast;
  ["PgCatalog.Types.PgTablesArray"]: Typecast;
  [10055]: Typecast;
  ["PgCatalog.Types.PgTablespaceArray"]: Typecast;
  [12123]: Typecast;
  ["PgCatalog.Types.PgTimezoneAbbrevsArray"]: Typecast;
  [12127]: Typecast;
  ["PgCatalog.Types.PgTimezoneNamesArray"]: Typecast;
  [10102]: Typecast;
  ["PgCatalog.Types.PgTransformArray"]: Typecast;
  [10036]: Typecast;
  ["PgCatalog.Types.PgTriggerArray"]: Typecast;
  [10063]: Typecast;
  ["PgCatalog.Types.PgTsConfigArray"]: Typecast;
  [10065]: Typecast;
  ["PgCatalog.Types.PgTsConfigMapArray"]: Typecast;
  [10067]: Typecast;
  ["PgCatalog.Types.PgTsDictArray"]: Typecast;
  [10069]: Typecast;
  ["PgCatalog.Types.PgTsParserArray"]: Typecast;
  [10071]: Typecast;
  ["PgCatalog.Types.PgTsTemplateArray"]: Typecast;
  [210]: Typecast;
  ["PgCatalog.Types.PgTypeArray"]: Typecast;
  [12015]: Typecast;
  ["PgCatalog.Types.PgUserArray"]: Typecast;
  [10079]: Typecast;
  ["PgCatalog.Types.PgUserMappingArray"]: Typecast;
  [12332]: Typecast;
  ["PgCatalog.Types.PgUserMappingsArray"]: Typecast;
  [12029]: Typecast;
  ["PgCatalog.Types.PgViewsArray"]: Typecast;
  [1017]: Typecast;
  ["PgCatalog.Types.PointArray"]: Typecast;
  [1027]: Typecast;
  ["PgCatalog.Types.PolygonArray"]: Typecast;
  [2287]: Typecast;
  ["PgCatalog.Types.RecordArray"]: Typecast;
  [2201]: Typecast;
  ["PgCatalog.Types.RefcursorArray"]: Typecast;
  [2210]: Typecast;
  ["PgCatalog.Types.RegclassArray"]: Typecast;
  [4192]: Typecast;
  ["PgCatalog.Types.RegcollationArray"]: Typecast;
  [3735]: Typecast;
  ["PgCatalog.Types.RegconfigArray"]: Typecast;
  [3770]: Typecast;
  ["PgCatalog.Types.RegdictionaryArray"]: Typecast;
  [4090]: Typecast;
  ["PgCatalog.Types.RegnamespaceArray"]: Typecast;
  [2208]: Typecast;
  ["PgCatalog.Types.RegoperArray"]: Typecast;
  [2209]: Typecast;
  ["PgCatalog.Types.RegoperatorArray"]: Typecast;
  [1008]: Typecast;
  ["PgCatalog.Types.RegprocArray"]: Typecast;
  [2207]: Typecast;
  ["PgCatalog.Types.RegprocedureArray"]: Typecast;
  [4097]: Typecast;
  ["PgCatalog.Types.RegroleArray"]: Typecast;
  [2211]: Typecast;
  ["PgCatalog.Types.RegtypeArray"]: Typecast;
  [1009]: Typecast;
  ["PgCatalog.Types.TextArray"]: Typecast;
  [1010]: Typecast;
  ["PgCatalog.Types.TidArray"]: Typecast;
  [1183]: Typecast;
  ["PgCatalog.Types.TimeArray"]: Typecast;
  [1115]: Typecast;
  ["PgCatalog.Types.TimestampArray"]: Typecast;
  [1185]: Typecast;
  ["PgCatalog.Types.TimestamptzArray"]: Typecast;
  [1270]: Typecast;
  ["PgCatalog.Types.TimetzArray"]: Typecast;
  [6152]: Typecast;
  ["PgCatalog.Types.TsmultirangeArray"]: Typecast;
  [3645]: Typecast;
  ["PgCatalog.Types.TsqueryArray"]: Typecast;
  [3909]: Typecast;
  ["PgCatalog.Types.TsrangeArray"]: Typecast;
  [6153]: Typecast;
  ["PgCatalog.Types.TstzmultirangeArray"]: Typecast;
  [3911]: Typecast;
  ["PgCatalog.Types.TstzrangeArray"]: Typecast;
  [3643]: Typecast;
  ["PgCatalog.Types.TsvectorArray"]: Typecast;
  [2949]: Typecast;
  ["PgCatalog.Types.TxidSnapshotArray"]: Typecast;
  [2951]: Typecast;
  ["PgCatalog.Types.UuidArray"]: Typecast;
  [1563]: Typecast;
  ["PgCatalog.Types.VarbitArray"]: Typecast;
  [1015]: Typecast;
  ["PgCatalog.Types.VarcharArray"]: Typecast;
  [1011]: Typecast;
  ["PgCatalog.Types.XidArray"]: Typecast;
  [271]: Typecast;
  ["PgCatalog.Types.Xid8Array"]: Typecast;
  [143]: Typecast;
  ["PgCatalog.Types.XmlArray"]: Typecast;
  [1033]: Typecast;
  ["PgCatalog.Types.Aclitem"]: Typecast;
  [2276]: Typecast;
  ["PgCatalog.Types.Any"]: Typecast;
  [2277]: Typecast;
  ["PgCatalog.Types.Anyarray"]: Typecast;
  [5077]: Typecast;
  ["PgCatalog.Types.Anycompatible"]: Typecast;
  [5078]: Typecast;
  ["PgCatalog.Types.Anycompatiblearray"]: Typecast;
  [4538]: Typecast;
  ["PgCatalog.Types.Anycompatiblemultirange"]: Typecast;
  [5079]: Typecast;
  ["PgCatalog.Types.Anycompatiblenonarray"]: Typecast;
  [5080]: Typecast;
  ["PgCatalog.Types.Anycompatiblerange"]: Typecast;
  [2283]: Typecast;
  ["PgCatalog.Types.Anyelement"]: Typecast;
  [3500]: Typecast;
  ["PgCatalog.Types.Anyenum"]: Typecast;
  [4537]: Typecast;
  ["PgCatalog.Types.Anymultirange"]: Typecast;
  [2776]: Typecast;
  ["PgCatalog.Types.Anynonarray"]: Typecast;
  [3831]: Typecast;
  ["PgCatalog.Types.Anyrange"]: Typecast;
  [1560]: Typecast;
  ["PgCatalog.Types.Bit"]: Typecast;
  [16]: Typecast;
  ["PgCatalog.Types.Bool"]: Typecast;
  [603]: Typecast;
  ["PgCatalog.Types.Box"]: Typecast;
  [1042]: Typecast;
  ["PgCatalog.Types.Bpchar"]: Typecast;
  [17]: Typecast;
  ["PgCatalog.Types.Bytea"]: Typecast;
  [18]: Typecast;
  ["PgCatalog.Types.Char"]: Typecast;
  [29]: Typecast;
  ["PgCatalog.Types.Cid"]: Typecast;
  [650]: Typecast;
  ["PgCatalog.Types.Cidr"]: Typecast;
  [718]: Typecast;
  ["PgCatalog.Types.Circle"]: Typecast;
  [2275]: Typecast;
  ["PgCatalog.Types.Cstring"]: Typecast;
  [1082]: Typecast;
  ["PgCatalog.Types.Date"]: Typecast;
  [4535]: Typecast;
  ["PgCatalog.Types.Datemultirange"]: Typecast;
  [3912]: Typecast;
  ["PgCatalog.Types.Daterange"]: Typecast;
  [3838]: Typecast;
  ["PgCatalog.Types.EventTrigger"]: Typecast;
  [3115]: Typecast;
  ["PgCatalog.Types.FdwHandler"]: Typecast;
  [700]: Typecast;
  ["PgCatalog.Types.Float4"]: Typecast;
  [701]: Typecast;
  ["PgCatalog.Types.Float8"]: Typecast;
  [3642]: Typecast;
  ["PgCatalog.Types.Gtsvector"]: Typecast;
  [325]: Typecast;
  ["PgCatalog.Types.IndexAmHandler"]: Typecast;
  [869]: Typecast;
  ["PgCatalog.Types.Inet"]: Typecast;
  [21]: Typecast;
  ["PgCatalog.Types.Int2"]: Typecast;
  [22]: Typecast;
  ["PgCatalog.Types.Int2vector"]: Typecast;
  [23]: Typecast;
  ["PgCatalog.Types.Int4"]: Typecast;
  [4451]: Typecast;
  ["PgCatalog.Types.Int4multirange"]: Typecast;
  [3904]: Typecast;
  ["PgCatalog.Types.Int4range"]: Typecast;
  [20]: Typecast;
  ["PgCatalog.Types.Int8"]: Typecast;
  [4536]: Typecast;
  ["PgCatalog.Types.Int8multirange"]: Typecast;
  [3926]: Typecast;
  ["PgCatalog.Types.Int8range"]: Typecast;
  [2281]: Typecast;
  ["PgCatalog.Types.Internal"]: Typecast;
  [1186]: Typecast;
  ["PgCatalog.Types.Interval"]: Typecast;
  [114]: Typecast;
  ["PgCatalog.Types.Json"]: Typecast;
  [3802]: Typecast;
  ["PgCatalog.Types.Jsonb"]: Typecast;
  [4072]: Typecast;
  ["PgCatalog.Types.Jsonpath"]: Typecast;
  [2280]: Typecast;
  ["PgCatalog.Types.LanguageHandler"]: Typecast;
  [628]: Typecast;
  ["PgCatalog.Types.Line"]: Typecast;
  [601]: Typecast;
  ["PgCatalog.Types.Lseg"]: Typecast;
  [829]: Typecast;
  ["PgCatalog.Types.Macaddr"]: Typecast;
  [774]: Typecast;
  ["PgCatalog.Types.Macaddr8"]: Typecast;
  [790]: Typecast;
  ["PgCatalog.Types.Money"]: Typecast;
  [19]: Typecast;
  ["PgCatalog.Types.Name"]: Typecast;
  [1700]: Typecast;
  ["PgCatalog.Types.Numeric"]: Typecast;
  [4532]: Typecast;
  ["PgCatalog.Types.Nummultirange"]: Typecast;
  [3906]: Typecast;
  ["PgCatalog.Types.Numrange"]: Typecast;
  [26]: Typecast;
  ["PgCatalog.Types.Oid"]: Typecast;
  [30]: Typecast;
  ["PgCatalog.Types.Oidvector"]: Typecast;
  [602]: Typecast;
  ["PgCatalog.Types.Path"]: Typecast;
  [10027]: Typecast;
  ["PgCatalog.Types.PgAggregate"]: Typecast;
  [10015]: Typecast;
  ["PgCatalog.Types.PgAm"]: Typecast;
  [10017]: Typecast;
  ["PgCatalog.Types.PgAmop"]: Typecast;
  [10019]: Typecast;
  ["PgCatalog.Types.PgAmproc"]: Typecast;
  [10001]: Typecast;
  ["PgCatalog.Types.PgAttrdef"]: Typecast;
  [75]: Typecast;
  ["PgCatalog.Types.PgAttribute"]: Typecast;
  [2843]: Typecast;
  ["PgCatalog.Types.PgAuthMembers"]: Typecast;
  [2842]: Typecast;
  ["PgCatalog.Types.PgAuthid"]: Typecast;
  [12087]: Typecast;
  ["PgCatalog.Types.PgAvailableExtensionVersions"]: Typecast;
  [12083]: Typecast;
  ["PgCatalog.Types.PgAvailableExtensions"]: Typecast;
  [12140]: Typecast;
  ["PgCatalog.Types.PgBackendMemoryContexts"]: Typecast;
  [4600]: Typecast;
  ["PgCatalog.Types.PgBrinBloomSummary"]: Typecast;
  [4601]: Typecast;
  ["PgCatalog.Types.PgBrinMinmaxMultiSummary"]: Typecast;
  [10043]: Typecast;
  ["PgCatalog.Types.PgCast"]: Typecast;
  [83]: Typecast;
  ["PgCatalog.Types.PgClass"]: Typecast;
  [10095]: Typecast;
  ["PgCatalog.Types.PgCollation"]: Typecast;
  [12132]: Typecast;
  ["PgCatalog.Types.PgConfig"]: Typecast;
  [10003]: Typecast;
  ["PgCatalog.Types.PgConstraint"]: Typecast;
  [10049]: Typecast;
  ["PgCatalog.Types.PgConversion"]: Typecast;
  [12079]: Typecast;
  ["PgCatalog.Types.PgCursors"]: Typecast;
  [1248]: Typecast;
  ["PgCatalog.Types.PgDatabase"]: Typecast;
  [10054]: Typecast;
  ["PgCatalog.Types.PgDbRoleSetting"]: Typecast;
  [32]: Typecast;
  ["PgCatalog.Types.PgDdlCommand"]: Typecast;
  [10088]: Typecast;
  ["PgCatalog.Types.PgDefaultAcl"]: Typecast;
  [10051]: Typecast;
  ["PgCatalog.Types.PgDepend"]: Typecast;
  [3402]: Typecast;
  ["PgCatalog.Types.PgDependencies"]: Typecast;
  [10041]: Typecast;
  ["PgCatalog.Types.PgDescription"]: Typecast;
  [10045]: Typecast;
  ["PgCatalog.Types.PgEnum"]: Typecast;
  [10039]: Typecast;
  ["PgCatalog.Types.PgEventTrigger"]: Typecast;
  [10074]: Typecast;
  ["PgCatalog.Types.PgExtension"]: Typecast;
  [12112]: Typecast;
  ["PgCatalog.Types.PgFileSettings"]: Typecast;
  [10076]: Typecast;
  ["PgCatalog.Types.PgForeignDataWrapper"]: Typecast;
  [10078]: Typecast;
  ["PgCatalog.Types.PgForeignServer"]: Typecast;
  [10082]: Typecast;
  ["PgCatalog.Types.PgForeignTable"]: Typecast;
  [12012]: Typecast;
  ["PgCatalog.Types.PgGroup"]: Typecast;
  [12116]: Typecast;
  ["PgCatalog.Types.PgHbaFileRules"]: Typecast;
  [12120]: Typecast;
  ["PgCatalog.Types.PgIdentFileMappings"]: Typecast;
  [10007]: Typecast;
  ["PgCatalog.Types.PgIndex"]: Typecast;
  [12045]: Typecast;
  ["PgCatalog.Types.PgIndexes"]: Typecast;
  [10005]: Typecast;
  ["PgCatalog.Types.PgInherits"]: Typecast;
  [10090]: Typecast;
  ["PgCatalog.Types.PgInitPrivs"]: Typecast;
  [10021]: Typecast;
  ["PgCatalog.Types.PgLanguage"]: Typecast;
  [10025]: Typecast;
  ["PgCatalog.Types.PgLargeobject"]: Typecast;
  [10023]: Typecast;
  ["PgCatalog.Types.PgLargeobjectMetadata"]: Typecast;
  [12075]: Typecast;
  ["PgCatalog.Types.PgLocks"]: Typecast;
  [3220]: Typecast;
  ["PgCatalog.Types.PgLsn"]: Typecast;
  [12040]: Typecast;
  ["PgCatalog.Types.PgMatviews"]: Typecast;
  [5017]: Typecast;
  ["PgCatalog.Types.PgMcvList"]: Typecast;
  [10047]: Typecast;
  ["PgCatalog.Types.PgNamespace"]: Typecast;
  [3361]: Typecast;
  ["PgCatalog.Types.PgNdistinct"]: Typecast;
  [194]: Typecast;
  ["PgCatalog.Types.PgNodeTree"]: Typecast;
  [10013]: Typecast;
  ["PgCatalog.Types.PgOpclass"]: Typecast;
  [10009]: Typecast;
  ["PgCatalog.Types.PgOperator"]: Typecast;
  [10011]: Typecast;
  ["PgCatalog.Types.PgOpfamily"]: Typecast;
  [10097]: Typecast;
  ["PgCatalog.Types.PgParameterAcl"]: Typecast;
  [10099]: Typecast;
  ["PgCatalog.Types.PgPartitionedTable"]: Typecast;
  [12020]: Typecast;
  ["PgCatalog.Types.PgPolicies"]: Typecast;
  [10084]: Typecast;
  ["PgCatalog.Types.PgPolicy"]: Typecast;
  [12097]: Typecast;
  ["PgCatalog.Types.PgPreparedStatements"]: Typecast;
  [12092]: Typecast;
  ["PgCatalog.Types.PgPreparedXacts"]: Typecast;
  [81]: Typecast;
  ["PgCatalog.Types.PgProc"]: Typecast;
  [10107]: Typecast;
  ["PgCatalog.Types.PgPublication"]: Typecast;
  [10109]: Typecast;
  ["PgCatalog.Types.PgPublicationNamespace"]: Typecast;
  [10111]: Typecast;
  ["PgCatalog.Types.PgPublicationRel"]: Typecast;
  [12070]: Typecast;
  ["PgCatalog.Types.PgPublicationTables"]: Typecast;
  [10101]: Typecast;
  ["PgCatalog.Types.PgRange"]: Typecast;
  [10086]: Typecast;
  ["PgCatalog.Types.PgReplicationOrigin"]: Typecast;
  [12338]: Typecast;
  ["PgCatalog.Types.PgReplicationOriginStatus"]: Typecast;
  [12259]: Typecast;
  ["PgCatalog.Types.PgReplicationSlots"]: Typecast;
  [10035]: Typecast;
  ["PgCatalog.Types.PgRewrite"]: Typecast;
  [12002]: Typecast;
  ["PgCatalog.Types.PgRoles"]: Typecast;
  [12025]: Typecast;
  ["PgCatalog.Types.PgRules"]: Typecast;
  [10092]: Typecast;
  ["PgCatalog.Types.PgSeclabel"]: Typecast;
  [12101]: Typecast;
  ["PgCatalog.Types.PgSeclabels"]: Typecast;
  [10105]: Typecast;
  ["PgCatalog.Types.PgSequence"]: Typecast;
  [12050]: Typecast;
  ["PgCatalog.Types.PgSequences"]: Typecast;
  [12106]: Typecast;
  ["PgCatalog.Types.PgSettings"]: Typecast;
  [12007]: Typecast;
  ["PgCatalog.Types.PgShadow"]: Typecast;
  [10060]: Typecast;
  ["PgCatalog.Types.PgShdepend"]: Typecast;
  [10062]: Typecast;
  ["PgCatalog.Types.PgShdescription"]: Typecast;
  [12136]: Typecast;
  ["PgCatalog.Types.PgShmemAllocations"]: Typecast;
  [4066]: Typecast;
  ["PgCatalog.Types.PgShseclabel"]: Typecast;
  [5038]: Typecast;
  ["PgCatalog.Types.PgSnapshot"]: Typecast;
  [12224]: Typecast;
  ["PgCatalog.Types.PgStatActivity"]: Typecast;
  [12185]: Typecast;
  ["PgCatalog.Types.PgStatAllIndexes"]: Typecast;
  [12144]: Typecast;
  ["PgCatalog.Types.PgStatAllTables"]: Typecast;
  [12287]: Typecast;
  ["PgCatalog.Types.PgStatArchiver"]: Typecast;
  [12291]: Typecast;
  ["PgCatalog.Types.PgStatBgwriter"]: Typecast;
  [12268]: Typecast;
  ["PgCatalog.Types.PgStatDatabase"]: Typecast;
  [12273]: Typecast;
  ["PgCatalog.Types.PgStatDatabaseConflicts"]: Typecast;
  [12255]: Typecast;
  ["PgCatalog.Types.PgStatGssapi"]: Typecast;
  [12295]: Typecast;
  ["PgCatalog.Types.PgStatIo"]: Typecast;
  [12303]: Typecast;
  ["PgCatalog.Types.PgStatProgressAnalyze"]: Typecast;
  [12323]: Typecast;
  ["PgCatalog.Types.PgStatProgressBasebackup"]: Typecast;
  [12313]: Typecast;
  ["PgCatalog.Types.PgStatProgressCluster"]: Typecast;
  [12328]: Typecast;
  ["PgCatalog.Types.PgStatProgressCopy"]: Typecast;
  [12318]: Typecast;
  ["PgCatalog.Types.PgStatProgressCreateIndex"]: Typecast;
  [12308]: Typecast;
  ["PgCatalog.Types.PgStatProgressVacuum"]: Typecast;
  [12242]: Typecast;
  ["PgCatalog.Types.PgStatRecoveryPrefetch"]: Typecast;
  [12229]: Typecast;
  ["PgCatalog.Types.PgStatReplication"]: Typecast;
  [12264]: Typecast;
  ["PgCatalog.Types.PgStatReplicationSlots"]: Typecast;
  [12234]: Typecast;
  ["PgCatalog.Types.PgStatSlru"]: Typecast;
  [12251]: Typecast;
  ["PgCatalog.Types.PgStatSsl"]: Typecast;
  [12246]: Typecast;
  ["PgCatalog.Types.PgStatSubscription"]: Typecast;
  [12342]: Typecast;
  ["PgCatalog.Types.PgStatSubscriptionStats"]: Typecast;
  [12190]: Typecast;
  ["PgCatalog.Types.PgStatSysIndexes"]: Typecast;
  [12154]: Typecast;
  ["PgCatalog.Types.PgStatSysTables"]: Typecast;
  [12277]: Typecast;
  ["PgCatalog.Types.PgStatUserFunctions"]: Typecast;
  [12194]: Typecast;
  ["PgCatalog.Types.PgStatUserIndexes"]: Typecast;
  [12163]: Typecast;
  ["PgCatalog.Types.PgStatUserTables"]: Typecast;
  [12299]: Typecast;
  ["PgCatalog.Types.PgStatWal"]: Typecast;
  [12238]: Typecast;
  ["PgCatalog.Types.PgStatWalReceiver"]: Typecast;
  [12149]: Typecast;
  ["PgCatalog.Types.PgStatXactAllTables"]: Typecast;
  [12159]: Typecast;
  ["PgCatalog.Types.PgStatXactSysTables"]: Typecast;
  [12282]: Typecast;
  ["PgCatalog.Types.PgStatXactUserFunctions"]: Typecast;
  [12168]: Typecast;
  ["PgCatalog.Types.PgStatXactUserTables"]: Typecast;
  [12198]: Typecast;
  ["PgCatalog.Types.PgStatioAllIndexes"]: Typecast;
  [12211]: Typecast;
  ["PgCatalog.Types.PgStatioAllSequences"]: Typecast;
  [12172]: Typecast;
  ["PgCatalog.Types.PgStatioAllTables"]: Typecast;
  [12203]: Typecast;
  ["PgCatalog.Types.PgStatioSysIndexes"]: Typecast;
  [12216]: Typecast;
  ["PgCatalog.Types.PgStatioSysSequences"]: Typecast;
  [12177]: Typecast;
  ["PgCatalog.Types.PgStatioSysTables"]: Typecast;
  [12207]: Typecast;
  ["PgCatalog.Types.PgStatioUserIndexes"]: Typecast;
  [12220]: Typecast;
  ["PgCatalog.Types.PgStatioUserSequences"]: Typecast;
  [12181]: Typecast;
  ["PgCatalog.Types.PgStatioUserTables"]: Typecast;
  [10029]: Typecast;
  ["PgCatalog.Types.PgStatistic"]: Typecast;
  [10031]: Typecast;
  ["PgCatalog.Types.PgStatisticExt"]: Typecast;
  [10033]: Typecast;
  ["PgCatalog.Types.PgStatisticExtData"]: Typecast;
  [12055]: Typecast;
  ["PgCatalog.Types.PgStats"]: Typecast;
  [12060]: Typecast;
  ["PgCatalog.Types.PgStatsExt"]: Typecast;
  [12065]: Typecast;
  ["PgCatalog.Types.PgStatsExtExprs"]: Typecast;
  [6101]: Typecast;
  ["PgCatalog.Types.PgSubscription"]: Typecast;
  [10114]: Typecast;
  ["PgCatalog.Types.PgSubscriptionRel"]: Typecast;
  [12035]: Typecast;
  ["PgCatalog.Types.PgTables"]: Typecast;
  [10056]: Typecast;
  ["PgCatalog.Types.PgTablespace"]: Typecast;
  [12124]: Typecast;
  ["PgCatalog.Types.PgTimezoneAbbrevs"]: Typecast;
  [12128]: Typecast;
  ["PgCatalog.Types.PgTimezoneNames"]: Typecast;
  [10103]: Typecast;
  ["PgCatalog.Types.PgTransform"]: Typecast;
  [10037]: Typecast;
  ["PgCatalog.Types.PgTrigger"]: Typecast;
  [10064]: Typecast;
  ["PgCatalog.Types.PgTsConfig"]: Typecast;
  [10066]: Typecast;
  ["PgCatalog.Types.PgTsConfigMap"]: Typecast;
  [10068]: Typecast;
  ["PgCatalog.Types.PgTsDict"]: Typecast;
  [10070]: Typecast;
  ["PgCatalog.Types.PgTsParser"]: Typecast;
  [10072]: Typecast;
  ["PgCatalog.Types.PgTsTemplate"]: Typecast;
  [71]: Typecast;
  ["PgCatalog.Types.PgType"]: Typecast;
  [12016]: Typecast;
  ["PgCatalog.Types.PgUser"]: Typecast;
  [10080]: Typecast;
  ["PgCatalog.Types.PgUserMapping"]: Typecast;
  [12333]: Typecast;
  ["PgCatalog.Types.PgUserMappings"]: Typecast;
  [12030]: Typecast;
  ["PgCatalog.Types.PgViews"]: Typecast;
  [600]: Typecast;
  ["PgCatalog.Types.Point"]: Typecast;
  [604]: Typecast;
  ["PgCatalog.Types.Polygon"]: Typecast;
  [2249]: Typecast;
  ["PgCatalog.Types.Record"]: Typecast;
  [1790]: Typecast;
  ["PgCatalog.Types.Refcursor"]: Typecast;
  [2205]: Typecast;
  ["PgCatalog.Types.Regclass"]: Typecast;
  [4191]: Typecast;
  ["PgCatalog.Types.Regcollation"]: Typecast;
  [3734]: Typecast;
  ["PgCatalog.Types.Regconfig"]: Typecast;
  [3769]: Typecast;
  ["PgCatalog.Types.Regdictionary"]: Typecast;
  [4089]: Typecast;
  ["PgCatalog.Types.Regnamespace"]: Typecast;
  [2203]: Typecast;
  ["PgCatalog.Types.Regoper"]: Typecast;
  [2204]: Typecast;
  ["PgCatalog.Types.Regoperator"]: Typecast;
  [24]: Typecast;
  ["PgCatalog.Types.Regproc"]: Typecast;
  [2202]: Typecast;
  ["PgCatalog.Types.Regprocedure"]: Typecast;
  [4096]: Typecast;
  ["PgCatalog.Types.Regrole"]: Typecast;
  [2206]: Typecast;
  ["PgCatalog.Types.Regtype"]: Typecast;
  [269]: Typecast;
  ["PgCatalog.Types.TableAmHandler"]: Typecast;
  [25]: Typecast;
  ["PgCatalog.Types.Text"]: Typecast;
  [27]: Typecast;
  ["PgCatalog.Types.Tid"]: Typecast;
  [1083]: Typecast;
  ["PgCatalog.Types.Time"]: Typecast;
  [1114]: Typecast;
  ["PgCatalog.Types.Timestamp"]: Typecast;
  [1184]: Typecast;
  ["PgCatalog.Types.Timestamptz"]: Typecast;
  [1266]: Typecast;
  ["PgCatalog.Types.Timetz"]: Typecast;
  [2279]: Typecast;
  ["PgCatalog.Types.Trigger"]: Typecast;
  [3310]: Typecast;
  ["PgCatalog.Types.TsmHandler"]: Typecast;
  [4533]: Typecast;
  ["PgCatalog.Types.Tsmultirange"]: Typecast;
  [3615]: Typecast;
  ["PgCatalog.Types.Tsquery"]: Typecast;
  [3908]: Typecast;
  ["PgCatalog.Types.Tsrange"]: Typecast;
  [4534]: Typecast;
  ["PgCatalog.Types.Tstzmultirange"]: Typecast;
  [3910]: Typecast;
  ["PgCatalog.Types.Tstzrange"]: Typecast;
  [3614]: Typecast;
  ["PgCatalog.Types.Tsvector"]: Typecast;
  [2970]: Typecast;
  ["PgCatalog.Types.TxidSnapshot"]: Typecast;
  [705]: Typecast;
  ["PgCatalog.Types.Unknown"]: Typecast;
  [2950]: Typecast;
  ["PgCatalog.Types.Uuid"]: Typecast;
  [1562]: Typecast;
  ["PgCatalog.Types.Varbit"]: Typecast;
  [1043]: Typecast;
  ["PgCatalog.Types.Varchar"]: Typecast;
  [2278]: Typecast;
  ["PgCatalog.Types.Void"]: Typecast;
  [28]: Typecast;
  ["PgCatalog.Types.Xid"]: Typecast;
  [5069]: Typecast;
  ["PgCatalog.Types.Xid8"]: Typecast;
  [142]: Typecast;
  ["PgCatalog.Types.Xml"]: Typecast;
  [27048]: Typecast;
  ["Public.Types.ActorArray"]: Typecast;
  [27079]: Typecast;
  ["Public.Types.ActorInfoArray"]: Typecast;
  [27085]: Typecast;
  ["Public.Types.AddressArray"]: Typecast;
  [27054]: Typecast;
  ["Public.Types.CategoryArray"]: Typecast;
  [27091]: Typecast;
  ["Public.Types.CityArray"]: Typecast;
  [27097]: Typecast;
  ["Public.Types.CountryArray"]: Typecast;
  [27038]: Typecast;
  ["Public.Types.CustomerArray"]: Typecast;
  [27102]: Typecast;
  ["Public.Types.CustomerListArray"]: Typecast;
  [27060]: Typecast;
  ["Public.Types.FilmArray"]: Typecast;
  [27071]: Typecast;
  ["Public.Types.FilmActorArray"]: Typecast;
  [27075]: Typecast;
  ["Public.Types.FilmCategoryArray"]: Typecast;
  [27107]: Typecast;
  ["Public.Types.FilmListArray"]: Typecast;
  [27113]: Typecast;
  ["Public.Types.InventoryArray"]: Typecast;
  [27119]: Typecast;
  ["Public.Types.LanguageArray"]: Typecast;
  [27013]: Typecast;
  ["Public.Types.MpaaRatingArray"]: Typecast;
  [27124]: Typecast;
  ["Public.Types.NicerButSlowerFilmListArray"]: Typecast;
  [27130]: Typecast;
  ["Public.Types.PaymentArray"]: Typecast;
  [27135]: Typecast;
  ["Public.Types.RentalArray"]: Typecast;
  [27140]: Typecast;
  ["Public.Types.SalesByFilmCategoryArray"]: Typecast;
  [27160]: Typecast;
  ["Public.Types.SalesByStoreArray"]: Typecast;
  [27146]: Typecast;
  ["Public.Types.StaffArray"]: Typecast;
  [27165]: Typecast;
  ["Public.Types.StaffListArray"]: Typecast;
  [27155]: Typecast;
  ["Public.Types.StoreArray"]: Typecast;
  [27025]: Typecast;
  ["Public.Types.YearArray"]: Typecast;
  [27049]: Typecast;
  ["Public.Types.Actor"]: Typecast;
  [27080]: Typecast;
  ["Public.Types.ActorInfo"]: Typecast;
  [27086]: Typecast;
  ["Public.Types.Address"]: Typecast;
  [27055]: Typecast;
  ["Public.Types.Category"]: Typecast;
  [27092]: Typecast;
  ["Public.Types.City"]: Typecast;
  [27098]: Typecast;
  ["Public.Types.Country"]: Typecast;
  [27039]: Typecast;
  ["Public.Types.Customer"]: Typecast;
  [27103]: Typecast;
  ["Public.Types.CustomerList"]: Typecast;
  [27061]: Typecast;
  ["Public.Types.Film"]: Typecast;
  [27072]: Typecast;
  ["Public.Types.FilmActor"]: Typecast;
  [27076]: Typecast;
  ["Public.Types.FilmCategory"]: Typecast;
  [27108]: Typecast;
  ["Public.Types.FilmList"]: Typecast;
  [27114]: Typecast;
  ["Public.Types.Inventory"]: Typecast;
  [27120]: Typecast;
  ["Public.Types.Language"]: Typecast;
  [27014]: Typecast;
  ["Public.Types.MpaaRating"]: Typecast;
  [27125]: Typecast;
  ["Public.Types.NicerButSlowerFilmList"]: Typecast;
  [27131]: Typecast;
  ["Public.Types.Payment"]: Typecast;
  [27136]: Typecast;
  ["Public.Types.Rental"]: Typecast;
  [27141]: Typecast;
  ["Public.Types.SalesByFilmCategory"]: Typecast;
  [27161]: Typecast;
  ["Public.Types.SalesByStore"]: Typecast;
  [27147]: Typecast;
  ["Public.Types.Staff"]: Typecast;
  [27166]: Typecast;
  ["Public.Types.StaffList"]: Typecast;
  [27156]: Typecast;
  ["Public.Types.Store"]: Typecast;
  [27026]: Typecast;
  ["Public.Types.Year"]: Typecast;

  ["Public.Procedures.FilmInStock.Parameters"]: Typecast;

  ["Public.Procedures.FilmNotInStock.Parameters"]: Typecast;

  ["Public.Procedures.GetCustomerBalance.Parameters"]: Typecast;

  ["Public.Procedures.InventoryHeldByCustomer.Parameters"]: Typecast;

  ["Public.Procedures.InventoryInStock.Parameters"]: Typecast;

  ["Public.Procedures.LastDay.Parameters"]: Typecast;

  ["Public.Procedures.RewardsReport.Parameters"]: Typecast;
  [13509]: Typecast;
  ["InformationSchema.Types.AdministrableRoleAuthorizationsArray"]: Typecast;
  [13504]: Typecast;
  ["InformationSchema.Types.ApplicableRolesArray"]: Typecast;
  [13513]: Typecast;
  ["InformationSchema.Types.AttributesArray"]: Typecast;
  [13487]: Typecast;
  ["InformationSchema.Types.CardinalNumberArray"]: Typecast;
  [13490]: Typecast;
  ["InformationSchema.Types.CharacterDataArray"]: Typecast;
  [13518]: Typecast;
  ["InformationSchema.Types.CharacterSetsArray"]: Typecast;
  [13523]: Typecast;
  ["InformationSchema.Types.CheckConstraintRoutineUsageArray"]: Typecast;
  [13528]: Typecast;
  ["InformationSchema.Types.CheckConstraintsArray"]: Typecast;
  [13538]: Typecast;
  ["InformationSchema.Types.CollationCharacterSetApplicabilityArray"]: Typecast;
  [13533]: Typecast;
  ["InformationSchema.Types.CollationsArray"]: Typecast;
  [13543]: Typecast;
  ["InformationSchema.Types.ColumnColumnUsageArray"]: Typecast;
  [13548]: Typecast;
  ["InformationSchema.Types.ColumnDomainUsageArray"]: Typecast;
  [13771]: Typecast;
  ["InformationSchema.Types.ColumnOptionsArray"]: Typecast;
  [13553]: Typecast;
  ["InformationSchema.Types.ColumnPrivilegesArray"]: Typecast;
  [13558]: Typecast;
  ["InformationSchema.Types.ColumnUdtUsageArray"]: Typecast;
  [13563]: Typecast;
  ["InformationSchema.Types.ColumnsArray"]: Typecast;
  [13568]: Typecast;
  ["InformationSchema.Types.ConstraintColumnUsageArray"]: Typecast;
  [13573]: Typecast;
  ["InformationSchema.Types.ConstraintTableUsageArray"]: Typecast;
  [13756]: Typecast;
  ["InformationSchema.Types.DataTypePrivilegesArray"]: Typecast;
  [13578]: Typecast;
  ["InformationSchema.Types.DomainConstraintsArray"]: Typecast;
  [13583]: Typecast;
  ["InformationSchema.Types.DomainUdtUsageArray"]: Typecast;
  [13588]: Typecast;
  ["InformationSchema.Types.DomainsArray"]: Typecast;
  [13761]: Typecast;
  ["InformationSchema.Types.ElementTypesArray"]: Typecast;
  [13593]: Typecast;
  ["InformationSchema.Types.EnabledRolesArray"]: Typecast;
  [13779]: Typecast;
  ["InformationSchema.Types.ForeignDataWrapperOptionsArray"]: Typecast;
  [13783]: Typecast;
  ["InformationSchema.Types.ForeignDataWrappersArray"]: Typecast;
  [13792]: Typecast;
  ["InformationSchema.Types.ForeignServerOptionsArray"]: Typecast;
  [13796]: Typecast;
  ["InformationSchema.Types.ForeignServersArray"]: Typecast;
  [13805]: Typecast;
  ["InformationSchema.Types.ForeignTableOptionsArray"]: Typecast;
  [13809]: Typecast;
  ["InformationSchema.Types.ForeignTablesArray"]: Typecast;
  [13495]: Typecast;
  ["InformationSchema.Types.InformationSchemaCatalogNameArray"]: Typecast;
  [13597]: Typecast;
  ["InformationSchema.Types.KeyColumnUsageArray"]: Typecast;
  [13602]: Typecast;
  ["InformationSchema.Types.ParametersArray"]: Typecast;
  [13776]: Typecast;
  ["InformationSchema.Types.PgForeignDataWrappers"]: Typecast;
  [13788]: Typecast;
  ["InformationSchema.Types.PgForeignServers"]: Typecast;
  [13767]: Typecast;
  ["InformationSchema.Types.PgForeignTableColumns"]: Typecast;
  [13801]: Typecast;
  ["InformationSchema.Types.PgForeignTables"]: Typecast;
  [13814]: Typecast;
  ["InformationSchema.Types.PgUserMappings"]: Typecast;
  [13607]: Typecast;
  ["InformationSchema.Types.ReferentialConstraintsArray"]: Typecast;
  [13612]: Typecast;
  ["InformationSchema.Types.RoleColumnGrantsArray"]: Typecast;
  [13626]: Typecast;
  ["InformationSchema.Types.RoleRoutineGrantsArray"]: Typecast;
  [13689]: Typecast;
  ["InformationSchema.Types.RoleTableGrantsArray"]: Typecast;
  [13718]: Typecast;
  ["InformationSchema.Types.RoleUdtGrantsArray"]: Typecast;
  [13727]: Typecast;
  ["InformationSchema.Types.RoleUsageGrantsArray"]: Typecast;
  [13616]: Typecast;
  ["InformationSchema.Types.RoutineColumnUsageArray"]: Typecast;
  [13621]: Typecast;
  ["InformationSchema.Types.RoutinePrivilegesArray"]: Typecast;
  [13630]: Typecast;
  ["InformationSchema.Types.RoutineRoutineUsageArray"]: Typecast;
  [13635]: Typecast;
  ["InformationSchema.Types.RoutineSequenceUsageArray"]: Typecast;
  [13640]: Typecast;
  ["InformationSchema.Types.RoutineTableUsageArray"]: Typecast;
  [13645]: Typecast;
  ["InformationSchema.Types.RoutinesArray"]: Typecast;
  [13650]: Typecast;
  ["InformationSchema.Types.SchemataArray"]: Typecast;
  [13654]: Typecast;
  ["InformationSchema.Types.SequencesArray"]: Typecast;
  [13659]: Typecast;
  ["InformationSchema.Types.SqlFeaturesArray"]: Typecast;
  [13492]: Typecast;
  ["InformationSchema.Types.SqlIdentifierArray"]: Typecast;
  [13664]: Typecast;
  ["InformationSchema.Types.SqlImplementationInfoArray"]: Typecast;
  [13669]: Typecast;
  ["InformationSchema.Types.SqlPartsArray"]: Typecast;
  [13674]: Typecast;
  ["InformationSchema.Types.SqlSizingArray"]: Typecast;
  [13679]: Typecast;
  ["InformationSchema.Types.TableConstraintsArray"]: Typecast;
  [13684]: Typecast;
  ["InformationSchema.Types.TablePrivilegesArray"]: Typecast;
  [13693]: Typecast;
  ["InformationSchema.Types.TablesArray"]: Typecast;
  [13498]: Typecast;
  ["InformationSchema.Types.TimeStampArray"]: Typecast;
  [13698]: Typecast;
  ["InformationSchema.Types.TransformsArray"]: Typecast;
  [13703]: Typecast;
  ["InformationSchema.Types.TriggeredUpdateColumnsArray"]: Typecast;
  [13708]: Typecast;
  ["InformationSchema.Types.TriggersArray"]: Typecast;
  [13713]: Typecast;
  ["InformationSchema.Types.UdtPrivilegesArray"]: Typecast;
  [13722]: Typecast;
  ["InformationSchema.Types.UsagePrivilegesArray"]: Typecast;
  [13731]: Typecast;
  ["InformationSchema.Types.UserDefinedTypesArray"]: Typecast;
  [13818]: Typecast;
  ["InformationSchema.Types.UserMappingOptionsArray"]: Typecast;
  [13823]: Typecast;
  ["InformationSchema.Types.UserMappingsArray"]: Typecast;
  [13736]: Typecast;
  ["InformationSchema.Types.ViewColumnUsageArray"]: Typecast;
  [13741]: Typecast;
  ["InformationSchema.Types.ViewRoutineUsageArray"]: Typecast;
  [13746]: Typecast;
  ["InformationSchema.Types.ViewTableUsageArray"]: Typecast;
  [13751]: Typecast;
  ["InformationSchema.Types.ViewsArray"]: Typecast;
  [13500]: Typecast;
  ["InformationSchema.Types.YesOrNoArray"]: Typecast;
  [13510]: Typecast;
  ["InformationSchema.Types.AdministrableRoleAuthorizations"]: Typecast;
  [13505]: Typecast;
  ["InformationSchema.Types.ApplicableRoles"]: Typecast;
  [13514]: Typecast;
  ["InformationSchema.Types.Attributes"]: Typecast;
  [13488]: Typecast;
  ["InformationSchema.Types.CardinalNumber"]: Typecast;
  [13491]: Typecast;
  ["InformationSchema.Types.CharacterData"]: Typecast;
  [13519]: Typecast;
  ["InformationSchema.Types.CharacterSets"]: Typecast;
  [13524]: Typecast;
  ["InformationSchema.Types.CheckConstraintRoutineUsage"]: Typecast;
  [13529]: Typecast;
  ["InformationSchema.Types.CheckConstraints"]: Typecast;
  [13539]: Typecast;
  ["InformationSchema.Types.CollationCharacterSetApplicability"]: Typecast;
  [13534]: Typecast;
  ["InformationSchema.Types.Collations"]: Typecast;
  [13544]: Typecast;
  ["InformationSchema.Types.ColumnColumnUsage"]: Typecast;
  [13549]: Typecast;
  ["InformationSchema.Types.ColumnDomainUsage"]: Typecast;
  [13772]: Typecast;
  ["InformationSchema.Types.ColumnOptions"]: Typecast;
  [13554]: Typecast;
  ["InformationSchema.Types.ColumnPrivileges"]: Typecast;
  [13559]: Typecast;
  ["InformationSchema.Types.ColumnUdtUsage"]: Typecast;
  [13564]: Typecast;
  ["InformationSchema.Types.Columns"]: Typecast;
  [13569]: Typecast;
  ["InformationSchema.Types.ConstraintColumnUsage"]: Typecast;
  [13574]: Typecast;
  ["InformationSchema.Types.ConstraintTableUsage"]: Typecast;
  [13757]: Typecast;
  ["InformationSchema.Types.DataTypePrivileges"]: Typecast;
  [13579]: Typecast;
  ["InformationSchema.Types.DomainConstraints"]: Typecast;
  [13584]: Typecast;
  ["InformationSchema.Types.DomainUdtUsage"]: Typecast;
  [13589]: Typecast;
  ["InformationSchema.Types.Domains"]: Typecast;
  [13762]: Typecast;
  ["InformationSchema.Types.ElementTypes"]: Typecast;
  [13594]: Typecast;
  ["InformationSchema.Types.EnabledRoles"]: Typecast;
  [13780]: Typecast;
  ["InformationSchema.Types.ForeignDataWrapperOptions"]: Typecast;
  [13784]: Typecast;
  ["InformationSchema.Types.ForeignDataWrappers"]: Typecast;
  [13793]: Typecast;
  ["InformationSchema.Types.ForeignServerOptions"]: Typecast;
  [13797]: Typecast;
  ["InformationSchema.Types.ForeignServers"]: Typecast;
  [13806]: Typecast;
  ["InformationSchema.Types.ForeignTableOptions"]: Typecast;
  [13810]: Typecast;
  ["InformationSchema.Types.ForeignTables"]: Typecast;
  [13496]: Typecast;
  ["InformationSchema.Types.InformationSchemaCatalogName"]: Typecast;
  [13598]: Typecast;
  ["InformationSchema.Types.KeyColumnUsage"]: Typecast;
  [13603]: Typecast;
  ["InformationSchema.Types.Parameters"]: Typecast;
  [13608]: Typecast;
  ["InformationSchema.Types.ReferentialConstraints"]: Typecast;
  [13613]: Typecast;
  ["InformationSchema.Types.RoleColumnGrants"]: Typecast;
  [13627]: Typecast;
  ["InformationSchema.Types.RoleRoutineGrants"]: Typecast;
  [13690]: Typecast;
  ["InformationSchema.Types.RoleTableGrants"]: Typecast;
  [13719]: Typecast;
  ["InformationSchema.Types.RoleUdtGrants"]: Typecast;
  [13728]: Typecast;
  ["InformationSchema.Types.RoleUsageGrants"]: Typecast;
  [13617]: Typecast;
  ["InformationSchema.Types.RoutineColumnUsage"]: Typecast;
  [13622]: Typecast;
  ["InformationSchema.Types.RoutinePrivileges"]: Typecast;
  [13631]: Typecast;
  ["InformationSchema.Types.RoutineRoutineUsage"]: Typecast;
  [13636]: Typecast;
  ["InformationSchema.Types.RoutineSequenceUsage"]: Typecast;
  [13641]: Typecast;
  ["InformationSchema.Types.RoutineTableUsage"]: Typecast;
  [13646]: Typecast;
  ["InformationSchema.Types.Routines"]: Typecast;
  [13651]: Typecast;
  ["InformationSchema.Types.Schemata"]: Typecast;
  [13655]: Typecast;
  ["InformationSchema.Types.Sequences"]: Typecast;
  [13660]: Typecast;
  ["InformationSchema.Types.SqlFeatures"]: Typecast;
  [13493]: Typecast;
  ["InformationSchema.Types.SqlIdentifier"]: Typecast;
  [13665]: Typecast;
  ["InformationSchema.Types.SqlImplementationInfo"]: Typecast;
  [13670]: Typecast;
  ["InformationSchema.Types.SqlParts"]: Typecast;
  [13675]: Typecast;
  ["InformationSchema.Types.SqlSizing"]: Typecast;
  [13680]: Typecast;
  ["InformationSchema.Types.TableConstraints"]: Typecast;
  [13685]: Typecast;
  ["InformationSchema.Types.TablePrivileges"]: Typecast;
  [13694]: Typecast;
  ["InformationSchema.Types.Tables"]: Typecast;
  [13499]: Typecast;
  ["InformationSchema.Types.TimeStamp"]: Typecast;
  [13699]: Typecast;
  ["InformationSchema.Types.Transforms"]: Typecast;
  [13704]: Typecast;
  ["InformationSchema.Types.TriggeredUpdateColumns"]: Typecast;
  [13709]: Typecast;
  ["InformationSchema.Types.Triggers"]: Typecast;
  [13714]: Typecast;
  ["InformationSchema.Types.UdtPrivileges"]: Typecast;
  [13723]: Typecast;
  ["InformationSchema.Types.UsagePrivileges"]: Typecast;
  [13732]: Typecast;
  ["InformationSchema.Types.UserDefinedTypes"]: Typecast;
  [13819]: Typecast;
  ["InformationSchema.Types.UserMappingOptions"]: Typecast;
  [13824]: Typecast;
  ["InformationSchema.Types.UserMappings"]: Typecast;
  [13737]: Typecast;
  ["InformationSchema.Types.ViewColumnUsage"]: Typecast;
  [13742]: Typecast;
  ["InformationSchema.Types.ViewRoutineUsage"]: Typecast;
  [13747]: Typecast;
  ["InformationSchema.Types.ViewTableUsage"]: Typecast;
  [13752]: Typecast;
  ["InformationSchema.Types.Views"]: Typecast;
  [13501]: Typecast;
  ["InformationSchema.Types.YesOrNo"]: Typecast;
}

interface HasDatabase {
  database: Database;
}

export class Database extends PostgresDatabase implements HasDatabase {
  get database() {
    return this;
  }

  /**
   * Connect to your database server via URL, and return
   * a fully typed database you can use to access it.
   */
  static async connect(postgresUrl: string, props?: postgres.Options<never>) {
    return new Database(await initializeContext(postgresUrl, props));
  }

  public Public = new (class implements HasDatabase {
    constructor(private hasDatabase: HasDatabase) {}

    get database() {
      return this.hasDatabase.database;
    }

    public Procedures = new (class implements HasDatabase {
      constructor(private hasDatabase: HasDatabase) {}

      get database() {
        return this.hasDatabase.database;
      }

      async filmInStock(parameters: Public.Procedures.FilmInStock.Parameters) {
        const parseResult = (
          context: Context,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          result: any,
        ) => {
          return context.procTypes[27029].parseFromPostgresIfRecord(
            context,
            result,
          ) as unknown as PgCatalog.Types.Int4;
        };

        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.film_in_stock(p_film_id => ${typed[23](
                    undefinedIsNull(parameters.pFilmId),
                  )},p_store_id => ${typed[23](
                    undefinedIsNull(parameters.pStoreId),
                  )})`;
        const results = response;
        const responseBody = results.map((x) =>
          parseResult(this.database.context, x.film_in_stock),
        ) as unknown as PgCatalog.Types.Int4[];
        return responseBody;
      }
      async filmNotInStock(
        parameters: Public.Procedures.FilmNotInStock.Parameters,
      ) {
        const parseResult = (
          context: Context,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          result: any,
        ) => {
          return context.procTypes[27030].parseFromPostgresIfRecord(
            context,
            result,
          ) as unknown as PgCatalog.Types.Int4;
        };

        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.film_not_in_stock(p_film_id => ${typed[23](
                    undefinedIsNull(parameters.pFilmId),
                  )},p_store_id => ${typed[23](
                    undefinedIsNull(parameters.pStoreId),
                  )})`;
        const results = response;
        const responseBody = results.map((x) =>
          parseResult(this.database.context, x.film_not_in_stock),
        ) as unknown as PgCatalog.Types.Int4[];
        return responseBody;
      }
      async getCustomerBalance(
        parameters: Public.Procedures.GetCustomerBalance.Parameters,
      ) {
        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.get_customer_balance(p_customer_id => ${typed[23](
                    undefinedIsNull(parameters.pCustomerId),
                  )},p_effective_date => ${typed[1114](
                    undefinedIsNull(parameters.pEffectiveDate),
                  )})`;
        const results = response;
        const responseBody = results?.[0]
          .get_customer_balance as unknown as PgCatalog.Types.Numeric;
        return responseBody;
      }
      async inventoryHeldByCustomer(
        parameters: Public.Procedures.InventoryHeldByCustomer.Parameters,
      ) {
        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.inventory_held_by_customer(p_inventory_id => ${typed[23](
                    undefinedIsNull(parameters.pInventoryId),
                  )})`;
        const results = response;
        const responseBody = results?.[0]
          .inventory_held_by_customer as unknown as PgCatalog.Types.Int4;
        return responseBody;
      }
      async inventoryInStock(
        parameters: Public.Procedures.InventoryInStock.Parameters,
      ) {
        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.inventory_in_stock(p_inventory_id => ${typed[23](
                    undefinedIsNull(parameters.pInventoryId),
                  )})`;
        const results = response;
        const responseBody = results?.[0]
          .inventory_in_stock as unknown as PgCatalog.Types.Bool;
        return responseBody;
      }
      async lastDay(parameters: Public.Procedures.LastDay.Parameters) {
        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.last_day( ${typed[1114](
                    undefinedIsNull(parameters.argument_0),
                  )})`;
        const results = response;
        const responseBody = results?.[0]
          .last_day as unknown as PgCatalog.Types.Date;
        return responseBody;
      }
      async rewardsReport(
        parameters: Public.Procedures.RewardsReport.Parameters,
      ) {
        console.assert(parameters);
        const sql = this.database.context.sql;
        const typed = sql.typed as unknown as PostgresTypecasts;
        const response = await sql`
                  SELECT
                  public.rewards_report(min_monthly_purchases => ${typed[23](
                    undefinedIsNull(parameters.minMonthlyPurchases),
                  )},min_dollar_amount_purchased => ${typed[1700](
                    undefinedIsNull(parameters.minDollarAmountPurchased),
                  )})`;
        const results = response;
        const responseBody = results.map(
          (x) => x.rewards_report,
        ) as unknown as Public.Types.Customer[];
        return responseBody;
      }
    })(this);

    public Tables = new (class implements HasDatabase {
      constructor(private hasDatabase: HasDatabase) {}

      get database() {
        return this.hasDatabase.database;
      }

      public FilmActor = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.FilmActor.Values,
        ): Promise<Public.Tables.FilmActor.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          const response = await sql`
    INSERT INTO
      public.film_actor (actor_id,film_id,last_update)
    VALUES (${
      values.actorId === undefined ? sql`DEFAULT` : typed[21](values.actorId)
    },${
      values.filmId === undefined ? sql`DEFAULT` : typed[21](values.filmId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (actor_id,film_id) DO UPDATE
    SET
      last_update = EXCLUDED.last_update
    RETURNING
      actor_id,film_id,last_update
    `;
          return response.map((record) => ({
            actorId: undefinedIsNull(record.actor_id),
            filmId: undefinedIsNull(record.film_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByActorIdFilmId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.FilmActor.ByActorIdFilmId,
          ): Promise<Public.Tables.FilmActor.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      actor_id,film_id,last_update 
    FROM
      public.film_actor 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.actorId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    `;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.FilmActor.ByActorIdFilmId,
            values: Partial<Public.Tables.FilmActor.Values>,
          ): Promise<Public.Tables.FilmActor.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film_actor 
    SET
      actor_id = ${
        values.actorId === undefined ? sql`actor_id` : typed[21](values.actorId)
      } , film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[21](values.filmId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.actorId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING actor_id,film_id,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.FilmActor.ByActorIdFilmId,
          ): Promise<Public.Tables.FilmActor.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film_actor 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.actorId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING actor_id,film_id,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByFilmId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.FilmActor.ByFilmId,
          ): Promise<Public.Tables.FilmActor.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      actor_id,film_id,last_update 
    FROM
      public.film_actor 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    `;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.FilmActor.ByFilmId,
            values: Partial<Public.Tables.FilmActor.Values>,
          ): Promise<Public.Tables.FilmActor.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film_actor 
    SET
      actor_id = ${
        values.actorId === undefined ? sql`actor_id` : typed[21](values.actorId)
      } , film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[21](values.filmId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING actor_id,film_id,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.FilmActor.ByFilmId,
          ): Promise<Public.Tables.FilmActor.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film_actor 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING actor_id,film_id,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              filmId: undefinedIsNull(record.film_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);
      })(this);

      public Address = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Address.Values,
        ): Promise<Public.Tables.Address.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Address.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.address (address,address2,district,city_id,postal_code,phone,last_update)
      VALUES (${
        values.address === undefined
          ? sql`DEFAULT`
          : typed[1043](values.address)
      },${
        values.address2 === undefined
          ? sql`DEFAULT`
          : typed[1043](values.address2)
      },${
        values.district === undefined
          ? sql`DEFAULT`
          : typed[1043](values.district)
      },${
        values.cityId === undefined ? sql`DEFAULT` : typed[21](values.cityId)
      },${
        values.postalCode === undefined
          ? sql`DEFAULT`
          : typed[1043](values.postalCode)
      },${
        values.phone === undefined ? sql`DEFAULT` : typed[1043](values.phone)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        address_id,address,address2,district,city_id,postal_code,phone,last_update
    `;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.address (address_id,address,address2,district,city_id,postal_code,phone,last_update)
    VALUES (${
      values.addressId === undefined
        ? sql`DEFAULT`
        : typed[23](values.addressId)
    },${
      values.address === undefined ? sql`DEFAULT` : typed[1043](values.address)
    },${
      values.address2 === undefined
        ? sql`DEFAULT`
        : typed[1043](values.address2)
    },${
      values.district === undefined
        ? sql`DEFAULT`
        : typed[1043](values.district)
    },${
      values.cityId === undefined ? sql`DEFAULT` : typed[21](values.cityId)
    },${
      values.postalCode === undefined
        ? sql`DEFAULT`
        : typed[1043](values.postalCode)
    },${
      values.phone === undefined ? sql`DEFAULT` : typed[1043](values.phone)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (address_id) DO UPDATE
    SET
      address = EXCLUDED.address,address2 = EXCLUDED.address2,district = EXCLUDED.district,city_id = EXCLUDED.city_id,postal_code = EXCLUDED.postal_code,phone = EXCLUDED.phone,last_update = EXCLUDED.last_update
    RETURNING
      address_id,address,address2,district,city_id,postal_code,phone,last_update
    `;
          return response.map((record) => ({
            addressId: undefinedIsNull(record.address_id),
            address: undefinedIsNull(record.address),
            address2: undefinedIsNull(record.address2),
            district: undefinedIsNull(record.district),
            cityId: undefinedIsNull(record.city_id),
            postalCode: undefinedIsNull(record.postal_code),
            phone: undefinedIsNull(record.phone),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByAddressId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Address.ByAddressId,
          ): Promise<Public.Tables.Address.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      address_id,address,address2,district,city_id,postal_code,phone,last_update 
    FROM
      public.address 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.addressId)
      }
    `;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Address.ByAddressId,
            values: Partial<Public.Tables.Address.Values>,
          ): Promise<Public.Tables.Address.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.address 
    SET
      address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[23](values.addressId)
      } , address = ${
        values.address === undefined
          ? sql`address`
          : typed[1043](values.address)
      } , address2 = ${
        values.address2 === undefined
          ? sql`address2`
          : typed[1043](values.address2)
      } , district = ${
        values.district === undefined
          ? sql`district`
          : typed[1043](values.district)
      } , city_id = ${
        values.cityId === undefined ? sql`city_id` : typed[21](values.cityId)
      } , postal_code = ${
        values.postalCode === undefined
          ? sql`postal_code`
          : typed[1043](values.postalCode)
      } , phone = ${
        values.phone === undefined ? sql`phone` : typed[1043](values.phone)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.addressId)
      }
    RETURNING address_id,address,address2,district,city_id,postal_code,phone,last_update`;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Address.ByAddressId,
          ): Promise<Public.Tables.Address.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.address 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.addressId)
      }
    RETURNING address_id,address,address2,district,city_id,postal_code,phone,last_update`;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByCityId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Address.ByCityId,
          ): Promise<Public.Tables.Address.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      address_id,address,address2,district,city_id,postal_code,phone,last_update 
    FROM
      public.address 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.cityId)
      }
    `;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.Address.ByCityId,
            values: Partial<Public.Tables.Address.Values>,
          ): Promise<Public.Tables.Address.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.address 
    SET
      address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[23](values.addressId)
      } , address = ${
        values.address === undefined
          ? sql`address`
          : typed[1043](values.address)
      } , address2 = ${
        values.address2 === undefined
          ? sql`address2`
          : typed[1043](values.address2)
      } , district = ${
        values.district === undefined
          ? sql`district`
          : typed[1043](values.district)
      } , city_id = ${
        values.cityId === undefined ? sql`city_id` : typed[21](values.cityId)
      } , postal_code = ${
        values.postalCode === undefined
          ? sql`postal_code`
          : typed[1043](values.postalCode)
      } , phone = ${
        values.phone === undefined ? sql`phone` : typed[1043](values.phone)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.cityId)
      }
    RETURNING address_id,address,address2,district,city_id,postal_code,phone,last_update`;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.Address.ByCityId,
          ): Promise<Public.Tables.Address.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.address 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.cityId)
      }
    RETURNING address_id,address,address2,district,city_id,postal_code,phone,last_update`;
            return response.map((record) => ({
              addressId: undefinedIsNull(record.address_id),
              address: undefinedIsNull(record.address),
              address2: undefinedIsNull(record.address2),
              district: undefinedIsNull(record.district),
              cityId: undefinedIsNull(record.city_id),
              postalCode: undefinedIsNull(record.postal_code),
              phone: undefinedIsNull(record.phone),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);
      })(this);

      public City = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.City.Values,
        ): Promise<Public.Tables.City.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.City.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.city (city,country_id,last_update)
      VALUES (${
        values.city === undefined ? sql`DEFAULT` : typed[1043](values.city)
      },${
        values.countryId === undefined
          ? sql`DEFAULT`
          : typed[21](values.countryId)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        city_id,city,country_id,last_update
    `;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.city (city_id,city,country_id,last_update)
    VALUES (${
      values.cityId === undefined ? sql`DEFAULT` : typed[23](values.cityId)
    },${values.city === undefined ? sql`DEFAULT` : typed[1043](values.city)},${
      values.countryId === undefined
        ? sql`DEFAULT`
        : typed[21](values.countryId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (city_id) DO UPDATE
    SET
      city = EXCLUDED.city,country_id = EXCLUDED.country_id,last_update = EXCLUDED.last_update
    RETURNING
      city_id,city,country_id,last_update
    `;
          return response.map((record) => ({
            cityId: undefinedIsNull(record.city_id),
            city: undefinedIsNull(record.city),
            countryId: undefinedIsNull(record.country_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByCityId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.City.ByCityId,
          ): Promise<Public.Tables.City.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      city_id,city,country_id,last_update 
    FROM
      public.city 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.cityId)
      }
    `;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.City.ByCityId,
            values: Partial<Public.Tables.City.Values>,
          ): Promise<Public.Tables.City.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.city 
    SET
      city_id = ${
        values.cityId === undefined ? sql`city_id` : typed[23](values.cityId)
      } , city = ${
        values.city === undefined ? sql`city` : typed[1043](values.city)
      } , country_id = ${
        values.countryId === undefined
          ? sql`country_id`
          : typed[21](values.countryId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.cityId)
      }
    RETURNING city_id,city,country_id,last_update`;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.City.ByCityId,
          ): Promise<Public.Tables.City.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.city 
    WHERE
      city_id = ${
        parameters.cityId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.cityId)
      }
    RETURNING city_id,city,country_id,last_update`;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByCountryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.City.ByCountryId,
          ): Promise<Public.Tables.City.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      city_id,city,country_id,last_update 
    FROM
      public.city 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.countryId)
      }
    `;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.City.ByCountryId,
            values: Partial<Public.Tables.City.Values>,
          ): Promise<Public.Tables.City.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.city 
    SET
      city_id = ${
        values.cityId === undefined ? sql`city_id` : typed[23](values.cityId)
      } , city = ${
        values.city === undefined ? sql`city` : typed[1043](values.city)
      } , country_id = ${
        values.countryId === undefined
          ? sql`country_id`
          : typed[21](values.countryId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.countryId)
      }
    RETURNING city_id,city,country_id,last_update`;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.City.ByCountryId,
          ): Promise<Public.Tables.City.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.city 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.countryId)
      }
    RETURNING city_id,city,country_id,last_update`;
            return response.map((record) => ({
              cityId: undefinedIsNull(record.city_id),
              city: undefinedIsNull(record.city),
              countryId: undefinedIsNull(record.country_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);
      })(this);

      public Customer = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Customer.Values,
        ): Promise<Public.Tables.Customer.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Customer.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.customer (store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active)
      VALUES (${
        values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
      },${
        values.firstName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.firstName)
      },${
        values.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.lastName)
      },${
        values.email === undefined ? sql`DEFAULT` : typed[1043](values.email)
      },${
        values.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](values.addressId)
      },${
        values.activebool === undefined
          ? sql`DEFAULT`
          : typed[16](values.activebool)
      },${
        values.createDate === undefined
          ? sql`DEFAULT`
          : typed[1082](values.createDate)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      },${
        values.active === undefined ? sql`DEFAULT` : typed[23](values.active)
      })
      RETURNING
        customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active
    `;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.customer (customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active)
    VALUES (${
      values.customerId === undefined
        ? sql`DEFAULT`
        : typed[23](values.customerId)
    },${
      values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
    },${
      values.firstName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.firstName)
    },${
      values.lastName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.lastName)
    },${
      values.email === undefined ? sql`DEFAULT` : typed[1043](values.email)
    },${
      values.addressId === undefined
        ? sql`DEFAULT`
        : typed[21](values.addressId)
    },${
      values.activebool === undefined
        ? sql`DEFAULT`
        : typed[16](values.activebool)
    },${
      values.createDate === undefined
        ? sql`DEFAULT`
        : typed[1082](values.createDate)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    },${values.active === undefined ? sql`DEFAULT` : typed[23](values.active)})
    ON CONFLICT (customer_id) DO UPDATE
    SET
      store_id = EXCLUDED.store_id,first_name = EXCLUDED.first_name,last_name = EXCLUDED.last_name,email = EXCLUDED.email,address_id = EXCLUDED.address_id,activebool = EXCLUDED.activebool,create_date = EXCLUDED.create_date,last_update = EXCLUDED.last_update,active = EXCLUDED.active
    RETURNING
      customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active
    `;
          return response.map((record) => ({
            customerId: undefinedIsNull(record.customer_id),
            storeId: undefinedIsNull(record.store_id),
            firstName: undefinedIsNull(record.first_name),
            lastName: undefinedIsNull(record.last_name),
            email: undefinedIsNull(record.email),
            addressId: undefinedIsNull(record.address_id),
            activebool: undefinedIsNull(record.activebool),
            createDate: undefinedIsNull(record.create_date),
            lastUpdate: undefinedIsNull(record.last_update),
            active: undefinedIsNull(record.active),
          }))[0];
        }

        public ByAddressId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Customer.ByAddressId,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active 
    FROM
      public.customer 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.addressId)
      }
    `;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async update(
            parameters: Public.Tables.Customer.ByAddressId,
            values: Partial<Public.Tables.Customer.Values>,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.customer 
    SET
      customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[23](values.customerId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , email = ${
        values.email === undefined ? sql`email` : typed[1043](values.email)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , activebool = ${
        values.activebool === undefined
          ? sql`activebool`
          : typed[16](values.activebool)
      } , create_date = ${
        values.createDate === undefined
          ? sql`create_date`
          : typed[1082](values.createDate)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , active = ${
        values.active === undefined ? sql`active` : typed[23](values.active)
      } 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.addressId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async delete(
            parameters: Public.Tables.Customer.ByAddressId,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.customer 
    WHERE
      address_id = ${
        parameters.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.addressId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }
        })(this);

        public ByCustomerId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Customer.ByCustomerId,
          ): Promise<Public.Tables.Customer.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active 
    FROM
      public.customer 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.customerId)
      }
    `;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Customer.ByCustomerId,
            values: Partial<Public.Tables.Customer.Values>,
          ): Promise<Public.Tables.Customer.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.customer 
    SET
      customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[23](values.customerId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , email = ${
        values.email === undefined ? sql`email` : typed[1043](values.email)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , activebool = ${
        values.activebool === undefined
          ? sql`activebool`
          : typed[16](values.activebool)
      } , create_date = ${
        values.createDate === undefined
          ? sql`create_date`
          : typed[1082](values.createDate)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , active = ${
        values.active === undefined ? sql`active` : typed[23](values.active)
      } 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.customerId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Customer.ByCustomerId,
          ): Promise<Public.Tables.Customer.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.customer 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.customerId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }))[0];
          }
        })(this);

        public ByLastName = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Customer.ByLastName,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active 
    FROM
      public.customer 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    `;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async update(
            parameters: Public.Tables.Customer.ByLastName,
            values: Partial<Public.Tables.Customer.Values>,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.customer 
    SET
      customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[23](values.customerId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , email = ${
        values.email === undefined ? sql`email` : typed[1043](values.email)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , activebool = ${
        values.activebool === undefined
          ? sql`activebool`
          : typed[16](values.activebool)
      } , create_date = ${
        values.createDate === undefined
          ? sql`create_date`
          : typed[1082](values.createDate)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , active = ${
        values.active === undefined ? sql`active` : typed[23](values.active)
      } 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async delete(
            parameters: Public.Tables.Customer.ByLastName,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.customer 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }
        })(this);

        public ByStoreId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Customer.ByStoreId,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active 
    FROM
      public.customer 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      }
    `;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async update(
            parameters: Public.Tables.Customer.ByStoreId,
            values: Partial<Public.Tables.Customer.Values>,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.customer 
    SET
      customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[23](values.customerId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , email = ${
        values.email === undefined ? sql`email` : typed[1043](values.email)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , activebool = ${
        values.activebool === undefined
          ? sql`activebool`
          : typed[16](values.activebool)
      } , create_date = ${
        values.createDate === undefined
          ? sql`create_date`
          : typed[1082](values.createDate)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , active = ${
        values.active === undefined ? sql`active` : typed[23](values.active)
      } 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }

          async delete(
            parameters: Public.Tables.Customer.ByStoreId,
          ): Promise<Public.Tables.Customer.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.customer 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      }
    RETURNING customer_id,store_id,first_name,last_name,email,address_id,activebool,create_date,last_update,active`;
            return response.map((record) => ({
              customerId: undefinedIsNull(record.customer_id),
              storeId: undefinedIsNull(record.store_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              email: undefinedIsNull(record.email),
              addressId: undefinedIsNull(record.address_id),
              activebool: undefinedIsNull(record.activebool),
              createDate: undefinedIsNull(record.create_date),
              lastUpdate: undefinedIsNull(record.last_update),
              active: undefinedIsNull(record.active),
            }));
          }
        })(this);
      })(this);

      public Actor = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Actor.Values,
        ): Promise<Public.Tables.Actor.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Actor.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.actor (first_name,last_name,last_update)
      VALUES (${
        values.firstName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.firstName)
      },${
        values.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.lastName)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        actor_id,first_name,last_name,last_update
    `;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.actor (actor_id,first_name,last_name,last_update)
    VALUES (${
      values.actorId === undefined ? sql`DEFAULT` : typed[23](values.actorId)
    },${
      values.firstName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.firstName)
    },${
      values.lastName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.lastName)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (actor_id) DO UPDATE
    SET
      first_name = EXCLUDED.first_name,last_name = EXCLUDED.last_name,last_update = EXCLUDED.last_update
    RETURNING
      actor_id,first_name,last_name,last_update
    `;
          return response.map((record) => ({
            actorId: undefinedIsNull(record.actor_id),
            firstName: undefinedIsNull(record.first_name),
            lastName: undefinedIsNull(record.last_name),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByActorId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Actor.ByActorId,
          ): Promise<Public.Tables.Actor.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      actor_id,first_name,last_name,last_update 
    FROM
      public.actor 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.actorId)
      }
    `;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Actor.ByActorId,
            values: Partial<Public.Tables.Actor.Values>,
          ): Promise<Public.Tables.Actor.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.actor 
    SET
      actor_id = ${
        values.actorId === undefined ? sql`actor_id` : typed[23](values.actorId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.actorId)
      }
    RETURNING actor_id,first_name,last_name,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Actor.ByActorId,
          ): Promise<Public.Tables.Actor.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.actor 
    WHERE
      actor_id = ${
        parameters.actorId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.actorId)
      }
    RETURNING actor_id,first_name,last_name,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByLastName = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Actor.ByLastName,
          ): Promise<Public.Tables.Actor.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      actor_id,first_name,last_name,last_update 
    FROM
      public.actor 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    `;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.Actor.ByLastName,
            values: Partial<Public.Tables.Actor.Values>,
          ): Promise<Public.Tables.Actor.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.actor 
    SET
      actor_id = ${
        values.actorId === undefined ? sql`actor_id` : typed[23](values.actorId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    RETURNING actor_id,first_name,last_name,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.Actor.ByLastName,
          ): Promise<Public.Tables.Actor.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.actor 
    WHERE
      last_name = ${
        parameters.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.lastName)
      }
    RETURNING actor_id,first_name,last_name,last_update`;
            return response.map((record) => ({
              actorId: undefinedIsNull(record.actor_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);
      })(this);

      public FilmCategory = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.FilmCategory.Values,
        ): Promise<Public.Tables.FilmCategory.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          const response = await sql`
    INSERT INTO
      public.film_category (film_id,category_id,last_update)
    VALUES (${
      values.filmId === undefined ? sql`DEFAULT` : typed[21](values.filmId)
    },${
      values.categoryId === undefined
        ? sql`DEFAULT`
        : typed[21](values.categoryId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (film_id,category_id) DO UPDATE
    SET
      last_update = EXCLUDED.last_update
    RETURNING
      film_id,category_id,last_update
    `;
          return response.map((record) => ({
            filmId: undefinedIsNull(record.film_id),
            categoryId: undefinedIsNull(record.category_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByFilmIdCategoryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.FilmCategory.ByFilmIdCategoryId,
          ): Promise<Public.Tables.FilmCategory.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      film_id,category_id,last_update 
    FROM
      public.film_category 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      } AND category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.categoryId)
      }
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              categoryId: undefinedIsNull(record.category_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.FilmCategory.ByFilmIdCategoryId,
            values: Partial<Public.Tables.FilmCategory.Values>,
          ): Promise<Public.Tables.FilmCategory.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film_category 
    SET
      film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[21](values.filmId)
      } , category_id = ${
        values.categoryId === undefined
          ? sql`category_id`
          : typed[21](values.categoryId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      } AND category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.categoryId)
      }
    RETURNING film_id,category_id,last_update`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              categoryId: undefinedIsNull(record.category_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.FilmCategory.ByFilmIdCategoryId,
          ): Promise<Public.Tables.FilmCategory.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film_category 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      } AND category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.categoryId)
      }
    RETURNING film_id,category_id,last_update`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              categoryId: undefinedIsNull(record.category_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Inventory = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Inventory.Values,
        ): Promise<Public.Tables.Inventory.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Inventory.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.inventory (film_id,store_id,last_update)
      VALUES (${
        values.filmId === undefined ? sql`DEFAULT` : typed[21](values.filmId)
      },${
        values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        inventory_id,film_id,store_id,last_update
    `;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.inventory (inventory_id,film_id,store_id,last_update)
    VALUES (${
      values.inventoryId === undefined
        ? sql`DEFAULT`
        : typed[23](values.inventoryId)
    },${
      values.filmId === undefined ? sql`DEFAULT` : typed[21](values.filmId)
    },${
      values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (inventory_id) DO UPDATE
    SET
      film_id = EXCLUDED.film_id,store_id = EXCLUDED.store_id,last_update = EXCLUDED.last_update
    RETURNING
      inventory_id,film_id,store_id,last_update
    `;
          return response.map((record) => ({
            inventoryId: undefinedIsNull(record.inventory_id),
            filmId: undefinedIsNull(record.film_id),
            storeId: undefinedIsNull(record.store_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByInventoryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Inventory.ByInventoryId,
          ): Promise<Public.Tables.Inventory.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      inventory_id,film_id,store_id,last_update 
    FROM
      public.inventory 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    `;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Inventory.ByInventoryId,
            values: Partial<Public.Tables.Inventory.Values>,
          ): Promise<Public.Tables.Inventory.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.inventory 
    SET
      inventory_id = ${
        values.inventoryId === undefined
          ? sql`inventory_id`
          : typed[23](values.inventoryId)
      } , film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[21](values.filmId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    RETURNING inventory_id,film_id,store_id,last_update`;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Inventory.ByInventoryId,
          ): Promise<Public.Tables.Inventory.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.inventory 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    RETURNING inventory_id,film_id,store_id,last_update`;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByStoreIdFilmId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Inventory.ByStoreIdFilmId,
          ): Promise<Public.Tables.Inventory.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      inventory_id,film_id,store_id,last_update 
    FROM
      public.inventory 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    `;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.Inventory.ByStoreIdFilmId,
            values: Partial<Public.Tables.Inventory.Values>,
          ): Promise<Public.Tables.Inventory.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.inventory 
    SET
      inventory_id = ${
        values.inventoryId === undefined
          ? sql`inventory_id`
          : typed[23](values.inventoryId)
      } , film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[21](values.filmId)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING inventory_id,film_id,store_id,last_update`;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.Inventory.ByStoreIdFilmId,
          ): Promise<Public.Tables.Inventory.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.inventory 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.storeId)
      } AND film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.filmId)
      }
    RETURNING inventory_id,film_id,store_id,last_update`;
            return response.map((record) => ({
              inventoryId: undefinedIsNull(record.inventory_id),
              filmId: undefinedIsNull(record.film_id),
              storeId: undefinedIsNull(record.store_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);
      })(this);

      public Category = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Category.Values,
        ): Promise<Public.Tables.Category.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Category.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.category (name,last_update)
      VALUES (${
        values.name === undefined ? sql`DEFAULT` : typed[1043](values.name)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        category_id,name,last_update
    `;
            return response.map((record) => ({
              categoryId: undefinedIsNull(record.category_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.category (category_id,name,last_update)
    VALUES (${
      values.categoryId === undefined
        ? sql`DEFAULT`
        : typed[23](values.categoryId)
    },${values.name === undefined ? sql`DEFAULT` : typed[1043](values.name)},${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (category_id) DO UPDATE
    SET
      name = EXCLUDED.name,last_update = EXCLUDED.last_update
    RETURNING
      category_id,name,last_update
    `;
          return response.map((record) => ({
            categoryId: undefinedIsNull(record.category_id),
            name: undefinedIsNull(record.name),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByCategoryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Category.ByCategoryId,
          ): Promise<Public.Tables.Category.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      category_id,name,last_update 
    FROM
      public.category 
    WHERE
      category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.categoryId)
      }
    `;
            return response.map((record) => ({
              categoryId: undefinedIsNull(record.category_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Category.ByCategoryId,
            values: Partial<Public.Tables.Category.Values>,
          ): Promise<Public.Tables.Category.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.category 
    SET
      category_id = ${
        values.categoryId === undefined
          ? sql`category_id`
          : typed[23](values.categoryId)
      } , name = ${
        values.name === undefined ? sql`name` : typed[1043](values.name)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.categoryId)
      }
    RETURNING category_id,name,last_update`;
            return response.map((record) => ({
              categoryId: undefinedIsNull(record.category_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Category.ByCategoryId,
          ): Promise<Public.Tables.Category.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.category 
    WHERE
      category_id = ${
        parameters.categoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.categoryId)
      }
    RETURNING category_id,name,last_update`;
            return response.map((record) => ({
              categoryId: undefinedIsNull(record.category_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Country = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Country.Values,
        ): Promise<Public.Tables.Country.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Country.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.country (country,last_update)
      VALUES (${
        values.country === undefined
          ? sql`DEFAULT`
          : typed[1043](values.country)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        country_id,country,last_update
    `;
            return response.map((record) => ({
              countryId: undefinedIsNull(record.country_id),
              country: undefinedIsNull(record.country),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.country (country_id,country,last_update)
    VALUES (${
      values.countryId === undefined
        ? sql`DEFAULT`
        : typed[23](values.countryId)
    },${
      values.country === undefined ? sql`DEFAULT` : typed[1043](values.country)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (country_id) DO UPDATE
    SET
      country = EXCLUDED.country,last_update = EXCLUDED.last_update
    RETURNING
      country_id,country,last_update
    `;
          return response.map((record) => ({
            countryId: undefinedIsNull(record.country_id),
            country: undefinedIsNull(record.country),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByCountryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Country.ByCountryId,
          ): Promise<Public.Tables.Country.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      country_id,country,last_update 
    FROM
      public.country 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.countryId)
      }
    `;
            return response.map((record) => ({
              countryId: undefinedIsNull(record.country_id),
              country: undefinedIsNull(record.country),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Country.ByCountryId,
            values: Partial<Public.Tables.Country.Values>,
          ): Promise<Public.Tables.Country.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.country 
    SET
      country_id = ${
        values.countryId === undefined
          ? sql`country_id`
          : typed[23](values.countryId)
      } , country = ${
        values.country === undefined
          ? sql`country`
          : typed[1043](values.country)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.countryId)
      }
    RETURNING country_id,country,last_update`;
            return response.map((record) => ({
              countryId: undefinedIsNull(record.country_id),
              country: undefinedIsNull(record.country),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Country.ByCountryId,
          ): Promise<Public.Tables.Country.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.country 
    WHERE
      country_id = ${
        parameters.countryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.countryId)
      }
    RETURNING country_id,country,last_update`;
            return response.map((record) => ({
              countryId: undefinedIsNull(record.country_id),
              country: undefinedIsNull(record.country),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Language = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Language.Values,
        ): Promise<Public.Tables.Language.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Language.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.language (name,last_update)
      VALUES (${
        values.name === undefined ? sql`DEFAULT` : typed[1042](values.name)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        language_id,name,last_update
    `;
            return response.map((record) => ({
              languageId: undefinedIsNull(record.language_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.language (language_id,name,last_update)
    VALUES (${
      values.languageId === undefined
        ? sql`DEFAULT`
        : typed[23](values.languageId)
    },${values.name === undefined ? sql`DEFAULT` : typed[1042](values.name)},${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (language_id) DO UPDATE
    SET
      name = EXCLUDED.name,last_update = EXCLUDED.last_update
    RETURNING
      language_id,name,last_update
    `;
          return response.map((record) => ({
            languageId: undefinedIsNull(record.language_id),
            name: undefinedIsNull(record.name),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByLanguageId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Language.ByLanguageId,
          ): Promise<Public.Tables.Language.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      language_id,name,last_update 
    FROM
      public.language 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.languageId)
      }
    `;
            return response.map((record) => ({
              languageId: undefinedIsNull(record.language_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Language.ByLanguageId,
            values: Partial<Public.Tables.Language.Values>,
          ): Promise<Public.Tables.Language.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.language 
    SET
      language_id = ${
        values.languageId === undefined
          ? sql`language_id`
          : typed[23](values.languageId)
      } , name = ${
        values.name === undefined ? sql`name` : typed[1042](values.name)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.languageId)
      }
    RETURNING language_id,name,last_update`;
            return response.map((record) => ({
              languageId: undefinedIsNull(record.language_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Language.ByLanguageId,
          ): Promise<Public.Tables.Language.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.language 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.languageId)
      }
    RETURNING language_id,name,last_update`;
            return response.map((record) => ({
              languageId: undefinedIsNull(record.language_id),
              name: undefinedIsNull(record.name),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Rental = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Rental.Values,
        ): Promise<Public.Tables.Rental.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Rental.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.rental (rental_date,inventory_id,customer_id,return_date,staff_id,last_update)
      VALUES (${
        values.rentalDate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.rentalDate)
      },${
        values.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](values.inventoryId)
      },${
        values.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](values.customerId)
      },${
        values.returnDate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.returnDate)
      },${
        values.staffId === undefined ? sql`DEFAULT` : typed[21](values.staffId)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update
    `;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.rental (rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update)
    VALUES (${
      values.rentalId === undefined ? sql`DEFAULT` : typed[23](values.rentalId)
    },${
      values.rentalDate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.rentalDate)
    },${
      values.inventoryId === undefined
        ? sql`DEFAULT`
        : typed[23](values.inventoryId)
    },${
      values.customerId === undefined
        ? sql`DEFAULT`
        : typed[21](values.customerId)
    },${
      values.returnDate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.returnDate)
    },${
      values.staffId === undefined ? sql`DEFAULT` : typed[21](values.staffId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (rental_id) DO UPDATE
    SET
      rental_date = EXCLUDED.rental_date,inventory_id = EXCLUDED.inventory_id,customer_id = EXCLUDED.customer_id,return_date = EXCLUDED.return_date,staff_id = EXCLUDED.staff_id,last_update = EXCLUDED.last_update
    RETURNING
      rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update
    `;
          return response.map((record) => ({
            rentalId: undefinedIsNull(record.rental_id),
            rentalDate: undefinedIsNull(record.rental_date),
            inventoryId: undefinedIsNull(record.inventory_id),
            customerId: undefinedIsNull(record.customer_id),
            returnDate: undefinedIsNull(record.return_date),
            staffId: undefinedIsNull(record.staff_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByInventoryId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Rental.ByInventoryId,
          ): Promise<Public.Tables.Rental.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update 
    FROM
      public.rental 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    `;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async update(
            parameters: Public.Tables.Rental.ByInventoryId,
            values: Partial<Public.Tables.Rental.Values>,
          ): Promise<Public.Tables.Rental.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.rental 
    SET
      rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , rental_date = ${
        values.rentalDate === undefined
          ? sql`rental_date`
          : typed[1114](values.rentalDate)
      } , inventory_id = ${
        values.inventoryId === undefined
          ? sql`inventory_id`
          : typed[23](values.inventoryId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , return_date = ${
        values.returnDate === undefined
          ? sql`return_date`
          : typed[1114](values.returnDate)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }

          async delete(
            parameters: Public.Tables.Rental.ByInventoryId,
          ): Promise<Public.Tables.Rental.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.rental 
    WHERE
      inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }));
          }
        })(this);

        public ByRentalDateInventoryIdCustomerId = new (class
          implements HasDatabase
        {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update 
    FROM
      public.rental 
    WHERE
      rental_date = ${
        parameters.rentalDate === undefined
          ? sql`DEFAULT`
          : typed[1114](parameters.rentalDate)
      } AND inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      } AND customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    `;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
            values: Partial<Public.Tables.Rental.Values>,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.rental 
    SET
      rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , rental_date = ${
        values.rentalDate === undefined
          ? sql`rental_date`
          : typed[1114](values.rentalDate)
      } , inventory_id = ${
        values.inventoryId === undefined
          ? sql`inventory_id`
          : typed[23](values.inventoryId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , return_date = ${
        values.returnDate === undefined
          ? sql`return_date`
          : typed[1114](values.returnDate)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      rental_date = ${
        parameters.rentalDate === undefined
          ? sql`DEFAULT`
          : typed[1114](parameters.rentalDate)
      } AND inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      } AND customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.rental 
    WHERE
      rental_date = ${
        parameters.rentalDate === undefined
          ? sql`DEFAULT`
          : typed[1114](parameters.rentalDate)
      } AND inventory_id = ${
        parameters.inventoryId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.inventoryId)
      } AND customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByRentalId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Rental.ByRentalId,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update 
    FROM
      public.rental 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    `;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Rental.ByRentalId,
            values: Partial<Public.Tables.Rental.Values>,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.rental 
    SET
      rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , rental_date = ${
        values.rentalDate === undefined
          ? sql`rental_date`
          : typed[1114](values.rentalDate)
      } , inventory_id = ${
        values.inventoryId === undefined
          ? sql`inventory_id`
          : typed[23](values.inventoryId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , return_date = ${
        values.returnDate === undefined
          ? sql`return_date`
          : typed[1114](values.returnDate)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Rental.ByRentalId,
          ): Promise<Public.Tables.Rental.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.rental 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    RETURNING rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update`;
            return response.map((record) => ({
              rentalId: undefinedIsNull(record.rental_id),
              rentalDate: undefinedIsNull(record.rental_date),
              inventoryId: undefinedIsNull(record.inventory_id),
              customerId: undefinedIsNull(record.customer_id),
              returnDate: undefinedIsNull(record.return_date),
              staffId: undefinedIsNull(record.staff_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Staff = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Staff.Values,
        ): Promise<Public.Tables.Staff.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Staff.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.staff (first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture)
      VALUES (${
        values.firstName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.firstName)
      },${
        values.lastName === undefined
          ? sql`DEFAULT`
          : typed[1043](values.lastName)
      },${
        values.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](values.addressId)
      },${
        values.email === undefined ? sql`DEFAULT` : typed[1043](values.email)
      },${
        values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
      },${
        values.active === undefined ? sql`DEFAULT` : typed[16](values.active)
      },${
        values.username === undefined
          ? sql`DEFAULT`
          : typed[1043](values.username)
      },${
        values.password === undefined
          ? sql`DEFAULT`
          : typed[1043](values.password)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      },${
        values.picture === undefined ? sql`DEFAULT` : typed[17](values.picture)
      })
      RETURNING
        staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture
    `;
            return response.map((record) => ({
              staffId: undefinedIsNull(record.staff_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              addressId: undefinedIsNull(record.address_id),
              email: undefinedIsNull(record.email),
              storeId: undefinedIsNull(record.store_id),
              active: undefinedIsNull(record.active),
              username: undefinedIsNull(record.username),
              password: undefinedIsNull(record.password),
              lastUpdate: undefinedIsNull(record.last_update),
              picture: undefinedIsNull(record.picture),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.staff (staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture)
    VALUES (${
      values.staffId === undefined ? sql`DEFAULT` : typed[23](values.staffId)
    },${
      values.firstName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.firstName)
    },${
      values.lastName === undefined
        ? sql`DEFAULT`
        : typed[1043](values.lastName)
    },${
      values.addressId === undefined
        ? sql`DEFAULT`
        : typed[21](values.addressId)
    },${
      values.email === undefined ? sql`DEFAULT` : typed[1043](values.email)
    },${
      values.storeId === undefined ? sql`DEFAULT` : typed[21](values.storeId)
    },${
      values.active === undefined ? sql`DEFAULT` : typed[16](values.active)
    },${
      values.username === undefined
        ? sql`DEFAULT`
        : typed[1043](values.username)
    },${
      values.password === undefined
        ? sql`DEFAULT`
        : typed[1043](values.password)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    },${
      values.picture === undefined ? sql`DEFAULT` : typed[17](values.picture)
    })
    ON CONFLICT (staff_id) DO UPDATE
    SET
      first_name = EXCLUDED.first_name,last_name = EXCLUDED.last_name,address_id = EXCLUDED.address_id,email = EXCLUDED.email,store_id = EXCLUDED.store_id,active = EXCLUDED.active,username = EXCLUDED.username,password = EXCLUDED.password,last_update = EXCLUDED.last_update,picture = EXCLUDED.picture
    RETURNING
      staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture
    `;
          return response.map((record) => ({
            staffId: undefinedIsNull(record.staff_id),
            firstName: undefinedIsNull(record.first_name),
            lastName: undefinedIsNull(record.last_name),
            addressId: undefinedIsNull(record.address_id),
            email: undefinedIsNull(record.email),
            storeId: undefinedIsNull(record.store_id),
            active: undefinedIsNull(record.active),
            username: undefinedIsNull(record.username),
            password: undefinedIsNull(record.password),
            lastUpdate: undefinedIsNull(record.last_update),
            picture: undefinedIsNull(record.picture),
          }))[0];
        }

        public ByStaffId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Staff.ByStaffId,
          ): Promise<Public.Tables.Staff.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture 
    FROM
      public.staff 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.staffId)
      }
    `;
            return response.map((record) => ({
              staffId: undefinedIsNull(record.staff_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              addressId: undefinedIsNull(record.address_id),
              email: undefinedIsNull(record.email),
              storeId: undefinedIsNull(record.store_id),
              active: undefinedIsNull(record.active),
              username: undefinedIsNull(record.username),
              password: undefinedIsNull(record.password),
              lastUpdate: undefinedIsNull(record.last_update),
              picture: undefinedIsNull(record.picture),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Staff.ByStaffId,
            values: Partial<Public.Tables.Staff.Values>,
          ): Promise<Public.Tables.Staff.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.staff 
    SET
      staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[23](values.staffId)
      } , first_name = ${
        values.firstName === undefined
          ? sql`first_name`
          : typed[1043](values.firstName)
      } , last_name = ${
        values.lastName === undefined
          ? sql`last_name`
          : typed[1043](values.lastName)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , email = ${
        values.email === undefined ? sql`email` : typed[1043](values.email)
      } , store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[21](values.storeId)
      } , active = ${
        values.active === undefined ? sql`active` : typed[16](values.active)
      } , username = ${
        values.username === undefined
          ? sql`username`
          : typed[1043](values.username)
      } , password = ${
        values.password === undefined
          ? sql`password`
          : typed[1043](values.password)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , picture = ${
        values.picture === undefined ? sql`picture` : typed[17](values.picture)
      } 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.staffId)
      }
    RETURNING staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture`;
            return response.map((record) => ({
              staffId: undefinedIsNull(record.staff_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              addressId: undefinedIsNull(record.address_id),
              email: undefinedIsNull(record.email),
              storeId: undefinedIsNull(record.store_id),
              active: undefinedIsNull(record.active),
              username: undefinedIsNull(record.username),
              password: undefinedIsNull(record.password),
              lastUpdate: undefinedIsNull(record.last_update),
              picture: undefinedIsNull(record.picture),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Staff.ByStaffId,
          ): Promise<Public.Tables.Staff.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.staff 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.staffId)
      }
    RETURNING staff_id,first_name,last_name,address_id,email,store_id,active,username,password,last_update,picture`;
            return response.map((record) => ({
              staffId: undefinedIsNull(record.staff_id),
              firstName: undefinedIsNull(record.first_name),
              lastName: undefinedIsNull(record.last_name),
              addressId: undefinedIsNull(record.address_id),
              email: undefinedIsNull(record.email),
              storeId: undefinedIsNull(record.store_id),
              active: undefinedIsNull(record.active),
              username: undefinedIsNull(record.username),
              password: undefinedIsNull(record.password),
              lastUpdate: undefinedIsNull(record.last_update),
              picture: undefinedIsNull(record.picture),
            }))[0];
          }
        })(this);
      })(this);

      public Store = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Store.Values,
        ): Promise<Public.Tables.Store.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Store.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.store (manager_staff_id,address_id,last_update)
      VALUES (${
        values.managerStaffId === undefined
          ? sql`DEFAULT`
          : typed[21](values.managerStaffId)
      },${
        values.addressId === undefined
          ? sql`DEFAULT`
          : typed[21](values.addressId)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      })
      RETURNING
        store_id,manager_staff_id,address_id,last_update
    `;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.store (store_id,manager_staff_id,address_id,last_update)
    VALUES (${
      values.storeId === undefined ? sql`DEFAULT` : typed[23](values.storeId)
    },${
      values.managerStaffId === undefined
        ? sql`DEFAULT`
        : typed[21](values.managerStaffId)
    },${
      values.addressId === undefined
        ? sql`DEFAULT`
        : typed[21](values.addressId)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    })
    ON CONFLICT (store_id) DO UPDATE
    SET
      manager_staff_id = EXCLUDED.manager_staff_id,address_id = EXCLUDED.address_id,last_update = EXCLUDED.last_update
    RETURNING
      store_id,manager_staff_id,address_id,last_update
    `;
          return response.map((record) => ({
            storeId: undefinedIsNull(record.store_id),
            managerStaffId: undefinedIsNull(record.manager_staff_id),
            addressId: undefinedIsNull(record.address_id),
            lastUpdate: undefinedIsNull(record.last_update),
          }))[0];
        }

        public ByManagerStaffId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Store.ByManagerStaffId,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      store_id,manager_staff_id,address_id,last_update 
    FROM
      public.store 
    WHERE
      manager_staff_id = ${
        parameters.managerStaffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.managerStaffId)
      }
    `;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Store.ByManagerStaffId,
            values: Partial<Public.Tables.Store.Values>,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.store 
    SET
      store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[23](values.storeId)
      } , manager_staff_id = ${
        values.managerStaffId === undefined
          ? sql`manager_staff_id`
          : typed[21](values.managerStaffId)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      manager_staff_id = ${
        parameters.managerStaffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.managerStaffId)
      }
    RETURNING store_id,manager_staff_id,address_id,last_update`;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Store.ByManagerStaffId,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.store 
    WHERE
      manager_staff_id = ${
        parameters.managerStaffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.managerStaffId)
      }
    RETURNING store_id,manager_staff_id,address_id,last_update`;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);

        public ByStoreId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Store.ByStoreId,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      store_id,manager_staff_id,address_id,last_update 
    FROM
      public.store 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.storeId)
      }
    `;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Store.ByStoreId,
            values: Partial<Public.Tables.Store.Values>,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.store 
    SET
      store_id = ${
        values.storeId === undefined ? sql`store_id` : typed[23](values.storeId)
      } , manager_staff_id = ${
        values.managerStaffId === undefined
          ? sql`manager_staff_id`
          : typed[21](values.managerStaffId)
      } , address_id = ${
        values.addressId === undefined
          ? sql`address_id`
          : typed[21](values.addressId)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.storeId)
      }
    RETURNING store_id,manager_staff_id,address_id,last_update`;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Store.ByStoreId,
          ): Promise<Public.Tables.Store.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.store 
    WHERE
      store_id = ${
        parameters.storeId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.storeId)
      }
    RETURNING store_id,manager_staff_id,address_id,last_update`;
            return response.map((record) => ({
              storeId: undefinedIsNull(record.store_id),
              managerStaffId: undefinedIsNull(record.manager_staff_id),
              addressId: undefinedIsNull(record.address_id),
              lastUpdate: undefinedIsNull(record.last_update),
            }))[0];
          }
        })(this);
      })(this);

      public Payment = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Payment.Values,
        ): Promise<Public.Tables.Payment.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Payment.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.payment (customer_id,staff_id,rental_id,amount,payment_date)
      VALUES (${
        values.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](values.customerId)
      },${
        values.staffId === undefined ? sql`DEFAULT` : typed[21](values.staffId)
      },${
        values.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](values.rentalId)
      },${
        values.amount === undefined ? sql`DEFAULT` : typed[1700](values.amount)
      },${
        values.paymentDate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.paymentDate)
      })
      RETURNING
        payment_id,customer_id,staff_id,rental_id,amount,payment_date
    `;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.payment (payment_id,customer_id,staff_id,rental_id,amount,payment_date)
    VALUES (${
      values.paymentId === undefined
        ? sql`DEFAULT`
        : typed[23](values.paymentId)
    },${
      values.customerId === undefined
        ? sql`DEFAULT`
        : typed[21](values.customerId)
    },${
      values.staffId === undefined ? sql`DEFAULT` : typed[21](values.staffId)
    },${
      values.rentalId === undefined ? sql`DEFAULT` : typed[23](values.rentalId)
    },${
      values.amount === undefined ? sql`DEFAULT` : typed[1700](values.amount)
    },${
      values.paymentDate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.paymentDate)
    })
    ON CONFLICT (payment_id) DO UPDATE
    SET
      customer_id = EXCLUDED.customer_id,staff_id = EXCLUDED.staff_id,rental_id = EXCLUDED.rental_id,amount = EXCLUDED.amount,payment_date = EXCLUDED.payment_date
    RETURNING
      payment_id,customer_id,staff_id,rental_id,amount,payment_date
    `;
          return response.map((record) => ({
            paymentId: undefinedIsNull(record.payment_id),
            customerId: undefinedIsNull(record.customer_id),
            staffId: undefinedIsNull(record.staff_id),
            rentalId: undefinedIsNull(record.rental_id),
            amount: undefinedIsNull(record.amount),
            paymentDate: undefinedIsNull(record.payment_date),
          }))[0];
        }

        public ByCustomerId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Payment.ByCustomerId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      payment_id,customer_id,staff_id,rental_id,amount,payment_date 
    FROM
      public.payment 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    `;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async update(
            parameters: Public.Tables.Payment.ByCustomerId,
            values: Partial<Public.Tables.Payment.Values>,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.payment 
    SET
      payment_id = ${
        values.paymentId === undefined
          ? sql`payment_id`
          : typed[23](values.paymentId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , amount = ${
        values.amount === undefined ? sql`amount` : typed[1700](values.amount)
      } , payment_date = ${
        values.paymentDate === undefined
          ? sql`payment_date`
          : typed[1114](values.paymentDate)
      } 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async delete(
            parameters: Public.Tables.Payment.ByCustomerId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.payment 
    WHERE
      customer_id = ${
        parameters.customerId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.customerId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }
        })(this);

        public ByPaymentId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Payment.ByPaymentId,
          ): Promise<Public.Tables.Payment.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      payment_id,customer_id,staff_id,rental_id,amount,payment_date 
    FROM
      public.payment 
    WHERE
      payment_id = ${
        parameters.paymentId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.paymentId)
      }
    `;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Payment.ByPaymentId,
            values: Partial<Public.Tables.Payment.Values>,
          ): Promise<Public.Tables.Payment.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.payment 
    SET
      payment_id = ${
        values.paymentId === undefined
          ? sql`payment_id`
          : typed[23](values.paymentId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , amount = ${
        values.amount === undefined ? sql`amount` : typed[1700](values.amount)
      } , payment_date = ${
        values.paymentDate === undefined
          ? sql`payment_date`
          : typed[1114](values.paymentDate)
      } 
    WHERE
      payment_id = ${
        parameters.paymentId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.paymentId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Payment.ByPaymentId,
          ): Promise<Public.Tables.Payment.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.payment 
    WHERE
      payment_id = ${
        parameters.paymentId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.paymentId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }))[0];
          }
        })(this);

        public ByRentalId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Payment.ByRentalId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      payment_id,customer_id,staff_id,rental_id,amount,payment_date 
    FROM
      public.payment 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    `;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async update(
            parameters: Public.Tables.Payment.ByRentalId,
            values: Partial<Public.Tables.Payment.Values>,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.payment 
    SET
      payment_id = ${
        values.paymentId === undefined
          ? sql`payment_id`
          : typed[23](values.paymentId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , amount = ${
        values.amount === undefined ? sql`amount` : typed[1700](values.amount)
      } , payment_date = ${
        values.paymentDate === undefined
          ? sql`payment_date`
          : typed[1114](values.paymentDate)
      } 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async delete(
            parameters: Public.Tables.Payment.ByRentalId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.payment 
    WHERE
      rental_id = ${
        parameters.rentalId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.rentalId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }
        })(this);

        public ByStaffId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Payment.ByStaffId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      payment_id,customer_id,staff_id,rental_id,amount,payment_date 
    FROM
      public.payment 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.staffId)
      }
    `;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async update(
            parameters: Public.Tables.Payment.ByStaffId,
            values: Partial<Public.Tables.Payment.Values>,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.payment 
    SET
      payment_id = ${
        values.paymentId === undefined
          ? sql`payment_id`
          : typed[23](values.paymentId)
      } , customer_id = ${
        values.customerId === undefined
          ? sql`customer_id`
          : typed[21](values.customerId)
      } , staff_id = ${
        values.staffId === undefined ? sql`staff_id` : typed[21](values.staffId)
      } , rental_id = ${
        values.rentalId === undefined
          ? sql`rental_id`
          : typed[23](values.rentalId)
      } , amount = ${
        values.amount === undefined ? sql`amount` : typed[1700](values.amount)
      } , payment_date = ${
        values.paymentDate === undefined
          ? sql`payment_date`
          : typed[1114](values.paymentDate)
      } 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.staffId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }

          async delete(
            parameters: Public.Tables.Payment.ByStaffId,
          ): Promise<Public.Tables.Payment.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.payment 
    WHERE
      staff_id = ${
        parameters.staffId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.staffId)
      }
    RETURNING payment_id,customer_id,staff_id,rental_id,amount,payment_date`;
            return response.map((record) => ({
              paymentId: undefinedIsNull(record.payment_id),
              customerId: undefinedIsNull(record.customer_id),
              staffId: undefinedIsNull(record.staff_id),
              rentalId: undefinedIsNull(record.rental_id),
              amount: undefinedIsNull(record.amount),
              paymentDate: undefinedIsNull(record.payment_date),
            }));
          }
        })(this);
      })(this);

      public Film = new (class implements HasDatabase {
        constructor(private hasDatabase: HasDatabase) {}

        get database() {
          return this.hasDatabase.database;
        }

        async create(
          values: Public.Tables.Film.Values,
        ): Promise<Public.Tables.Film.Record> {
          const sql = this.database.context.sql;
          const typed = sql.typed as unknown as PostgresTypecasts;

          if (!Public.Tables.Film.includesPrimaryKey(values)) {
            const response = await sql`
      --
      INSERT INTO
        public.film (title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext)
      VALUES (${
        values.title === undefined ? sql`DEFAULT` : typed[1043](values.title)
      },${
        values.description === undefined
          ? sql`DEFAULT`
          : typed[25](values.description)
      },${
        values.releaseYear === undefined
          ? sql`DEFAULT`
          : typed[27026](values.releaseYear)
      },${
        values.languageId === undefined
          ? sql`DEFAULT`
          : typed[21](values.languageId)
      },${
        values.rentalDuration === undefined
          ? sql`DEFAULT`
          : typed[21](values.rentalDuration)
      },${
        values.rentalRate === undefined
          ? sql`DEFAULT`
          : typed[1700](values.rentalRate)
      },${
        values.length === undefined ? sql`DEFAULT` : typed[21](values.length)
      },${
        values.replacementCost === undefined
          ? sql`DEFAULT`
          : typed[1700](values.replacementCost)
      },${
        values.rating === undefined ? sql`DEFAULT` : typed[27014](values.rating)
      },${
        values.lastUpdate === undefined
          ? sql`DEFAULT`
          : typed[1114](values.lastUpdate)
      },${
        values.specialFeatures === undefined
          ? sql`DEFAULT`
          : typed[1009](values.specialFeatures)
      },${
        values.fulltext === undefined
          ? sql`DEFAULT`
          : typed[3614](values.fulltext)
      })
      RETURNING
        film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }))[0];
          }
          const response = await sql`
    INSERT INTO
      public.film (film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext)
    VALUES (${
      values.filmId === undefined ? sql`DEFAULT` : typed[23](values.filmId)
    },${
      values.title === undefined ? sql`DEFAULT` : typed[1043](values.title)
    },${
      values.description === undefined
        ? sql`DEFAULT`
        : typed[25](values.description)
    },${
      values.releaseYear === undefined
        ? sql`DEFAULT`
        : typed[27026](values.releaseYear)
    },${
      values.languageId === undefined
        ? sql`DEFAULT`
        : typed[21](values.languageId)
    },${
      values.rentalDuration === undefined
        ? sql`DEFAULT`
        : typed[21](values.rentalDuration)
    },${
      values.rentalRate === undefined
        ? sql`DEFAULT`
        : typed[1700](values.rentalRate)
    },${
      values.length === undefined ? sql`DEFAULT` : typed[21](values.length)
    },${
      values.replacementCost === undefined
        ? sql`DEFAULT`
        : typed[1700](values.replacementCost)
    },${
      values.rating === undefined ? sql`DEFAULT` : typed[27014](values.rating)
    },${
      values.lastUpdate === undefined
        ? sql`DEFAULT`
        : typed[1114](values.lastUpdate)
    },${
      values.specialFeatures === undefined
        ? sql`DEFAULT`
        : typed[1009](values.specialFeatures)
    },${
      values.fulltext === undefined
        ? sql`DEFAULT`
        : typed[3614](values.fulltext)
    })
    ON CONFLICT (film_id) DO UPDATE
    SET
      title = EXCLUDED.title,description = EXCLUDED.description,release_year = EXCLUDED.release_year,language_id = EXCLUDED.language_id,rental_duration = EXCLUDED.rental_duration,rental_rate = EXCLUDED.rental_rate,length = EXCLUDED.length,replacement_cost = EXCLUDED.replacement_cost,rating = EXCLUDED.rating,last_update = EXCLUDED.last_update,special_features = EXCLUDED.special_features,fulltext = EXCLUDED.fulltext
    RETURNING
      film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext
    `;
          return response.map((record) => ({
            filmId: undefinedIsNull(record.film_id),
            title: undefinedIsNull(record.title),
            description: undefinedIsNull(record.description),
            releaseYear: undefinedIsNull(record.release_year),
            languageId: undefinedIsNull(record.language_id),
            rentalDuration: undefinedIsNull(record.rental_duration),
            rentalRate: undefinedIsNull(record.rental_rate),
            length: undefinedIsNull(record.length),
            replacementCost: undefinedIsNull(record.replacement_cost),
            rating: undefinedIsNull(record.rating),
            lastUpdate: undefinedIsNull(record.last_update),
            specialFeatures: undefinedIsNull(record.special_features),
            fulltext: undefinedIsNull(record.fulltext),
          }))[0];
        }

        public ByFilmId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Film.ByFilmId,
          ): Promise<Public.Tables.Film.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext 
    FROM
      public.film 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.filmId)
      }
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }))[0];
          }

          async update(
            parameters: Public.Tables.Film.ByFilmId,
            values: Partial<Public.Tables.Film.Values>,
          ): Promise<Public.Tables.Film.Record> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film 
    SET
      film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[23](values.filmId)
      } , title = ${
        values.title === undefined ? sql`title` : typed[1043](values.title)
      } , description = ${
        values.description === undefined
          ? sql`description`
          : typed[25](values.description)
      } , release_year = ${
        values.releaseYear === undefined
          ? sql`release_year`
          : typed[27026](values.releaseYear)
      } , language_id = ${
        values.languageId === undefined
          ? sql`language_id`
          : typed[21](values.languageId)
      } , rental_duration = ${
        values.rentalDuration === undefined
          ? sql`rental_duration`
          : typed[21](values.rentalDuration)
      } , rental_rate = ${
        values.rentalRate === undefined
          ? sql`rental_rate`
          : typed[1700](values.rentalRate)
      } , length = ${
        values.length === undefined ? sql`length` : typed[21](values.length)
      } , replacement_cost = ${
        values.replacementCost === undefined
          ? sql`replacement_cost`
          : typed[1700](values.replacementCost)
      } , rating = ${
        values.rating === undefined ? sql`rating` : typed[27014](values.rating)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , special_features = ${
        values.specialFeatures === undefined
          ? sql`special_features`
          : typed[1009](values.specialFeatures)
      } , fulltext = ${
        values.fulltext === undefined
          ? sql`fulltext`
          : typed[3614](values.fulltext)
      } 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.filmId)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }))[0];
          }

          async delete(
            parameters: Public.Tables.Film.ByFilmId,
          ): Promise<Public.Tables.Film.Record> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film 
    WHERE
      film_id = ${
        parameters.filmId === undefined
          ? sql`DEFAULT`
          : typed[23](parameters.filmId)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }))[0];
          }
        })(this);

        public ByFulltext = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Film.ByFulltext,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext 
    FROM
      public.film 
    WHERE
      fulltext = ${
        parameters.fulltext === undefined
          ? sql`DEFAULT`
          : typed[3642](parameters.fulltext)
      }
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async update(
            parameters: Public.Tables.Film.ByFulltext,
            values: Partial<Public.Tables.Film.Values>,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film 
    SET
      film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[23](values.filmId)
      } , title = ${
        values.title === undefined ? sql`title` : typed[1043](values.title)
      } , description = ${
        values.description === undefined
          ? sql`description`
          : typed[25](values.description)
      } , release_year = ${
        values.releaseYear === undefined
          ? sql`release_year`
          : typed[27026](values.releaseYear)
      } , language_id = ${
        values.languageId === undefined
          ? sql`language_id`
          : typed[21](values.languageId)
      } , rental_duration = ${
        values.rentalDuration === undefined
          ? sql`rental_duration`
          : typed[21](values.rentalDuration)
      } , rental_rate = ${
        values.rentalRate === undefined
          ? sql`rental_rate`
          : typed[1700](values.rentalRate)
      } , length = ${
        values.length === undefined ? sql`length` : typed[21](values.length)
      } , replacement_cost = ${
        values.replacementCost === undefined
          ? sql`replacement_cost`
          : typed[1700](values.replacementCost)
      } , rating = ${
        values.rating === undefined ? sql`rating` : typed[27014](values.rating)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , special_features = ${
        values.specialFeatures === undefined
          ? sql`special_features`
          : typed[1009](values.specialFeatures)
      } , fulltext = ${
        values.fulltext === undefined
          ? sql`fulltext`
          : typed[3614](values.fulltext)
      } 
    WHERE
      fulltext = ${
        parameters.fulltext === undefined
          ? sql`DEFAULT`
          : typed[3642](parameters.fulltext)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async delete(
            parameters: Public.Tables.Film.ByFulltext,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film 
    WHERE
      fulltext = ${
        parameters.fulltext === undefined
          ? sql`DEFAULT`
          : typed[3642](parameters.fulltext)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }
        })(this);

        public ByLanguageId = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Film.ByLanguageId,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext 
    FROM
      public.film 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.languageId)
      }
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async update(
            parameters: Public.Tables.Film.ByLanguageId,
            values: Partial<Public.Tables.Film.Values>,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film 
    SET
      film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[23](values.filmId)
      } , title = ${
        values.title === undefined ? sql`title` : typed[1043](values.title)
      } , description = ${
        values.description === undefined
          ? sql`description`
          : typed[25](values.description)
      } , release_year = ${
        values.releaseYear === undefined
          ? sql`release_year`
          : typed[27026](values.releaseYear)
      } , language_id = ${
        values.languageId === undefined
          ? sql`language_id`
          : typed[21](values.languageId)
      } , rental_duration = ${
        values.rentalDuration === undefined
          ? sql`rental_duration`
          : typed[21](values.rentalDuration)
      } , rental_rate = ${
        values.rentalRate === undefined
          ? sql`rental_rate`
          : typed[1700](values.rentalRate)
      } , length = ${
        values.length === undefined ? sql`length` : typed[21](values.length)
      } , replacement_cost = ${
        values.replacementCost === undefined
          ? sql`replacement_cost`
          : typed[1700](values.replacementCost)
      } , rating = ${
        values.rating === undefined ? sql`rating` : typed[27014](values.rating)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , special_features = ${
        values.specialFeatures === undefined
          ? sql`special_features`
          : typed[1009](values.specialFeatures)
      } , fulltext = ${
        values.fulltext === undefined
          ? sql`fulltext`
          : typed[3614](values.fulltext)
      } 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.languageId)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async delete(
            parameters: Public.Tables.Film.ByLanguageId,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film 
    WHERE
      language_id = ${
        parameters.languageId === undefined
          ? sql`DEFAULT`
          : typed[21](parameters.languageId)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }
        })(this);

        public ByTitle = new (class implements HasDatabase {
          constructor(private hasDatabase: HasDatabase) {}

          get database() {
            return this.hasDatabase.database;
          }

          async read(
            parameters: Public.Tables.Film.ByTitle,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    -- 
    SELECT 
      film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext 
    FROM
      public.film 
    WHERE
      title = ${
        parameters.title === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.title)
      }
    `;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async update(
            parameters: Public.Tables.Film.ByTitle,
            values: Partial<Public.Tables.Film.Values>,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            console.assert(values);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    UPDATE 
      public.film 
    SET
      film_id = ${
        values.filmId === undefined ? sql`film_id` : typed[23](values.filmId)
      } , title = ${
        values.title === undefined ? sql`title` : typed[1043](values.title)
      } , description = ${
        values.description === undefined
          ? sql`description`
          : typed[25](values.description)
      } , release_year = ${
        values.releaseYear === undefined
          ? sql`release_year`
          : typed[27026](values.releaseYear)
      } , language_id = ${
        values.languageId === undefined
          ? sql`language_id`
          : typed[21](values.languageId)
      } , rental_duration = ${
        values.rentalDuration === undefined
          ? sql`rental_duration`
          : typed[21](values.rentalDuration)
      } , rental_rate = ${
        values.rentalRate === undefined
          ? sql`rental_rate`
          : typed[1700](values.rentalRate)
      } , length = ${
        values.length === undefined ? sql`length` : typed[21](values.length)
      } , replacement_cost = ${
        values.replacementCost === undefined
          ? sql`replacement_cost`
          : typed[1700](values.replacementCost)
      } , rating = ${
        values.rating === undefined ? sql`rating` : typed[27014](values.rating)
      } , last_update = ${
        values.lastUpdate === undefined
          ? sql`last_update`
          : typed[1114](values.lastUpdate)
      } , special_features = ${
        values.specialFeatures === undefined
          ? sql`special_features`
          : typed[1009](values.specialFeatures)
      } , fulltext = ${
        values.fulltext === undefined
          ? sql`fulltext`
          : typed[3614](values.fulltext)
      } 
    WHERE
      title = ${
        parameters.title === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.title)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }

          async delete(
            parameters: Public.Tables.Film.ByTitle,
          ): Promise<Public.Tables.Film.Record[]> {
            console.assert(parameters);
            const sql = this.database.context.sql;
            const typed = sql.typed as unknown as PostgresTypecasts;

            const response = await sql`
    --
    DELETE FROM 
      public.film 
    WHERE
      title = ${
        parameters.title === undefined
          ? sql`DEFAULT`
          : typed[1043](parameters.title)
      }
    RETURNING film_id,title,description,release_year,language_id,rental_duration,rental_rate,length,replacement_cost,rating,last_update,special_features,fulltext`;
            return response.map((record) => ({
              filmId: undefinedIsNull(record.film_id),
              title: undefinedIsNull(record.title),
              description: undefinedIsNull(record.description),
              releaseYear: undefinedIsNull(record.release_year),
              languageId: undefinedIsNull(record.language_id),
              rentalDuration: undefinedIsNull(record.rental_duration),
              rentalRate: undefinedIsNull(record.rental_rate),
              length: undefinedIsNull(record.length),
              replacementCost: undefinedIsNull(record.replacement_cost),
              rating: undefinedIsNull(record.rating),
              lastUpdate: undefinedIsNull(record.last_update),
              specialFeatures: undefinedIsNull(record.special_features),
              fulltext: undefinedIsNull(record.fulltext),
            }));
          }
        })(this);
      })(this);
    })(this);
  })(this);
}

// begin - operation dispatch map
import { EmbraceSQLRequest, OperationDispatchMethod } from "@embracesql/shared";
export class OperationDispatcher {
  private dispatchMap: Record<string, OperationDispatchMethod>;
  constructor(private database: Database) {
    this.dispatchMap = {
      "Public.Procedures.filmInStock": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.filmInStock(
          request.parameters as Public.Procedures.FilmInStock.Parameters,
        ),
      "Public.Procedures.filmNotInStock": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.filmNotInStock(
          request.parameters as Public.Procedures.FilmNotInStock.Parameters,
        ),
      "Public.Procedures.getCustomerBalance": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.getCustomerBalance(
          request.parameters as Public.Procedures.GetCustomerBalance.Parameters,
        ),
      "Public.Procedures.inventoryHeldByCustomer": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.inventoryHeldByCustomer(
          request.parameters as Public.Procedures.InventoryHeldByCustomer.Parameters,
        ),
      "Public.Procedures.inventoryInStock": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.inventoryInStock(
          request.parameters as Public.Procedures.InventoryInStock.Parameters,
        ),
      "Public.Procedures.lastDay": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.lastDay(
          request.parameters as Public.Procedures.LastDay.Parameters,
        ),
      "Public.Procedures.rewardsReport": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Procedures.rewardsReport(
          request.parameters as Public.Procedures.RewardsReport.Parameters,
        ),
      "Public.Tables.FilmActor.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.create(
          request.values as Public.Tables.FilmActor.Values,
        ),
      "Public.Tables.FilmActor.ByActorIdFilmId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByActorIdFilmId.read(
          request.parameters as Public.Tables.FilmActor.ByActorIdFilmId,
        ),
      "Public.Tables.FilmActor.ByActorIdFilmId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByActorIdFilmId.update(
          request.parameters as Public.Tables.FilmActor.ByActorIdFilmId,
          request.values as Partial<Public.Tables.FilmActor.Values>,
        ),
      "Public.Tables.FilmActor.ByActorIdFilmId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByActorIdFilmId.delete(
          request.parameters as Public.Tables.FilmActor.ByActorIdFilmId,
        ),
      "Public.Tables.FilmActor.ByFilmId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByFilmId.read(
          request.parameters as Public.Tables.FilmActor.ByFilmId,
        ),
      "Public.Tables.FilmActor.ByFilmId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByFilmId.update(
          request.parameters as Public.Tables.FilmActor.ByFilmId,
          request.values as Partial<Public.Tables.FilmActor.Values>,
        ),
      "Public.Tables.FilmActor.ByFilmId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmActor.ByFilmId.delete(
          request.parameters as Public.Tables.FilmActor.ByFilmId,
        ),
      "Public.Tables.Address.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.create(
          request.values as Public.Tables.Address.Values,
        ),
      "Public.Tables.Address.ByAddressId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByAddressId.read(
          request.parameters as Public.Tables.Address.ByAddressId,
        ),
      "Public.Tables.Address.ByAddressId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByAddressId.update(
          request.parameters as Public.Tables.Address.ByAddressId,
          request.values as Partial<Public.Tables.Address.Values>,
        ),
      "Public.Tables.Address.ByAddressId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByAddressId.delete(
          request.parameters as Public.Tables.Address.ByAddressId,
        ),
      "Public.Tables.Address.ByCityId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByCityId.read(
          request.parameters as Public.Tables.Address.ByCityId,
        ),
      "Public.Tables.Address.ByCityId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByCityId.update(
          request.parameters as Public.Tables.Address.ByCityId,
          request.values as Partial<Public.Tables.Address.Values>,
        ),
      "Public.Tables.Address.ByCityId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Address.ByCityId.delete(
          request.parameters as Public.Tables.Address.ByCityId,
        ),
      "Public.Tables.City.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.create(
          request.values as Public.Tables.City.Values,
        ),
      "Public.Tables.City.ByCityId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCityId.read(
          request.parameters as Public.Tables.City.ByCityId,
        ),
      "Public.Tables.City.ByCityId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCityId.update(
          request.parameters as Public.Tables.City.ByCityId,
          request.values as Partial<Public.Tables.City.Values>,
        ),
      "Public.Tables.City.ByCityId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCityId.delete(
          request.parameters as Public.Tables.City.ByCityId,
        ),
      "Public.Tables.City.ByCountryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCountryId.read(
          request.parameters as Public.Tables.City.ByCountryId,
        ),
      "Public.Tables.City.ByCountryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCountryId.update(
          request.parameters as Public.Tables.City.ByCountryId,
          request.values as Partial<Public.Tables.City.Values>,
        ),
      "Public.Tables.City.ByCountryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.City.ByCountryId.delete(
          request.parameters as Public.Tables.City.ByCountryId,
        ),
      "Public.Tables.Customer.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.create(
          request.values as Public.Tables.Customer.Values,
        ),
      "Public.Tables.Customer.ByAddressId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByAddressId.read(
          request.parameters as Public.Tables.Customer.ByAddressId,
        ),
      "Public.Tables.Customer.ByAddressId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByAddressId.update(
          request.parameters as Public.Tables.Customer.ByAddressId,
          request.values as Partial<Public.Tables.Customer.Values>,
        ),
      "Public.Tables.Customer.ByAddressId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByAddressId.delete(
          request.parameters as Public.Tables.Customer.ByAddressId,
        ),
      "Public.Tables.Customer.ByCustomerId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByCustomerId.read(
          request.parameters as Public.Tables.Customer.ByCustomerId,
        ),
      "Public.Tables.Customer.ByCustomerId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByCustomerId.update(
          request.parameters as Public.Tables.Customer.ByCustomerId,
          request.values as Partial<Public.Tables.Customer.Values>,
        ),
      "Public.Tables.Customer.ByCustomerId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByCustomerId.delete(
          request.parameters as Public.Tables.Customer.ByCustomerId,
        ),
      "Public.Tables.Customer.ByLastName.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByLastName.read(
          request.parameters as Public.Tables.Customer.ByLastName,
        ),
      "Public.Tables.Customer.ByLastName.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByLastName.update(
          request.parameters as Public.Tables.Customer.ByLastName,
          request.values as Partial<Public.Tables.Customer.Values>,
        ),
      "Public.Tables.Customer.ByLastName.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByLastName.delete(
          request.parameters as Public.Tables.Customer.ByLastName,
        ),
      "Public.Tables.Customer.ByStoreId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByStoreId.read(
          request.parameters as Public.Tables.Customer.ByStoreId,
        ),
      "Public.Tables.Customer.ByStoreId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByStoreId.update(
          request.parameters as Public.Tables.Customer.ByStoreId,
          request.values as Partial<Public.Tables.Customer.Values>,
        ),
      "Public.Tables.Customer.ByStoreId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Customer.ByStoreId.delete(
          request.parameters as Public.Tables.Customer.ByStoreId,
        ),
      "Public.Tables.Actor.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.create(
          request.values as Public.Tables.Actor.Values,
        ),
      "Public.Tables.Actor.ByActorId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByActorId.read(
          request.parameters as Public.Tables.Actor.ByActorId,
        ),
      "Public.Tables.Actor.ByActorId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByActorId.update(
          request.parameters as Public.Tables.Actor.ByActorId,
          request.values as Partial<Public.Tables.Actor.Values>,
        ),
      "Public.Tables.Actor.ByActorId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByActorId.delete(
          request.parameters as Public.Tables.Actor.ByActorId,
        ),
      "Public.Tables.Actor.ByLastName.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByLastName.read(
          request.parameters as Public.Tables.Actor.ByLastName,
        ),
      "Public.Tables.Actor.ByLastName.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByLastName.update(
          request.parameters as Public.Tables.Actor.ByLastName,
          request.values as Partial<Public.Tables.Actor.Values>,
        ),
      "Public.Tables.Actor.ByLastName.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Actor.ByLastName.delete(
          request.parameters as Public.Tables.Actor.ByLastName,
        ),
      "Public.Tables.FilmCategory.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmCategory.create(
          request.values as Public.Tables.FilmCategory.Values,
        ),
      "Public.Tables.FilmCategory.ByFilmIdCategoryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmCategory.ByFilmIdCategoryId.read(
          request.parameters as Public.Tables.FilmCategory.ByFilmIdCategoryId,
        ),
      "Public.Tables.FilmCategory.ByFilmIdCategoryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmCategory.ByFilmIdCategoryId.update(
          request.parameters as Public.Tables.FilmCategory.ByFilmIdCategoryId,
          request.values as Partial<Public.Tables.FilmCategory.Values>,
        ),
      "Public.Tables.FilmCategory.ByFilmIdCategoryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.FilmCategory.ByFilmIdCategoryId.delete(
          request.parameters as Public.Tables.FilmCategory.ByFilmIdCategoryId,
        ),
      "Public.Tables.Inventory.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.create(
          request.values as Public.Tables.Inventory.Values,
        ),
      "Public.Tables.Inventory.ByInventoryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByInventoryId.read(
          request.parameters as Public.Tables.Inventory.ByInventoryId,
        ),
      "Public.Tables.Inventory.ByInventoryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByInventoryId.update(
          request.parameters as Public.Tables.Inventory.ByInventoryId,
          request.values as Partial<Public.Tables.Inventory.Values>,
        ),
      "Public.Tables.Inventory.ByInventoryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByInventoryId.delete(
          request.parameters as Public.Tables.Inventory.ByInventoryId,
        ),
      "Public.Tables.Inventory.ByStoreIdFilmId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByStoreIdFilmId.read(
          request.parameters as Public.Tables.Inventory.ByStoreIdFilmId,
        ),
      "Public.Tables.Inventory.ByStoreIdFilmId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByStoreIdFilmId.update(
          request.parameters as Public.Tables.Inventory.ByStoreIdFilmId,
          request.values as Partial<Public.Tables.Inventory.Values>,
        ),
      "Public.Tables.Inventory.ByStoreIdFilmId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Inventory.ByStoreIdFilmId.delete(
          request.parameters as Public.Tables.Inventory.ByStoreIdFilmId,
        ),
      "Public.Tables.Category.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Category.create(
          request.values as Public.Tables.Category.Values,
        ),
      "Public.Tables.Category.ByCategoryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Category.ByCategoryId.read(
          request.parameters as Public.Tables.Category.ByCategoryId,
        ),
      "Public.Tables.Category.ByCategoryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Category.ByCategoryId.update(
          request.parameters as Public.Tables.Category.ByCategoryId,
          request.values as Partial<Public.Tables.Category.Values>,
        ),
      "Public.Tables.Category.ByCategoryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Category.ByCategoryId.delete(
          request.parameters as Public.Tables.Category.ByCategoryId,
        ),
      "Public.Tables.Country.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Country.create(
          request.values as Public.Tables.Country.Values,
        ),
      "Public.Tables.Country.ByCountryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Country.ByCountryId.read(
          request.parameters as Public.Tables.Country.ByCountryId,
        ),
      "Public.Tables.Country.ByCountryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Country.ByCountryId.update(
          request.parameters as Public.Tables.Country.ByCountryId,
          request.values as Partial<Public.Tables.Country.Values>,
        ),
      "Public.Tables.Country.ByCountryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Country.ByCountryId.delete(
          request.parameters as Public.Tables.Country.ByCountryId,
        ),
      "Public.Tables.Language.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Language.create(
          request.values as Public.Tables.Language.Values,
        ),
      "Public.Tables.Language.ByLanguageId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Language.ByLanguageId.read(
          request.parameters as Public.Tables.Language.ByLanguageId,
        ),
      "Public.Tables.Language.ByLanguageId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Language.ByLanguageId.update(
          request.parameters as Public.Tables.Language.ByLanguageId,
          request.values as Partial<Public.Tables.Language.Values>,
        ),
      "Public.Tables.Language.ByLanguageId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Language.ByLanguageId.delete(
          request.parameters as Public.Tables.Language.ByLanguageId,
        ),
      "Public.Tables.Rental.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.create(
          request.values as Public.Tables.Rental.Values,
        ),
      "Public.Tables.Rental.ByInventoryId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByInventoryId.read(
          request.parameters as Public.Tables.Rental.ByInventoryId,
        ),
      "Public.Tables.Rental.ByInventoryId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByInventoryId.update(
          request.parameters as Public.Tables.Rental.ByInventoryId,
          request.values as Partial<Public.Tables.Rental.Values>,
        ),
      "Public.Tables.Rental.ByInventoryId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByInventoryId.delete(
          request.parameters as Public.Tables.Rental.ByInventoryId,
        ),
      "Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.read(
          request.parameters as Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
        ),
      "Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.update(
          request.parameters as Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
          request.values as Partial<Public.Tables.Rental.Values>,
        ),
      "Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalDateInventoryIdCustomerId.delete(
          request.parameters as Public.Tables.Rental.ByRentalDateInventoryIdCustomerId,
        ),
      "Public.Tables.Rental.ByRentalId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalId.read(
          request.parameters as Public.Tables.Rental.ByRentalId,
        ),
      "Public.Tables.Rental.ByRentalId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalId.update(
          request.parameters as Public.Tables.Rental.ByRentalId,
          request.values as Partial<Public.Tables.Rental.Values>,
        ),
      "Public.Tables.Rental.ByRentalId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Rental.ByRentalId.delete(
          request.parameters as Public.Tables.Rental.ByRentalId,
        ),
      "Public.Tables.Staff.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Staff.create(
          request.values as Public.Tables.Staff.Values,
        ),
      "Public.Tables.Staff.ByStaffId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Staff.ByStaffId.read(
          request.parameters as Public.Tables.Staff.ByStaffId,
        ),
      "Public.Tables.Staff.ByStaffId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Staff.ByStaffId.update(
          request.parameters as Public.Tables.Staff.ByStaffId,
          request.values as Partial<Public.Tables.Staff.Values>,
        ),
      "Public.Tables.Staff.ByStaffId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Staff.ByStaffId.delete(
          request.parameters as Public.Tables.Staff.ByStaffId,
        ),
      "Public.Tables.Store.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.create(
          request.values as Public.Tables.Store.Values,
        ),
      "Public.Tables.Store.ByManagerStaffId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByManagerStaffId.read(
          request.parameters as Public.Tables.Store.ByManagerStaffId,
        ),
      "Public.Tables.Store.ByManagerStaffId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByManagerStaffId.update(
          request.parameters as Public.Tables.Store.ByManagerStaffId,
          request.values as Partial<Public.Tables.Store.Values>,
        ),
      "Public.Tables.Store.ByManagerStaffId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByManagerStaffId.delete(
          request.parameters as Public.Tables.Store.ByManagerStaffId,
        ),
      "Public.Tables.Store.ByStoreId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByStoreId.read(
          request.parameters as Public.Tables.Store.ByStoreId,
        ),
      "Public.Tables.Store.ByStoreId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByStoreId.update(
          request.parameters as Public.Tables.Store.ByStoreId,
          request.values as Partial<Public.Tables.Store.Values>,
        ),
      "Public.Tables.Store.ByStoreId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Store.ByStoreId.delete(
          request.parameters as Public.Tables.Store.ByStoreId,
        ),
      "Public.Tables.Payment.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.create(
          request.values as Public.Tables.Payment.Values,
        ),
      "Public.Tables.Payment.ByCustomerId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByCustomerId.read(
          request.parameters as Public.Tables.Payment.ByCustomerId,
        ),
      "Public.Tables.Payment.ByCustomerId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByCustomerId.update(
          request.parameters as Public.Tables.Payment.ByCustomerId,
          request.values as Partial<Public.Tables.Payment.Values>,
        ),
      "Public.Tables.Payment.ByCustomerId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByCustomerId.delete(
          request.parameters as Public.Tables.Payment.ByCustomerId,
        ),
      "Public.Tables.Payment.ByPaymentId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByPaymentId.read(
          request.parameters as Public.Tables.Payment.ByPaymentId,
        ),
      "Public.Tables.Payment.ByPaymentId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByPaymentId.update(
          request.parameters as Public.Tables.Payment.ByPaymentId,
          request.values as Partial<Public.Tables.Payment.Values>,
        ),
      "Public.Tables.Payment.ByPaymentId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByPaymentId.delete(
          request.parameters as Public.Tables.Payment.ByPaymentId,
        ),
      "Public.Tables.Payment.ByRentalId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByRentalId.read(
          request.parameters as Public.Tables.Payment.ByRentalId,
        ),
      "Public.Tables.Payment.ByRentalId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByRentalId.update(
          request.parameters as Public.Tables.Payment.ByRentalId,
          request.values as Partial<Public.Tables.Payment.Values>,
        ),
      "Public.Tables.Payment.ByRentalId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByRentalId.delete(
          request.parameters as Public.Tables.Payment.ByRentalId,
        ),
      "Public.Tables.Payment.ByStaffId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByStaffId.read(
          request.parameters as Public.Tables.Payment.ByStaffId,
        ),
      "Public.Tables.Payment.ByStaffId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByStaffId.update(
          request.parameters as Public.Tables.Payment.ByStaffId,
          request.values as Partial<Public.Tables.Payment.Values>,
        ),
      "Public.Tables.Payment.ByStaffId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Payment.ByStaffId.delete(
          request.parameters as Public.Tables.Payment.ByStaffId,
        ),
      "Public.Tables.Film.create": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.create(
          request.values as Public.Tables.Film.Values,
        ),
      "Public.Tables.Film.ByFilmId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFilmId.read(
          request.parameters as Public.Tables.Film.ByFilmId,
        ),
      "Public.Tables.Film.ByFilmId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFilmId.update(
          request.parameters as Public.Tables.Film.ByFilmId,
          request.values as Partial<Public.Tables.Film.Values>,
        ),
      "Public.Tables.Film.ByFilmId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFilmId.delete(
          request.parameters as Public.Tables.Film.ByFilmId,
        ),
      "Public.Tables.Film.ByFulltext.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFulltext.read(
          request.parameters as Public.Tables.Film.ByFulltext,
        ),
      "Public.Tables.Film.ByFulltext.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFulltext.update(
          request.parameters as Public.Tables.Film.ByFulltext,
          request.values as Partial<Public.Tables.Film.Values>,
        ),
      "Public.Tables.Film.ByFulltext.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByFulltext.delete(
          request.parameters as Public.Tables.Film.ByFulltext,
        ),
      "Public.Tables.Film.ByLanguageId.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByLanguageId.read(
          request.parameters as Public.Tables.Film.ByLanguageId,
        ),
      "Public.Tables.Film.ByLanguageId.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByLanguageId.update(
          request.parameters as Public.Tables.Film.ByLanguageId,
          request.values as Partial<Public.Tables.Film.Values>,
        ),
      "Public.Tables.Film.ByLanguageId.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByLanguageId.delete(
          request.parameters as Public.Tables.Film.ByLanguageId,
        ),
      "Public.Tables.Film.ByTitle.read": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByTitle.read(
          request.parameters as Public.Tables.Film.ByTitle,
        ),
      "Public.Tables.Film.ByTitle.update": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByTitle.update(
          request.parameters as Public.Tables.Film.ByTitle,
          request.values as Partial<Public.Tables.Film.Values>,
        ),
      "Public.Tables.Film.ByTitle.delete": async (
        request: EmbraceSQLRequest<object, object>,
      ) =>
        database.Public.Tables.Film.ByTitle.delete(
          request.parameters as Public.Tables.Film.ByTitle,
        ),
    };
  }

  async dispatch(request: EmbraceSQLRequest<object, object>) {
    if (!this.dispatchMap[request.operation]) {
      throw new Error(`${request.operation} not available`);
    }
    return this.dispatchMap[request.operation](request);
  }
}
// Begin Express generated section
import { EmbraceSQLExpress } from "@embracesql/express";

export const EmbraceSQLExpressApp = async (
  postgresUrl: string,
  database?: Database,
) => {
  const dispatchToDatabase = database ?? (await Database.connect(postgresUrl));
  const dispatcher = new OperationDispatcher(dispatchToDatabase);
  return EmbraceSQLExpress(dispatcher);
};

// End Express generated section
